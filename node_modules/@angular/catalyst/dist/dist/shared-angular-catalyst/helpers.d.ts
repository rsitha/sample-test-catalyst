import 'zone.js';
import 'zone.js/testing';
import { AbstractType, DebugElement, InjectionToken, ModuleWithProviders, Provider, SchemaMetadata, Type } from '@angular/core';
import { ModuleTeardownOptions } from '@angular/core/testing';
import * as angular from 'angular';
/** Whether execution is currently being managed by catalyst. */
export declare function isInCatalyst(): boolean;
/** @checkReturnValue */
export declare const expect: (actual?: any) => jasmine.Matchers<any> & jasmine.NothingMatcher;
/** Catalyst wrapper to done. */
export interface DoneFn {
    (): void;
    fail: (message?: Error | string) => void;
}
declare type SpecFn = (done: DoneFn) => void;
declare type SpecFnStrict = () => void;
/** Catalyst wrapper to describe. */
export interface Describe {
    (description: string, specDefinitions: () => void): {};
    only: (description: string, specDefinitions: () => void) => {};
    skip: (description: string, specDefinitions: () => void) => {};
}
/**
 * Wrapper that allows you to configure the mocked current date that catalyst
 * sets.
 */
export interface DescribeWithDate {
    (description: string, mockedDate: Date, specDefinitions: () => void): {};
    only: (description: string, mockedDate: Date, specDefinitions: () => void) => {};
    skip: (description: string, mockedDate: Date, specDefinitions: () => void) => {};
}
/**
 * Catalyst wrapper to xdescribe.
 */
export declare function xdescribe(description: string, specDefinitions: () => void): any;
/**
 * Catalyst wrapper to fdescribe.
 */
export declare function fdescribe(description: string, specDefinitions: () => void): any;
/** Catalyst wrapper to it. */
export interface It {
    (description: string, specDefinitions: SpecFnStrict, timeout?: number): {};
    only: (description: string, specDefinitions: SpecFnStrict, timeout?: number) => {};
    skip: (description: string, specDefinitions: SpecFnStrict, timeout?: number) => {};
    async: {
        (description: string, specDefinitions: SpecFnStrict, timeout?: number): {};
        only: (description: string, specDefinitions: SpecFnStrict, timeout?: number) => {};
        skip: (description: string, specDefinitions: SpecFnStrict, timeout?: number) => {};
    };
    /**
     * A version of `it` that preserves the (incorrect) behavior of not checking
     * that a promise returned from the test has finished. It will be removed
     * once go/catalyst-it-async-problem fixes are implemented.
     */
    broken: {
        /**
         * @deprecated `it.broken` with an async spec (or a spec that returns a
         *     promise) is not guaranteed to finish. Use `it` or `it.async` instead.
         *     See also: go/catalyst-it-async-problem
         */
        (description: string, specDefinitions: SpecFn, timeout?: number): {};
        /**
         * @deprecated `it.broken` with an async spec (or a spec that returns a
         *     promise) is not guaranteed to finish. Use `it` or `it.async` instead.
         *     See also: go/catalyst-it-async-problem
         */
        only: (description: string, specDefinitions: SpecFn, timeout?: number) => {};
        /**
         * @deprecated `it.broken` with an async spec (or a spec that returns a
         *     promise) is not guaranteed to finish. Use `it` or `it.async` instead.
         *     See also: go/catalyst-it-async-problem
         */
        skip: (description: string, specDefinitions: SpecFn, timeout?: number) => {};
    };
}
/** Interface for itLegacy. */
export interface ItLegacy {
    (description: string, specDefinitions: SpecFn, timeout?: number): {};
    only: (description: string, specDefinitions: SpecFn, timeout?: number) => {};
    skip: (description: string, specDefinitions: SpecFn, timeout?: number) => {};
}
/**
 * Catalyst wrapper to 'xit'.
 * @param timeout optional timeout in milliseconds
 */
export declare function xit(description: string, specDefinitions: SpecFn, timeout?: number): any;
/**
 * Catalyst wrapper to 'fit'.
 * @param timeout optional timeout in milliseconds
 */
export declare function fit(description: string, specDefinitions: SpecFn, timeout?: number): any;
/**
 * Legacy wrapper of `fit()` which does **not** `flush()` after executing a test
 * that returns a Promise. This exists to support tests which would otherwise be
 * broken by adding this `flush()` call.
 *
 * @see http://b/144701308#comment16.
 * @deprecated Tests that are using this function should be updated so that they
 *   work with the implicit flush at the end and switched to {@link fit}.
 */
export declare function fitLegacy(description: string, specDefinitions: SpecFn, timeout?: number): any;
/** Catalyst wrapper to 'beforeEach'. */
export interface BeforeEach {
    /**
     * Catalyst wrapper to 'beforeEach'.
     * @param timeout optional timeout in milliseconds
     */
    (specDefinitions: SpecFnStrict, timeout?: number): {};
    /**
     * Catalyst wrapper to 'beforeEach' using the async Zone.
     * @param timeout optional timeout in milliseconds
     */
    async: (specDefinitions: SpecFnStrict, timeout?: number) => {};
    /**
     * A version of `beforeEach` that preserves the (incorrect) behavior of not
     * checking that a promise returned from the test has finished. It will be
     * removed once go/catalyst-it-async-problem fixes are implemented.
     *
     * @deprecated `beforeEach.broken` with an async spec (or a spec that returns
     *     a promise) is not guaranteed to finish. Use `beforeEach` or
     *     `beforeEach.async` instead. See also: go/catalyst-it-async-problem
     */
    broken: (specDefinitions: SpecFn, timeout?: number) => {};
}
/** Catalyst wrapper to describe. */
export declare const describe: Describe;
/** Catalyst wrapper to describeWithDate. */
export declare const describeWithDate: DescribeWithDate;
/** Catalyst wrapper to it. */
export declare const it: It;
/**
 * Legacy wrapper of `it()` which does **not** `flush()` after executing a test
 * that returns a Promise. This exists to support tests which would otherwise be
 * broken by adding this `flush()` call.
 *
 * @see http://b/144701308#comment16.
 * @deprecated Tests that are using this function should be updated so that they
 *   work with the implicit flush at the end and switched to {@link it}.
 */
export declare const itLegacy: ItLegacy;
/**
 * Catalyst wrapper to 'beforeEach'.
 */
export declare const beforeEach: BeforeEach;
/**
 * Legacy wrapper of `beforeEach()` which does **not** `flush()` after executing
 * a code block that returns a Promise. This exists to support tests which would
 * otherwise be broken by adding this `flush()` call.
 *
 * @see http://b/144701308#comment16.
 * @deprecated Tests that are using this function should be updated so that they
 *   work with the implicit flush at the end and switched to {@link beforeEach}.
 */
export declare function beforeEachLegacy(specDefinitions: SpecFn, timeout?: number): any;
/**
 * Catalyst wrapper to 'beforeAll'.
 * @param timeout optional timeout in milliseconds
 */
export declare function beforeAll(specDefinitions: SpecFn, timeout?: number): any;
/**
 * Catalyst wrapper to 'afterEach'.
 * @param timeout optional timeout in milliseconds
 */
export declare function afterEach(specDefinitions: SpecFnStrict, timeout?: number): any;
/**
 * Legacy wrapper of `afterEach()` which does **not** `flush()` after executing
 * a code block that returns a Promise. This exists to support tests which would
 * otherwise be broken by adding this `flush()` call.
 *
 * @see http://b/144701308#comment16.
 * @deprecated Tests that are using this function should be updated so that they
 *   work with the implicit flush at the end and switched to {@link afterEach}.
 */
export declare function afterEachLegacy(specDefinitions: SpecFn, timeout?: number): any;
/**
 * Catalyst wrapper to 'afterAll'.
 * @param timeout optional timeout in milliseconds
 */
export declare function afterAll(specDefinitions: SpecFn, timeout?: number): any;
/** Template override config. */
export interface TemplateOverride {
    component: Type<{}>;
    template: string;
}
/** Extra configuration of AngularJS Scope. */
export interface ScopeConfig {
    [attrName: string]: any;
}
/**
 * Configuration passed into setupModule to setup the testing NgModule.
 */
export interface ModuleConfig {
    imports?: Array<Type<{}> | ModuleWithProviders<{}>> | null;
    declarations?: Array<Type<{}>> | null;
    providers?: Provider[] | null;
    superProviders?: Provider[] | null;
    /**
     * @deprecated This legacy config option is unused and will be removed.
     */
    useDeprecatedOverrideProvider?: boolean;
    /**
     * @deprecated summary files are unused and passing them has no effect. All
     *     Components and NgModules are still AOT-compiled, but the generated code
     *     is included into a corresponding class (thus no need to pass anything
     *     extra). Please refactor your tests to avoid passing summary files. This
     *     field will be completely removed in the future.
     */
    summaries?: any[];
    templateOverrides?: TemplateOverride[];
    ng1Modules?: angular.IModule[] | null;
    ng1Scope?: ScopeConfig | null;
    schemas?: Array<SchemaMetadata | Array<{}>>;
    teardown?: ModuleTeardownOptions;
}
/** Get the injected instance for the given InjectionToken. */
export declare function get<T>(token: InjectionToken<T>): T;
/** Get the injected instance for the given concrete class. */
export declare function get<T>(token: Type<T>): T;
/** Get the injected instance for the given abstract class. */
export declare function get<T>(token: AbstractType<T>): T;
/**
 * Get the injected instance for the string token. This value must be casted
 * because we cannot know the type at compile time.
 */
export declare function get(token: string): unknown;
/**
 * Interface to reduce casting of the component instance of a DebugElement.
 */
export interface TypedDebugElement<T, N extends Element = HTMLElement> extends DebugElement {
    componentInstance: T;
    nativeElement: N;
}
/**
 * Destroys the test component.
 *
 * This is useful when you need to test component destruction but you cannot
 * call ngOnInit directly (this can happen if you using structural directives
 * that do not render on the page). Note that there is no going back from this.
 */
export declare function destroyTestComponent(): void;
/**
 * Set up Ng1 Module based on Ng2 NgModule class.
 *
 * @param ng1Module ng1 module's name
 * @param ng2Module ng2 NgModule class
 * @param cachedTemplateModuleName optional, if ng1 component uses templateUrl
 *   to load template, cachedTemplateModuleName should be specified for test to
 *   load template The template module's name  can be achieved by: import
 *   {templates} from {your template bundle}; templates.name
 * @param configFn optional, extra config function for creating ng1 module.
 *   It usually looks like:
 *   ($provide: ng.auto.IProvideService) => {
 *     $provide.value('$rootElement', root);
 *   }
 */
export declare function setupNg1Module<T>(ng1Module: string, ng2Module: Type<T>, cachedTemplateModuleName?: string, configFn?: (...args: any[]) => void): void;
/**
 * Compile and create Ng1 component
 * Must be called after setupNg1Module
 *
 * @param ng1Componentselector     ng1 component's selector which is used to
 * locate ng1 component. e.g. "<ng1-component></ng1-component>"
 * @param $scope  optional  scope used to compile component. If not specified,
 * it will create a new scope based on rootscope
 * Note that if your tests create your own scope and use it to do your tests,
 * you should pass it to the function rather than creating a new scope, which
 * will cause problems due to scope mismatch
 * @return AngularJS element created
 */
export declare function compileNg1Component(ng1Componentselector: string, $scope?: angular.IScope): angular.IAugmentedJQuery;
/**
 * Create AngularJS component from an AngularJS module which uses an Angular(2+)
 * downgraded module.
 * This is a convenience wrapper around setupNg1Module and compileNg1Component.
 * If you need better flexibility, please use them separately.
 *
 * @param ng1Module ng1 module's name
 * @param ng1Componentselector ng1 component's selector which is used to
 * locate ng1 component. e.g. "<ng1-component></ng1-component>"
 * @param ng2Module ng2 NgModule class reference
 * @param cachedTemplateModuleName optional, if ng1 component uses templateUrl
 * to load template, cachedTemplateModuleName should be specified for test to
 * load template The template module's name  can be achieved by: import
 * {templates} from {your template bundle}; templates.name
 * @return AngularJS element created
 */
export declare function createNg1Component<T>(ng1Module: string, ng1Componentselector: string, ng2Module: Type<T>, cachedTemplateModuleName?: string): angular.IAugmentedJQuery;
/**
 * Setup the Angular 2+ NgModule for the test.
 * If you want to setup AngularJS Module that uses Angular2 downgraded Module,
 * Please use setupNg1Module
 */
export declare function setupModule(config: ModuleConfig): unknown;
/**
 * Bootstrap a root Component for testing.
 *
 * @param component too component bootstrapped for the test
 * @param inputs component @Input values
 * @param beforeChangeDetection function to be run after component instance is
 *                              created but before first change detection is run
 * @param flush whether to flush tasks after bootstrapping. Defaults to `true`.
 * @return root component instance
 */
export declare function bootstrap<T>(component: Type<T>, inputs?: Partial<T>, beforeChangeDetection?: (comp: T) => void, flush?: boolean): T;
/**
 * Bootstrap a dynamic test Component from a template string.
 *
 * The test component is created on the fly from a combination of the template
 * string and a map with properties referenced in the template. Only keys that
 * are present in the map as it is passed on to the function are observed
 * throughout the lifetime of the component.
 * Ex.
 * bootstrapTemplate(
 *     `<test-component [name]="testName"></test-component>`,
 *     {testName: 'John'});
 * creates a dynamic component that instantiates the component under test
 * with the specified 'testName' property passed in as binding for the 'name'
 * attribute.
 *
 * @param templateString template for root component.
 * @param instance instance object backing the root component.
 * @param beforeChangeDetection function to be run after component instance is
 * created but before first change detection is run.
 * @param flush whether to flush tasks after bootstrapping. Defaults to `true`.
 * @return root component instance
 */
export declare function bootstrapTemplate<T extends {} = {}>(templateString: string, instance?: Partial<T>, beforeChangeDetection?: (comp: T) => void, flush?: boolean): T;
/**
 * Simulate passage of time to trigger setTimeout and setInterval events.
 * Any change in state in the event handlers is reflected in the DOM.
 *
 * @param millis time to advance in milliseconds
 */
export declare function tick(millis: number): void;
/**
 * Flush all tasks and currently queued timers.
 * Helpful in triggering timers without knowing how long they are waiting for.
 */
export declare function flush(): void;
/**
 * Flush which works on components with OnPush change detection strategy.
 */
export declare function markForCheckAndFlush(): void;
/**
 * Synchronously execute the specified function and reflects any changes made
 * to the component to the DOM.
 *
 * Executes the function synchronously even if it is asynchronous by executing
 * it in a Zone where task queue can be emptied synchronously.
 *
 * @param fn function to execute
 * @return return value of 'fn' converting Promises to immediate values
 */
export declare function now<T>(fn: () => T | Promise<T>): T;
/** {@see getEl} */
export declare function getEl<K extends keyof HTMLElementTagNameMap>(tagName: K, root?: ParentNode): HTMLElementTagNameMap[K];
/** {@see getEl} */
export declare function getEl<K extends keyof SVGElementTagNameMap>(tagName: K, root?: ParentNode): SVGElementTagNameMap[K];
/** {@see getEl} */
export declare function getEl<T extends Element = HTMLElement>(selector?: string, root?: ParentNode): T;
/** {@see getEls} */
export declare function getEls<K extends keyof HTMLElementTagNameMap>(tagName: K, root?: ParentNode): Array<HTMLElementTagNameMap[K]>;
/** {@see getEls} */
export declare function getEls<K extends keyof SVGElementTagNameMap>(tagName: K, root?: ParentNode): Array<SVGElementTagNameMap[K]>;
/** {@see getEls} */
export declare function getEls<T extends Element = HTMLElement>(selector?: string, root?: ParentNode): T[];
/**
 * Return whether an element with the specified CSS selector is present.
 *
 * @param selector CSS selector
 * @param root root element to select within, defaults to fixture root
 */
export declare function hasEl(selector: string, root?: ParentNode): boolean;
/**
 * Get the root TypedDebugElement for this test. If bootstrap was used this
 * will be the DebugElement of the component bootstraped, if bootstrapTemplate
 * was used this will be the DebugElement of the root test component.
 */
export declare function getDebugEl<T = any, N extends Element = HTMLElement>(): TypedDebugElement<T, N>;
/** {@see getDebugEl} */
export declare function getDebugEl<T>(query: Type<T>, root?: DebugElement): TypedDebugElement<T, HTMLElement>;
/** {@see getDebugEl} */
export declare function getDebugEl<N extends keyof HTMLElementTagNameMap>(tagName: N, root?: DebugElement): TypedDebugElement<unknown, HTMLElementTagNameMap[N]>;
/** {@see getDebugEl} */
export declare function getDebugEl<N extends keyof SVGElementTagNameMap>(tagName: N, root?: DebugElement): TypedDebugElement<unknown, SVGElementTagNameMap[N]>;
/** {@see getDebugEl} */
export declare function getDebugEl<T = any, N extends Element = HTMLElement>(query?: Type<T> | string, root?: DebugElement): TypedDebugElement<T, N>;
/** {@see getDebugEls} */
export declare function getDebugEls<T>(query: Type<T>, root?: DebugElement): Array<TypedDebugElement<T, HTMLElement>>;
/** {@see getDebugEls} */
export declare function getDebugEls<N extends keyof HTMLElementTagNameMap>(tagName: N, root?: DebugElement): Array<TypedDebugElement<unknown, HTMLElementTagNameMap[N]>>;
/** {@see getDebugEls} */
export declare function getDebugEls<N extends keyof SVGElementTagNameMap>(tagName: N, root?: DebugElement): Array<TypedDebugElement<unknown, SVGElementTagNameMap[N]>>;
/** {@see getDebugEls} */
export declare function getDebugEls<T = any, N extends Element = HTMLElement>(query: Type<T> | string, root?: DebugElement): Array<TypedDebugElement<T, N>>;
/**
 * Helper function to determine whether an element with the given
 * directive or CSS selector exists.
 *
 * @return `true` if DebugElement with given type is found. `false` otherise
 */
export declare function hasDebugEl(query: Type<unknown> | string, root?: DebugElement): boolean;
/**
 * Helper function to trigger HTMLElementEvent on a provided element.
 *
 * When the eventType is one of KeyboardEvent types, an additional eventParam
 * must represent a map that fits into KeyboardEventInit instance, followed
 * by extra parameters that are not covered in KeyboardEventInit. Of particular
 * highlight is the keyCode property, which is not part of KeyboardEventInit
 * (https://github.com/Microsoft/TypeScript/issues/15228). When a KeyboardEvent
 * is created with a properly populated KeyboardEventInit, the keyCode won't be
 * populated (https://bugs.webkit.org/show_bug.cgi?id=16735).
 * An example use:
 *
 *     trigger(el, 'keydown', {key: 'Enter'}, {'keyCode': 13});
 *
 * @return The event that was triggered.
 */
export declare function trigger(el: EventTarget, eventType: keyof HTMLElementEventMap, eventParam?: KeyboardEventInit, extraParams?: {
    [eventProp: string]: {};
}): Event;
export {};
//# sourceMappingURL=helpers.d.ts.map