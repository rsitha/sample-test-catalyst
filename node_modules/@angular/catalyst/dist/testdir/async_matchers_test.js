(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/tslib/tslib.js"(exports, module) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate3;
      var __param2;
      var __metadata2;
      var __awaiter4;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __createBinding2;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends2 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest2 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate3 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter4 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding2 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar2 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values2 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error3) {
            e = { error: error3 };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read2(arguments[i]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await2 = function(v) {
          return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues2 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate3);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter4);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      });
    }
  });

  // node_modules/angular/angular.js
  var require_angular = __commonJS({
    "node_modules/angular/angular.js"() {
      (function(window2) {
        "use strict";
        var minErrConfig = {
          objectMaxDepth: 5,
          urlErrorParamsEnabled: true
        };
        function errorHandlingConfig(config2) {
          if (isObject2(config2)) {
            if (isDefined(config2.objectMaxDepth)) {
              minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config2.objectMaxDepth) ? config2.objectMaxDepth : NaN;
            }
            if (isDefined(config2.urlErrorParamsEnabled) && isBoolean(config2.urlErrorParamsEnabled)) {
              minErrConfig.urlErrorParamsEnabled = config2.urlErrorParamsEnabled;
            }
          } else {
            return minErrConfig;
          }
        }
        function isValidObjectMaxDepth(maxDepth) {
          return isNumber(maxDepth) && maxDepth > 0;
        }
        function minErr(module2, ErrorConstructor) {
          ErrorConstructor = ErrorConstructor || Error;
          var url = "https://errors.angularjs.org/1.8.3/";
          var regex = url.replace(".", "\\.") + "[\\s\\S]*";
          var errRegExp = new RegExp(regex, "g");
          return function() {
            var code = arguments[0], template = arguments[1], message = "[" + (module2 ? module2 + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
              return toDebugString(arg, minErrConfig.objectMaxDepth);
            }), paramPrefix, i;
            message += template.replace(/\{\d+\}/g, function(match) {
              var index = +match.slice(1, -1);
              if (index < templateArgs.length) {
                return templateArgs[index].replace(errRegExp, "");
              }
              return match;
            });
            message += "\n" + url + (module2 ? module2 + "/" : "") + code;
            if (minErrConfig.urlErrorParamsEnabled) {
              for (i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") {
                message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
              }
            }
            return new ErrorConstructor(message);
          };
        }
        var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
        var VALIDITY_STATE_PROPERTY = "validity";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var lowercase = function(string) {
          return isString(string) ? string.toLowerCase() : string;
        };
        var uppercase = function(string) {
          return isString(string) ? string.toUpperCase() : string;
        };
        var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular3 = window2.angular || (window2.angular = {}), angularModule, uid = 0;
        msie = window2.document.documentMode;
        function isArrayLike2(obj) {
          if (obj == null || isWindow(obj))
            return false;
          if (isArray2(obj) || isString(obj) || jqLite && obj instanceof jqLite)
            return true;
          var length = "length" in Object(obj) && obj.length;
          return isNumber(length) && (length >= 0 && length - 1 in obj || typeof obj.item === "function");
        }
        function forEach(obj, iterator2, context) {
          var key2, length;
          if (obj) {
            if (isFunction2(obj)) {
              for (key2 in obj) {
                if (key2 !== "prototype" && key2 !== "length" && key2 !== "name" && obj.hasOwnProperty(key2)) {
                  iterator2.call(context, obj[key2], key2, obj);
                }
              }
            } else if (isArray2(obj) || isArrayLike2(obj)) {
              var isPrimitive = typeof obj !== "object";
              for (key2 = 0, length = obj.length; key2 < length; key2++) {
                if (isPrimitive || key2 in obj) {
                  iterator2.call(context, obj[key2], key2, obj);
                }
              }
            } else if (obj.forEach && obj.forEach !== forEach) {
              obj.forEach(iterator2, context, obj);
            } else if (isBlankObject(obj)) {
              for (key2 in obj) {
                iterator2.call(context, obj[key2], key2, obj);
              }
            } else if (typeof obj.hasOwnProperty === "function") {
              for (key2 in obj) {
                if (obj.hasOwnProperty(key2)) {
                  iterator2.call(context, obj[key2], key2, obj);
                }
              }
            } else {
              for (key2 in obj) {
                if (hasOwnProperty.call(obj, key2)) {
                  iterator2.call(context, obj[key2], key2, obj);
                }
              }
            }
          }
          return obj;
        }
        function forEachSorted(obj, iterator2, context) {
          var keys = Object.keys(obj).sort();
          for (var i = 0; i < keys.length; i++) {
            iterator2.call(context, obj[keys[i]], keys[i]);
          }
          return keys;
        }
        function reverseParams(iteratorFn) {
          return function(value, key2) {
            iteratorFn(key2, value);
          };
        }
        function nextUid() {
          return ++uid;
        }
        function setHashKey(obj, h) {
          if (h) {
            obj.$$hashKey = h;
          } else {
            delete obj.$$hashKey;
          }
        }
        function baseExtend(dst, objs, deep) {
          var h = dst.$$hashKey;
          for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!isObject2(obj) && !isFunction2(obj))
              continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
              var key2 = keys[j];
              var src = obj[key2];
              if (deep && isObject2(src)) {
                if (isDate2(src)) {
                  dst[key2] = new Date(src.valueOf());
                } else if (isRegExp(src)) {
                  dst[key2] = new RegExp(src);
                } else if (src.nodeName) {
                  dst[key2] = src.cloneNode(true);
                } else if (isElement(src)) {
                  dst[key2] = src.clone();
                } else {
                  if (key2 !== "__proto__") {
                    if (!isObject2(dst[key2]))
                      dst[key2] = isArray2(src) ? [] : {};
                    baseExtend(dst[key2], [src], true);
                  }
                }
              } else {
                dst[key2] = src;
              }
            }
          }
          setHashKey(dst, h);
          return dst;
        }
        function extend(dst) {
          return baseExtend(dst, slice.call(arguments, 1), false);
        }
        function merge3(dst) {
          return baseExtend(dst, slice.call(arguments, 1), true);
        }
        function toInt(str) {
          return parseInt(str, 10);
        }
        var isNumberNaN = Number.isNaN || function isNumberNaN2(num) {
          return num !== num;
        };
        function inherit(parent, extra) {
          return extend(Object.create(parent), extra);
        }
        function noop3() {
        }
        noop3.$inject = [];
        function identity2($) {
          return $;
        }
        identity2.$inject = [];
        function valueFn(value) {
          return function valueRef() {
            return value;
          };
        }
        function hasCustomToString(obj) {
          return isFunction2(obj.toString) && obj.toString !== toString;
        }
        function isUndefined(value) {
          return typeof value === "undefined";
        }
        function isDefined(value) {
          return typeof value !== "undefined";
        }
        function isObject2(value) {
          return value !== null && typeof value === "object";
        }
        function isBlankObject(value) {
          return value !== null && typeof value === "object" && !getPrototypeOf(value);
        }
        function isString(value) {
          return typeof value === "string";
        }
        function isNumber(value) {
          return typeof value === "number";
        }
        function isDate2(value) {
          return toString.call(value) === "[object Date]";
        }
        function isArray2(arr) {
          return Array.isArray(arr) || arr instanceof Array;
        }
        function isError(value) {
          var tag = toString.call(value);
          switch (tag) {
            case "[object Error]":
              return true;
            case "[object Exception]":
              return true;
            case "[object DOMException]":
              return true;
            default:
              return value instanceof Error;
          }
        }
        function isFunction2(value) {
          return typeof value === "function";
        }
        function isRegExp(value) {
          return toString.call(value) === "[object RegExp]";
        }
        function isWindow(obj) {
          return obj && obj.window === obj;
        }
        function isScope(obj) {
          return obj && obj.$evalAsync && obj.$watch;
        }
        function isFile(obj) {
          return toString.call(obj) === "[object File]";
        }
        function isFormData(obj) {
          return toString.call(obj) === "[object FormData]";
        }
        function isBlob(obj) {
          return toString.call(obj) === "[object Blob]";
        }
        function isBoolean(value) {
          return typeof value === "boolean";
        }
        function isPromiseLike(obj) {
          return obj && isFunction2(obj.then);
        }
        var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
        function isTypedArray(value) {
          return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
        }
        function isArrayBuffer(obj) {
          return toString.call(obj) === "[object ArrayBuffer]";
        }
        var trim = function(value) {
          return isString(value) ? value.trim() : value;
        };
        var escapeForRegexp = function(s) {
          return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
        };
        function isElement(node) {
          return !!(node && (node.nodeName || node.prop && node.attr && node.find));
        }
        function makeMap(str) {
          var obj = {}, items = str.split(","), i;
          for (i = 0; i < items.length; i++) {
            obj[items[i]] = true;
          }
          return obj;
        }
        function nodeName_(element2) {
          return lowercase(element2.nodeName || element2[0] && element2[0].nodeName);
        }
        function includes(array, obj) {
          return Array.prototype.indexOf.call(array, obj) !== -1;
        }
        function arrayRemove(array, value) {
          var index = array.indexOf(value);
          if (index >= 0) {
            array.splice(index, 1);
          }
          return index;
        }
        function copy(source, destination, maxDepth) {
          var stackSource = [];
          var stackDest = [];
          maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;
          if (destination) {
            if (isTypedArray(destination) || isArrayBuffer(destination)) {
              throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            }
            if (source === destination) {
              throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            }
            if (isArray2(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key2) {
                if (key2 !== "$$hashKey") {
                  delete destination[key2];
                }
              });
            }
            stackSource.push(source);
            stackDest.push(destination);
            return copyRecurse(source, destination, maxDepth);
          }
          return copyElement(source, maxDepth);
          function copyRecurse(source2, destination2, maxDepth2) {
            maxDepth2--;
            if (maxDepth2 < 0) {
              return "...";
            }
            var h = destination2.$$hashKey;
            var key2;
            if (isArray2(source2)) {
              for (var i = 0, ii = source2.length; i < ii; i++) {
                destination2.push(copyElement(source2[i], maxDepth2));
              }
            } else if (isBlankObject(source2)) {
              for (key2 in source2) {
                destination2[key2] = copyElement(source2[key2], maxDepth2);
              }
            } else if (source2 && typeof source2.hasOwnProperty === "function") {
              for (key2 in source2) {
                if (source2.hasOwnProperty(key2)) {
                  destination2[key2] = copyElement(source2[key2], maxDepth2);
                }
              }
            } else {
              for (key2 in source2) {
                if (hasOwnProperty.call(source2, key2)) {
                  destination2[key2] = copyElement(source2[key2], maxDepth2);
                }
              }
            }
            setHashKey(destination2, h);
            return destination2;
          }
          function copyElement(source2, maxDepth2) {
            if (!isObject2(source2)) {
              return source2;
            }
            var index = stackSource.indexOf(source2);
            if (index !== -1) {
              return stackDest[index];
            }
            if (isWindow(source2) || isScope(source2)) {
              throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            }
            var needsRecurse = false;
            var destination2 = copyType(source2);
            if (destination2 === void 0) {
              destination2 = isArray2(source2) ? [] : Object.create(getPrototypeOf(source2));
              needsRecurse = true;
            }
            stackSource.push(source2);
            stackDest.push(destination2);
            return needsRecurse ? copyRecurse(source2, destination2, maxDepth2) : destination2;
          }
          function copyType(source2) {
            switch (toString.call(source2)) {
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return new source2.constructor(copyElement(source2.buffer), source2.byteOffset, source2.length);
              case "[object ArrayBuffer]":
                if (!source2.slice) {
                  var copied = new ArrayBuffer(source2.byteLength);
                  new Uint8Array(copied).set(new Uint8Array(source2));
                  return copied;
                }
                return source2.slice(0);
              case "[object Boolean]":
              case "[object Number]":
              case "[object String]":
              case "[object Date]":
                return new source2.constructor(source2.valueOf());
              case "[object RegExp]":
                var re = new RegExp(source2.source, source2.toString().match(/[^/]*$/)[0]);
                re.lastIndex = source2.lastIndex;
                return re;
              case "[object Blob]":
                return new source2.constructor([source2], { type: source2.type });
            }
            if (isFunction2(source2.cloneNode)) {
              return source2.cloneNode(true);
            }
          }
        }
        function simpleCompare(a, b) {
          return a === b || a !== a && b !== b;
        }
        function equals(o1, o2) {
          if (o1 === o2)
            return true;
          if (o1 === null || o2 === null)
            return false;
          if (o1 !== o1 && o2 !== o2)
            return true;
          var t1 = typeof o1, t2 = typeof o2, length, key2, keySet;
          if (t1 === t2 && t1 === "object") {
            if (isArray2(o1)) {
              if (!isArray2(o2))
                return false;
              if ((length = o1.length) === o2.length) {
                for (key2 = 0; key2 < length; key2++) {
                  if (!equals(o1[key2], o2[key2]))
                    return false;
                }
                return true;
              }
            } else if (isDate2(o1)) {
              if (!isDate2(o2))
                return false;
              return simpleCompare(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              if (!isRegExp(o2))
                return false;
              return o1.toString() === o2.toString();
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray2(o2) || isDate2(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key2 in o1) {
                if (key2.charAt(0) === "$" || isFunction2(o1[key2]))
                  continue;
                if (!equals(o1[key2], o2[key2]))
                  return false;
                keySet[key2] = true;
              }
              for (key2 in o2) {
                if (!(key2 in keySet) && key2.charAt(0) !== "$" && isDefined(o2[key2]) && !isFunction2(o2[key2]))
                  return false;
              }
              return true;
            }
          }
          return false;
        }
        var csp = function() {
          if (!isDefined(csp.rules)) {
            var ngCspElement = window2.document.querySelector("[ng-csp]") || window2.document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
              var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
              csp.rules = {
                noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
                noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1
              };
            } else {
              csp.rules = {
                noUnsafeEval: noUnsafeEval(),
                noInlineStyle: false
              };
            }
          }
          return csp.rules;
          function noUnsafeEval() {
            try {
              new Function("");
              return false;
            } catch (e) {
              return true;
            }
          }
        };
        var jq = function() {
          if (isDefined(jq.name_))
            return jq.name_;
          var el;
          var i, ii = ngAttrPrefixes.length, prefix, name;
          for (i = 0; i < ii; ++i) {
            prefix = ngAttrPrefixes[i];
            el = window2.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]");
            if (el) {
              name = el.getAttribute(prefix + "jq");
              break;
            }
          }
          return jq.name_ = name;
        };
        function concat(array1, array2, index) {
          return array1.concat(slice.call(array2, index));
        }
        function sliceArgs(args, startIndex) {
          return slice.call(args, startIndex || 0);
        }
        function bind(self2, fn2) {
          var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
          if (isFunction2(fn2) && !(fn2 instanceof RegExp)) {
            return curryArgs.length ? function() {
              return arguments.length ? fn2.apply(self2, concat(curryArgs, arguments, 0)) : fn2.apply(self2, curryArgs);
            } : function() {
              return arguments.length ? fn2.apply(self2, arguments) : fn2.call(self2);
            };
          } else {
            return fn2;
          }
        }
        function toJsonReplacer(key2, value) {
          var val = value;
          if (typeof key2 === "string" && key2.charAt(0) === "$" && key2.charAt(1) === "$") {
            val = void 0;
          } else if (isWindow(value)) {
            val = "$WINDOW";
          } else if (value && window2.document === value) {
            val = "$DOCUMENT";
          } else if (isScope(value)) {
            val = "$SCOPE";
          }
          return val;
        }
        function toJson(obj, pretty) {
          if (isUndefined(obj))
            return void 0;
          if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
          }
          return JSON.stringify(obj, toJsonReplacer, pretty);
        }
        function fromJson(json) {
          return isString(json) ? JSON.parse(json) : json;
        }
        var ALL_COLONS = /:/g;
        function timezoneToOffset(timezone, fallback) {
          timezone = timezone.replace(ALL_COLONS, "");
          var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
          return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
          date = new Date(date.getTime());
          date.setMinutes(date.getMinutes() + minutes);
          return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
          reverse = reverse ? -1 : 1;
          var dateTimezoneOffset = date.getTimezoneOffset();
          var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
          return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
        }
        function startingTag(element2) {
          element2 = jqLite(element2).clone().empty();
          var elemHtml = jqLite("<div></div>").append(element2).html();
          try {
            return element2[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
              return "<" + lowercase(nodeName);
            });
          } catch (e) {
            return lowercase(elemHtml);
          }
        }
        function tryDecodeURIComponent(value) {
          try {
            return decodeURIComponent(value);
          } catch (e) {
          }
        }
        function parseKeyValue(keyValue) {
          var obj = {};
          forEach((keyValue || "").split("&"), function(keyValue2) {
            var splitPoint, key2, val;
            if (keyValue2) {
              key2 = keyValue2 = keyValue2.replace(/\+/g, "%20");
              splitPoint = keyValue2.indexOf("=");
              if (splitPoint !== -1) {
                key2 = keyValue2.substring(0, splitPoint);
                val = keyValue2.substring(splitPoint + 1);
              }
              key2 = tryDecodeURIComponent(key2);
              if (isDefined(key2)) {
                val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                if (!hasOwnProperty.call(obj, key2)) {
                  obj[key2] = val;
                } else if (isArray2(obj[key2])) {
                  obj[key2].push(val);
                } else {
                  obj[key2] = [obj[key2], val];
                }
              }
            }
          });
          return obj;
        }
        function toKeyValue(obj) {
          var parts = [];
          forEach(obj, function(value, key2) {
            if (isArray2(value)) {
              forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key2, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
              });
            } else {
              parts.push(encodeUriQuery(key2, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
          });
          return parts.length ? parts.join("&") : "";
        }
        function encodeUriSegment(val) {
          return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
        }
        function encodeUriQuery(val, pctEncodeSpaces) {
          return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
        }
        var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];
        function getNgAttribute(element2, ngAttr) {
          var attr, i, ii = ngAttrPrefixes.length;
          for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element2.getAttribute(attr))) {
              return attr;
            }
          }
          return null;
        }
        function allowAutoBootstrap(document2) {
          var script = document2.currentScript;
          if (!script) {
            return true;
          }
          if (!(script instanceof window2.HTMLScriptElement || script instanceof window2.SVGScriptElement)) {
            return false;
          }
          var attributes = script.attributes;
          var srcs = [attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href")];
          return srcs.every(function(src) {
            if (!src) {
              return true;
            }
            if (!src.value) {
              return false;
            }
            var link = document2.createElement("a");
            link.href = src.value;
            if (document2.location.origin === link.origin) {
              return true;
            }
            switch (link.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "blob:":
              case "file:":
              case "data:":
                return true;
              default:
                return false;
            }
          });
        }
        var isAutoBootstrapAllowed = allowAutoBootstrap(window2.document);
        function angularInit(element2, bootstrap2) {
          var appElement, module2, config2 = {};
          forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element2.hasAttribute && element2.hasAttribute(name)) {
              appElement = element2;
              module2 = element2.getAttribute(name);
            }
          });
          forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element2.querySelector("[" + name.replace(":", "\\:") + "]"))) {
              appElement = candidate;
              module2 = candidate.getAttribute(name);
            }
          });
          if (appElement) {
            if (!isAutoBootstrapAllowed) {
              window2.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
              return;
            }
            config2.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap2(appElement, module2 ? [module2] : [], config2);
          }
        }
        function bootstrap(element2, modules2, config2) {
          if (!isObject2(config2))
            config2 = {};
          var defaultConfig = {
            strictDi: false
          };
          config2 = extend(defaultConfig, config2);
          var doBootstrap = function() {
            element2 = jqLite(element2);
            if (element2.injector()) {
              var tag = element2[0] === window2.document ? "document" : startingTag(element2);
              throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules2 = modules2 || [];
            modules2.unshift(["$provide", function($provide) {
              $provide.value("$rootElement", element2);
            }]);
            if (config2.debugInfoEnabled) {
              modules2.push(["$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(true);
              }]);
            }
            modules2.unshift("ng");
            var injector2 = createInjector2(modules2, config2.strictDi);
            injector2.invoke([
              "$rootScope",
              "$rootElement",
              "$compile",
              "$injector",
              function bootstrapApply(scope, element3, compile, injector3) {
                scope.$apply(function() {
                  element3.data("$injector", injector3);
                  compile(element3)(scope);
                });
              }
            ]);
            return injector2;
          };
          var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
          var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
          if (window2 && NG_ENABLE_DEBUG_INFO.test(window2.name)) {
            config2.debugInfoEnabled = true;
            window2.name = window2.name.replace(NG_ENABLE_DEBUG_INFO, "");
          }
          if (window2 && !NG_DEFER_BOOTSTRAP.test(window2.name)) {
            return doBootstrap();
          }
          window2.name = window2.name.replace(NG_DEFER_BOOTSTRAP, "");
          angular3.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module2) {
              modules2.push(module2);
            });
            return doBootstrap();
          };
          if (isFunction2(angular3.resumeDeferredBootstrap)) {
            angular3.resumeDeferredBootstrap();
          }
        }
        function reloadWithDebugInfo() {
          window2.name = "NG_ENABLE_DEBUG_INFO!" + window2.name;
          window2.location.reload();
        }
        function getTestability(rootElement) {
          var injector2 = angular3.element(rootElement).injector();
          if (!injector2) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
          }
          return injector2.get("$$testability");
        }
        var SNAKE_CASE_REGEXP = /[A-Z]/g;
        function snake_case(name, separator) {
          separator = separator || "_";
          return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
          });
        }
        var bindJQueryFired = false;
        function bindJQuery() {
          var originalCleanData;
          if (bindJQueryFired) {
            return;
          }
          var jqName = jq();
          jQuery = isUndefined(jqName) ? window2.jQuery : !jqName ? void 0 : window2[jqName];
          if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
              scope: JQLitePrototype.scope,
              isolateScope: JQLitePrototype.isolateScope,
              controller: JQLitePrototype.controller,
              injector: JQLitePrototype.injector,
              inheritedData: JQLitePrototype.inheritedData
            });
          } else {
            jqLite = JQLite;
          }
          originalCleanData = jqLite.cleanData;
          jqLite.cleanData = function(elems) {
            var events;
            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
              events = (jqLite._data(elem) || {}).events;
              if (events && events.$destroy) {
                jqLite(elem).triggerHandler("$destroy");
              }
            }
            originalCleanData(elems);
          };
          angular3.element = jqLite;
          bindJQueryFired = true;
        }
        function UNSAFE_restoreLegacyJqLiteXHTMLReplacement() {
          JQLite.legacyXHTMLReplacement = true;
        }
        function assertArg(arg, name, reason) {
          if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
          }
          return arg;
        }
        function assertArgFn(arg, name, acceptArrayAnnotation) {
          if (acceptArrayAnnotation && isArray2(arg)) {
            arg = arg[arg.length - 1];
          }
          assertArg(isFunction2(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
          return arg;
        }
        function assertNotHasOwnProperty(name, context) {
          if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
          }
        }
        function getter(obj, path, bindFnToScope) {
          if (!path)
            return obj;
          var keys = path.split(".");
          var key2;
          var lastInstance = obj;
          var len = keys.length;
          for (var i = 0; i < len; i++) {
            key2 = keys[i];
            if (obj) {
              obj = (lastInstance = obj)[key2];
            }
          }
          if (!bindFnToScope && isFunction2(obj)) {
            return bind(lastInstance, obj);
          }
          return obj;
        }
        function getBlockNodes(nodes) {
          var node = nodes[0];
          var endNode = nodes[nodes.length - 1];
          var blockNodes;
          for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
            if (blockNodes || nodes[i] !== node) {
              if (!blockNodes) {
                blockNodes = jqLite(slice.call(nodes, 0, i));
              }
              blockNodes.push(node);
            }
          }
          return blockNodes || nodes;
        }
        function createMap() {
          return /* @__PURE__ */ Object.create(null);
        }
        function stringify3(value) {
          if (value == null) {
            return "";
          }
          switch (typeof value) {
            case "string":
              break;
            case "number":
              value = "" + value;
              break;
            default:
              if (hasCustomToString(value) && !isArray2(value) && !isDate2(value)) {
                value = value.toString();
              } else {
                value = toJson(value);
              }
          }
          return value;
        }
        var NODE_TYPE_ELEMENT = 1;
        var NODE_TYPE_ATTRIBUTE = 2;
        var NODE_TYPE_TEXT = 3;
        var NODE_TYPE_COMMENT = 8;
        var NODE_TYPE_DOCUMENT = 9;
        var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
        function setupModuleLoader(window3) {
          var $injectorMinErr2 = minErr("$injector");
          var ngMinErr2 = minErr("ng");
          function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
          }
          var angular4 = ensure(window3, "angular", Object);
          angular4.$$minErr = angular4.$$minErr || minErr;
          return ensure(angular4, "module", function() {
            var modules2 = {};
            return function module2(name, requires, configFn) {
              var info = {};
              var assertNotHasOwnProperty2 = function(name2, context) {
                if (name2 === "hasOwnProperty") {
                  throw ngMinErr2("badname", "hasOwnProperty is not a valid {0} name", context);
                }
              };
              assertNotHasOwnProperty2(name, "module");
              if (requires && modules2.hasOwnProperty(name)) {
                modules2[name] = null;
              }
              return ensure(modules2, name, function() {
                if (!requires) {
                  throw $injectorMinErr2("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                }
                var invokeQueue = [];
                var configBlocks = [];
                var runBlocks = [];
                var config2 = invokeLater("$injector", "invoke", "push", configBlocks);
                var moduleInstance = {
                  _invokeQueue: invokeQueue,
                  _configBlocks: configBlocks,
                  _runBlocks: runBlocks,
                  info: function(value) {
                    if (isDefined(value)) {
                      if (!isObject2(value))
                        throw ngMinErr2("aobj", "Argument '{0}' must be an object", "value");
                      info = value;
                      return this;
                    }
                    return info;
                  },
                  requires,
                  name,
                  provider: invokeLaterAndSetModuleName("$provide", "provider"),
                  factory: invokeLaterAndSetModuleName("$provide", "factory"),
                  service: invokeLaterAndSetModuleName("$provide", "service"),
                  value: invokeLater("$provide", "value"),
                  constant: invokeLater("$provide", "constant", "unshift"),
                  decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                  animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                  filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                  controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                  directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                  component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                  config: config2,
                  run: function(block) {
                    runBlocks.push(block);
                    return this;
                  }
                };
                if (configFn) {
                  config2(configFn);
                }
                return moduleInstance;
                function invokeLater(provider, method, insertMethod, queue2) {
                  if (!queue2)
                    queue2 = invokeQueue;
                  return function() {
                    queue2[insertMethod || "push"]([provider, method, arguments]);
                    return moduleInstance;
                  };
                }
                function invokeLaterAndSetModuleName(provider, method, queue2) {
                  if (!queue2)
                    queue2 = invokeQueue;
                  return function(recipeName, factoryFunction) {
                    if (factoryFunction && isFunction2(factoryFunction))
                      factoryFunction.$$moduleName = name;
                    queue2.push([provider, method, arguments]);
                    return moduleInstance;
                  };
                }
              });
            };
          });
        }
        function shallowCopy(src, dst) {
          if (isArray2(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
              dst[i] = src[i];
            }
          } else if (isObject2(src)) {
            dst = dst || {};
            for (var key2 in src) {
              if (!(key2.charAt(0) === "$" && key2.charAt(1) === "$")) {
                dst[key2] = src[key2];
              }
            }
          }
          return dst || src;
        }
        function serializeObject(obj, maxDepth) {
          var seen = [];
          if (isValidObjectMaxDepth(maxDepth)) {
            obj = angular3.copy(obj, null, maxDepth);
          }
          return JSON.stringify(obj, function(key2, val) {
            val = toJsonReplacer(key2, val);
            if (isObject2(val)) {
              if (seen.indexOf(val) >= 0)
                return "...";
              seen.push(val);
            }
            return val;
          });
        }
        function toDebugString(obj, maxDepth) {
          if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
          } else if (isUndefined(obj)) {
            return "undefined";
          } else if (typeof obj !== "string") {
            return serializeObject(obj, maxDepth);
          }
          return obj;
        }
        var version = {
          full: "1.8.3",
          major: 1,
          minor: 8,
          dot: 3,
          codeName: "ultimate-farewell"
        };
        function publishExternalAPI(angular4) {
          extend(angular4, {
            "errorHandlingConfig": errorHandlingConfig,
            "bootstrap": bootstrap,
            "copy": copy,
            "extend": extend,
            "merge": merge3,
            "equals": equals,
            "element": jqLite,
            "forEach": forEach,
            "injector": createInjector2,
            "noop": noop3,
            "bind": bind,
            "toJson": toJson,
            "fromJson": fromJson,
            "identity": identity2,
            "isUndefined": isUndefined,
            "isDefined": isDefined,
            "isString": isString,
            "isFunction": isFunction2,
            "isObject": isObject2,
            "isNumber": isNumber,
            "isElement": isElement,
            "isArray": isArray2,
            "version": version,
            "isDate": isDate2,
            "callbacks": { $$counter: 0 },
            "getTestability": getTestability,
            "reloadWithDebugInfo": reloadWithDebugInfo,
            "UNSAFE_restoreLegacyJqLiteXHTMLReplacement": UNSAFE_restoreLegacyJqLiteXHTMLReplacement,
            "$$minErr": minErr,
            "$$csp": csp,
            "$$encodeUriSegment": encodeUriSegment,
            "$$encodeUriQuery": encodeUriQuery,
            "$$lowercase": lowercase,
            "$$stringify": stringify3,
            "$$uppercase": uppercase
          });
          angularModule = setupModuleLoader(window2);
          angularModule("ng", ["ngLocale"], [
            "$provide",
            function ngModule($provide) {
              $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
              });
              $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
              }).directive({
                ngInclude: ngIncludeFillContentDirective,
                input: hiddenInputBrowserCacheDirective
              }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
              $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $$intervalFactory: $$IntervalFactoryProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
              });
            }
          ]).info({ angularVersion: "1.8.3" });
        }
        JQLite.expando = "ng339";
        var jqCache = JQLite.cache = {}, jqId = 1;
        JQLite._data = function(node) {
          return this.cache[node[this.expando]] || {};
        };
        function jqNextId() {
          return ++jqId;
        }
        var DASH_LOWERCASE_REGEXP = /-([a-z])/g;
        var MS_HACK_REGEXP = /^-ms-/;
        var MOUSE_EVENT_MAP = { mouseleave: "mouseout", mouseenter: "mouseover" };
        var jqLiteMinErr = minErr("jqLite");
        function cssKebabToCamel(name) {
          return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
        }
        function fnCamelCaseReplace(all, letter) {
          return letter.toUpperCase();
        }
        function kebabToCamel(name) {
          return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
        }
        var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
        var HTML_REGEXP = /<|&#?\w+;/;
        var TAG_NAME_REGEXP = /<([\w:-]+)/;
        var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
        var wrapMap = {
          thead: ["table"],
          col: ["colgroup", "table"],
          tr: ["tbody", "table"],
          td: ["tr", "tbody", "table"]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        var wrapMapIE9 = {
          option: [1, '<select multiple="multiple">', "</select>"],
          _default: [0, "", ""]
        };
        for (var key in wrapMap) {
          var wrapMapValueClosing = wrapMap[key];
          var wrapMapValue = wrapMapValueClosing.slice().reverse();
          wrapMapIE9[key] = [wrapMapValue.length, "<" + wrapMapValue.join("><") + ">", "</" + wrapMapValueClosing.join("></") + ">"];
        }
        wrapMapIE9.optgroup = wrapMapIE9.option;
        function jqLiteIsTextNode(html) {
          return !HTML_REGEXP.test(html);
        }
        function jqLiteAcceptsData(node) {
          var nodeType = node.nodeType;
          return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
        }
        function jqLiteHasData(node) {
          for (var key2 in jqCache[node.ng339]) {
            return true;
          }
          return false;
        }
        function jqLiteBuildFragment(html, context) {
          var tmp, tag, wrap2, finalHtml, fragment = context.createDocumentFragment(), nodes = [], i;
          if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
          } else {
            tmp = fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
            finalHtml = JQLite.legacyXHTMLReplacement ? html.replace(XHTML_TAG_REGEXP, "<$1></$2>") : html;
            if (msie < 10) {
              wrap2 = wrapMapIE9[tag] || wrapMapIE9._default;
              tmp.innerHTML = wrap2[1] + finalHtml + wrap2[2];
              i = wrap2[0];
              while (i--) {
                tmp = tmp.firstChild;
              }
            } else {
              wrap2 = wrapMap[tag] || [];
              i = wrap2.length;
              while (--i > -1) {
                tmp.appendChild(window2.document.createElement(wrap2[i]));
                tmp = tmp.firstChild;
              }
              tmp.innerHTML = finalHtml;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
          fragment.textContent = "";
          fragment.innerHTML = "";
          forEach(nodes, function(node) {
            fragment.appendChild(node);
          });
          return fragment;
        }
        function jqLiteParseHTML(html, context) {
          context = context || window2.document;
          var parsed;
          if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [context.createElement(parsed[1])];
          }
          if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
          }
          return [];
        }
        function jqLiteWrapNode(node, wrapper) {
          var parent = node.parentNode;
          if (parent) {
            parent.replaceChild(wrapper, node);
          }
          wrapper.appendChild(node);
        }
        var jqLiteContains = window2.Node.prototype.contains || function(arg) {
          return !!(this.compareDocumentPosition(arg) & 16);
        };
        function JQLite(element2) {
          if (element2 instanceof JQLite) {
            return element2;
          }
          var argIsString;
          if (isString(element2)) {
            element2 = trim(element2);
            argIsString = true;
          }
          if (!(this instanceof JQLite)) {
            if (argIsString && element2.charAt(0) !== "<") {
              throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element2);
          }
          if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element2));
          } else if (isFunction2(element2)) {
            jqLiteReady(element2);
          } else {
            jqLiteAddNodes(this, element2);
          }
        }
        function jqLiteClone(element2) {
          return element2.cloneNode(true);
        }
        function jqLiteDealoc(element2, onlyDescendants) {
          if (!onlyDescendants && jqLiteAcceptsData(element2))
            jqLite.cleanData([element2]);
          if (element2.querySelectorAll) {
            jqLite.cleanData(element2.querySelectorAll("*"));
          }
        }
        function isEmptyObject(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        }
        function removeIfEmptyData(element2) {
          var expandoId = element2.ng339;
          var expandoStore = expandoId && jqCache[expandoId];
          var events = expandoStore && expandoStore.events;
          var data = expandoStore && expandoStore.data;
          if ((!data || isEmptyObject(data)) && (!events || isEmptyObject(events))) {
            delete jqCache[expandoId];
            element2.ng339 = void 0;
          }
        }
        function jqLiteOff(element2, type, fn2, unsupported2) {
          if (isDefined(unsupported2))
            throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
          var expandoStore = jqLiteExpandoStore(element2);
          var events = expandoStore && expandoStore.events;
          var handle = expandoStore && expandoStore.handle;
          if (!handle)
            return;
          if (!type) {
            for (type in events) {
              if (type !== "$destroy") {
                element2.removeEventListener(type, handle);
              }
              delete events[type];
            }
          } else {
            var removeHandler = function(type2) {
              var listenerFns = events[type2];
              if (isDefined(fn2)) {
                arrayRemove(listenerFns || [], fn2);
              }
              if (!(isDefined(fn2) && listenerFns && listenerFns.length > 0)) {
                element2.removeEventListener(type2, handle);
                delete events[type2];
              }
            };
            forEach(type.split(" "), function(type2) {
              removeHandler(type2);
              if (MOUSE_EVENT_MAP[type2]) {
                removeHandler(MOUSE_EVENT_MAP[type2]);
              }
            });
          }
          removeIfEmptyData(element2);
        }
        function jqLiteRemoveData(element2, name) {
          var expandoId = element2.ng339;
          var expandoStore = expandoId && jqCache[expandoId];
          if (expandoStore) {
            if (name) {
              delete expandoStore.data[name];
            } else {
              expandoStore.data = {};
            }
            removeIfEmptyData(element2);
          }
        }
        function jqLiteExpandoStore(element2, createIfNecessary) {
          var expandoId = element2.ng339, expandoStore = expandoId && jqCache[expandoId];
          if (createIfNecessary && !expandoStore) {
            element2.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = { events: {}, data: {}, handle: void 0 };
          }
          return expandoStore;
        }
        function jqLiteData(element2, key2, value) {
          if (jqLiteAcceptsData(element2)) {
            var prop;
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key2 && !isObject2(key2);
            var massGetter = !key2;
            var expandoStore = jqLiteExpandoStore(element2, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
              data[kebabToCamel(key2)] = value;
            } else {
              if (massGetter) {
                return data;
              } else {
                if (isSimpleGetter) {
                  return data && data[kebabToCamel(key2)];
                } else {
                  for (prop in key2) {
                    data[kebabToCamel(prop)] = key2[prop];
                  }
                }
              }
            }
          }
        }
        function jqLiteHasClass(element2, selector) {
          if (!element2.getAttribute)
            return false;
          return (" " + (element2.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
        }
        function jqLiteRemoveClass(element2, cssClasses) {
          if (cssClasses && element2.setAttribute) {
            var existingClasses = (" " + (element2.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            var newClasses = existingClasses;
            forEach(cssClasses.split(" "), function(cssClass) {
              cssClass = trim(cssClass);
              newClasses = newClasses.replace(" " + cssClass + " ", " ");
            });
            if (newClasses !== existingClasses) {
              element2.setAttribute("class", trim(newClasses));
            }
          }
        }
        function jqLiteAddClass(element2, cssClasses) {
          if (cssClasses && element2.setAttribute) {
            var existingClasses = (" " + (element2.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            var newClasses = existingClasses;
            forEach(cssClasses.split(" "), function(cssClass) {
              cssClass = trim(cssClass);
              if (newClasses.indexOf(" " + cssClass + " ") === -1) {
                newClasses += cssClass + " ";
              }
            });
            if (newClasses !== existingClasses) {
              element2.setAttribute("class", trim(newClasses));
            }
          }
        }
        function jqLiteAddNodes(root, elements) {
          if (elements) {
            if (elements.nodeType) {
              root[root.length++] = elements;
            } else {
              var length = elements.length;
              if (typeof length === "number" && elements.window !== elements) {
                if (length) {
                  for (var i = 0; i < length; i++) {
                    root[root.length++] = elements[i];
                  }
                }
              } else {
                root[root.length++] = elements;
              }
            }
          }
        }
        function jqLiteController(element2, name) {
          return jqLiteInheritedData(element2, "$" + (name || "ngController") + "Controller");
        }
        function jqLiteInheritedData(element2, name, value) {
          if (element2.nodeType === NODE_TYPE_DOCUMENT) {
            element2 = element2.documentElement;
          }
          var names = isArray2(name) ? name : [name];
          while (element2) {
            for (var i = 0, ii = names.length; i < ii; i++) {
              if (isDefined(value = jqLite.data(element2, names[i])))
                return value;
            }
            element2 = element2.parentNode || element2.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element2.host;
          }
        }
        function jqLiteEmpty(element2) {
          jqLiteDealoc(element2, true);
          while (element2.firstChild) {
            element2.removeChild(element2.firstChild);
          }
        }
        function jqLiteRemove(element2, keepData) {
          if (!keepData)
            jqLiteDealoc(element2);
          var parent = element2.parentNode;
          if (parent)
            parent.removeChild(element2);
        }
        function jqLiteDocumentLoaded(action, win) {
          win = win || window2;
          if (win.document.readyState === "complete") {
            win.setTimeout(action);
          } else {
            jqLite(win).on("load", action);
          }
        }
        function jqLiteReady(fn2) {
          function trigger() {
            window2.document.removeEventListener("DOMContentLoaded", trigger);
            window2.removeEventListener("load", trigger);
            fn2();
          }
          if (window2.document.readyState === "complete") {
            window2.setTimeout(fn2);
          } else {
            window2.document.addEventListener("DOMContentLoaded", trigger);
            window2.addEventListener("load", trigger);
          }
        }
        var JQLitePrototype = JQLite.prototype = {
          ready: jqLiteReady,
          toString: function() {
            var value = [];
            forEach(this, function(e) {
              value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
          },
          eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
          },
          length: 0,
          push,
          sort: [].sort,
          splice: [].splice
        };
        var BOOLEAN_ATTR = {};
        forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
          BOOLEAN_ATTR[lowercase(value)] = value;
        });
        var BOOLEAN_ELEMENTS = {};
        forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
          BOOLEAN_ELEMENTS[value] = true;
        });
        var ALIASED_ATTR = {
          "ngMinlength": "minlength",
          "ngMaxlength": "maxlength",
          "ngMin": "min",
          "ngMax": "max",
          "ngPattern": "pattern",
          "ngStep": "step"
        };
        function getBooleanAttrName(element2, name) {
          var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
          return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element2)] && booleanAttr;
        }
        function getAliasedAttrName(name) {
          return ALIASED_ATTR[name];
        }
        forEach({
          data: jqLiteData,
          removeData: jqLiteRemoveData,
          hasData: jqLiteHasData,
          cleanData: function jqLiteCleanData(nodes) {
            for (var i = 0, ii = nodes.length; i < ii; i++) {
              jqLiteRemoveData(nodes[i]);
              jqLiteOff(nodes[i]);
            }
          }
        }, function(fn2, name) {
          JQLite[name] = fn2;
        });
        forEach({
          data: jqLiteData,
          inheritedData: jqLiteInheritedData,
          scope: function(element2) {
            return jqLite.data(element2, "$scope") || jqLiteInheritedData(element2.parentNode || element2, ["$isolateScope", "$scope"]);
          },
          isolateScope: function(element2) {
            return jqLite.data(element2, "$isolateScope") || jqLite.data(element2, "$isolateScopeNoTemplate");
          },
          controller: jqLiteController,
          injector: function(element2) {
            return jqLiteInheritedData(element2, "$injector");
          },
          removeAttr: function(element2, name) {
            element2.removeAttribute(name);
          },
          hasClass: jqLiteHasClass,
          css: function(element2, name, value) {
            name = cssKebabToCamel(name);
            if (isDefined(value)) {
              element2.style[name] = value;
            } else {
              return element2.style[name];
            }
          },
          attr: function(element2, name, value) {
            var ret;
            var nodeType = element2.nodeType;
            if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element2.getAttribute) {
              return;
            }
            var lowercasedName = lowercase(name);
            var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
            if (isDefined(value)) {
              if (value === null || value === false && isBooleanAttr) {
                element2.removeAttribute(name);
              } else {
                element2.setAttribute(name, isBooleanAttr ? lowercasedName : value);
              }
            } else {
              ret = element2.getAttribute(name);
              if (isBooleanAttr && ret !== null) {
                ret = lowercasedName;
              }
              return ret === null ? void 0 : ret;
            }
          },
          prop: function(element2, name, value) {
            if (isDefined(value)) {
              element2[name] = value;
            } else {
              return element2[name];
            }
          },
          text: function() {
            getText.$dv = "";
            return getText;
            function getText(element2, value) {
              if (isUndefined(value)) {
                var nodeType = element2.nodeType;
                return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element2.textContent : "";
              }
              element2.textContent = value;
            }
          }(),
          val: function(element2, value) {
            if (isUndefined(value)) {
              if (element2.multiple && nodeName_(element2) === "select") {
                var result = [];
                forEach(element2.options, function(option) {
                  if (option.selected) {
                    result.push(option.value || option.text);
                  }
                });
                return result;
              }
              return element2.value;
            }
            element2.value = value;
          },
          html: function(element2, value) {
            if (isUndefined(value)) {
              return element2.innerHTML;
            }
            jqLiteDealoc(element2, true);
            element2.innerHTML = value;
          },
          empty: jqLiteEmpty
        }, function(fn2, name) {
          JQLite.prototype[name] = function(arg1, arg2) {
            var i, key2;
            var nodeCount = this.length;
            if (fn2 !== jqLiteEmpty && isUndefined(fn2.length === 2 && (fn2 !== jqLiteHasClass && fn2 !== jqLiteController) ? arg1 : arg2)) {
              if (isObject2(arg1)) {
                for (i = 0; i < nodeCount; i++) {
                  if (fn2 === jqLiteData) {
                    fn2(this[i], arg1);
                  } else {
                    for (key2 in arg1) {
                      fn2(this[i], key2, arg1[key2]);
                    }
                  }
                }
                return this;
              } else {
                var value = fn2.$dv;
                var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                for (var j = 0; j < jj; j++) {
                  var nodeValue = fn2(this[j], arg1, arg2);
                  value = value ? value + nodeValue : nodeValue;
                }
                return value;
              }
            } else {
              for (i = 0; i < nodeCount; i++) {
                fn2(this[i], arg1, arg2);
              }
              return this;
            }
          };
        });
        function createEventHandler(element2, events) {
          var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
              return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength)
              return;
            if (isUndefined(event.immediatePropagationStopped)) {
              var originalStopImmediatePropagation = event.stopImmediatePropagation;
              event.stopImmediatePropagation = function() {
                event.immediatePropagationStopped = true;
                if (event.stopPropagation) {
                  event.stopPropagation();
                }
                if (originalStopImmediatePropagation) {
                  originalStopImmediatePropagation.call(event);
                }
              };
            }
            event.isImmediatePropagationStopped = function() {
              return event.immediatePropagationStopped === true;
            };
            var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
            if (eventFnsLength > 1) {
              eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
              if (!event.isImmediatePropagationStopped()) {
                handlerWrapper(element2, event, eventFns[i]);
              }
            }
          };
          eventHandler.elem = element2;
          return eventHandler;
        }
        function defaultHandlerWrapper(element2, event, handler) {
          handler.call(element2, event);
        }
        function specialMouseHandlerWrapper(target, event, handler) {
          var related = event.relatedTarget;
          if (!related || related !== target && !jqLiteContains.call(target, related)) {
            handler.call(target, event);
          }
        }
        forEach({
          removeData: jqLiteRemoveData,
          on: function jqLiteOn(element2, type, fn2, unsupported2) {
            if (isDefined(unsupported2))
              throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element2)) {
              return;
            }
            var expandoStore = jqLiteExpandoStore(element2, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
              handle = expandoStore.handle = createEventHandler(element2, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type];
            var i = types.length;
            var addHandler = function(type2, specialHandlerWrapper, noEventListener) {
              var eventFns = events[type2];
              if (!eventFns) {
                eventFns = events[type2] = [];
                eventFns.specialHandlerWrapper = specialHandlerWrapper;
                if (type2 !== "$destroy" && !noEventListener) {
                  element2.addEventListener(type2, handle);
                }
              }
              eventFns.push(fn2);
            };
            while (i--) {
              type = types[i];
              if (MOUSE_EVENT_MAP[type]) {
                addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                addHandler(type, void 0, true);
              } else {
                addHandler(type);
              }
            }
          },
          off: jqLiteOff,
          one: function(element2, type, fn2) {
            element2 = jqLite(element2);
            element2.on(type, function onFn() {
              element2.off(type, fn2);
              element2.off(type, onFn);
            });
            element2.on(type, fn2);
          },
          replaceWith: function(element2, replaceNode) {
            var index, parent = element2.parentNode;
            jqLiteDealoc(element2);
            forEach(new JQLite(replaceNode), function(node) {
              if (index) {
                parent.insertBefore(node, index.nextSibling);
              } else {
                parent.replaceChild(node, element2);
              }
              index = node;
            });
          },
          children: function(element2) {
            var children = [];
            forEach(element2.childNodes, function(element3) {
              if (element3.nodeType === NODE_TYPE_ELEMENT) {
                children.push(element3);
              }
            });
            return children;
          },
          contents: function(element2) {
            return element2.contentDocument || element2.childNodes || [];
          },
          append: function(element2, node) {
            var nodeType = element2.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
              return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
              var child = node[i];
              element2.appendChild(child);
            }
          },
          prepend: function(element2, node) {
            if (element2.nodeType === NODE_TYPE_ELEMENT) {
              var index = element2.firstChild;
              forEach(new JQLite(node), function(child) {
                element2.insertBefore(child, index);
              });
            }
          },
          wrap: function(element2, wrapNode) {
            jqLiteWrapNode(element2, jqLite(wrapNode).eq(0).clone()[0]);
          },
          remove: jqLiteRemove,
          detach: function(element2) {
            jqLiteRemove(element2, true);
          },
          after: function(element2, newElement) {
            var index = element2, parent = element2.parentNode;
            if (parent) {
              newElement = new JQLite(newElement);
              for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling);
                index = node;
              }
            }
          },
          addClass: jqLiteAddClass,
          removeClass: jqLiteRemoveClass,
          toggleClass: function(element2, selector, condition) {
            if (selector) {
              forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                if (isUndefined(classCondition)) {
                  classCondition = !jqLiteHasClass(element2, className);
                }
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element2, className);
              });
            }
          },
          parent: function(element2) {
            var parent = element2.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
          },
          next: function(element2) {
            return element2.nextElementSibling;
          },
          find: function(element2, selector) {
            if (element2.getElementsByTagName) {
              return element2.getElementsByTagName(selector);
            } else {
              return [];
            }
          },
          clone: jqLiteClone,
          triggerHandler: function(element2, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element2);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
              dummyEvent = {
                preventDefault: function() {
                  this.defaultPrevented = true;
                },
                isDefaultPrevented: function() {
                  return this.defaultPrevented === true;
                },
                stopImmediatePropagation: function() {
                  this.immediatePropagationStopped = true;
                },
                isImmediatePropagationStopped: function() {
                  return this.immediatePropagationStopped === true;
                },
                stopPropagation: noop3,
                type: eventName,
                target: element2
              };
              if (event.type) {
                dummyEvent = extend(dummyEvent, event);
              }
              eventFnsCopy = shallowCopy(eventFns);
              handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
              forEach(eventFnsCopy, function(fn2) {
                if (!dummyEvent.isImmediatePropagationStopped()) {
                  fn2.apply(element2, handlerArgs);
                }
              });
            }
          }
        }, function(fn2, name) {
          JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
              if (isUndefined(value)) {
                value = fn2(this[i], arg1, arg2, arg3);
                if (isDefined(value)) {
                  value = jqLite(value);
                }
              } else {
                jqLiteAddNodes(value, fn2(this[i], arg1, arg2, arg3));
              }
            }
            return isDefined(value) ? value : this;
          };
        });
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
        function $$jqLiteProvider() {
          this.$get = function $$jqLite() {
            return extend(JQLite, {
              hasClass: function(node, classes) {
                if (node.attr)
                  node = node[0];
                return jqLiteHasClass(node, classes);
              },
              addClass: function(node, classes) {
                if (node.attr)
                  node = node[0];
                return jqLiteAddClass(node, classes);
              },
              removeClass: function(node, classes) {
                if (node.attr)
                  node = node[0];
                return jqLiteRemoveClass(node, classes);
              }
            });
          };
        }
        function hashKey(obj, nextUidFn) {
          var key2 = obj && obj.$$hashKey;
          if (key2) {
            if (typeof key2 === "function") {
              key2 = obj.$$hashKey();
            }
            return key2;
          }
          var objType = typeof obj;
          if (objType === "function" || objType === "object" && obj !== null) {
            key2 = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
          } else {
            key2 = objType + ":" + obj;
          }
          return key2;
        }
        var nanKey = /* @__PURE__ */ Object.create(null);
        function NgMapShim() {
          this._keys = [];
          this._values = [];
          this._lastKey = NaN;
          this._lastIndex = -1;
        }
        NgMapShim.prototype = {
          _idx: function(key2) {
            if (key2 !== this._lastKey) {
              this._lastKey = key2;
              this._lastIndex = this._keys.indexOf(key2);
            }
            return this._lastIndex;
          },
          _transformKey: function(key2) {
            return isNumberNaN(key2) ? nanKey : key2;
          },
          get: function(key2) {
            key2 = this._transformKey(key2);
            var idx = this._idx(key2);
            if (idx !== -1) {
              return this._values[idx];
            }
          },
          has: function(key2) {
            key2 = this._transformKey(key2);
            var idx = this._idx(key2);
            return idx !== -1;
          },
          set: function(key2, value) {
            key2 = this._transformKey(key2);
            var idx = this._idx(key2);
            if (idx === -1) {
              idx = this._lastIndex = this._keys.length;
            }
            this._keys[idx] = key2;
            this._values[idx] = value;
          },
          delete: function(key2) {
            key2 = this._transformKey(key2);
            var idx = this._idx(key2);
            if (idx === -1) {
              return false;
            }
            this._keys.splice(idx, 1);
            this._values.splice(idx, 1);
            this._lastKey = NaN;
            this._lastIndex = -1;
            return true;
          }
        };
        var NgMap = NgMapShim;
        var $$MapProvider = [function() {
          this.$get = [function() {
            return NgMap;
          }];
        }];
        var ARROW_ARG = /^([^(]+?)=>/;
        var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
        var $injectorMinErr = minErr("$injector");
        function stringifyFn(fn2) {
          return Function.prototype.toString.call(fn2);
        }
        function extractArgs(fn2) {
          var fnText = stringifyFn(fn2).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
          return args;
        }
        function anonFn(fn2) {
          var args = extractArgs(fn2);
          if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
          }
          return "fn";
        }
        function annotate(fn2, strictDi, name) {
          var $inject, argDecl, last;
          if (typeof fn2 === "function") {
            if (!($inject = fn2.$inject)) {
              $inject = [];
              if (fn2.length) {
                if (strictDi) {
                  if (!isString(name) || !name) {
                    name = fn2.name || anonFn(fn2);
                  }
                  throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                }
                argDecl = extractArgs(fn2);
                forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                  arg.replace(FN_ARG, function(all, underscore, name2) {
                    $inject.push(name2);
                  });
                });
              }
              fn2.$inject = $inject;
            }
          } else if (isArray2(fn2)) {
            last = fn2.length - 1;
            assertArgFn(fn2[last], "fn");
            $inject = fn2.slice(0, last);
          } else {
            assertArgFn(fn2, "fn", true);
          }
          return $inject;
        }
        function createInjector2(modulesToLoad, strictDi) {
          strictDi = strictDi === true;
          var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
            $provide: {
              provider: supportObject(provider),
              factory: supportObject(factory),
              service: supportObject(service),
              value: supportObject(value),
              constant: supportObject(constant),
              decorator
            }
          }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular3.isString(caller)) {
              path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
          }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider2 = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider2.$get, provider2, void 0, serviceName);
          }), instanceInjector = protoInstanceInjector;
          providerCache["$injector" + providerSuffix] = { $get: valueFn(protoInstanceInjector) };
          instanceInjector.modules = providerInjector.modules = createMap();
          var runBlocks = loadModules(modulesToLoad);
          instanceInjector = protoInstanceInjector.get("$injector");
          instanceInjector.strictDi = strictDi;
          forEach(runBlocks, function(fn2) {
            if (fn2)
              instanceInjector.invoke(fn2);
          });
          instanceInjector.loadNewModules = function(mods) {
            forEach(loadModules(mods), function(fn2) {
              if (fn2)
                instanceInjector.invoke(fn2);
            });
          };
          return instanceInjector;
          function supportObject(delegate) {
            return function(key2, value2) {
              if (isObject2(key2)) {
                forEach(key2, reverseParams(delegate));
              } else {
                return delegate(key2, value2);
              }
            };
          }
          function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction2(provider_) || isArray2(provider_)) {
              provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
              throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
          }
          function enforceReturnValue(name, factory2) {
            return function enforcedReturnValue() {
              var result = instanceInjector.invoke(factory2, this);
              if (isUndefined(result)) {
                throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
              }
              return result;
            };
          }
          function factory(name, factoryFn, enforce) {
            return provider(name, {
              $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
          }
          function service(name, constructor) {
            return factory(name, ["$injector", function($injector) {
              return $injector.instantiate(constructor);
            }]);
          }
          function value(name, val) {
            return factory(name, valueFn(val), false);
          }
          function constant(name, value2) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value2;
            instanceCache[name] = value2;
          }
          function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
              var origInstance = instanceInjector.invoke(orig$get, origProvider);
              return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
            };
          }
          function loadModules(modulesToLoad2) {
            assertArg(isUndefined(modulesToLoad2) || isArray2(modulesToLoad2), "modulesToLoad", "not an array");
            var runBlocks2 = [], moduleFn;
            forEach(modulesToLoad2, function(module2) {
              if (loadedModules.get(module2))
                return;
              loadedModules.set(module2, true);
              function runInvokeQueue(queue2) {
                var i, ii;
                for (i = 0, ii = queue2.length; i < ii; i++) {
                  var invokeArgs = queue2[i], provider2 = providerInjector.get(invokeArgs[0]);
                  provider2[invokeArgs[1]].apply(provider2, invokeArgs[2]);
                }
              }
              try {
                if (isString(module2)) {
                  moduleFn = angularModule(module2);
                  instanceInjector.modules[module2] = moduleFn;
                  runBlocks2 = runBlocks2.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                  runInvokeQueue(moduleFn._invokeQueue);
                  runInvokeQueue(moduleFn._configBlocks);
                } else if (isFunction2(module2)) {
                  runBlocks2.push(providerInjector.invoke(module2));
                } else if (isArray2(module2)) {
                  runBlocks2.push(providerInjector.invoke(module2));
                } else {
                  assertArgFn(module2, "module");
                }
              } catch (e) {
                if (isArray2(module2)) {
                  module2 = module2[module2.length - 1];
                }
                if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                  e = e.message + "\n" + e.stack;
                }
                throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module2, e.stack || e.message || e);
              }
            });
            return runBlocks2;
          }
          function createInternalInjector(cache, factory2) {
            function getService(serviceName, caller) {
              if (cache.hasOwnProperty(serviceName)) {
                if (cache[serviceName] === INSTANTIATING) {
                  throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                }
                return cache[serviceName];
              } else {
                try {
                  path.unshift(serviceName);
                  cache[serviceName] = INSTANTIATING;
                  cache[serviceName] = factory2(serviceName, caller);
                  return cache[serviceName];
                } catch (err) {
                  if (cache[serviceName] === INSTANTIATING) {
                    delete cache[serviceName];
                  }
                  throw err;
                } finally {
                  path.shift();
                }
              }
            }
            function injectionArgs(fn2, locals, serviceName) {
              var args = [], $inject = createInjector2.$$annotate(fn2, strictDi, serviceName);
              for (var i = 0, length = $inject.length; i < length; i++) {
                var key2 = $inject[i];
                if (typeof key2 !== "string") {
                  throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key2);
                }
                args.push(locals && locals.hasOwnProperty(key2) ? locals[key2] : getService(key2, serviceName));
              }
              return args;
            }
            function isClass(func) {
              if (msie || typeof func !== "function") {
                return false;
              }
              var result = func.$$ngIsClass;
              if (!isBoolean(result)) {
                result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func));
              }
              return result;
            }
            function invoke(fn2, self2, locals, serviceName) {
              if (typeof locals === "string") {
                serviceName = locals;
                locals = null;
              }
              var args = injectionArgs(fn2, locals, serviceName);
              if (isArray2(fn2)) {
                fn2 = fn2[fn2.length - 1];
              }
              if (!isClass(fn2)) {
                return fn2.apply(self2, args);
              } else {
                args.unshift(null);
                return new (Function.prototype.bind.apply(fn2, args))();
              }
            }
            function instantiate(Type3, locals, serviceName) {
              var ctor = isArray2(Type3) ? Type3[Type3.length - 1] : Type3;
              var args = injectionArgs(Type3, locals, serviceName);
              args.unshift(null);
              return new (Function.prototype.bind.apply(ctor, args))();
            }
            return {
              invoke,
              instantiate,
              get: getService,
              annotate: createInjector2.$$annotate,
              has: function(name) {
                return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
              }
            };
          }
        }
        createInjector2.$$annotate = annotate;
        function $AnchorScrollProvider() {
          var autoScrollingEnabled = true;
          this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
          };
          this.$get = ["$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document2 = $window.document;
            function getFirstAnchor(list) {
              var result = null;
              Array.prototype.some.call(list, function(element2) {
                if (nodeName_(element2) === "a") {
                  result = element2;
                  return true;
                }
              });
              return result;
            }
            function getYOffset() {
              var offset = scroll.yOffset;
              if (isFunction2(offset)) {
                offset = offset();
              } else if (isElement(offset)) {
                var elem = offset[0];
                var style = $window.getComputedStyle(elem);
                if (style.position !== "fixed") {
                  offset = 0;
                } else {
                  offset = elem.getBoundingClientRect().bottom;
                }
              } else if (!isNumber(offset)) {
                offset = 0;
              }
              return offset;
            }
            function scrollTo(elem) {
              if (elem) {
                elem.scrollIntoView();
                var offset = getYOffset();
                if (offset) {
                  var elemTop = elem.getBoundingClientRect().top;
                  $window.scrollBy(0, elemTop - offset);
                }
              } else {
                $window.scrollTo(0, 0);
              }
            }
            function scroll(hash) {
              hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
              var elm;
              if (!hash)
                scrollTo(null);
              else if (elm = document2.getElementById(hash))
                scrollTo(elm);
              else if (elm = getFirstAnchor(document2.getElementsByName(hash)))
                scrollTo(elm);
              else if (hash === "top")
                scrollTo(null);
            }
            if (autoScrollingEnabled) {
              $rootScope.$watch(function autoScrollWatch() {
                return $location.hash();
              }, function autoScrollWatchAction(newVal, oldVal) {
                if (newVal === oldVal && newVal === "")
                  return;
                jqLiteDocumentLoaded(function() {
                  $rootScope.$evalAsync(scroll);
                });
              });
            }
            return scroll;
          }];
        }
        var $animateMinErr = minErr("$animate");
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_CLASSNAME = "ng-animate";
        function mergeClasses(a, b) {
          if (!a && !b)
            return "";
          if (!a)
            return b;
          if (!b)
            return a;
          if (isArray2(a))
            a = a.join(" ");
          if (isArray2(b))
            b = b.join(" ");
          return a + " " + b;
        }
        function extractElementNode(element2) {
          for (var i = 0; i < element2.length; i++) {
            var elm = element2[i];
            if (elm.nodeType === ELEMENT_NODE) {
              return elm;
            }
          }
        }
        function splitClasses(classes) {
          if (isString(classes)) {
            classes = classes.split(" ");
          }
          var obj = createMap();
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        function prepareAnimateOptions(options) {
          return isObject2(options) ? options : {};
        }
        var $$CoreAnimateJsProvider = function() {
          this.$get = noop3;
        };
        var $$CoreAnimateQueueProvider = function() {
          var postDigestQueue = new NgMap();
          var postDigestElements = [];
          this.$get = [
            "$$AnimateRunner",
            "$rootScope",
            function($$AnimateRunner, $rootScope) {
              return {
                enabled: noop3,
                on: noop3,
                off: noop3,
                pin: noop3,
                push: function(element2, event, options, domOperation) {
                  if (domOperation) {
                    domOperation();
                  }
                  options = options || {};
                  if (options.from) {
                    element2.css(options.from);
                  }
                  if (options.to) {
                    element2.css(options.to);
                  }
                  if (options.addClass || options.removeClass) {
                    addRemoveClassesPostDigest(element2, options.addClass, options.removeClass);
                  }
                  var runner = new $$AnimateRunner();
                  runner.complete();
                  return runner;
                }
              };
              function updateData(data, classes, value) {
                var changed = false;
                if (classes) {
                  classes = isString(classes) ? classes.split(" ") : isArray2(classes) ? classes : [];
                  forEach(classes, function(className) {
                    if (className) {
                      changed = true;
                      data[className] = value;
                    }
                  });
                }
                return changed;
              }
              function handleCSSClassChanges() {
                forEach(postDigestElements, function(element2) {
                  var data = postDigestQueue.get(element2);
                  if (data) {
                    var existing = splitClasses(element2.attr("class"));
                    var toAdd = "";
                    var toRemove = "";
                    forEach(data, function(status, className) {
                      var hasClass = !!existing[className];
                      if (status !== hasClass) {
                        if (status) {
                          toAdd += (toAdd.length ? " " : "") + className;
                        } else {
                          toRemove += (toRemove.length ? " " : "") + className;
                        }
                      }
                    });
                    forEach(element2, function(elm) {
                      if (toAdd) {
                        jqLiteAddClass(elm, toAdd);
                      }
                      if (toRemove) {
                        jqLiteRemoveClass(elm, toRemove);
                      }
                    });
                    postDigestQueue.delete(element2);
                  }
                });
                postDigestElements.length = 0;
              }
              function addRemoveClassesPostDigest(element2, add, remove2) {
                var data = postDigestQueue.get(element2) || {};
                var classesAdded = updateData(data, add, true);
                var classesRemoved = updateData(data, remove2, false);
                if (classesAdded || classesRemoved) {
                  postDigestQueue.set(element2, data);
                  postDigestElements.push(element2);
                  if (postDigestElements.length === 1) {
                    $rootScope.$$postDigest(handleCSSClassChanges);
                  }
                }
              }
            }
          ];
        };
        var $AnimateProvider = ["$provide", function($provide) {
          var provider = this;
          var classNameFilter = null;
          var customFilter = null;
          this.$$registeredAnimations = /* @__PURE__ */ Object.create(null);
          this.register = function(name, factory) {
            if (name && name.charAt(0) !== ".") {
              throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            }
            var key2 = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key2;
            $provide.factory(key2, factory);
          };
          this.customFilter = function(filterFn) {
            if (arguments.length === 1) {
              customFilter = isFunction2(filterFn) ? filterFn : null;
            }
            return customFilter;
          };
          this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
              classNameFilter = expression instanceof RegExp ? expression : null;
              if (classNameFilter) {
                var reservedRegex = new RegExp("[(\\s|\\/)]" + NG_ANIMATE_CLASSNAME + "[(\\s|\\/)]");
                if (reservedRegex.test(classNameFilter.toString())) {
                  classNameFilter = null;
                  throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                }
              }
            }
            return classNameFilter;
          };
          this.$get = ["$$animateQueue", function($$animateQueue) {
            function domInsert(element2, parentElement, afterElement) {
              if (afterElement) {
                var afterNode = extractElementNode(afterElement);
                if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                  afterElement = null;
                }
              }
              if (afterElement) {
                afterElement.after(element2);
              } else {
                parentElement.prepend(element2);
              }
            }
            return {
              on: $$animateQueue.on,
              off: $$animateQueue.off,
              pin: $$animateQueue.pin,
              enabled: $$animateQueue.enabled,
              cancel: function(runner) {
                if (runner.cancel) {
                  runner.cancel();
                }
              },
              enter: function(element2, parent, after, options) {
                parent = parent && jqLite(parent);
                after = after && jqLite(after);
                parent = parent || after.parent();
                domInsert(element2, parent, after);
                return $$animateQueue.push(element2, "enter", prepareAnimateOptions(options));
              },
              move: function(element2, parent, after, options) {
                parent = parent && jqLite(parent);
                after = after && jqLite(after);
                parent = parent || after.parent();
                domInsert(element2, parent, after);
                return $$animateQueue.push(element2, "move", prepareAnimateOptions(options));
              },
              leave: function(element2, options) {
                return $$animateQueue.push(element2, "leave", prepareAnimateOptions(options), function() {
                  element2.remove();
                });
              },
              addClass: function(element2, className, options) {
                options = prepareAnimateOptions(options);
                options.addClass = mergeClasses(options.addclass, className);
                return $$animateQueue.push(element2, "addClass", options);
              },
              removeClass: function(element2, className, options) {
                options = prepareAnimateOptions(options);
                options.removeClass = mergeClasses(options.removeClass, className);
                return $$animateQueue.push(element2, "removeClass", options);
              },
              setClass: function(element2, add, remove2, options) {
                options = prepareAnimateOptions(options);
                options.addClass = mergeClasses(options.addClass, add);
                options.removeClass = mergeClasses(options.removeClass, remove2);
                return $$animateQueue.push(element2, "setClass", options);
              },
              animate: function(element2, from2, to, className, options) {
                options = prepareAnimateOptions(options);
                options.from = options.from ? extend(options.from, from2) : from2;
                options.to = options.to ? extend(options.to, to) : to;
                className = className || "ng-inline-animate";
                options.tempClasses = mergeClasses(options.tempClasses, className);
                return $$animateQueue.push(element2, "animate", options);
              }
            };
          }];
        }];
        var $$AnimateAsyncRunFactoryProvider = function() {
          this.$get = ["$$rAF", function($$rAF) {
            var waitQueue = [];
            function waitForTick(fn2) {
              waitQueue.push(fn2);
              if (waitQueue.length > 1)
                return;
              $$rAF(function() {
                for (var i = 0; i < waitQueue.length; i++) {
                  waitQueue[i]();
                }
                waitQueue = [];
              });
            }
            return function() {
              var passed = false;
              waitForTick(function() {
                passed = true;
              });
              return function(callback) {
                if (passed) {
                  callback();
                } else {
                  waitForTick(callback);
                }
              };
            };
          }];
        };
        var $$AnimateRunnerFactoryProvider = function() {
          this.$get = [
            "$q",
            "$sniffer",
            "$$animateAsyncRun",
            "$$isDocumentHidden",
            "$timeout",
            function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
              var INITIAL_STATE = 0;
              var DONE_PENDING_STATE = 1;
              var DONE_COMPLETE_STATE = 2;
              AnimateRunner.chain = function(chain, callback) {
                var index = 0;
                next();
                function next() {
                  if (index === chain.length) {
                    callback(true);
                    return;
                  }
                  chain[index](function(response) {
                    if (response === false) {
                      callback(false);
                      return;
                    }
                    index++;
                    next();
                  });
                }
              };
              AnimateRunner.all = function(runners, callback) {
                var count = 0;
                var status = true;
                forEach(runners, function(runner) {
                  runner.done(onProgress);
                });
                function onProgress(response) {
                  status = status && response;
                  if (++count === runners.length) {
                    callback(status);
                  }
                }
              };
              function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun();
                var timeoutTick = function(fn2) {
                  $timeout(fn2, 0, false);
                };
                this._doneCallbacks = [];
                this._tick = function(fn2) {
                  if ($$isDocumentHidden()) {
                    timeoutTick(fn2);
                  } else {
                    rafTick(fn2);
                  }
                };
                this._state = 0;
              }
              AnimateRunner.prototype = {
                setHost: function(host) {
                  this.host = host || {};
                },
                done: function(fn2) {
                  if (this._state === DONE_COMPLETE_STATE) {
                    fn2();
                  } else {
                    this._doneCallbacks.push(fn2);
                  }
                },
                progress: noop3,
                getPromise: function() {
                  if (!this.promise) {
                    var self2 = this;
                    this.promise = $q(function(resolve, reject) {
                      self2.done(function(status) {
                        if (status === false) {
                          reject();
                        } else {
                          resolve();
                        }
                      });
                    });
                  }
                  return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                  return this.getPromise().then(resolveHandler, rejectHandler);
                },
                "catch": function(handler) {
                  return this.getPromise()["catch"](handler);
                },
                "finally": function(handler) {
                  return this.getPromise()["finally"](handler);
                },
                pause: function() {
                  if (this.host.pause) {
                    this.host.pause();
                  }
                },
                resume: function() {
                  if (this.host.resume) {
                    this.host.resume();
                  }
                },
                end: function() {
                  if (this.host.end) {
                    this.host.end();
                  }
                  this._resolve(true);
                },
                cancel: function() {
                  if (this.host.cancel) {
                    this.host.cancel();
                  }
                  this._resolve(false);
                },
                complete: function(response) {
                  var self2 = this;
                  if (self2._state === INITIAL_STATE) {
                    self2._state = DONE_PENDING_STATE;
                    self2._tick(function() {
                      self2._resolve(response);
                    });
                  }
                },
                _resolve: function(response) {
                  if (this._state !== DONE_COMPLETE_STATE) {
                    forEach(this._doneCallbacks, function(fn2) {
                      fn2(response);
                    });
                    this._doneCallbacks.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                  }
                }
              };
              return AnimateRunner;
            }
          ];
        };
        var $CoreAnimateCssProvider = function() {
          this.$get = ["$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element2, initialOptions) {
              var options = initialOptions || {};
              if (!options.$$prepared) {
                options = copy(options);
              }
              if (options.cleanupStyles) {
                options.from = options.to = null;
              }
              if (options.from) {
                element2.css(options.from);
                options.from = null;
              }
              var closed, runner = new $$AnimateRunner();
              return {
                start: run,
                end: run
              };
              function run() {
                $$rAF(function() {
                  applyAnimationContents();
                  if (!closed) {
                    runner.complete();
                  }
                  closed = true;
                });
                return runner;
              }
              function applyAnimationContents() {
                if (options.addClass) {
                  element2.addClass(options.addClass);
                  options.addClass = null;
                }
                if (options.removeClass) {
                  element2.removeClass(options.removeClass);
                  options.removeClass = null;
                }
                if (options.to) {
                  element2.css(options.to);
                  options.to = null;
                }
              }
            };
          }];
        };
        function getHash(url) {
          var index = url.indexOf("#");
          return index === -1 ? "" : url.substr(index);
        }
        function trimEmptyHash(url) {
          return url.replace(/#$/, "");
        }
        function Browser(window3, document2, $log, $sniffer, $$taskTrackerFactory) {
          var self2 = this, location2 = window3.location, history = window3.history, setTimeout2 = window3.setTimeout, clearTimeout2 = window3.clearTimeout, pendingDeferIds = {}, taskTracker = $$taskTrackerFactory($log);
          self2.isMock = false;
          self2.$$completeOutstandingRequest = taskTracker.completeTask;
          self2.$$incOutstandingRequestCount = taskTracker.incTaskCount;
          self2.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
          var cachedState, lastHistoryState, lastBrowserUrl = location2.href, baseElement = document2.find("base"), pendingLocation = null, getCurrentState = !$sniffer.history ? noop3 : function getCurrentState2() {
            try {
              return history.state;
            } catch (e) {
            }
          };
          cacheState();
          self2.url = function(url, replace, state) {
            if (isUndefined(state)) {
              state = null;
            }
            if (location2 !== window3.location)
              location2 = window3.location;
            if (history !== window3.history)
              history = window3.history;
            if (url) {
              var sameState = lastHistoryState === state;
              url = urlResolve(url).href;
              if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                return self2;
              }
              var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
              lastBrowserUrl = url;
              lastHistoryState = state;
              if ($sniffer.history && (!sameBase || !sameState)) {
                history[replace ? "replaceState" : "pushState"](state, "", url);
                cacheState();
              } else {
                if (!sameBase) {
                  pendingLocation = url;
                }
                if (replace) {
                  location2.replace(url);
                } else if (!sameBase) {
                  location2.href = url;
                } else {
                  location2.hash = getHash(url);
                }
                if (location2.href !== url) {
                  pendingLocation = url;
                }
              }
              if (pendingLocation) {
                pendingLocation = url;
              }
              return self2;
            } else {
              return trimEmptyHash(pendingLocation || location2.href);
            }
          };
          self2.state = function() {
            return cachedState;
          };
          var urlChangeListeners = [], urlChangeInit = false;
          function cacheStateAndFireUrlChange() {
            pendingLocation = null;
            fireStateOrUrlChange();
          }
          var lastCachedState = null;
          function cacheState() {
            cachedState = getCurrentState();
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
              cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
            lastHistoryState = cachedState;
          }
          function fireStateOrUrlChange() {
            var prevLastHistoryState = lastHistoryState;
            cacheState();
            if (lastBrowserUrl === self2.url() && prevLastHistoryState === cachedState) {
              return;
            }
            lastBrowserUrl = self2.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
              listener(self2.url(), cachedState);
            });
          }
          self2.onUrlChange = function(callback) {
            if (!urlChangeInit) {
              if ($sniffer.history)
                jqLite(window3).on("popstate", cacheStateAndFireUrlChange);
              jqLite(window3).on("hashchange", cacheStateAndFireUrlChange);
              urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
          };
          self2.$$applicationDestroyed = function() {
            jqLite(window3).off("hashchange popstate", cacheStateAndFireUrlChange);
          };
          self2.$$checkUrlChange = fireStateOrUrlChange;
          self2.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
          };
          self2.defer = function(fn2, delay2, taskType) {
            var timeoutId;
            delay2 = delay2 || 0;
            taskType = taskType || taskTracker.DEFAULT_TASK_TYPE;
            taskTracker.incTaskCount(taskType);
            timeoutId = setTimeout2(function() {
              delete pendingDeferIds[timeoutId];
              taskTracker.completeTask(fn2, taskType);
            }, delay2);
            pendingDeferIds[timeoutId] = taskType;
            return timeoutId;
          };
          self2.defer.cancel = function(deferId) {
            if (pendingDeferIds.hasOwnProperty(deferId)) {
              var taskType = pendingDeferIds[deferId];
              delete pendingDeferIds[deferId];
              clearTimeout2(deferId);
              taskTracker.completeTask(noop3, taskType);
              return true;
            }
            return false;
          };
        }
        function $BrowserProvider() {
          this.$get = [
            "$window",
            "$log",
            "$sniffer",
            "$document",
            "$$taskTrackerFactory",
            function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
              return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory);
            }
          ];
        }
        function $CacheFactoryProvider() {
          this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
              if (cacheId in caches) {
                throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
              }
              var size = 0, stats = extend({}, options, { id: cacheId }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
              return caches[cacheId] = {
                put: function(key2, value) {
                  if (isUndefined(value))
                    return;
                  if (capacity < Number.MAX_VALUE) {
                    var lruEntry = lruHash[key2] || (lruHash[key2] = { key: key2 });
                    refresh(lruEntry);
                  }
                  if (!(key2 in data))
                    size++;
                  data[key2] = value;
                  if (size > capacity) {
                    this.remove(staleEnd.key);
                  }
                  return value;
                },
                get: function(key2) {
                  if (capacity < Number.MAX_VALUE) {
                    var lruEntry = lruHash[key2];
                    if (!lruEntry)
                      return;
                    refresh(lruEntry);
                  }
                  return data[key2];
                },
                remove: function(key2) {
                  if (capacity < Number.MAX_VALUE) {
                    var lruEntry = lruHash[key2];
                    if (!lruEntry)
                      return;
                    if (lruEntry === freshEnd)
                      freshEnd = lruEntry.p;
                    if (lruEntry === staleEnd)
                      staleEnd = lruEntry.n;
                    link(lruEntry.n, lruEntry.p);
                    delete lruHash[key2];
                  }
                  if (!(key2 in data))
                    return;
                  delete data[key2];
                  size--;
                },
                removeAll: function() {
                  data = createMap();
                  size = 0;
                  lruHash = createMap();
                  freshEnd = staleEnd = null;
                },
                destroy: function() {
                  data = null;
                  stats = null;
                  lruHash = null;
                  delete caches[cacheId];
                },
                info: function() {
                  return extend({}, stats, { size });
                }
              };
              function refresh(entry) {
                if (entry !== freshEnd) {
                  if (!staleEnd) {
                    staleEnd = entry;
                  } else if (staleEnd === entry) {
                    staleEnd = entry.n;
                  }
                  link(entry.n, entry.p);
                  link(entry, freshEnd);
                  freshEnd = entry;
                  freshEnd.n = null;
                }
              }
              function link(nextEntry, prevEntry) {
                if (nextEntry !== prevEntry) {
                  if (nextEntry)
                    nextEntry.p = prevEntry;
                  if (prevEntry)
                    prevEntry.n = nextEntry;
                }
              }
            }
            cacheFactory.info = function() {
              var info = {};
              forEach(caches, function(cache, cacheId) {
                info[cacheId] = cache.info();
              });
              return info;
            };
            cacheFactory.get = function(cacheId) {
              return caches[cacheId];
            };
            return cacheFactory;
          };
        }
        function $TemplateCacheProvider() {
          this.$get = ["$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
          }];
        }
        var $compileMinErr = minErr("$compile");
        function UNINITIALIZED_VALUE() {
        }
        var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
        $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
        function $CompileProvider($provide, $$sanitizeUriProvider) {
          var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
          var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
          var bindingCache = createMap();
          function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/;
            var bindings = createMap();
            forEach(scope, function(definition, scopeName) {
              definition = definition.trim();
              if (definition in bindingCache) {
                bindings[scopeName] = bindingCache[definition];
                return;
              }
              var match = definition.match(LOCAL_REGEXP);
              if (!match) {
                throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
              }
              bindings[scopeName] = {
                mode: match[1][0],
                collection: match[2] === "*",
                optional: match[3] === "?",
                attrName: match[4] || scopeName
              };
              if (match[4]) {
                bindingCache[definition] = bindings[scopeName];
              }
            });
            return bindings;
          }
          function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
              isolateScope: null,
              bindToController: null
            };
            if (isObject2(directive.scope)) {
              if (directive.bindToController === true) {
                bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                bindings.isolateScope = {};
              } else {
                bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
              }
            }
            if (isObject2(directive.bindToController)) {
              bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
            }
            if (bindings.bindToController && !directive.controller) {
              throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            }
            return bindings;
          }
          function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) {
              throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
            }
            if (name !== name.trim()) {
              throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
            }
          }
          function getDirectiveRequire(directive) {
            var require2 = directive.require || directive.controller && directive.name;
            if (!isArray2(require2) && isObject2(require2)) {
              forEach(require2, function(value, key2) {
                var match = value.match(REQUIRE_PREFIX_REGEXP);
                var name = value.substring(match[0].length);
                if (!name)
                  require2[key2] = match[0] + key2;
              });
            }
            return require2;
          }
          function getDirectiveRestrict(restrict, name) {
            if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
              throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
            }
            return restrict || "EA";
          }
          this.directive = function registerDirective(name, directiveFactory) {
            assertArg(name, "name");
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
              assertValidDirectiveName(name);
              assertArg(directiveFactory, "directiveFactory");
              if (!hasDirectives.hasOwnProperty(name)) {
                hasDirectives[name] = [];
                $provide.factory(name + Suffix, [
                  "$injector",
                  "$exceptionHandler",
                  function($injector, $exceptionHandler) {
                    var directives = [];
                    forEach(hasDirectives[name], function(directiveFactory2, index) {
                      try {
                        var directive = $injector.invoke(directiveFactory2);
                        if (isFunction2(directive)) {
                          directive = { compile: valueFn(directive) };
                        } else if (!directive.compile && directive.link) {
                          directive.compile = valueFn(directive.link);
                        }
                        directive.priority = directive.priority || 0;
                        directive.index = index;
                        directive.name = directive.name || name;
                        directive.require = getDirectiveRequire(directive);
                        directive.restrict = getDirectiveRestrict(directive.restrict, name);
                        directive.$$moduleName = directiveFactory2.$$moduleName;
                        directives.push(directive);
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    });
                    return directives;
                  }
                ]);
              }
              hasDirectives[name].push(directiveFactory);
            } else {
              forEach(name, reverseParams(registerDirective));
            }
            return this;
          };
          this.component = function registerComponent(name, options) {
            if (!isString(name)) {
              forEach(name, reverseParams(bind(this, registerComponent)));
              return this;
            }
            var controller = options.controller || function() {
            };
            function factory($injector) {
              function makeInjectable(fn2) {
                if (isFunction2(fn2) || isArray2(fn2)) {
                  return function(tElement, tAttrs) {
                    return $injector.invoke(fn2, this, { $element: tElement, $attrs: tAttrs });
                  };
                } else {
                  return fn2;
                }
              }
              var template = !options.template && !options.templateUrl ? "" : options.template;
              var ddo = {
                controller,
                controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                template: makeInjectable(template),
                templateUrl: makeInjectable(options.templateUrl),
                transclude: options.transclude,
                scope: {},
                bindToController: options.bindings || {},
                restrict: "E",
                require: options.require
              };
              forEach(options, function(val, key2) {
                if (key2.charAt(0) === "$")
                  ddo[key2] = val;
              });
              return ddo;
            }
            forEach(options, function(val, key2) {
              if (key2.charAt(0) === "$") {
                factory[key2] = val;
                if (isFunction2(controller))
                  controller[key2] = val;
              }
            });
            factory.$inject = ["$injector"];
            return this.directive(name, factory);
          };
          this.aHrefSanitizationTrustedUrlList = function(regexp) {
            if (isDefined(regexp)) {
              $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp);
              return this;
            } else {
              return $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
            }
          };
          Object.defineProperty(this, "aHrefSanitizationWhitelist", {
            get: function() {
              return this.aHrefSanitizationTrustedUrlList;
            },
            set: function(value) {
              this.aHrefSanitizationTrustedUrlList = value;
            }
          });
          this.imgSrcSanitizationTrustedUrlList = function(regexp) {
            if (isDefined(regexp)) {
              $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp);
              return this;
            } else {
              return $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
            }
          };
          Object.defineProperty(this, "imgSrcSanitizationWhitelist", {
            get: function() {
              return this.imgSrcSanitizationTrustedUrlList;
            },
            set: function(value) {
              this.imgSrcSanitizationTrustedUrlList = value;
            }
          });
          var debugInfoEnabled = true;
          this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
              debugInfoEnabled = enabled;
              return this;
            }
            return debugInfoEnabled;
          };
          var strictComponentBindingsEnabled = false;
          this.strictComponentBindingsEnabled = function(enabled) {
            if (isDefined(enabled)) {
              strictComponentBindingsEnabled = enabled;
              return this;
            }
            return strictComponentBindingsEnabled;
          };
          var TTL = 10;
          this.onChangesTtl = function(value) {
            if (arguments.length) {
              TTL = value;
              return this;
            }
            return TTL;
          };
          var commentDirectivesEnabledConfig = true;
          this.commentDirectivesEnabled = function(value) {
            if (arguments.length) {
              commentDirectivesEnabledConfig = value;
              return this;
            }
            return commentDirectivesEnabledConfig;
          };
          var cssClassDirectivesEnabledConfig = true;
          this.cssClassDirectivesEnabled = function(value) {
            if (arguments.length) {
              cssClassDirectivesEnabledConfig = value;
              return this;
            }
            return cssClassDirectivesEnabledConfig;
          };
          var PROP_CONTEXTS = createMap();
          this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
            var key2 = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
            if (key2 in PROP_CONTEXTS && PROP_CONTEXTS[key2] !== ctx) {
              throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key2], ctx);
            }
            PROP_CONTEXTS[key2] = ctx;
            return this;
          };
          (function registerNativePropertyContexts() {
            function registerContext2(ctx, values) {
              forEach(values, function(v) {
                PROP_CONTEXTS[v.toLowerCase()] = ctx;
              });
            }
            registerContext2(SCE_CONTEXTS.HTML, [
              "iframe|srcdoc",
              "*|innerHTML",
              "*|outerHTML"
            ]);
            registerContext2(SCE_CONTEXTS.CSS, ["*|style"]);
            registerContext2(SCE_CONTEXTS.URL, [
              "area|href",
              "area|ping",
              "a|href",
              "a|ping",
              "blockquote|cite",
              "body|background",
              "del|cite",
              "input|src",
              "ins|cite",
              "q|cite"
            ]);
            registerContext2(SCE_CONTEXTS.MEDIA_URL, [
              "audio|src",
              "img|src",
              "img|srcset",
              "source|src",
              "source|srcset",
              "track|src",
              "video|src",
              "video|poster"
            ]);
            registerContext2(SCE_CONTEXTS.RESOURCE_URL, [
              "*|formAction",
              "applet|code",
              "applet|codebase",
              "base|href",
              "embed|src",
              "frame|src",
              "form|action",
              "head|profile",
              "html|manifest",
              "iframe|src",
              "link|href",
              "media|src",
              "object|codebase",
              "object|data",
              "script|src"
            ]);
          })();
          this.$get = [
            "$injector",
            "$interpolate",
            "$exceptionHandler",
            "$templateRequest",
            "$parse",
            "$controller",
            "$rootScope",
            "$sce",
            "$animate",
            function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
              var SIMPLE_ATTR_NAME = /^\w/;
              var specialAttrHolder = window2.document.createElement("div");
              var commentDirectivesEnabled = commentDirectivesEnabledConfig;
              var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
              var onChangesTtl = TTL;
              var onChangesQueue;
              function flushOnChangesQueue() {
                try {
                  if (!--onChangesTtl) {
                    onChangesQueue = void 0;
                    throw $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                  }
                  $rootScope.$apply(function() {
                    for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                      try {
                        onChangesQueue[i]();
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                    onChangesQueue = void 0;
                  });
                } finally {
                  onChangesTtl++;
                }
              }
              function sanitizeSrcset2(value, invokeType) {
                if (!value) {
                  return value;
                }
                if (!isString(value)) {
                  throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, value.toString());
                }
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
                  result += " " + trim(rawUris[innerIdx + 1]);
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $sce.getTrustedMediaUrl(trim(lastTuple[0]));
                if (lastTuple.length === 2) {
                  result += " " + trim(lastTuple[1]);
                }
                return result;
              }
              function Attributes(element2, attributesToCopy) {
                if (attributesToCopy) {
                  var keys = Object.keys(attributesToCopy);
                  var i, l, key2;
                  for (i = 0, l = keys.length; i < l; i++) {
                    key2 = keys[i];
                    this[key2] = attributesToCopy[key2];
                  }
                } else {
                  this.$attr = {};
                }
                this.$$element = element2;
              }
              Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                  if (classVal && classVal.length > 0) {
                    $animate.addClass(this.$$element, classVal);
                  }
                },
                $removeClass: function(classVal) {
                  if (classVal && classVal.length > 0) {
                    $animate.removeClass(this.$$element, classVal);
                  }
                },
                $updateClass: function(newClasses, oldClasses) {
                  var toAdd = tokenDifference(newClasses, oldClasses);
                  if (toAdd && toAdd.length) {
                    $animate.addClass(this.$$element, toAdd);
                  }
                  var toRemove = tokenDifference(oldClasses, newClasses);
                  if (toRemove && toRemove.length) {
                    $animate.removeClass(this.$$element, toRemove);
                  }
                },
                $set: function(key2, value, writeAttr, attrName) {
                  var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key2), aliasedKey = getAliasedAttrName(key2), observer = key2, nodeName;
                  if (booleanKey) {
                    this.$$element.prop(key2, value);
                    attrName = booleanKey;
                  } else if (aliasedKey) {
                    this[aliasedKey] = value;
                    observer = aliasedKey;
                  }
                  this[key2] = value;
                  if (attrName) {
                    this.$attr[key2] = attrName;
                  } else {
                    attrName = this.$attr[key2];
                    if (!attrName) {
                      this.$attr[key2] = attrName = snake_case(key2, "-");
                    }
                  }
                  nodeName = nodeName_(this.$$element);
                  if (nodeName === "img" && key2 === "srcset") {
                    this[key2] = value = sanitizeSrcset2(value, "$set('srcset', value)");
                  }
                  if (writeAttr !== false) {
                    if (value === null || isUndefined(value)) {
                      this.$$element.removeAttr(attrName);
                    } else {
                      if (SIMPLE_ATTR_NAME.test(attrName)) {
                        if (booleanKey && value === false) {
                          this.$$element.removeAttr(attrName);
                        } else {
                          this.$$element.attr(attrName, value);
                        }
                      } else {
                        setSpecialAttr(this.$$element[0], attrName, value);
                      }
                    }
                  }
                  var $$observers = this.$$observers;
                  if ($$observers) {
                    forEach($$observers[observer], function(fn2) {
                      try {
                        fn2(value);
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    });
                  }
                },
                $observe: function(key2, fn2) {
                  var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key2] || ($$observers[key2] = []);
                  listeners.push(fn2);
                  $rootScope.$evalAsync(function() {
                    if (!listeners.$$inter && attrs.hasOwnProperty(key2) && !isUndefined(attrs[key2])) {
                      fn2(attrs[key2]);
                    }
                  });
                  return function() {
                    arrayRemove(listeners, fn2);
                  };
                }
              };
              function setSpecialAttr(element2, attrName, value) {
                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                var attributes = specialAttrHolder.firstChild.attributes;
                var attribute = attributes[0];
                attributes.removeNamedItem(attribute.name);
                attribute.value = value;
                element2.attributes.setNamedItem(attribute);
              }
              function safeAddClass($element, className) {
                try {
                  $element.addClass(className);
                } catch (e) {
                }
              }
              var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === "{{" && endSymbol === "}}" ? identity2 : function denormalizeTemplate2(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              }, NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/;
              var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
              compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray2(binding)) {
                  bindings = bindings.concat(binding);
                } else {
                  bindings.push(binding);
                }
                $element.data("$binding", bindings);
              } : noop3;
              compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
              } : noop3;
              compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
              } : noop3;
              compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
              } : noop3;
              compile.$$createComment = function(directiveName, comment) {
                var content = "";
                if (debugInfoEnabled) {
                  content = " " + (directiveName || "") + ": ";
                  if (comment)
                    content += comment + " ";
                }
                return window2.document.createComment(content);
              };
              return compile;
              function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                  $compileNodes = jqLite($compileNodes);
                }
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                  if (!$compileNodes) {
                    throw $compileMinErr("multilink", "This element has already been linked.");
                  }
                  assertArg(scope, "scope");
                  if (previousCompileContext && previousCompileContext.needsNewScope) {
                    scope = scope.$parent.$new();
                  }
                  options = options || {};
                  var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                  if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                    parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                  }
                  if (!namespace) {
                    namespace = detectNamespaceForChildElements(futureParentElement);
                  }
                  var $linkNode;
                  if (namespace !== "html") {
                    $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html()));
                  } else if (cloneConnectFn) {
                    $linkNode = JQLitePrototype.clone.call($compileNodes);
                  } else {
                    $linkNode = $compileNodes;
                  }
                  if (transcludeControllers) {
                    for (var controllerName in transcludeControllers) {
                      $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    }
                  }
                  compile.$$addScopeInfo($linkNode, scope);
                  if (cloneConnectFn)
                    cloneConnectFn($linkNode, scope);
                  if (compositeLinkFn)
                    compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                  if (!cloneConnectFn) {
                    $compileNodes = compositeLinkFn = null;
                  }
                  return $linkNode;
                };
              }
              function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                  return "html";
                } else {
                  return nodeName_(node) !== "foreignobject" && toString.call(node).match(/SVG/) ? "svg" : "html";
                }
              }
              function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], notLiveList = isArray2(nodeList) || nodeList instanceof jqLite, attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                  attrs = new Attributes();
                  if (msie === 11) {
                    mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                  }
                  directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : void 0, ignoreDirective);
                  nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                  if (nodeLinkFn && nodeLinkFn.scope) {
                    compile.$$addScopeClass(attrs.$$element);
                  }
                  childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                  if (nodeLinkFn || childLinkFn) {
                    linkFns.push(i, nodeLinkFn, childLinkFn);
                    linkFnFound = true;
                    nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                  }
                  previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList2, $rootElement2, parentBoundTranscludeFn) {
                  var nodeLinkFn2, childLinkFn2, node, childScope, i2, ii, idx, childBoundTranscludeFn;
                  var stableNodeList;
                  if (nodeLinkFnFound) {
                    var nodeListLength = nodeList2.length;
                    stableNodeList = new Array(nodeListLength);
                    for (i2 = 0; i2 < linkFns.length; i2 += 3) {
                      idx = linkFns[i2];
                      stableNodeList[idx] = nodeList2[idx];
                    }
                  } else {
                    stableNodeList = nodeList2;
                  }
                  for (i2 = 0, ii = linkFns.length; i2 < ii; ) {
                    node = stableNodeList[linkFns[i2++]];
                    nodeLinkFn2 = linkFns[i2++];
                    childLinkFn2 = linkFns[i2++];
                    if (nodeLinkFn2) {
                      if (nodeLinkFn2.scope) {
                        childScope = scope.$new();
                        compile.$$addScopeInfo(jqLite(node), childScope);
                      } else {
                        childScope = scope;
                      }
                      if (nodeLinkFn2.transcludeOnThisElement) {
                        childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn2.transclude, parentBoundTranscludeFn);
                      } else if (!nodeLinkFn2.templateOnThisElement && parentBoundTranscludeFn) {
                        childBoundTranscludeFn = parentBoundTranscludeFn;
                      } else if (!parentBoundTranscludeFn && transcludeFn) {
                        childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                      } else {
                        childBoundTranscludeFn = null;
                      }
                      nodeLinkFn2(childLinkFn2, childScope, node, $rootElement2, childBoundTranscludeFn);
                    } else if (childLinkFn2) {
                      childLinkFn2(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                    }
                  }
                }
              }
              function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                var node = nodeList[idx];
                var parent = node.parentNode;
                var sibling;
                if (node.nodeType !== NODE_TYPE_TEXT) {
                  return;
                }
                while (true) {
                  sibling = parent ? node.nextSibling : nodeList[idx + 1];
                  if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
                    break;
                  }
                  node.nodeValue = node.nodeValue + sibling.nodeValue;
                  if (sibling.parentNode) {
                    sibling.parentNode.removeChild(sibling);
                  }
                  if (notLiveList && sibling === nodeList[idx + 1]) {
                    nodeList.splice(idx + 1, 1);
                  }
                }
              }
              function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                  if (!transcludedScope) {
                    transcludedScope = scope.$new(false, containingScope);
                    transcludedScope.$$transcluded = true;
                  }
                  return transcludeFn(transcludedScope, cloneFn, {
                    parentBoundTranscludeFn: previousBoundTranscludeFn,
                    transcludeControllers: controllers,
                    futureParentElement
                  });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) {
                  if (transcludeFn.$$slots[slotName]) {
                    boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                  } else {
                    boundSlots[slotName] = null;
                  }
                }
                return boundTranscludeFn;
              }
              function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node);
                    addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, value, ngPrefixMatch, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                      var attrStartName = false;
                      var attrEndName = false;
                      var isNgAttr = false, isNgProp = false, isNgEvent = false;
                      var multiElementMatch;
                      attr = nAttrs[j];
                      name = attr.name;
                      value = attr.value;
                      nName = directiveNormalize(name.toLowerCase());
                      if (ngPrefixMatch = nName.match(NG_PREFIX_BINDING)) {
                        isNgAttr = ngPrefixMatch[1] === "Attr";
                        isNgProp = ngPrefixMatch[1] === "Prop";
                        isNgEvent = ngPrefixMatch[1] === "On";
                        name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + ngPrefixMatch[1].length).replace(/_(.)/g, function(match2, letter) {
                          return letter.toUpperCase();
                        });
                      } else if ((multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && directiveIsMultiElement(multiElementMatch[1])) {
                        attrStartName = name;
                        attrEndName = name.substr(0, name.length - 5) + "end";
                        name = name.substr(0, name.length - 6);
                      }
                      if (isNgProp || isNgEvent) {
                        attrs[nName] = value;
                        attrsMap[nName] = attr.name;
                        if (isNgProp) {
                          addPropertyDirective(node, directives, nName, name);
                        } else {
                          addEventDirective(directives, nName, name);
                        }
                      } else {
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                          attrs[nName] = value;
                          if (getBooleanAttrName(node, nName)) {
                            attrs[nName] = true;
                          }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                      }
                    }
                    if (nodeName === "input" && node.getAttribute("type") === "hidden") {
                      node.setAttribute("autocomplete", "off");
                    }
                    if (!cssClassDirectivesEnabled)
                      break;
                    className = node.className;
                    if (isObject2(className)) {
                      className = className.animVal;
                    }
                    if (isString(className) && className !== "") {
                      while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                        nName = directiveNormalize(match[2]);
                        if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                          attrs[nName] = trim(match[3]);
                        }
                        className = className.substr(match.index + match[0].length);
                      }
                    }
                    break;
                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;
                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled)
                      break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                    break;
                }
                directives.sort(byPriority);
                return directives;
              }
              function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                  var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    var nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {
                }
              }
              function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                  do {
                    if (!node) {
                      throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                    }
                    if (node.nodeType === NODE_TYPE_ELEMENT) {
                      if (node.hasAttribute(attrStart))
                        depth++;
                      if (node.hasAttribute(attrEnd))
                        depth--;
                    }
                    nodes.push(node);
                    node = node.nextSibling;
                  } while (depth > 0);
                } else {
                  nodes.push(node);
                }
                return jqLite(nodes);
              }
              function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function groupedElementsLink(scope, element2, attrs, controllers, transcludeFn) {
                  element2 = groupScan(element2[0], attrStart, attrEnd);
                  return linkFn(scope, element2, attrs, controllers, transcludeFn);
                };
              }
              function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                if (eager) {
                  return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                }
                return function lazyCompilation() {
                  if (!compiled) {
                    compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                    $compileNodes = transcludeFn = previousCompileContext = null;
                  }
                  return compiled.apply(this, arguments);
                };
              }
              function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                  directive = directives[i];
                  var attrStart = directive.$$start;
                  var attrEnd = directive.$$end;
                  if (attrStart) {
                    $compileNode = groupScan(compileNode, attrStart, attrEnd);
                  }
                  $template = void 0;
                  if (terminalPriority > directive.priority) {
                    break;
                  }
                  directiveValue = directive.scope;
                  if (directiveValue) {
                    if (!directive.templateUrl) {
                      if (isObject2(directiveValue)) {
                        assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                        newIsolateScopeDirective = directive;
                      } else {
                        assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                      }
                    }
                    newScopeDirective = newScopeDirective || directive;
                  }
                  directiveName = directive.name;
                  if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                    var candidateDirective;
                    for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                      if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                        mightHaveMultipleTransclusionError = true;
                        break;
                      }
                    }
                    didScanForMultipleTransclusion = true;
                  }
                  if (!directive.templateUrl && directive.controller) {
                    controllerDirectives = controllerDirectives || createMap();
                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                    controllerDirectives[directiveName] = directive;
                  }
                  directiveValue = directive.transclude;
                  if (directiveValue) {
                    hasTranscludeDirective = true;
                    if (!directive.$$tlb) {
                      assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                      nonTlbTranscludeDirective = directive;
                    }
                    if (directiveValue === "element") {
                      hasElementTranscludeDirective = true;
                      terminalPriority = directive.priority;
                      $template = $compileNode;
                      $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                      compileNode = $compileNode[0];
                      replaceWith(jqCollection, sliceArgs($template), compileNode);
                      childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective
                      });
                    } else {
                      var slots = createMap();
                      if (!isObject2(directiveValue)) {
                        $template = jqLite(jqLiteClone(compileNode)).contents();
                      } else {
                        $template = window2.document.createDocumentFragment();
                        var slotMap = createMap();
                        var filledSlots = createMap();
                        forEach(directiveValue, function(elementSelector, slotName2) {
                          var optional = elementSelector.charAt(0) === "?";
                          elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                          slotMap[elementSelector] = slotName2;
                          slots[slotName2] = null;
                          filledSlots[slotName2] = optional;
                        });
                        forEach($compileNode.contents(), function(node) {
                          var slotName2 = slotMap[directiveNormalize(nodeName_(node))];
                          if (slotName2) {
                            filledSlots[slotName2] = true;
                            slots[slotName2] = slots[slotName2] || window2.document.createDocumentFragment();
                            slots[slotName2].appendChild(node);
                          } else {
                            $template.appendChild(node);
                          }
                        });
                        forEach(filledSlots, function(filled, slotName2) {
                          if (!filled) {
                            throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName2);
                          }
                        });
                        for (var slotName in slots) {
                          if (slots[slotName]) {
                            var slotCompileNodes = jqLite(slots[slotName].childNodes);
                            slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn);
                          }
                        }
                        $template = jqLite($template.childNodes);
                      }
                      $compileNode.empty();
                      childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, { needsNewScope: directive.$$isolateScope || directive.$$newScope });
                      childTranscludeFn.$$slots = slots;
                    }
                  }
                  if (directive.template) {
                    hasTemplate = true;
                    assertNoDuplicate("template", templateDirective, directive, $compileNode);
                    templateDirective = directive;
                    directiveValue = isFunction2(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                    directiveValue = denormalizeTemplate(directiveValue);
                    if (directive.replace) {
                      replaceDirective = directive;
                      if (jqLiteIsTextNode(directiveValue)) {
                        $template = [];
                      } else {
                        $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                      }
                      compileNode = $template[0];
                      if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                        throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                      }
                      replaceWith(jqCollection, $compileNode, compileNode);
                      var newTemplateAttrs = { $attr: {} };
                      var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                      var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                      if (newIsolateScopeDirective || newScopeDirective) {
                        markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                      }
                      directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                      mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                      ii = directives.length;
                    } else {
                      $compileNode.html(directiveValue);
                    }
                  }
                  if (directive.templateUrl) {
                    hasTemplate = true;
                    assertNoDuplicate("template", templateDirective, directive, $compileNode);
                    templateDirective = directive;
                    if (directive.replace) {
                      replaceDirective = directive;
                    }
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                      controllerDirectives,
                      newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                      newIsolateScopeDirective,
                      templateDirective,
                      nonTlbTranscludeDirective
                    });
                    ii = directives.length;
                  } else if (directive.compile) {
                    try {
                      linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                      var context = directive.$$originalDirective || directive;
                      if (isFunction2(linkFn)) {
                        addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                      } else if (linkFn) {
                        addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                      }
                    } catch (e) {
                      $exceptionHandler(e, startingTag($compileNode));
                    }
                  }
                  if (directive.terminal) {
                    nodeLinkFn.terminal = true;
                    terminalPriority = Math.max(terminalPriority, directive.priority);
                  }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart2, attrEnd2) {
                  if (pre) {
                    if (attrStart2)
                      pre = groupElementsLinkFnWrapper(pre, attrStart2, attrEnd2);
                    pre.require = directive.require;
                    pre.directiveName = directiveName;
                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                      pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                    }
                    preLinkFns.push(pre);
                  }
                  if (post) {
                    if (attrStart2)
                      post = groupElementsLinkFnWrapper(post, attrStart2, attrEnd2);
                    post.require = directive.require;
                    post.directiveName = directiveName;
                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                      post = cloneAndAnnotateFn(post, { isolateScope: true });
                    }
                    postLinkFns.push(post);
                  }
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                  var i2, ii2, linkFn2, isolateScope, controllerScope, elementControllers, transcludeFn2, $element, attrs, scopeBindingInfo;
                  if (compileNode === linkNode) {
                    attrs = templateAttrs;
                    $element = templateAttrs.$$element;
                  } else {
                    $element = jqLite(linkNode);
                    attrs = new Attributes($element, templateAttrs);
                  }
                  controllerScope = scope;
                  if (newIsolateScopeDirective) {
                    isolateScope = scope.$new(true);
                  } else if (newScopeDirective) {
                    controllerScope = scope.$parent;
                  }
                  if (boundTranscludeFn) {
                    transcludeFn2 = controllersBoundTransclude;
                    transcludeFn2.$$boundTransclude = boundTranscludeFn;
                    transcludeFn2.isSlotFilled = function(slotName2) {
                      return !!boundTranscludeFn.$$slots[slotName2];
                    };
                  }
                  if (controllerDirectives) {
                    elementControllers = setupControllers($element, attrs, transcludeFn2, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                  }
                  if (newIsolateScopeDirective) {
                    compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                    compile.$$addScopeClass($element, true);
                    isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                    scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                    if (scopeBindingInfo.removeWatches) {
                      isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                    }
                  }
                  for (var name in elementControllers) {
                    var controllerDirective = controllerDirectives[name];
                    var controller = elementControllers[name];
                    var bindings = controllerDirective.$$bindings.bindToController;
                    controller.instance = controller();
                    $element.data("$" + controllerDirective.name + "Controller", controller.instance);
                    controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                  }
                  forEach(controllerDirectives, function(controllerDirective2, name2) {
                    var require2 = controllerDirective2.require;
                    if (controllerDirective2.bindToController && !isArray2(require2) && isObject2(require2)) {
                      extend(elementControllers[name2].instance, getControllers(name2, require2, $element, elementControllers));
                    }
                  });
                  forEach(elementControllers, function(controller2) {
                    var controllerInstance = controller2.instance;
                    if (isFunction2(controllerInstance.$onChanges)) {
                      try {
                        controllerInstance.$onChanges(controller2.bindingInfo.initialChanges);
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                    if (isFunction2(controllerInstance.$onInit)) {
                      try {
                        controllerInstance.$onInit();
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                    if (isFunction2(controllerInstance.$doCheck)) {
                      controllerScope.$watch(function() {
                        controllerInstance.$doCheck();
                      });
                      controllerInstance.$doCheck();
                    }
                    if (isFunction2(controllerInstance.$onDestroy)) {
                      controllerScope.$on("$destroy", function callOnDestroyHook() {
                        controllerInstance.$onDestroy();
                      });
                    }
                  });
                  for (i2 = 0, ii2 = preLinkFns.length; i2 < ii2; i2++) {
                    linkFn2 = preLinkFns[i2];
                    invokeLinkFn(linkFn2, linkFn2.isolateScope ? isolateScope : scope, $element, attrs, linkFn2.require && getControllers(linkFn2.directiveName, linkFn2.require, $element, elementControllers), transcludeFn2);
                  }
                  var scopeToChild = scope;
                  if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                    scopeToChild = isolateScope;
                  }
                  if (childLinkFn) {
                    childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn);
                  }
                  for (i2 = postLinkFns.length - 1; i2 >= 0; i2--) {
                    linkFn2 = postLinkFns[i2];
                    invokeLinkFn(linkFn2, linkFn2.isolateScope ? isolateScope : scope, $element, attrs, linkFn2.require && getControllers(linkFn2.directiveName, linkFn2.require, $element, elementControllers), transcludeFn2);
                  }
                  forEach(elementControllers, function(controller2) {
                    var controllerInstance = controller2.instance;
                    if (isFunction2(controllerInstance.$postLink)) {
                      controllerInstance.$postLink();
                    }
                  });
                  function controllersBoundTransclude(scope2, cloneAttachFn, futureParentElement, slotName2) {
                    var transcludeControllers;
                    if (!isScope(scope2)) {
                      slotName2 = futureParentElement;
                      futureParentElement = cloneAttachFn;
                      cloneAttachFn = scope2;
                      scope2 = void 0;
                    }
                    if (hasElementTranscludeDirective) {
                      transcludeControllers = elementControllers;
                    }
                    if (!futureParentElement) {
                      futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                    }
                    if (slotName2) {
                      var slotTranscludeFn = boundTranscludeFn.$$slots[slotName2];
                      if (slotTranscludeFn) {
                        return slotTranscludeFn(scope2, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                      } else if (isUndefined(slotTranscludeFn)) {
                        throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName2, startingTag($element));
                      }
                    } else {
                      return boundTranscludeFn(scope2, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                  }
                }
              }
              function getControllers(directiveName, require2, $element, elementControllers) {
                var value;
                if (isString(require2)) {
                  var match = require2.match(REQUIRE_PREFIX_REGEXP);
                  var name = require2.substring(match[0].length);
                  var inheritType = match[1] || match[3];
                  var optional = match[2] === "?";
                  if (inheritType === "^^") {
                    $element = $element.parent();
                  } else {
                    value = elementControllers && elementControllers[name];
                    value = value && value.instance;
                  }
                  if (!value) {
                    var dataName = "$" + name + "Controller";
                    if (inheritType === "^^" && $element[0] && $element[0].nodeType === NODE_TYPE_DOCUMENT) {
                      value = null;
                    } else {
                      value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                    }
                  }
                  if (!value && !optional) {
                    throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                  }
                } else if (isArray2(require2)) {
                  value = [];
                  for (var i = 0, ii = require2.length; i < ii; i++) {
                    value[i] = getControllers(directiveName, require2[i], $element, elementControllers);
                  }
                } else if (isObject2(require2)) {
                  value = {};
                  forEach(require2, function(controller, property) {
                    value[property] = getControllers(directiveName, controller, $element, elementControllers);
                  });
                }
                return value || null;
              }
              function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                  var directive = controllerDirectives[controllerKey];
                  var locals = {
                    $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                    $element,
                    $attrs: attrs,
                    $transclude: transcludeFn
                  };
                  var controller = directive.controller;
                  if (controller === "@") {
                    controller = attrs[directive.name];
                  }
                  var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                  elementControllers[directive.name] = controllerInstance;
                  $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                }
                return elementControllers;
              }
              function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                  directives[j] = inherit(directives[j], { $$isolateScope: isolateScope, $$newScope: newScope });
                }
              }
              function addDirective(tDirectives, name, location2, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective)
                  return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                  for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location2) !== -1) {
                      if (startAttrName) {
                        directive = inherit(directive, { $$start: startAttrName, $$end: endAttrName });
                      }
                      if (!directive.$$bindings) {
                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        if (isObject2(bindings.isolateScope)) {
                          directive.$$isolateBindings = bindings.isolateScope;
                        }
                      }
                      tDirectives.push(directive);
                      match = directive;
                    }
                  }
                }
                return match;
              }
              function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                  for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    if (directive.multiElement) {
                      return true;
                    }
                  }
                }
                return false;
              }
              function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key2) {
                  if (key2.charAt(0) !== "$") {
                    if (src[key2] && src[key2] !== value) {
                      if (value.length) {
                        value += (key2 === "style" ? ";" : " ") + src[key2];
                      } else {
                        value = src[key2];
                      }
                    }
                    dst.$set(key2, value, true, srcAttr[key2]);
                  }
                });
                forEach(src, function(value, key2) {
                  if (!dst.hasOwnProperty(key2) && key2.charAt(0) !== "$") {
                    dst[key2] = value;
                    if (key2 !== "class" && key2 !== "style") {
                      dstAttr[key2] = srcAttr[key2];
                    }
                  }
                });
              }
              function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction2(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest(templateUrl).then(function(content) {
                  var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                  content = denormalizeTemplate(content);
                  if (origAsyncDirective.replace) {
                    if (jqLiteIsTextNode(content)) {
                      $template = [];
                    } else {
                      $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                    }
                    compileNode = $template[0];
                    if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                      throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                    }
                    tempTemplateAttrs = { $attr: {} };
                    replaceWith($rootElement, $compileNode, compileNode);
                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                    if (isObject2(origAsyncDirective.scope)) {
                      markDirectiveScope(templateDirectives, true);
                    }
                    directives = templateDirectives.concat(directives);
                    mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                  } else {
                    compileNode = beforeTemplateCompileNode;
                    $compileNode.html(content);
                  }
                  directives.unshift(derivedSyncDirective);
                  afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                  forEach($rootElement, function(node, i) {
                    if (node === compileNode) {
                      $rootElement[i] = $compileNode[0];
                    }
                  });
                  afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                  while (linkQueue.length) {
                    var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                    if (scope.$$destroyed)
                      continue;
                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                      var oldClasses = beforeTemplateLinkNode.className;
                      if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                        linkNode = jqLiteClone(compileNode);
                      }
                      replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                      safeAddClass(jqLite(linkNode), oldClasses);
                    }
                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                      childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                    } else {
                      childBoundTranscludeFn = boundTranscludeFn;
                    }
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                  }
                  linkQueue = null;
                }).catch(function(error3) {
                  if (isError(error3)) {
                    $exceptionHandler(error3);
                  }
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                  var childBoundTranscludeFn = boundTranscludeFn;
                  if (scope.$$destroyed)
                    return;
                  if (linkQueue) {
                    linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                  } else {
                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                      childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                    }
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                  }
                };
              }
              function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0)
                  return diff;
                if (a.name !== b.name)
                  return a.name < b.name ? -1 : 1;
                return a.index - b.index;
              }
              function assertNoDuplicate(what, previousDirective, directive, element2) {
                function wrapModuleNameIfDefined(moduleName) {
                  return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) {
                  throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element2));
                }
              }
              function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                  directives.push({
                    priority: 0,
                    compile: function textInterpolateCompileFn(templateNode) {
                      var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                      if (hasCompileParent)
                        compile.$$addBindingClass(templateNodeParent);
                      return function textInterpolateLinkFn(scope, node) {
                        var parent = node.parent();
                        if (!hasCompileParent)
                          compile.$$addBindingClass(parent);
                        compile.$$addBindingInfo(parent, interpolateFn.expressions);
                        scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                          node[0].nodeValue = value;
                        });
                      };
                    }
                  });
                }
              }
              function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = window2.document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;
                  default:
                    return template;
                }
              }
              function getTrustedAttrContext(nodeName, attrNormalizedName) {
                if (attrNormalizedName === "srcdoc") {
                  return $sce.HTML;
                }
                if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
                  if (["img", "video", "audio", "source", "track"].indexOf(nodeName) === -1) {
                    return $sce.RESOURCE_URL;
                  }
                  return $sce.MEDIA_URL;
                } else if (attrNormalizedName === "xlinkHref") {
                  if (nodeName === "image")
                    return $sce.MEDIA_URL;
                  if (nodeName === "a")
                    return $sce.URL;
                  return $sce.RESOURCE_URL;
                } else if (nodeName === "form" && attrNormalizedName === "action" || nodeName === "base" && attrNormalizedName === "href" || nodeName === "link" && attrNormalizedName === "href") {
                  return $sce.RESOURCE_URL;
                } else if (nodeName === "a" && (attrNormalizedName === "href" || attrNormalizedName === "ngHref")) {
                  return $sce.URL;
                }
              }
              function getTrustedPropContext(nodeName, propNormalizedName) {
                var prop = propNormalizedName.toLowerCase();
                return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop];
              }
              function sanitizeSrcsetPropertyValue(value) {
                return sanitizeSrcset2($sce.valueOf(value), "ng-prop-srcset");
              }
              function addPropertyDirective(node, directives, attrName, propName) {
                if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) {
                  throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                }
                var nodeName = nodeName_(node);
                var trustedContext = getTrustedPropContext(nodeName, propName);
                var sanitizer = identity2;
                if (propName === "srcset" && (nodeName === "img" || nodeName === "source")) {
                  sanitizer = sanitizeSrcsetPropertyValue;
                } else if (trustedContext) {
                  sanitizer = $sce.getTrusted.bind($sce, trustedContext);
                }
                directives.push({
                  priority: 100,
                  compile: function ngPropCompileFn(_, attr) {
                    var ngPropGetter = $parse(attr[attrName]);
                    var ngPropWatch = $parse(attr[attrName], function sceValueOf(val) {
                      return $sce.valueOf(val);
                    });
                    return {
                      pre: function ngPropPreLinkFn(scope, $element) {
                        function applyPropValue() {
                          var propValue = ngPropGetter(scope);
                          $element[0][propName] = sanitizer(propValue);
                        }
                        applyPropValue();
                        scope.$watch(ngPropWatch, applyPropValue);
                      }
                    };
                  }
                });
              }
              function addEventDirective(directives, attrName, eventName) {
                directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, false));
              }
              function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var nodeName = nodeName_(node);
                var trustedContext = getTrustedAttrContext(nodeName, name);
                var mustHaveExpression = !isNgAttr;
                var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
                var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (!interpolateFn)
                  return;
                if (name === "multiple" && nodeName === "select") {
                  throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                  throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                }
                directives.push({
                  priority: 100,
                  compile: function() {
                    return {
                      pre: function attrInterpolatePreLinkFn(scope, element2, attr) {
                        var $$observers = attr.$$observers || (attr.$$observers = createMap());
                        var newValue = attr[name];
                        if (newValue !== value) {
                          interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                          value = newValue;
                        }
                        if (!interpolateFn)
                          return;
                        attr[name] = interpolateFn(scope);
                        ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                        (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue2, oldValue) {
                          if (name === "class" && newValue2 !== oldValue) {
                            attr.$updateClass(newValue2, oldValue);
                          } else {
                            attr.$set(name, newValue2);
                          }
                        });
                      }
                    };
                  }
                });
              }
              function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                  for (i = 0, ii = $rootElement.length; i < ii; i++) {
                    if ($rootElement[i] === firstElementToRemove) {
                      $rootElement[i++] = newNode;
                      for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                        if (j2 < jj) {
                          $rootElement[j] = $rootElement[j2];
                        } else {
                          delete $rootElement[j];
                        }
                      }
                      $rootElement.length -= removeCount - 1;
                      if ($rootElement.context === firstElementToRemove) {
                        $rootElement.context = newNode;
                      }
                      break;
                    }
                  }
                }
                if (parent) {
                  parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = window2.document.createDocumentFragment();
                for (i = 0; i < removeCount; i++) {
                  fragment.appendChild(elementsToRemove[i]);
                }
                if (jqLite.hasData(firstElementToRemove)) {
                  jqLite.data(newNode, jqLite.data(firstElementToRemove));
                  jqLite(firstElementToRemove).off("$destroy");
                }
                jqLite.cleanData(fragment.querySelectorAll("*"));
                for (i = 1; i < removeCount; i++) {
                  delete elementsToRemove[i];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
              }
              function cloneAndAnnotateFn(fn2, annotation) {
                return extend(function() {
                  return fn2.apply(null, arguments);
                }, fn2, annotation);
              }
              function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                  linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                  $exceptionHandler(e, startingTag($element));
                }
              }
              function strictBindingsCheck(attrName, directiveName) {
                if (strictComponentBindingsEnabled) {
                  throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
                }
              }
              function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                var removeWatchCollection = [];
                var initialChanges = {};
                var changes;
                forEach(bindings, function initializeBinding(definition, scopeName) {
                  var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                  switch (mode) {
                    case "@":
                      if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                        strictBindingsCheck(attrName, directive.name);
                        destination[scopeName] = attrs[attrName] = void 0;
                      }
                      removeWatch = attrs.$observe(attrName, function(value) {
                        if (isString(value) || isBoolean(value)) {
                          var oldValue = destination[scopeName];
                          recordChanges(scopeName, value, oldValue);
                          destination[scopeName] = value;
                        }
                      });
                      attrs.$$observers[attrName].$$scope = scope;
                      lastValue = attrs[attrName];
                      if (isString(lastValue)) {
                        destination[scopeName] = $interpolate(lastValue)(scope);
                      } else if (isBoolean(lastValue)) {
                        destination[scopeName] = lastValue;
                      }
                      initialChanges[scopeName] = new SimpleChange2(_UNINITIALIZED_VALUE, destination[scopeName]);
                      removeWatchCollection.push(removeWatch);
                      break;
                    case "=":
                      if (!hasOwnProperty.call(attrs, attrName)) {
                        if (optional)
                          break;
                        strictBindingsCheck(attrName, directive.name);
                        attrs[attrName] = void 0;
                      }
                      if (optional && !attrs[attrName])
                        break;
                      parentGet = $parse(attrs[attrName]);
                      if (parentGet.literal) {
                        compare = equals;
                      } else {
                        compare = simpleCompare;
                      }
                      parentSet = parentGet.assign || function() {
                        lastValue = destination[scopeName] = parentGet(scope);
                        throw $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                      };
                      lastValue = destination[scopeName] = parentGet(scope);
                      var parentValueWatch = function parentValueWatch2(parentValue) {
                        if (!compare(parentValue, destination[scopeName])) {
                          if (!compare(parentValue, lastValue)) {
                            destination[scopeName] = parentValue;
                          } else {
                            parentSet(scope, parentValue = destination[scopeName]);
                          }
                        }
                        lastValue = parentValue;
                        return lastValue;
                      };
                      parentValueWatch.$stateful = true;
                      if (definition.collection) {
                        removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                      } else {
                        removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                      }
                      removeWatchCollection.push(removeWatch);
                      break;
                    case "<":
                      if (!hasOwnProperty.call(attrs, attrName)) {
                        if (optional)
                          break;
                        strictBindingsCheck(attrName, directive.name);
                        attrs[attrName] = void 0;
                      }
                      if (optional && !attrs[attrName])
                        break;
                      parentGet = $parse(attrs[attrName]);
                      var isLiteral2 = parentGet.literal;
                      var initialValue = destination[scopeName] = parentGet(scope);
                      initialChanges[scopeName] = new SimpleChange2(_UNINITIALIZED_VALUE, destination[scopeName]);
                      removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, function parentValueWatchAction(newValue, oldValue) {
                        if (oldValue === newValue) {
                          if (oldValue === initialValue || isLiteral2 && equals(oldValue, initialValue)) {
                            return;
                          }
                          oldValue = initialValue;
                        }
                        recordChanges(scopeName, newValue, oldValue);
                        destination[scopeName] = newValue;
                      });
                      removeWatchCollection.push(removeWatch);
                      break;
                    case "&":
                      if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                        strictBindingsCheck(attrName, directive.name);
                      }
                      parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop3;
                      if (parentGet === noop3 && optional)
                        break;
                      destination[scopeName] = function(locals) {
                        return parentGet(scope, locals);
                      };
                      break;
                  }
                });
                function recordChanges(key2, currentValue, previousValue) {
                  if (isFunction2(destination.$onChanges) && !simpleCompare(currentValue, previousValue)) {
                    if (!onChangesQueue) {
                      scope.$$postDigest(flushOnChangesQueue);
                      onChangesQueue = [];
                    }
                    if (!changes) {
                      changes = {};
                      onChangesQueue.push(triggerOnChangesHook);
                    }
                    if (changes[key2]) {
                      previousValue = changes[key2].previousValue;
                    }
                    changes[key2] = new SimpleChange2(previousValue, currentValue);
                  }
                }
                function triggerOnChangesHook() {
                  destination.$onChanges(changes);
                  changes = void 0;
                }
                return {
                  initialChanges,
                  removeWatches: removeWatchCollection.length && function removeWatches() {
                    for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                      removeWatchCollection[i]();
                    }
                  }
                };
              }
            }
          ];
        }
        function SimpleChange2(previous, current) {
          this.previousValue = previous;
          this.currentValue = current;
        }
        SimpleChange2.prototype.isFirstChange = function() {
          return this.previousValue === _UNINITIALIZED_VALUE;
        };
        var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
        var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
        function directiveNormalize(name) {
          return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
          });
        }
        function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
        }
        function directiveLinkingFn(nodesetLinkingFn2, scope, node, rootElement, boundTranscludeFn) {
        }
        function tokenDifference(str1, str2) {
          var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
          outer:
            for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token === tokens2[j])
                  continue outer;
              }
              values += (values.length > 0 ? " " : "") + token;
            }
          return values;
        }
        function removeComments(jqNodes) {
          jqNodes = jqLite(jqNodes);
          var i = jqNodes.length;
          if (i <= 1) {
            return jqNodes;
          }
          while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === "") {
              splice.call(jqNodes, i, 1);
            }
          }
          return jqNodes;
        }
        var $controllerMinErr = minErr("$controller");
        var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
        function identifierForController(controller, ident) {
          if (ident && isString(ident))
            return ident;
          if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match)
              return match[3];
          }
        }
        function $ControllerProvider() {
          var controllers = {};
          this.has = function(name) {
            return controllers.hasOwnProperty(name);
          };
          this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject2(name)) {
              extend(controllers, name);
            } else {
              controllers[name] = constructor;
            }
          };
          this.$get = ["$injector", function($injector) {
            return function $controller(expression, locals, later, ident) {
              var instance, match, constructor, identifier;
              later = later === true;
              if (ident && isString(ident)) {
                identifier = ident;
              }
              if (isString(expression)) {
                match = expression.match(CNTRL_REG);
                if (!match) {
                  throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                }
                constructor = match[1];
                identifier = identifier || match[3];
                expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true);
                if (!expression) {
                  throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                }
                assertArgFn(expression, constructor, true);
              }
              if (later) {
                var controllerPrototype = (isArray2(expression) ? expression[expression.length - 1] : expression).prototype;
                instance = Object.create(controllerPrototype || null);
                if (identifier) {
                  addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return extend(function $controllerInit() {
                  var result = $injector.invoke(expression, instance, locals, constructor);
                  if (result !== instance && (isObject2(result) || isFunction2(result))) {
                    instance = result;
                    if (identifier) {
                      addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                  }
                  return instance;
                }, {
                  instance,
                  identifier
                });
              }
              instance = $injector.instantiate(expression, locals, constructor);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
              if (!(locals && isObject2(locals.$scope))) {
                throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
              }
              locals.$scope[identifier] = instance;
            }
          }];
        }
        function $DocumentProvider() {
          this.$get = ["$window", function(window3) {
            return jqLite(window3.document);
          }];
        }
        function $$IsDocumentHiddenProvider() {
          this.$get = ["$document", "$rootScope", function($document, $rootScope) {
            var doc = $document[0];
            var hidden = doc && doc.hidden;
            $document.on("visibilitychange", changeListener);
            $rootScope.$on("$destroy", function() {
              $document.off("visibilitychange", changeListener);
            });
            function changeListener() {
              hidden = doc.hidden;
            }
            return function() {
              return hidden;
            };
          }];
        }
        function $ExceptionHandlerProvider() {
          this.$get = ["$log", function($log) {
            return function(exception, cause) {
              $log.error.apply($log, arguments);
            };
          }];
        }
        var $$ForceReflowProvider = function() {
          this.$get = ["$document", function($document) {
            return function(domNode) {
              if (domNode) {
                if (!domNode.nodeType && domNode instanceof jqLite) {
                  domNode = domNode[0];
                }
              } else {
                domNode = $document[0].body;
              }
              return domNode.offsetWidth + 1;
            };
          }];
        };
        var APPLICATION_JSON = "application/json";
        var CONTENT_TYPE_APPLICATION_JSON = { "Content-Type": APPLICATION_JSON + ";charset=utf-8" };
        var JSON_START = /^\[|^\{(?!\{)/;
        var JSON_ENDS = {
          "[": /]$/,
          "{": /}$/
        };
        var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
        var $httpMinErr = minErr("$http");
        function serializeValue(v) {
          if (isObject2(v)) {
            return isDate2(v) ? v.toISOString() : toJson(v);
          }
          return v;
        }
        function $HttpParamSerializerProvider() {
          this.$get = function() {
            return function ngParamSerializer(params) {
              if (!params)
                return "";
              var parts = [];
              forEachSorted(params, function(value, key2) {
                if (value === null || isUndefined(value) || isFunction2(value))
                  return;
                if (isArray2(value)) {
                  forEach(value, function(v) {
                    parts.push(encodeUriQuery(key2) + "=" + encodeUriQuery(serializeValue(v)));
                  });
                } else {
                  parts.push(encodeUriQuery(key2) + "=" + encodeUriQuery(serializeValue(value)));
                }
              });
              return parts.join("&");
            };
          };
        }
        function $HttpParamSerializerJQLikeProvider() {
          this.$get = function() {
            return function jQueryLikeParamSerializer(params) {
              if (!params)
                return "";
              var parts = [];
              serialize(params, "", true);
              return parts.join("&");
              function serialize(toSerialize, prefix, topLevel) {
                if (isArray2(toSerialize)) {
                  forEach(toSerialize, function(value, index) {
                    serialize(value, prefix + "[" + (isObject2(value) ? index : "") + "]");
                  });
                } else if (isObject2(toSerialize) && !isDate2(toSerialize)) {
                  forEachSorted(toSerialize, function(value, key2) {
                    serialize(value, prefix + (topLevel ? "" : "[") + key2 + (topLevel ? "" : "]"));
                  });
                } else {
                  if (isFunction2(toSerialize)) {
                    toSerialize = toSerialize();
                  }
                  parts.push(encodeUriQuery(prefix) + "=" + (toSerialize == null ? "" : encodeUriQuery(serializeValue(toSerialize))));
                }
              }
            };
          };
        }
        function defaultHttpResponseTransform(data, headers) {
          if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
              var contentType = headers("Content-Type");
              var hasJsonContentType = contentType && contentType.indexOf(APPLICATION_JSON) === 0;
              if (hasJsonContentType || isJsonLike(tempData)) {
                try {
                  data = fromJson(tempData);
                } catch (e) {
                  if (!hasJsonContentType) {
                    return data;
                  }
                  throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e);
                }
              }
            }
          }
          return data;
        }
        function isJsonLike(str) {
          var jsonStart = str.match(JSON_START);
          return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
        }
        function parseHeaders(headers) {
          var parsed = createMap(), i;
          function fillInParsed(key2, val) {
            if (key2) {
              parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
            }
          }
          if (isString(headers)) {
            forEach(headers.split("\n"), function(line) {
              i = line.indexOf(":");
              fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
            });
          } else if (isObject2(headers)) {
            forEach(headers, function(headerVal, headerKey) {
              fillInParsed(lowercase(headerKey), trim(headerVal));
            });
          }
          return parsed;
        }
        function headersGetter(headers) {
          var headersObj;
          return function(name) {
            if (!headersObj)
              headersObj = parseHeaders(headers);
            if (name) {
              var value = headersObj[lowercase(name)];
              if (value === void 0) {
                value = null;
              }
              return value;
            }
            return headersObj;
          };
        }
        function transformData(data, headers, status, fns) {
          if (isFunction2(fns)) {
            return fns(data, headers, status);
          }
          forEach(fns, function(fn2) {
            data = fn2(data, headers, status);
          });
          return data;
        }
        function isSuccess(status) {
          return 200 <= status && status < 300;
        }
        function $HttpProvider() {
          var defaults2 = this.defaults = {
            transformResponse: [defaultHttpResponseTransform],
            transformRequest: [function(d) {
              return isObject2(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            }],
            headers: {
              common: {
                "Accept": "application/json, text/plain, */*"
              },
              post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
              put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
              patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer",
            jsonpCallbackParam: "callback"
          };
          var useApplyAsync = false;
          this.useApplyAsync = function(value) {
            if (isDefined(value)) {
              useApplyAsync = !!value;
              return this;
            }
            return useApplyAsync;
          };
          var interceptorFactories = this.interceptors = [];
          var xsrfTrustedOrigins = this.xsrfTrustedOrigins = [];
          Object.defineProperty(this, "xsrfWhitelistedOrigins", {
            get: function() {
              return this.xsrfTrustedOrigins;
            },
            set: function(origins) {
              this.xsrfTrustedOrigins = origins;
            }
          });
          this.$get = [
            "$browser",
            "$httpBackend",
            "$$cookieReader",
            "$cacheFactory",
            "$rootScope",
            "$q",
            "$injector",
            "$sce",
            function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
              var defaultCache = $cacheFactory("$http");
              defaults2.paramSerializer = isString(defaults2.paramSerializer) ? $injector.get(defaults2.paramSerializer) : defaults2.paramSerializer;
              var reversedInterceptors = [];
              forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
              });
              var urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfTrustedOrigins);
              function $http(requestConfig) {
                if (!isObject2(requestConfig)) {
                  throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                if (!isString($sce.valueOf(requestConfig.url))) {
                  throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                }
                var config2 = extend({
                  method: "get",
                  transformRequest: defaults2.transformRequest,
                  transformResponse: defaults2.transformResponse,
                  paramSerializer: defaults2.paramSerializer,
                  jsonpCallbackParam: defaults2.jsonpCallbackParam
                }, requestConfig);
                config2.headers = mergeHeaders(requestConfig);
                config2.method = uppercase(config2.method);
                config2.paramSerializer = isString(config2.paramSerializer) ? $injector.get(config2.paramSerializer) : config2.paramSerializer;
                $browser.$$incOutstandingRequestCount("$http");
                var requestInterceptors = [];
                var responseInterceptors = [];
                var promise2 = $q.resolve(config2);
                forEach(reversedInterceptors, function(interceptor) {
                  if (interceptor.request || interceptor.requestError) {
                    requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                  }
                  if (interceptor.response || interceptor.responseError) {
                    responseInterceptors.push(interceptor.response, interceptor.responseError);
                  }
                });
                promise2 = chainInterceptors(promise2, requestInterceptors);
                promise2 = promise2.then(serverRequest);
                promise2 = chainInterceptors(promise2, responseInterceptors);
                promise2 = promise2.finally(completeOutstandingRequest);
                return promise2;
                function chainInterceptors(promise3, interceptors) {
                  for (var i = 0, ii = interceptors.length; i < ii; ) {
                    var thenFn = interceptors[i++];
                    var rejectFn = interceptors[i++];
                    promise3 = promise3.then(thenFn, rejectFn);
                  }
                  interceptors.length = 0;
                  return promise3;
                }
                function completeOutstandingRequest() {
                  $browser.$$completeOutstandingRequest(noop3, "$http");
                }
                function executeHeaderFns(headers, config3) {
                  var headerContent, processedHeaders = {};
                  forEach(headers, function(headerFn, header) {
                    if (isFunction2(headerFn)) {
                      headerContent = headerFn(config3);
                      if (headerContent != null) {
                        processedHeaders[header] = headerContent;
                      }
                    } else {
                      processedHeaders[header] = headerFn;
                    }
                  });
                  return processedHeaders;
                }
                function mergeHeaders(config3) {
                  var defHeaders = defaults2.headers, reqHeaders = extend({}, config3.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                  defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config3.method)]);
                  defaultHeadersIteration:
                    for (defHeaderName in defHeaders) {
                      lowercaseDefHeaderName = lowercase(defHeaderName);
                      for (reqHeaderName in reqHeaders) {
                        if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                          continue defaultHeadersIteration;
                        }
                      }
                      reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                  return executeHeaderFns(reqHeaders, shallowCopy(config3));
                }
                function serverRequest(config3) {
                  var headers = config3.headers;
                  var reqData = transformData(config3.data, headersGetter(headers), void 0, config3.transformRequest);
                  if (isUndefined(reqData)) {
                    forEach(headers, function(value, header) {
                      if (lowercase(header) === "content-type") {
                        delete headers[header];
                      }
                    });
                  }
                  if (isUndefined(config3.withCredentials) && !isUndefined(defaults2.withCredentials)) {
                    config3.withCredentials = defaults2.withCredentials;
                  }
                  return sendReq(config3, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                  var resp = extend({}, response);
                  resp.data = transformData(response.data, response.headers, response.status, config2.transformResponse);
                  return isSuccess(response.status) ? resp : $q.reject(resp);
                }
              }
              $http.pendingRequests = [];
              createShortMethods("get", "delete", "head", "jsonp");
              createShortMethodsWithData("post", "put", "patch");
              $http.defaults = defaults2;
              return $http;
              function createShortMethods(names) {
                forEach(arguments, function(name) {
                  $http[name] = function(url, config2) {
                    return $http(extend({}, config2 || {}, {
                      method: name,
                      url
                    }));
                  };
                });
              }
              function createShortMethodsWithData(name) {
                forEach(arguments, function(name2) {
                  $http[name2] = function(url, data, config2) {
                    return $http(extend({}, config2 || {}, {
                      method: name2,
                      url,
                      data
                    }));
                  };
                });
              }
              function sendReq(config2, reqData) {
                var deferred = $q.defer(), promise2 = deferred.promise, cache, cachedResp, reqHeaders = config2.headers, isJsonp = lowercase(config2.method) === "jsonp", url = config2.url;
                if (isJsonp) {
                  url = $sce.getTrustedResourceUrl(url);
                } else if (!isString(url)) {
                  url = $sce.valueOf(url);
                }
                url = buildUrl(url, config2.paramSerializer(config2.params));
                if (isJsonp) {
                  url = sanitizeJsonpCallbackParam(url, config2.jsonpCallbackParam);
                }
                $http.pendingRequests.push(config2);
                promise2.then(removePendingReq, removePendingReq);
                if ((config2.cache || defaults2.cache) && config2.cache !== false && (config2.method === "GET" || config2.method === "JSONP")) {
                  cache = isObject2(config2.cache) ? config2.cache : isObject2(defaults2.cache) ? defaults2.cache : defaultCache;
                }
                if (cache) {
                  cachedResp = cache.get(url);
                  if (isDefined(cachedResp)) {
                    if (isPromiseLike(cachedResp)) {
                      cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                    } else {
                      if (isArray2(cachedResp)) {
                        resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]);
                      } else {
                        resolvePromise(cachedResp, 200, {}, "OK", "complete");
                      }
                    }
                  } else {
                    cache.put(url, promise2);
                  }
                }
                if (isUndefined(cachedResp)) {
                  var xsrfValue = urlIsAllowedOrigin(config2.url) ? $$cookieReader()[config2.xsrfCookieName || defaults2.xsrfCookieName] : void 0;
                  if (xsrfValue) {
                    reqHeaders[config2.xsrfHeaderName || defaults2.xsrfHeaderName] = xsrfValue;
                  }
                  $httpBackend(config2.method, url, reqData, done, reqHeaders, config2.timeout, config2.withCredentials, config2.responseType, createApplyHandlers(config2.eventHandlers), createApplyHandlers(config2.uploadEventHandlers));
                }
                return promise2;
                function createApplyHandlers(eventHandlers) {
                  if (eventHandlers) {
                    var applyHandlers = {};
                    forEach(eventHandlers, function(eventHandler, key2) {
                      applyHandlers[key2] = function(event) {
                        if (useApplyAsync) {
                          $rootScope.$applyAsync(callEventHandler);
                        } else if ($rootScope.$$phase) {
                          callEventHandler();
                        } else {
                          $rootScope.$apply(callEventHandler);
                        }
                        function callEventHandler() {
                          eventHandler(event);
                        }
                      };
                    });
                    return applyHandlers;
                  }
                }
                function done(status, response, headersString, statusText, xhrStatus) {
                  if (cache) {
                    if (isSuccess(status)) {
                      cache.put(url, [status, response, parseHeaders(headersString), statusText, xhrStatus]);
                    } else {
                      cache.remove(url);
                    }
                  }
                  function resolveHttpPromise() {
                    resolvePromise(response, status, headersString, statusText, xhrStatus);
                  }
                  if (useApplyAsync) {
                    $rootScope.$applyAsync(resolveHttpPromise);
                  } else {
                    resolveHttpPromise();
                    if (!$rootScope.$$phase)
                      $rootScope.$apply();
                  }
                }
                function resolvePromise(response, status, headers, statusText, xhrStatus) {
                  status = status >= -1 ? status : 0;
                  (isSuccess(status) ? deferred.resolve : deferred.reject)({
                    data: response,
                    status,
                    headers: headersGetter(headers),
                    config: config2,
                    statusText,
                    xhrStatus
                  });
                }
                function resolvePromiseWithResult(result) {
                  resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                }
                function removePendingReq() {
                  var idx = $http.pendingRequests.indexOf(config2);
                  if (idx !== -1)
                    $http.pendingRequests.splice(idx, 1);
                }
              }
              function buildUrl(url, serializedParams) {
                if (serializedParams.length > 0) {
                  url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                }
                return url;
              }
              function sanitizeJsonpCallbackParam(url, cbKey) {
                var parts = url.split("?");
                if (parts.length > 2) {
                  throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                }
                var params = parseKeyValue(parts[1]);
                forEach(params, function(value, key2) {
                  if (value === "JSON_CALLBACK") {
                    throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                  }
                  if (key2 === cbKey) {
                    throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                  }
                });
                url += (url.indexOf("?") === -1 ? "?" : "&") + cbKey + "=JSON_CALLBACK";
                return url;
              }
            }
          ];
        }
        function $xhrFactoryProvider() {
          this.$get = function() {
            return function createXhr() {
              return new window2.XMLHttpRequest();
            };
          };
        }
        function $HttpBackendProvider() {
          this.$get = ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
          }];
        }
        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
          return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            url = url || $browser.url();
            if (lowercase(method) === "jsonp") {
              var callbackPath = callbacks.createCallback(url);
              var jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                var response = status === 200 && callbacks.getResponse(callbackPath);
                completeRequest(callback, status, response, "", text, "complete");
                callbacks.removeCallback(callbackPath);
              });
            } else {
              var xhr = createXhr(method, url);
              var abortedByTimeout = false;
              xhr.open(method, url, true);
              forEach(headers, function(value, key2) {
                if (isDefined(value)) {
                  xhr.setRequestHeader(key2, value);
                }
              });
              xhr.onload = function requestLoaded() {
                var statusText = xhr.statusText || "";
                var response = "response" in xhr ? xhr.response : xhr.responseText;
                var status = xhr.status === 1223 ? 204 : xhr.status;
                if (status === 0) {
                  status = response ? 200 : urlResolve(url).protocol === "file" ? 404 : 0;
                }
                completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
              };
              var requestError = function() {
                completeRequest(callback, -1, null, null, "", "error");
              };
              var requestAborted = function() {
                completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort");
              };
              var requestTimeout = function() {
                completeRequest(callback, -1, null, null, "", "timeout");
              };
              xhr.onerror = requestError;
              xhr.ontimeout = requestTimeout;
              xhr.onabort = requestAborted;
              forEach(eventHandlers, function(value, key2) {
                xhr.addEventListener(key2, value);
              });
              forEach(uploadEventHandlers, function(value, key2) {
                xhr.upload.addEventListener(key2, value);
              });
              if (withCredentials) {
                xhr.withCredentials = true;
              }
              if (responseType) {
                try {
                  xhr.responseType = responseType;
                } catch (e) {
                  if (responseType !== "json") {
                    throw e;
                  }
                }
              }
              xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) {
              var timeoutId = $browserDefer(function() {
                timeoutRequest("timeout");
              }, timeout);
            } else if (isPromiseLike(timeout)) {
              timeout.then(function() {
                timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort");
              });
            }
            function timeoutRequest(reason) {
              abortedByTimeout = reason === "timeout";
              if (jsonpDone) {
                jsonpDone();
              }
              if (xhr) {
                xhr.abort();
              }
            }
            function completeRequest(callback2, status, response, headersString, statusText, xhrStatus) {
              if (isDefined(timeoutId)) {
                $browserDefer.cancel(timeoutId);
              }
              jsonpDone = xhr = null;
              callback2(status, response, headersString, statusText, xhrStatus);
            }
          };
          function jsonpReq(url, callbackPath, done) {
            url = url.replace("JSON_CALLBACK", callbackPath);
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
              script.removeEventListener("load", callback);
              script.removeEventListener("error", callback);
              rawDocument.body.removeChild(script);
              script = null;
              var status = -1;
              var text = "unknown";
              if (event) {
                if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
                  event = { type: "error" };
                }
                text = event.type;
                status = event.type === "error" ? 404 : 200;
              }
              if (done) {
                done(status, text);
              }
            };
            script.addEventListener("load", callback);
            script.addEventListener("error", callback);
            rawDocument.body.appendChild(script);
            return callback;
          }
        }
        var $interpolateMinErr = angular3.$interpolateMinErr = minErr("$interpolate");
        $interpolateMinErr.throwNoconcat = function(text) {
          throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
        };
        $interpolateMinErr.interr = function(text, err) {
          return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
        };
        function $InterpolateProvider() {
          var startSymbol = "{{";
          var endSymbol = "}}";
          this.startSymbol = function(value) {
            if (value) {
              startSymbol = value;
              return this;
            }
            return startSymbol;
          };
          this.endSymbol = function(value) {
            if (value) {
              endSymbol = value;
              return this;
            }
            return endSymbol;
          };
          this.$get = ["$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
              return "\\\\\\" + ch;
            }
            function unescapeText(text) {
              return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
              var unwatch = scope.$watch(function constantInterpolateWatch(scope2) {
                unwatch();
                return constantInterp(scope2);
              }, listener, objectEquality);
              return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
              var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
              if (!text.length || text.indexOf(startSymbol) === -1) {
                if (mustHaveExpression)
                  return;
                var unescapedText = unescapeText(text);
                if (contextAllowsConcatenation) {
                  unescapedText = $sce.getTrusted(trustedContext, unescapedText);
                }
                var constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
                return constantInterp;
              }
              allOrNothing = !!allOrNothing;
              var startIndex, endIndex, index = 0, expressions = [], parseFns, textLength = text.length, exp, concat2 = [], expressionPositions = [], singleExpression;
              while (index < textLength) {
                if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                  if (index !== startIndex) {
                    concat2.push(unescapeText(text.substring(index, startIndex)));
                  }
                  exp = text.substring(startIndex + startSymbolLength, endIndex);
                  expressions.push(exp);
                  index = endIndex + endSymbolLength;
                  expressionPositions.push(concat2.length);
                  concat2.push("");
                } else {
                  if (index !== textLength) {
                    concat2.push(unescapeText(text.substring(index)));
                  }
                  break;
                }
              }
              singleExpression = concat2.length === 1 && expressionPositions.length === 1;
              var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : parseStringifyInterceptor;
              parseFns = expressions.map(function(exp2) {
                return $parse(exp2, interceptor);
              });
              if (!mustHaveExpression || expressions.length) {
                var compute = function(values) {
                  for (var i = 0, ii = expressions.length; i < ii; i++) {
                    if (allOrNothing && isUndefined(values[i]))
                      return;
                    concat2[expressionPositions[i]] = values[i];
                  }
                  if (contextAllowsConcatenation) {
                    return $sce.getTrusted(trustedContext, singleExpression ? concat2[0] : concat2.join(""));
                  } else if (trustedContext && concat2.length > 1) {
                    $interpolateMinErr.throwNoconcat(text);
                  }
                  return concat2.join("");
                };
                return extend(function interpolationFn(context) {
                  var i = 0;
                  var ii = expressions.length;
                  var values = new Array(ii);
                  try {
                    for (; i < ii; i++) {
                      values[i] = parseFns[i](context);
                    }
                    return compute(values);
                  } catch (err) {
                    $exceptionHandler($interpolateMinErr.interr(text, err));
                  }
                }, {
                  exp: text,
                  expressions,
                  $$watchDelegate: function(scope, listener) {
                    var lastValue;
                    return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                      var currValue = compute(values);
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                      lastValue = currValue;
                    });
                  }
                });
              }
              function parseStringifyInterceptor(value) {
                try {
                  value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                  return allOrNothing && !isDefined(value) ? value : stringify3(value);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }
            }
            $interpolate.startSymbol = function() {
              return startSymbol;
            };
            $interpolate.endSymbol = function() {
              return endSymbol;
            };
            return $interpolate;
          }];
        }
        var $intervalMinErr = minErr("$interval");
        function $IntervalProvider() {
          this.$get = [
            "$$intervalFactory",
            "$window",
            function($$intervalFactory, $window) {
              var intervals = {};
              var setIntervalFn = function(tick, delay2, deferred) {
                var id = $window.setInterval(tick, delay2);
                intervals[id] = deferred;
                return id;
              };
              var clearIntervalFn = function(id) {
                $window.clearInterval(id);
                delete intervals[id];
              };
              var interval = $$intervalFactory(setIntervalFn, clearIntervalFn);
              interval.cancel = function(promise2) {
                if (!promise2)
                  return false;
                if (!promise2.hasOwnProperty("$$intervalId")) {
                  throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                }
                if (!intervals.hasOwnProperty(promise2.$$intervalId))
                  return false;
                var id = promise2.$$intervalId;
                var deferred = intervals[id];
                markQExceptionHandled(deferred.promise);
                deferred.reject("canceled");
                clearIntervalFn(id);
                return true;
              };
              return interval;
            }
          ];
        }
        function $$IntervalFactoryProvider() {
          this.$get = [
            "$browser",
            "$q",
            "$$q",
            "$rootScope",
            function($browser, $q, $$q, $rootScope) {
              return function intervalFactory(setIntervalFn, clearIntervalFn) {
                return function intervalFn(fn2, delay2, count, invokeApply) {
                  var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise2 = deferred.promise;
                  count = isDefined(count) ? count : 0;
                  function callback() {
                    if (!hasParams) {
                      fn2(iteration);
                    } else {
                      fn2.apply(null, args);
                    }
                  }
                  function tick() {
                    if (skipApply) {
                      $browser.defer(callback);
                    } else {
                      $rootScope.$evalAsync(callback);
                    }
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                      deferred.resolve(iteration);
                      clearIntervalFn(promise2.$$intervalId);
                    }
                    if (!skipApply)
                      $rootScope.$apply();
                  }
                  promise2.$$intervalId = setIntervalFn(tick, delay2, deferred, skipApply);
                  return promise2;
                };
              };
            }
          ];
        }
        var $jsonpCallbacksProvider = function() {
          this.$get = function() {
            var callbacks = angular3.callbacks;
            var callbackMap = {};
            function createCallback(callbackId) {
              var callback = function(data) {
                callback.data = data;
                callback.called = true;
              };
              callback.id = callbackId;
              return callback;
            }
            return {
              createCallback: function(url) {
                var callbackId = "_" + (callbacks.$$counter++).toString(36);
                var callbackPath = "angular.callbacks." + callbackId;
                var callback = createCallback(callbackId);
                callbackMap[callbackPath] = callbacks[callbackId] = callback;
                return callbackPath;
              },
              wasCalled: function(callbackPath) {
                return callbackMap[callbackPath].called;
              },
              getResponse: function(callbackPath) {
                return callbackMap[callbackPath].data;
              },
              removeCallback: function(callbackPath) {
                var callback = callbackMap[callbackPath];
                delete callbacks[callback.id];
                delete callbackMap[callbackPath];
              }
            };
          };
        };
        var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = { "http": 80, "https": 443, "ftp": 21 };
        var $locationMinErr = minErr("$location");
        function encodePath(path) {
          var segments = path.split("/"), i = segments.length;
          while (i--) {
            segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
          }
          return segments.join("/");
        }
        function decodePath(path, html5Mode) {
          var segments = path.split("/"), i = segments.length;
          while (i--) {
            segments[i] = decodeURIComponent(segments[i]);
            if (html5Mode) {
              segments[i] = segments[i].replace(/\//g, "%2F");
            }
          }
          return segments.join("/");
        }
        function normalizePath(pathValue, searchValue, hashValue) {
          var search = toKeyValue(searchValue), hash = hashValue ? "#" + encodeUriSegment(hashValue) : "", path = encodePath(pathValue);
          return path + (search ? "?" + search : "") + hash;
        }
        function parseAbsoluteUrl(absoluteUrl, locationObj) {
          var parsedUrl = urlResolve(absoluteUrl);
          locationObj.$$protocol = parsedUrl.protocol;
          locationObj.$$host = parsedUrl.hostname;
          locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
        }
        var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;
        function parseAppUrl(url, locationObj, html5Mode) {
          if (DOUBLE_SLASH_REGEX.test(url)) {
            throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
          }
          var prefixed = url.charAt(0) !== "/";
          if (prefixed) {
            url = "/" + url;
          }
          var match = urlResolve(url);
          var path = prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname;
          locationObj.$$path = decodePath(path, html5Mode);
          locationObj.$$search = parseKeyValue(match.search);
          locationObj.$$hash = decodeURIComponent(match.hash);
          if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
            locationObj.$$path = "/" + locationObj.$$path;
          }
        }
        function startsWith(str, search) {
          return str.slice(0, search.length) === search;
        }
        function stripBaseUrl(base, url) {
          if (startsWith(url, base)) {
            return url.substr(base.length);
          }
        }
        function stripHash(url) {
          var index = url.indexOf("#");
          return index === -1 ? url : url.substr(0, index);
        }
        function stripFile(url) {
          return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
        }
        function serverBase(url) {
          return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
        }
        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
          this.$$html5 = true;
          basePrefix = basePrefix || "";
          parseAbsoluteUrl(appBase, this);
          this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) {
              throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this, true);
            if (!this.$$path) {
              this.$$path = "/";
            }
            this.$$compose();
          };
          this.$$normalizeUrl = function(url) {
            return appBaseNoFile + url.substr(1);
          };
          this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
              this.hash(relHref.slice(1));
              return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
              prevAppUrl = appUrl;
              if (basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
                rewrittenUrl = appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
              } else {
                rewrittenUrl = appBase + prevAppUrl;
              }
            } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
              rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile === url + "/") {
              rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
              this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
          };
        }
        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
          parseAbsoluteUrl(appBase, this);
          this.$$parse = function(url) {
            var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            var withoutHashUrl;
            if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
              withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
              if (isUndefined(withoutHashUrl)) {
                withoutHashUrl = withoutBaseUrl;
              }
            } else {
              if (this.$$html5) {
                withoutHashUrl = withoutBaseUrl;
              } else {
                withoutHashUrl = "";
                if (isUndefined(withoutBaseUrl)) {
                  appBase = url;
                  this.replace();
                }
              }
            }
            parseAppUrl(withoutHashUrl, this, false);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url2, base) {
              var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
              var firstPathSegmentMatch;
              if (startsWith(url2, base)) {
                url2 = url2.replace(base, "");
              }
              if (windowsFilePathExp.exec(url2)) {
                return path;
              }
              firstPathSegmentMatch = windowsFilePathExp.exec(path);
              return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
          };
          this.$$normalizeUrl = function(url) {
            return appBase + (url ? hashPrefix + url : "");
          };
          this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) === stripHash(url)) {
              this.$$parse(url);
              return true;
            }
            return false;
          };
        }
        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
          this.$$html5 = true;
          LocationHashbangUrl.apply(this, arguments);
          this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
              this.hash(relHref.slice(1));
              return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase === stripHash(url)) {
              rewrittenUrl = url;
            } else if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
              rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
              rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
              this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
          };
          this.$$normalizeUrl = function(url) {
            return appBase + hashPrefix + url;
          };
        }
        var locationPrototype = {
          $$absUrl: "",
          $$html5: false,
          $$replace: false,
          $$compose: function() {
            this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash);
            this.$$absUrl = this.$$normalizeUrl(this.$$url);
            this.$$urlUpdatedByLocation = true;
          },
          absUrl: locationGetter("$$absUrl"),
          url: function(url) {
            if (isUndefined(url)) {
              return this.$$url;
            }
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "")
              this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "")
              this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
          },
          protocol: locationGetter("$$protocol"),
          host: locationGetter("$$host"),
          port: locationGetter("$$port"),
          path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) === "/" ? path : "/" + path;
          }),
          search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;
              case 1:
                if (isString(search) || isNumber(search)) {
                  search = search.toString();
                  this.$$search = parseKeyValue(search);
                } else if (isObject2(search)) {
                  search = copy(search, {});
                  forEach(search, function(value, key2) {
                    if (value == null)
                      delete search[key2];
                  });
                  this.$$search = search;
                } else {
                  throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;
              default:
                if (isUndefined(paramValue) || paramValue === null) {
                  delete this.$$search[search];
                } else {
                  this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
          },
          hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
          }),
          replace: function() {
            this.$$replace = true;
            return this;
          }
        };
        forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
          Location.prototype = Object.create(locationPrototype);
          Location.prototype.state = function(state) {
            if (!arguments.length) {
              return this.$$state;
            }
            if (Location !== LocationHtml5Url || !this.$$html5) {
              throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            this.$$urlUpdatedByLocation = true;
            return this;
          };
        });
        function locationGetter(property) {
          return function() {
            return this[property];
          };
        }
        function locationGetterSetter(property, preprocess) {
          return function(value) {
            if (isUndefined(value)) {
              return this[property];
            }
            this[property] = preprocess(value);
            this.$$compose();
            return this;
          };
        }
        function $LocationProvider() {
          var hashPrefix = "!", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
          };
          this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
              hashPrefix = prefix;
              return this;
            } else {
              return hashPrefix;
            }
          };
          this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
              html5Mode.enabled = mode;
              return this;
            } else if (isObject2(mode)) {
              if (isBoolean(mode.enabled)) {
                html5Mode.enabled = mode.enabled;
              }
              if (isBoolean(mode.requireBase)) {
                html5Mode.requireBase = mode.requireBase;
              }
              if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
                html5Mode.rewriteLinks = mode.rewriteLinks;
              }
              return this;
            } else {
              return html5Mode;
            }
          };
          this.$get = [
            "$rootScope",
            "$browser",
            "$sniffer",
            "$rootElement",
            "$window",
            function($rootScope, $browser, $sniffer, $rootElement, $window) {
              var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
              if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                  throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
              } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
              }
              var appBaseNoFile = stripFile(appBase);
              $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
              $location.$$parseLinkUrl(initialUrl, initialUrl);
              $location.$$state = $browser.state();
              var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
              function urlsEqual(a, b) {
                return a === b || urlResolve(a).href === urlResolve(b).href;
              }
              function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                  $browser.url(url, replace, state);
                  $location.$$state = $browser.state();
                } catch (e) {
                  $location.url(oldUrl);
                  $location.$$state = oldState;
                  throw e;
                }
              }
              $rootElement.on("click", function(event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2)
                  return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                  if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                    return;
                }
                if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks)))
                  return;
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject2(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                  absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref))
                  return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                  if ($location.$$parseLinkUrl(absHref, relHref)) {
                    event.preventDefault();
                    if ($location.absUrl() !== $browser.url()) {
                      $rootScope.$apply();
                    }
                  }
                }
              });
              if ($location.absUrl() !== initialUrl) {
                $browser.url($location.absUrl(), true);
              }
              var initializing = true;
              $browser.onUrlChange(function(newUrl, newState) {
                if (!startsWith(newUrl, appBaseNoFile)) {
                  $window.location.href = newUrl;
                  return;
                }
                $rootScope.$evalAsync(function() {
                  var oldUrl = $location.absUrl();
                  var oldState = $location.$$state;
                  var defaultPrevented;
                  $location.$$parse(newUrl);
                  $location.$$state = newState;
                  defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                  if ($location.absUrl() !== newUrl)
                    return;
                  if (defaultPrevented) {
                    $location.$$parse(oldUrl);
                    $location.$$state = oldState;
                    setBrowserUrlWithFallback(oldUrl, false, oldState);
                  } else {
                    initializing = false;
                    afterLocationChange(oldUrl, oldState);
                  }
                });
                if (!$rootScope.$$phase)
                  $rootScope.$digest();
              });
              $rootScope.$watch(function $locationWatch() {
                if (initializing || $location.$$urlUpdatedByLocation) {
                  $location.$$urlUpdatedByLocation = false;
                  var oldUrl = $browser.url();
                  var newUrl = $location.absUrl();
                  var oldState = $browser.state();
                  var currentReplace = $location.$$replace;
                  var urlOrStateChanged = !urlsEqual(oldUrl, newUrl) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                  if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function() {
                      var newUrl2 = $location.absUrl();
                      var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl2, oldUrl, $location.$$state, oldState).defaultPrevented;
                      if ($location.absUrl() !== newUrl2)
                        return;
                      if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                      } else {
                        if (urlOrStateChanged) {
                          setBrowserUrlWithFallback(newUrl2, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                        }
                        afterLocationChange(oldUrl, oldState);
                      }
                    });
                  }
                }
                $location.$$replace = false;
              });
              return $location;
              function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
              }
            }
          ];
        }
        function $LogProvider() {
          var debug = true, self2 = this;
          this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
              debug = flag;
              return this;
            } else {
              return debug;
            }
          };
          this.$get = ["$window", function($window) {
            var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
            return {
              log: consoleLog("log"),
              info: consoleLog("info"),
              warn: consoleLog("warn"),
              error: consoleLog("error"),
              debug: function() {
                var fn2 = consoleLog("debug");
                return function() {
                  if (debug) {
                    fn2.apply(self2, arguments);
                  }
                };
              }()
            };
            function formatError2(arg) {
              if (isError(arg)) {
                if (arg.stack && formatStackTrace) {
                  arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                } else if (arg.sourceURL) {
                  arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                }
              }
              return arg;
            }
            function consoleLog(type) {
              var console2 = $window.console || {}, logFn = console2[type] || console2.log || noop3;
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError2(arg));
                });
                return Function.prototype.apply.call(logFn, console2, args);
              };
            }
          }];
        }
        var $parseMinErr = minErr("$parse");
        var objectValueOf = {}.constructor.prototype.valueOf;
        function getStringValue(name) {
          return name + "";
        }
        var OPERATORS = createMap();
        forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
          OPERATORS[operator] = true;
        });
        var ESCAPE2 = { "n": "\n", "f": "\f", "r": "\r", "t": "	", "v": "\v", "'": "'", '"': '"' };
        var Lexer2 = function Lexer3(options) {
          this.options = options;
        };
        Lexer2.prototype = {
          constructor: Lexer2,
          lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
              var ch = this.text.charAt(this.index);
              if (ch === '"' || ch === "'") {
                this.readString(ch);
              } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                this.readNumber();
              } else if (this.isIdentifierStart(this.peekMultichar())) {
                this.readIdent();
              } else if (this.is(ch, "(){}[].,;:?")) {
                this.tokens.push({ index: this.index, text: ch });
                this.index++;
              } else if (this.isWhitespace(ch)) {
                this.index++;
              } else {
                var ch2 = ch + this.peek();
                var ch3 = ch2 + this.peek(2);
                var op1 = OPERATORS[ch];
                var op2 = OPERATORS[ch2];
                var op3 = OPERATORS[ch3];
                if (op1 || op2 || op3) {
                  var token = op3 ? ch3 : op2 ? ch2 : ch;
                  this.tokens.push({ index: this.index, text: token, operator: true });
                  this.index += token.length;
                } else {
                  this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
              }
            }
            return this.tokens;
          },
          is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
          },
          peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
          },
          isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
          },
          isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "\v" || ch === "\xA0";
          },
          isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
          },
          isValidIdentifierStart: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || ch === "_" || ch === "$";
          },
          isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
          },
          isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
          },
          codePointAt: function(ch) {
            if (ch.length === 1)
              return ch.charCodeAt(0);
            return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
          },
          peekMultichar: function() {
            var ch = this.text.charAt(this.index);
            var peek = this.peek();
            if (!peek) {
              return ch;
            }
            var cp1 = ch.charCodeAt(0);
            var cp2 = peek.charCodeAt(0);
            if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
              return ch + peek;
            }
            return ch;
          },
          isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
          },
          throwError: function(error3, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error3, colStr, this.text);
          },
          readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
              var ch = lowercase(this.text.charAt(this.index));
              if (ch === "." || this.isNumber(ch)) {
                number += ch;
              } else {
                var peekCh = this.peek();
                if (ch === "e" && this.isExpOperator(peekCh)) {
                  number += ch;
                } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === "e") {
                  number += ch;
                } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === "e") {
                  this.throwError("Invalid exponent");
                } else {
                  break;
                }
              }
              this.index++;
            }
            this.tokens.push({
              index: start,
              text: number,
              constant: true,
              value: Number(number)
            });
          },
          readIdent: function() {
            var start = this.index;
            this.index += this.peekMultichar().length;
            while (this.index < this.text.length) {
              var ch = this.peekMultichar();
              if (!this.isIdentifierContinue(ch)) {
                break;
              }
              this.index += ch.length;
            }
            this.tokens.push({
              index: start,
              text: this.text.slice(start, this.index),
              identifier: true
            });
          },
          readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
              var ch = this.text.charAt(this.index);
              rawString += ch;
              if (escape) {
                if (ch === "u") {
                  var hex = this.text.substring(this.index + 1, this.index + 5);
                  if (!hex.match(/[\da-f]{4}/i)) {
                    this.throwError("Invalid unicode escape [\\u" + hex + "]");
                  }
                  this.index += 4;
                  string += String.fromCharCode(parseInt(hex, 16));
                } else {
                  var rep = ESCAPE2[ch];
                  string = string + (rep || ch);
                }
                escape = false;
              } else if (ch === "\\") {
                escape = true;
              } else if (ch === quote) {
                this.index++;
                this.tokens.push({
                  index: start,
                  text: rawString,
                  constant: true,
                  value: string
                });
                return;
              } else {
                string += ch;
              }
              this.index++;
            }
            this.throwError("Unterminated quote", start);
          }
        };
        var AST2 = function AST3(lexer, options) {
          this.lexer = lexer;
          this.options = options;
        };
        AST2.Program = "Program";
        AST2.ExpressionStatement = "ExpressionStatement";
        AST2.AssignmentExpression = "AssignmentExpression";
        AST2.ConditionalExpression = "ConditionalExpression";
        AST2.LogicalExpression = "LogicalExpression";
        AST2.BinaryExpression = "BinaryExpression";
        AST2.UnaryExpression = "UnaryExpression";
        AST2.CallExpression = "CallExpression";
        AST2.MemberExpression = "MemberExpression";
        AST2.Identifier = "Identifier";
        AST2.Literal = "Literal";
        AST2.ArrayExpression = "ArrayExpression";
        AST2.Property = "Property";
        AST2.ObjectExpression = "ObjectExpression";
        AST2.ThisExpression = "ThisExpression";
        AST2.LocalsExpression = "LocalsExpression";
        AST2.NGValueParameter = "NGValueParameter";
        AST2.prototype = {
          ast: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.program();
            if (this.tokens.length !== 0) {
              this.throwError("is an unexpected token", this.tokens[0]);
            }
            return value;
          },
          program: function() {
            var body = [];
            while (true) {
              if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
                body.push(this.expressionStatement());
              if (!this.expect(";")) {
                return { type: AST2.Program, body };
              }
            }
          },
          expressionStatement: function() {
            return { type: AST2.ExpressionStatement, expression: this.filterChain() };
          },
          filterChain: function() {
            var left = this.expression();
            while (this.expect("|")) {
              left = this.filter(left);
            }
            return left;
          },
          expression: function() {
            return this.assignment();
          },
          assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
              if (!isAssignable(result)) {
                throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
              }
              result = { type: AST2.AssignmentExpression, left: result, right: this.assignment(), operator: "=" };
            }
            return result;
          },
          ternary: function() {
            var test = this.logicalOR();
            var alternate;
            var consequent;
            if (this.expect("?")) {
              alternate = this.expression();
              if (this.consume(":")) {
                consequent = this.expression();
                return { type: AST2.ConditionalExpression, test, alternate, consequent };
              }
            }
            return test;
          },
          logicalOR: function() {
            var left = this.logicalAND();
            while (this.expect("||")) {
              left = { type: AST2.LogicalExpression, operator: "||", left, right: this.logicalAND() };
            }
            return left;
          },
          logicalAND: function() {
            var left = this.equality();
            while (this.expect("&&")) {
              left = { type: AST2.LogicalExpression, operator: "&&", left, right: this.equality() };
            }
            return left;
          },
          equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
              left = { type: AST2.BinaryExpression, operator: token.text, left, right: this.relational() };
            }
            return left;
          },
          relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
              left = { type: AST2.BinaryExpression, operator: token.text, left, right: this.additive() };
            }
            return left;
          },
          additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
              left = { type: AST2.BinaryExpression, operator: token.text, left, right: this.multiplicative() };
            }
            return left;
          },
          multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
              left = { type: AST2.BinaryExpression, operator: token.text, left, right: this.unary() };
            }
            return left;
          },
          unary: function() {
            var token;
            if (token = this.expect("+", "-", "!")) {
              return { type: AST2.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };
            } else {
              return this.primary();
            }
          },
          primary: function() {
            var primary;
            if (this.expect("(")) {
              primary = this.filterChain();
              this.consume(")");
            } else if (this.expect("[")) {
              primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
              primary = this.object();
            } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
              primary = copy(this.selfReferential[this.consume().text]);
            } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
              primary = { type: AST2.Literal, value: this.options.literals[this.consume().text] };
            } else if (this.peek().identifier) {
              primary = this.identifier();
            } else if (this.peek().constant) {
              primary = this.constant();
            } else {
              this.throwError("not a primary expression", this.peek());
            }
            var next;
            while (next = this.expect("(", "[", ".")) {
              if (next.text === "(") {
                primary = { type: AST2.CallExpression, callee: primary, arguments: this.parseArguments() };
                this.consume(")");
              } else if (next.text === "[") {
                primary = { type: AST2.MemberExpression, object: primary, property: this.expression(), computed: true };
                this.consume("]");
              } else if (next.text === ".") {
                primary = { type: AST2.MemberExpression, object: primary, property: this.identifier(), computed: false };
              } else {
                this.throwError("IMPOSSIBLE");
              }
            }
            return primary;
          },
          filter: function(baseExpression) {
            var args = [baseExpression];
            var result = { type: AST2.CallExpression, callee: this.identifier(), arguments: args, filter: true };
            while (this.expect(":")) {
              args.push(this.expression());
            }
            return result;
          },
          parseArguments: function() {
            var args = [];
            if (this.peekToken().text !== ")") {
              do {
                args.push(this.filterChain());
              } while (this.expect(","));
            }
            return args;
          },
          identifier: function() {
            var token = this.consume();
            if (!token.identifier) {
              this.throwError("is not a valid identifier", token);
            }
            return { type: AST2.Identifier, name: token.text };
          },
          constant: function() {
            return { type: AST2.Literal, value: this.consume().value };
          },
          arrayDeclaration: function() {
            var elements = [];
            if (this.peekToken().text !== "]") {
              do {
                if (this.peek("]")) {
                  break;
                }
                elements.push(this.expression());
              } while (this.expect(","));
            }
            this.consume("]");
            return { type: AST2.ArrayExpression, elements };
          },
          object: function() {
            var properties = [], property;
            if (this.peekToken().text !== "}") {
              do {
                if (this.peek("}")) {
                  break;
                }
                property = { type: AST2.Property, kind: "init" };
                if (this.peek().constant) {
                  property.key = this.constant();
                  property.computed = false;
                  this.consume(":");
                  property.value = this.expression();
                } else if (this.peek().identifier) {
                  property.key = this.identifier();
                  property.computed = false;
                  if (this.peek(":")) {
                    this.consume(":");
                    property.value = this.expression();
                  } else {
                    property.value = property.key;
                  }
                } else if (this.peek("[")) {
                  this.consume("[");
                  property.key = this.expression();
                  this.consume("]");
                  property.computed = true;
                  this.consume(":");
                  property.value = this.expression();
                } else {
                  this.throwError("invalid key", this.peek());
                }
                properties.push(property);
              } while (this.expect(","));
            }
            this.consume("}");
            return { type: AST2.ObjectExpression, properties };
          },
          throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
          },
          consume: function(e1) {
            if (this.tokens.length === 0) {
              throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
              this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
          },
          peekToken: function() {
            if (this.tokens.length === 0) {
              throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            return this.tokens[0];
          },
          peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
          },
          peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
              var token = this.tokens[i];
              var t = token.text;
              if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                return token;
              }
            }
            return false;
          },
          expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
              this.tokens.shift();
              return token;
            }
            return false;
          },
          selfReferential: {
            "this": { type: AST2.ThisExpression },
            "$locals": { type: AST2.LocalsExpression }
          }
        };
        function ifDefined(v, d) {
          return typeof v !== "undefined" ? v : d;
        }
        function plusFn(l, r) {
          if (typeof l === "undefined")
            return r;
          if (typeof r === "undefined")
            return l;
          return l + r;
        }
        function isStateless($filter, filterName) {
          var fn2 = $filter(filterName);
          return !fn2.$stateful;
        }
        var PURITY_ABSOLUTE = 1;
        var PURITY_RELATIVE = 2;
        function isPure2(node, parentIsPure) {
          switch (node.type) {
            case AST2.MemberExpression:
              if (node.computed) {
                return false;
              }
              break;
            case AST2.UnaryExpression:
              return PURITY_ABSOLUTE;
            case AST2.BinaryExpression:
              return node.operator !== "+" ? PURITY_ABSOLUTE : false;
            case AST2.CallExpression:
              return false;
          }
          return parentIsPure === void 0 ? PURITY_RELATIVE : parentIsPure;
        }
        function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
          var allConstants;
          var argsToWatch;
          var isStatelessFilter;
          var astIsPure = ast.isPure = isPure2(ast, parentIsPure);
          switch (ast.type) {
            case AST2.Program:
              allConstants = true;
              forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter, astIsPure);
                allConstants = allConstants && expr.expression.constant;
              });
              ast.constant = allConstants;
              break;
            case AST2.Literal:
              ast.constant = true;
              ast.toWatch = [];
              break;
            case AST2.UnaryExpression:
              findConstantAndWatchExpressions(ast.argument, $filter, astIsPure);
              ast.constant = ast.argument.constant;
              ast.toWatch = ast.argument.toWatch;
              break;
            case AST2.BinaryExpression:
              findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
              findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
              ast.constant = ast.left.constant && ast.right.constant;
              ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
              break;
            case AST2.LogicalExpression:
              findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
              findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
              ast.constant = ast.left.constant && ast.right.constant;
              ast.toWatch = ast.constant ? [] : [ast];
              break;
            case AST2.ConditionalExpression:
              findConstantAndWatchExpressions(ast.test, $filter, astIsPure);
              findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure);
              findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure);
              ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
              ast.toWatch = ast.constant ? [] : [ast];
              break;
            case AST2.Identifier:
              ast.constant = false;
              ast.toWatch = [ast];
              break;
            case AST2.MemberExpression:
              findConstantAndWatchExpressions(ast.object, $filter, astIsPure);
              if (ast.computed) {
                findConstantAndWatchExpressions(ast.property, $filter, astIsPure);
              }
              ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
              ast.toWatch = ast.constant ? [] : [ast];
              break;
            case AST2.CallExpression:
              isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
              allConstants = isStatelessFilter;
              argsToWatch = [];
              forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure);
                allConstants = allConstants && expr.constant;
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              });
              ast.constant = allConstants;
              ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
              break;
            case AST2.AssignmentExpression:
              findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
              findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
              ast.constant = ast.left.constant && ast.right.constant;
              ast.toWatch = [ast];
              break;
            case AST2.ArrayExpression:
              allConstants = true;
              argsToWatch = [];
              forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure);
                allConstants = allConstants && expr.constant;
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              });
              ast.constant = allConstants;
              ast.toWatch = argsToWatch;
              break;
            case AST2.ObjectExpression:
              allConstants = true;
              argsToWatch = [];
              forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter, astIsPure);
                allConstants = allConstants && property.value.constant;
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                if (property.computed) {
                  findConstantAndWatchExpressions(property.key, $filter, false);
                  allConstants = allConstants && property.key.constant;
                  argsToWatch.push.apply(argsToWatch, property.key.toWatch);
                }
              });
              ast.constant = allConstants;
              ast.toWatch = argsToWatch;
              break;
            case AST2.ThisExpression:
              ast.constant = false;
              ast.toWatch = [];
              break;
            case AST2.LocalsExpression:
              ast.constant = false;
              ast.toWatch = [];
              break;
          }
        }
        function getInputs(body) {
          if (body.length !== 1)
            return;
          var lastExpression = body[0].expression;
          var candidate = lastExpression.toWatch;
          if (candidate.length !== 1)
            return candidate;
          return candidate[0] !== lastExpression ? candidate : void 0;
        }
        function isAssignable(ast) {
          return ast.type === AST2.Identifier || ast.type === AST2.MemberExpression;
        }
        function assignableAST(ast) {
          if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
            return { type: AST2.AssignmentExpression, left: ast.body[0].expression, right: { type: AST2.NGValueParameter }, operator: "=" };
          }
        }
        function isLiteral(ast) {
          return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST2.Literal || ast.body[0].expression.type === AST2.ArrayExpression || ast.body[0].expression.type === AST2.ObjectExpression);
        }
        function isConstant(ast) {
          return ast.constant;
        }
        function ASTCompiler($filter) {
          this.$filter = $filter;
        }
        ASTCompiler.prototype = {
          compile: function(ast) {
            var self2 = this;
            this.state = {
              nextId: 0,
              filters: {},
              fn: { vars: [], body: [], own: {} },
              assign: { vars: [], body: [], own: {} },
              inputs: []
            };
            findConstantAndWatchExpressions(ast, self2.$filter);
            var extra = "";
            var assignable;
            this.stage = "assign";
            if (assignable = assignableAST(ast)) {
              this.state.computing = "assign";
              var result = this.nextId();
              this.recurse(assignable, result);
              this.return_(result);
              extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self2.stage = "inputs";
            forEach(toWatch, function(watch, key2) {
              var fnKey = "fn" + key2;
              self2.state[fnKey] = { vars: [], body: [], own: {} };
              self2.state.computing = fnKey;
              var intoId = self2.nextId();
              self2.recurse(watch, intoId);
              self2.return_(intoId);
              self2.state.inputs.push({ name: fnKey, isPure: watch.isPure });
              watch.watchId = key2;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;";
            var fn2 = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
            this.state = this.stage = void 0;
            return fn2;
          },
          USE: "use",
          STRICT: "strict",
          watchFns: function() {
            var result = [];
            var inputs = this.state.inputs;
            var self2 = this;
            forEach(inputs, function(input) {
              result.push("var " + input.name + "=" + self2.generateFunction(input.name, "s"));
              if (input.isPure) {
                result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
              }
            });
            if (inputs.length) {
              result.push("fn.inputs=[" + inputs.map(function(i) {
                return i.name;
              }).join(",") + "];");
            }
            return result.join("");
          },
          generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
          },
          filterPrefix: function() {
            var parts = [];
            var self2 = this;
            forEach(this.state.filters, function(id, filter2) {
              parts.push(id + "=$filter(" + self2.escape(filter2) + ")");
            });
            if (parts.length)
              return "var " + parts.join(",") + ";";
            return "";
          },
          varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
          },
          body: function(section) {
            return this.state[section].body.join("");
          },
          recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, self2 = this, args, expression, computed;
            recursionFn = recursionFn || noop3;
            if (!skipWatchIdCheck && isDefined(ast.watchId)) {
              intoId = intoId || this.nextId();
              this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
              return;
            }
            switch (ast.type) {
              case AST2.Program:
                forEach(ast.body, function(expression2, pos) {
                  self2.recurse(expression2.expression, void 0, void 0, function(expr) {
                    right = expr;
                  });
                  if (pos !== ast.body.length - 1) {
                    self2.current().body.push(right, ";");
                  } else {
                    self2.return_(right);
                  }
                });
                break;
              case AST2.Literal:
                expression = this.escape(ast.value);
                this.assign(intoId, expression);
                recursionFn(intoId || expression);
                break;
              case AST2.UnaryExpression:
                this.recurse(ast.argument, void 0, void 0, function(expr) {
                  right = expr;
                });
                expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;
              case AST2.BinaryExpression:
                this.recurse(ast.left, void 0, void 0, function(expr) {
                  left = expr;
                });
                this.recurse(ast.right, void 0, void 0, function(expr) {
                  right = expr;
                });
                if (ast.operator === "+") {
                  expression = this.plus(left, right);
                } else if (ast.operator === "-") {
                  expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                } else {
                  expression = "(" + left + ")" + ast.operator + "(" + right + ")";
                }
                this.assign(intoId, expression);
                recursionFn(expression);
                break;
              case AST2.LogicalExpression:
                intoId = intoId || this.nextId();
                self2.recurse(ast.left, intoId);
                self2.if_(ast.operator === "&&" ? intoId : self2.not(intoId), self2.lazyRecurse(ast.right, intoId));
                recursionFn(intoId);
                break;
              case AST2.ConditionalExpression:
                intoId = intoId || this.nextId();
                self2.recurse(ast.test, intoId);
                self2.if_(intoId, self2.lazyRecurse(ast.alternate, intoId), self2.lazyRecurse(ast.consequent, intoId));
                recursionFn(intoId);
                break;
              case AST2.Identifier:
                intoId = intoId || this.nextId();
                if (nameId) {
                  nameId.context = self2.stage === "inputs" ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s");
                  nameId.computed = false;
                  nameId.name = ast.name;
                }
                self2.if_(self2.stage === "inputs" || self2.not(self2.getHasOwnProperty("l", ast.name)), function() {
                  self2.if_(self2.stage === "inputs" || "s", function() {
                    if (create && create !== 1) {
                      self2.if_(self2.isNull(self2.nonComputedMember("s", ast.name)), self2.lazyAssign(self2.nonComputedMember("s", ast.name), "{}"));
                    }
                    self2.assign(intoId, self2.nonComputedMember("s", ast.name));
                  });
                }, intoId && self2.lazyAssign(intoId, self2.nonComputedMember("l", ast.name)));
                recursionFn(intoId);
                break;
              case AST2.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId();
                intoId = intoId || this.nextId();
                self2.recurse(ast.object, left, void 0, function() {
                  self2.if_(self2.notNull(left), function() {
                    if (ast.computed) {
                      right = self2.nextId();
                      self2.recurse(ast.property, right);
                      self2.getStringValue(right);
                      if (create && create !== 1) {
                        self2.if_(self2.not(self2.computedMember(left, right)), self2.lazyAssign(self2.computedMember(left, right), "{}"));
                      }
                      expression = self2.computedMember(left, right);
                      self2.assign(intoId, expression);
                      if (nameId) {
                        nameId.computed = true;
                        nameId.name = right;
                      }
                    } else {
                      if (create && create !== 1) {
                        self2.if_(self2.isNull(self2.nonComputedMember(left, ast.property.name)), self2.lazyAssign(self2.nonComputedMember(left, ast.property.name), "{}"));
                      }
                      expression = self2.nonComputedMember(left, ast.property.name);
                      self2.assign(intoId, expression);
                      if (nameId) {
                        nameId.computed = false;
                        nameId.name = ast.property.name;
                      }
                    }
                  }, function() {
                    self2.assign(intoId, "undefined");
                  });
                  recursionFn(intoId);
                }, !!create);
                break;
              case AST2.CallExpression:
                intoId = intoId || this.nextId();
                if (ast.filter) {
                  right = self2.filter(ast.callee.name);
                  args = [];
                  forEach(ast.arguments, function(expr) {
                    var argument = self2.nextId();
                    self2.recurse(expr, argument);
                    args.push(argument);
                  });
                  expression = right + "(" + args.join(",") + ")";
                  self2.assign(intoId, expression);
                  recursionFn(intoId);
                } else {
                  right = self2.nextId();
                  left = {};
                  args = [];
                  self2.recurse(ast.callee, right, left, function() {
                    self2.if_(self2.notNull(right), function() {
                      forEach(ast.arguments, function(expr) {
                        self2.recurse(expr, ast.constant ? void 0 : self2.nextId(), void 0, function(argument) {
                          args.push(argument);
                        });
                      });
                      if (left.name) {
                        expression = self2.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")";
                      } else {
                        expression = right + "(" + args.join(",") + ")";
                      }
                      self2.assign(intoId, expression);
                    }, function() {
                      self2.assign(intoId, "undefined");
                    });
                    recursionFn(intoId);
                  });
                }
                break;
              case AST2.AssignmentExpression:
                right = this.nextId();
                left = {};
                this.recurse(ast.left, void 0, left, function() {
                  self2.if_(self2.notNull(left.context), function() {
                    self2.recurse(ast.right, right);
                    expression = self2.member(left.context, left.name, left.computed) + ast.operator + right;
                    self2.assign(intoId, expression);
                    recursionFn(intoId || expression);
                  });
                }, 1);
                break;
              case AST2.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                  self2.recurse(expr, ast.constant ? void 0 : self2.nextId(), void 0, function(argument) {
                    args.push(argument);
                  });
                });
                expression = "[" + args.join(",") + "]";
                this.assign(intoId, expression);
                recursionFn(intoId || expression);
                break;
              case AST2.ObjectExpression:
                args = [];
                computed = false;
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    computed = true;
                  }
                });
                if (computed) {
                  intoId = intoId || this.nextId();
                  this.assign(intoId, "{}");
                  forEach(ast.properties, function(property) {
                    if (property.computed) {
                      left = self2.nextId();
                      self2.recurse(property.key, left);
                    } else {
                      left = property.key.type === AST2.Identifier ? property.key.name : "" + property.key.value;
                    }
                    right = self2.nextId();
                    self2.recurse(property.value, right);
                    self2.assign(self2.member(intoId, left, property.computed), right);
                  });
                } else {
                  forEach(ast.properties, function(property) {
                    self2.recurse(property.value, ast.constant ? void 0 : self2.nextId(), void 0, function(expr) {
                      args.push(self2.escape(property.key.type === AST2.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                  });
                  expression = "{" + args.join(",") + "}";
                  this.assign(intoId, expression);
                }
                recursionFn(intoId || expression);
                break;
              case AST2.ThisExpression:
                this.assign(intoId, "s");
                recursionFn(intoId || "s");
                break;
              case AST2.LocalsExpression:
                this.assign(intoId, "l");
                recursionFn(intoId || "l");
                break;
              case AST2.NGValueParameter:
                this.assign(intoId, "v");
                recursionFn(intoId || "v");
                break;
            }
          },
          getHasOwnProperty: function(element2, property) {
            var key2 = element2 + "." + property;
            var own = this.current().own;
            if (!own.hasOwnProperty(key2)) {
              own[key2] = this.nextId(false, element2 + "&&(" + this.escape(property) + " in " + element2 + ")");
            }
            return own[key2];
          },
          assign: function(id, value) {
            if (!id)
              return;
            this.current().body.push(id, "=", value, ";");
            return id;
          },
          filter: function(filterName) {
            if (!this.state.filters.hasOwnProperty(filterName)) {
              this.state.filters[filterName] = this.nextId(true);
            }
            return this.state.filters[filterName];
          },
          ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
          },
          plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
          },
          return_: function(id) {
            this.current().body.push("return ", id, ";");
          },
          if_: function(test, alternate, consequent) {
            if (test === true) {
              alternate();
            } else {
              var body = this.current().body;
              body.push("if(", test, "){");
              alternate();
              body.push("}");
              if (consequent) {
                body.push("else{");
                consequent();
                body.push("}");
              }
            }
          },
          not: function(expression) {
            return "!(" + expression + ")";
          },
          isNull: function(expression) {
            return expression + "==null";
          },
          notNull: function(expression) {
            return expression + "!=null";
          },
          nonComputedMember: function(left, right) {
            var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
            var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
            if (SAFE_IDENTIFIER.test(right)) {
              return left + "." + right;
            } else {
              return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
            }
          },
          computedMember: function(left, right) {
            return left + "[" + right + "]";
          },
          member: function(left, right, computed) {
            if (computed)
              return this.computedMember(left, right);
            return this.nonComputedMember(left, right);
          },
          getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
          },
          lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self2 = this;
            return function() {
              self2.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
          },
          lazyAssign: function(id, value) {
            var self2 = this;
            return function() {
              self2.assign(id, value);
            };
          },
          stringEscapeRegex: /[^ a-zA-Z0-9]/g,
          stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
          },
          escape: function(value) {
            if (isString(value))
              return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value))
              return value.toString();
            if (value === true)
              return "true";
            if (value === false)
              return "false";
            if (value === null)
              return "null";
            if (typeof value === "undefined")
              return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
          },
          nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            if (!skip) {
              this.current().vars.push(id + (init ? "=" + init : ""));
            }
            return id;
          },
          current: function() {
            return this.state[this.state.computing];
          }
        };
        function ASTInterpreter($filter) {
          this.$filter = $filter;
        }
        ASTInterpreter.prototype = {
          compile: function(ast) {
            var self2 = this;
            findConstantAndWatchExpressions(ast, self2.$filter);
            var assignable;
            var assign;
            if (assignable = assignableAST(ast)) {
              assign = this.recurse(assignable);
            }
            var toWatch = getInputs(ast.body);
            var inputs;
            if (toWatch) {
              inputs = [];
              forEach(toWatch, function(watch, key2) {
                var input = self2.recurse(watch);
                input.isPure = watch.isPure;
                watch.input = input;
                inputs.push(input);
                watch.watchId = key2;
              });
            }
            var expressions = [];
            forEach(ast.body, function(expression) {
              expressions.push(self2.recurse(expression.expression));
            });
            var fn2 = ast.body.length === 0 ? noop3 : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
              var lastValue;
              forEach(expressions, function(exp) {
                lastValue = exp(scope, locals);
              });
              return lastValue;
            };
            if (assign) {
              fn2.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
              };
            }
            if (inputs) {
              fn2.inputs = inputs;
            }
            return fn2;
          },
          recurse: function(ast, context, create) {
            var left, right, self2 = this, args;
            if (ast.input) {
              return this.inputs(ast.input, ast.watchId);
            }
            switch (ast.type) {
              case AST2.Literal:
                return this.value(ast.value, context);
              case AST2.UnaryExpression:
                right = this.recurse(ast.argument);
                return this["unary" + ast.operator](right, context);
              case AST2.BinaryExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);
              case AST2.LogicalExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);
              case AST2.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
              case AST2.Identifier:
                return self2.identifier(ast.name, context, create);
              case AST2.MemberExpression:
                left = this.recurse(ast.object, false, !!create);
                if (!ast.computed) {
                  right = ast.property.name;
                }
                if (ast.computed)
                  right = this.recurse(ast.property);
                return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);
              case AST2.CallExpression:
                args = [];
                forEach(ast.arguments, function(expr) {
                  args.push(self2.recurse(expr));
                });
                if (ast.filter)
                  right = this.$filter(ast.callee.name);
                if (!ast.filter)
                  right = this.recurse(ast.callee, true);
                return ast.filter ? function(scope, locals, assign, inputs) {
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(args[i](scope, locals, assign, inputs));
                  }
                  var value = right.apply(void 0, values, inputs);
                  return context ? { context: void 0, name: void 0, value } : value;
                } : function(scope, locals, assign, inputs) {
                  var rhs = right(scope, locals, assign, inputs);
                  var value;
                  if (rhs.value != null) {
                    var values = [];
                    for (var i = 0; i < args.length; ++i) {
                      values.push(args[i](scope, locals, assign, inputs));
                    }
                    value = rhs.value.apply(rhs.context, values);
                  }
                  return context ? { value } : value;
                };
              case AST2.AssignmentExpression:
                left = this.recurse(ast.left, true, 1);
                right = this.recurse(ast.right);
                return function(scope, locals, assign, inputs) {
                  var lhs = left(scope, locals, assign, inputs);
                  var rhs = right(scope, locals, assign, inputs);
                  lhs.context[lhs.name] = rhs;
                  return context ? { value: rhs } : rhs;
                };
              case AST2.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                  args.push(self2.recurse(expr));
                });
                return function(scope, locals, assign, inputs) {
                  var value = [];
                  for (var i = 0; i < args.length; ++i) {
                    value.push(args[i](scope, locals, assign, inputs));
                  }
                  return context ? { value } : value;
                };
              case AST2.ObjectExpression:
                args = [];
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    args.push({
                      key: self2.recurse(property.key),
                      computed: true,
                      value: self2.recurse(property.value)
                    });
                  } else {
                    args.push({
                      key: property.key.type === AST2.Identifier ? property.key.name : "" + property.key.value,
                      computed: false,
                      value: self2.recurse(property.value)
                    });
                  }
                });
                return function(scope, locals, assign, inputs) {
                  var value = {};
                  for (var i = 0; i < args.length; ++i) {
                    if (args[i].computed) {
                      value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                    } else {
                      value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    }
                  }
                  return context ? { value } : value;
                };
              case AST2.ThisExpression:
                return function(scope) {
                  return context ? { value: scope } : scope;
                };
              case AST2.LocalsExpression:
                return function(scope, locals) {
                  return context ? { value: locals } : locals;
                };
              case AST2.NGValueParameter:
                return function(scope, locals, assign) {
                  return context ? { value: assign } : assign;
                };
            }
          },
          "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
              var arg = argument(scope, locals, assign, inputs);
              if (isDefined(arg)) {
                arg = +arg;
              } else {
                arg = 0;
              }
              return context ? { value: arg } : arg;
            };
          },
          "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
              var arg = argument(scope, locals, assign, inputs);
              if (isDefined(arg)) {
                arg = -arg;
              } else {
                arg = -0;
              }
              return context ? { value: arg } : arg;
            };
          },
          "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
              var arg = !argument(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var lhs = left(scope, locals, assign, inputs);
              var rhs = right(scope, locals, assign, inputs);
              var arg = plusFn(lhs, rhs);
              return context ? { value: arg } : arg;
            };
          },
          "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var lhs = left(scope, locals, assign, inputs);
              var rhs = right(scope, locals, assign, inputs);
              var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
              return context ? { value: arg } : arg;
            };
          },
          "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
              var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
              var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
              return context ? { value: arg } : arg;
            };
          },
          value: function(value, context) {
            return function() {
              return context ? { context: void 0, name: void 0, value } : value;
            };
          },
          identifier: function(name, context, create) {
            return function(scope, locals, assign, inputs) {
              var base = locals && name in locals ? locals : scope;
              if (create && create !== 1 && base && base[name] == null) {
                base[name] = {};
              }
              var value = base ? base[name] : void 0;
              if (context) {
                return { context: base, name, value };
              } else {
                return value;
              }
            };
          },
          computedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
              var lhs = left(scope, locals, assign, inputs);
              var rhs;
              var value;
              if (lhs != null) {
                rhs = right(scope, locals, assign, inputs);
                rhs = getStringValue(rhs);
                if (create && create !== 1) {
                  if (lhs && !lhs[rhs]) {
                    lhs[rhs] = {};
                  }
                }
                value = lhs[rhs];
              }
              if (context) {
                return { context: lhs, name: rhs, value };
              } else {
                return value;
              }
            };
          },
          nonComputedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
              var lhs = left(scope, locals, assign, inputs);
              if (create && create !== 1) {
                if (lhs && lhs[right] == null) {
                  lhs[right] = {};
                }
              }
              var value = lhs != null ? lhs[right] : void 0;
              if (context) {
                return { context: lhs, name: right, value };
              } else {
                return value;
              }
            };
          },
          inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
              if (inputs)
                return inputs[watchId];
              return input(scope, value, locals);
            };
          }
        };
        function Parser2(lexer, $filter, options) {
          this.ast = new AST2(lexer, options);
          this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
        }
        Parser2.prototype = {
          constructor: Parser2,
          parse: function(text) {
            var ast = this.getAst(text);
            var fn2 = this.astCompiler.compile(ast.ast);
            fn2.literal = isLiteral(ast.ast);
            fn2.constant = isConstant(ast.ast);
            fn2.oneTime = ast.oneTime;
            return fn2;
          },
          getAst: function(exp) {
            var oneTime = false;
            exp = exp.trim();
            if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
              oneTime = true;
              exp = exp.substring(2);
            }
            return {
              ast: this.ast.ast(exp),
              oneTime
            };
          }
        };
        function getValueOf(value) {
          return isFunction2(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
        }
        function $ParseProvider() {
          var cache = createMap();
          var literals = {
            "true": true,
            "false": false,
            "null": null,
            "undefined": void 0
          };
          var identStart, identContinue;
          this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
          };
          this.setIdentifierFns = function(identifierStart, identifierContinue) {
            identStart = identifierStart;
            identContinue = identifierContinue;
            return this;
          };
          this.$get = ["$filter", function($filter) {
            var noUnsafeEval = csp().noUnsafeEval;
            var $parseOptions = {
              csp: noUnsafeEval,
              literals: copy(literals),
              isIdentifierStart: isFunction2(identStart) && identStart,
              isIdentifierContinue: isFunction2(identContinue) && identContinue
            };
            $parse.$$getAst = $$getAst;
            return $parse;
            function $parse(exp, interceptorFn) {
              var parsedExpression, cacheKey;
              switch (typeof exp) {
                case "string":
                  exp = exp.trim();
                  cacheKey = exp;
                  parsedExpression = cache[cacheKey];
                  if (!parsedExpression) {
                    var lexer = new Lexer2($parseOptions);
                    var parser = new Parser2(lexer, $filter, $parseOptions);
                    parsedExpression = parser.parse(exp);
                    cache[cacheKey] = addWatchDelegate(parsedExpression);
                  }
                  return addInterceptor(parsedExpression, interceptorFn);
                case "function":
                  return addInterceptor(exp, interceptorFn);
                default:
                  return addInterceptor(noop3, interceptorFn);
              }
            }
            function $$getAst(exp) {
              var lexer = new Lexer2($parseOptions);
              var parser = new Parser2(lexer, $filter, $parseOptions);
              return parser.getAst(exp).ast;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
              if (newValue == null || oldValueOfValue == null) {
                return newValue === oldValueOfValue;
              }
              if (typeof newValue === "object") {
                newValue = getValueOf(newValue);
                if (typeof newValue === "object" && !compareObjectIdentity) {
                  return false;
                }
              }
              return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
              var inputExpressions = parsedExpression.inputs;
              var lastResult;
              if (inputExpressions.length === 1) {
                var oldInputValueOf = expressionInputDirtyCheck;
                inputExpressions = inputExpressions[0];
                return scope.$watch(function expressionInputWatch(scope2) {
                  var newInputValue = inputExpressions(scope2);
                  if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure)) {
                    lastResult = parsedExpression(scope2, void 0, void 0, [newInputValue]);
                    oldInputValueOf = newInputValue && getValueOf(newInputValue);
                  }
                  return lastResult;
                }, listener, objectEquality, prettyPrintExpression);
              }
              var oldInputValueOfValues = [];
              var oldInputValues = [];
              for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                oldInputValueOfValues[i] = expressionInputDirtyCheck;
                oldInputValues[i] = null;
              }
              return scope.$watch(function expressionInputsWatch(scope2) {
                var changed = false;
                for (var i2 = 0, ii2 = inputExpressions.length; i2 < ii2; i2++) {
                  var newInputValue = inputExpressions[i2](scope2);
                  if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i2], inputExpressions[i2].isPure))) {
                    oldInputValues[i2] = newInputValue;
                    oldInputValueOfValues[i2] = newInputValue && getValueOf(newInputValue);
                  }
                }
                if (changed) {
                  lastResult = parsedExpression(scope2, void 0, void 0, oldInputValues);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
              var isDone = parsedExpression.literal ? isAllDefined : isDefined;
              var unwatch, lastValue;
              var exp = parsedExpression.$$intercepted || parsedExpression;
              var post = parsedExpression.$$interceptor || identity2;
              var useInputs = parsedExpression.inputs && !exp.inputs;
              oneTimeWatch.literal = parsedExpression.literal;
              oneTimeWatch.constant = parsedExpression.constant;
              oneTimeWatch.inputs = parsedExpression.inputs;
              addWatchDelegate(oneTimeWatch);
              unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
              return unwatch;
              function unwatchIfDone() {
                if (isDone(lastValue)) {
                  unwatch();
                }
              }
              function oneTimeWatch(scope2, locals, assign, inputs) {
                lastValue = useInputs && inputs ? inputs[0] : exp(scope2, locals, assign, inputs);
                if (isDone(lastValue)) {
                  scope2.$$postDigest(unwatchIfDone);
                }
                return post(lastValue);
              }
            }
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
              var unwatch = scope.$watch(function constantWatch(scope2) {
                unwatch();
                return parsedExpression(scope2);
              }, listener, objectEquality);
              return unwatch;
            }
            function addWatchDelegate(parsedExpression) {
              if (parsedExpression.constant) {
                parsedExpression.$$watchDelegate = constantWatchDelegate;
              } else if (parsedExpression.oneTime) {
                parsedExpression.$$watchDelegate = oneTimeWatchDelegate;
              } else if (parsedExpression.inputs) {
                parsedExpression.$$watchDelegate = inputsWatchDelegate;
              }
              return parsedExpression;
            }
            function chainInterceptors(first, second) {
              function chainedInterceptor(value) {
                return second(first(value));
              }
              chainedInterceptor.$stateful = first.$stateful || second.$stateful;
              chainedInterceptor.$$pure = first.$$pure && second.$$pure;
              return chainedInterceptor;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
              if (!interceptorFn)
                return parsedExpression;
              if (parsedExpression.$$interceptor) {
                interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn);
                parsedExpression = parsedExpression.$$intercepted;
              }
              var useInputs = false;
              var fn2 = function interceptedExpression(scope, locals, assign, inputs) {
                var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                return interceptorFn(value);
              };
              fn2.$$intercepted = parsedExpression;
              fn2.$$interceptor = interceptorFn;
              fn2.literal = parsedExpression.literal;
              fn2.oneTime = parsedExpression.oneTime;
              fn2.constant = parsedExpression.constant;
              if (!interceptorFn.$stateful) {
                useInputs = !parsedExpression.inputs;
                fn2.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
                if (!interceptorFn.$$pure) {
                  fn2.inputs = fn2.inputs.map(function(e) {
                    if (e.isPure === PURITY_RELATIVE) {
                      return function depurifier(s) {
                        return e(s);
                      };
                    }
                    return e;
                  });
                }
              }
              return addWatchDelegate(fn2);
            }
          }];
        }
        function $QProvider() {
          var errorOnUnhandledRejections = true;
          this.$get = ["$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
              $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
          }];
          this.errorOnUnhandledRejections = function(value) {
            if (isDefined(value)) {
              errorOnUnhandledRejections = value;
              return this;
            } else {
              return errorOnUnhandledRejections;
            }
          };
        }
        function $$QProvider() {
          var errorOnUnhandledRejections = true;
          this.$get = ["$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
              $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
          }];
          this.errorOnUnhandledRejections = function(value) {
            if (isDefined(value)) {
              errorOnUnhandledRejections = value;
              return this;
            } else {
              return errorOnUnhandledRejections;
            }
          };
        }
        function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
          var $qMinErr = minErr("$q", TypeError);
          var queueSize = 0;
          var checkQueue = [];
          function defer() {
            return new Deferred();
          }
          function Deferred() {
            var promise2 = this.promise = new Promise2();
            this.resolve = function(val) {
              resolvePromise(promise2, val);
            };
            this.reject = function(reason) {
              rejectPromise(promise2, reason);
            };
            this.notify = function(progress) {
              notifyPromise(promise2, progress);
            };
          }
          function Promise2() {
            this.$$state = { status: 0 };
          }
          extend(Promise2.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
              if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                return this;
              }
              var result = new Promise2();
              this.$$state.pending = this.$$state.pending || [];
              this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
              if (this.$$state.status > 0)
                scheduleProcessQueue(this.$$state);
              return result;
            },
            "catch": function(callback) {
              return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
              return this.then(function(value) {
                return handleCallback(value, resolve, callback);
              }, function(error3) {
                return handleCallback(error3, reject, callback);
              }, progressBack);
            }
          });
          function processQueue(state) {
            var fn2, promise2, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = void 0;
            try {
              for (var i = 0, ii = pending.length; i < ii; ++i) {
                markQStateExceptionHandled(state);
                promise2 = pending[i][0];
                fn2 = pending[i][state.status];
                try {
                  if (isFunction2(fn2)) {
                    resolvePromise(promise2, fn2(state.value));
                  } else if (state.status === 1) {
                    resolvePromise(promise2, state.value);
                  } else {
                    rejectPromise(promise2, state.value);
                  }
                } catch (e) {
                  rejectPromise(promise2, e);
                  if (e && e.$$passToExceptionHandler === true) {
                    exceptionHandler(e);
                  }
                }
              }
            } finally {
              --queueSize;
              if (errorOnUnhandledRejections && queueSize === 0) {
                nextTick(processChecks);
              }
            }
          }
          function processChecks() {
            while (!queueSize && checkQueue.length) {
              var toCheck = checkQueue.shift();
              if (!isStateExceptionHandled(toCheck)) {
                markQStateExceptionHandled(toCheck);
                var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                if (isError(toCheck.value)) {
                  exceptionHandler(toCheck.value, errorMessage);
                } else {
                  exceptionHandler(errorMessage);
                }
              }
            }
          }
          function scheduleProcessQueue(state) {
            if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !isStateExceptionHandled(state)) {
              if (queueSize === 0 && checkQueue.length === 0) {
                nextTick(processChecks);
              }
              checkQueue.push(state);
            }
            if (state.processScheduled || !state.pending)
              return;
            state.processScheduled = true;
            ++queueSize;
            nextTick(function() {
              processQueue(state);
            });
          }
          function resolvePromise(promise2, val) {
            if (promise2.$$state.status)
              return;
            if (val === promise2) {
              $$reject(promise2, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              $$resolve(promise2, val);
            }
          }
          function $$resolve(promise2, val) {
            var then;
            var done = false;
            try {
              if (isObject2(val) || isFunction2(val))
                then = val.then;
              if (isFunction2(then)) {
                promise2.$$state.status = -1;
                then.call(val, doResolve, doReject, doNotify);
              } else {
                promise2.$$state.value = val;
                promise2.$$state.status = 1;
                scheduleProcessQueue(promise2.$$state);
              }
            } catch (e) {
              doReject(e);
            }
            function doResolve(val2) {
              if (done)
                return;
              done = true;
              $$resolve(promise2, val2);
            }
            function doReject(val2) {
              if (done)
                return;
              done = true;
              $$reject(promise2, val2);
            }
            function doNotify(progress) {
              notifyPromise(promise2, progress);
            }
          }
          function rejectPromise(promise2, reason) {
            if (promise2.$$state.status)
              return;
            $$reject(promise2, reason);
          }
          function $$reject(promise2, reason) {
            promise2.$$state.value = reason;
            promise2.$$state.status = 2;
            scheduleProcessQueue(promise2.$$state);
          }
          function notifyPromise(promise2, progress) {
            var callbacks = promise2.$$state.pending;
            if (promise2.$$state.status <= 0 && callbacks && callbacks.length) {
              nextTick(function() {
                var callback, result;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    notifyPromise(result, isFunction2(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
          function reject(reason) {
            var result = new Promise2();
            rejectPromise(result, reason);
            return result;
          }
          function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
              if (isFunction2(callback))
                callbackOutput = callback();
            } catch (e) {
              return reject(e);
            }
            if (isPromiseLike(callbackOutput)) {
              return callbackOutput.then(function() {
                return resolver(value);
              }, reject);
            } else {
              return resolver(value);
            }
          }
          function when(value, callback, errback, progressBack) {
            var result = new Promise2();
            resolvePromise(result, value);
            return result.then(callback, errback, progressBack);
          }
          var resolve = when;
          function all(promises) {
            var result = new Promise2(), counter = 0, results = isArray2(promises) ? [] : {};
            forEach(promises, function(promise2, key2) {
              counter++;
              when(promise2).then(function(value) {
                results[key2] = value;
                if (!--counter)
                  resolvePromise(result, results);
              }, function(reason) {
                rejectPromise(result, reason);
              });
            });
            if (counter === 0) {
              resolvePromise(result, results);
            }
            return result;
          }
          function race(promises) {
            var deferred = defer();
            forEach(promises, function(promise2) {
              when(promise2).then(deferred.resolve, deferred.reject);
            });
            return deferred.promise;
          }
          function $Q(resolver) {
            if (!isFunction2(resolver)) {
              throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            var promise2 = new Promise2();
            function resolveFn(value) {
              resolvePromise(promise2, value);
            }
            function rejectFn(reason) {
              rejectPromise(promise2, reason);
            }
            resolver(resolveFn, rejectFn);
            return promise2;
          }
          $Q.prototype = Promise2.prototype;
          $Q.defer = defer;
          $Q.reject = reject;
          $Q.when = when;
          $Q.resolve = resolve;
          $Q.all = all;
          $Q.race = race;
          return $Q;
        }
        function isStateExceptionHandled(state) {
          return !!state.pur;
        }
        function markQStateExceptionHandled(state) {
          state.pur = true;
        }
        function markQExceptionHandled(q) {
          if (q.$$state) {
            markQStateExceptionHandled(q.$$state);
          }
        }
        function $$RAFProvider() {
          this.$get = ["$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame2 = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame2;
            var raf = rafSupported ? function(fn2) {
              var id = requestAnimationFrame2(fn2);
              return function() {
                cancelAnimationFrame(id);
              };
            } : function(fn2) {
              var timer = $timeout(fn2, 16.66, false);
              return function() {
                $timeout.cancel(timer);
              };
            };
            raf.supported = rafSupported;
            return raf;
          }];
        }
        function $RootScopeProvider() {
          var TTL = 10;
          var $rootScopeMinErr = minErr("$rootScope");
          var lastDirtyWatch = null;
          var applyAsyncId = null;
          this.digestTtl = function(value) {
            if (arguments.length) {
              TTL = value;
            }
            return TTL;
          };
          function createChildScopeClass(parent) {
            function ChildScope() {
              this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
              this.$$listeners = {};
              this.$$listenerCount = {};
              this.$$watchersCount = 0;
              this.$id = nextUid();
              this.$$ChildScope = null;
              this.$$suspended = false;
            }
            ChildScope.prototype = parent;
            return ChildScope;
          }
          this.$get = [
            "$exceptionHandler",
            "$parse",
            "$browser",
            function($exceptionHandler, $parse, $browser) {
              function destroyChildScope($event) {
                $event.currentScope.$$destroyed = true;
              }
              function cleanUpScope($scope) {
                if (msie === 9) {
                  if ($scope.$$childHead) {
                    cleanUpScope($scope.$$childHead);
                  }
                  if ($scope.$$nextSibling) {
                    cleanUpScope($scope.$$nextSibling);
                  }
                }
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
              }
              function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$suspended = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
              }
              Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                  var child;
                  parent = parent || this;
                  if (isolate) {
                    child = new Scope();
                    child.$root = this.$root;
                  } else {
                    if (!this.$$ChildScope) {
                      this.$$ChildScope = createChildScopeClass(this);
                    }
                    child = new this.$$ChildScope();
                  }
                  child.$parent = parent;
                  child.$$prevSibling = parent.$$childTail;
                  if (parent.$$childHead) {
                    parent.$$childTail.$$nextSibling = child;
                    parent.$$childTail = child;
                  } else {
                    parent.$$childHead = parent.$$childTail = child;
                  }
                  if (isolate || parent !== this)
                    child.$on("$destroy", destroyChildScope);
                  return child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                  var get = $parse(watchExp);
                  var fn2 = isFunction2(listener) ? listener : noop3;
                  if (get.$$watchDelegate) {
                    return get.$$watchDelegate(this, fn2, objectEquality, get, watchExp);
                  }
                  var scope = this, array = scope.$$watchers, watcher = {
                    fn: fn2,
                    last: initWatchVal,
                    get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
                  lastDirtyWatch = null;
                  if (!array) {
                    array = scope.$$watchers = [];
                    array.$$digestWatchIndex = -1;
                  }
                  array.unshift(watcher);
                  array.$$digestWatchIndex++;
                  incrementWatchersCount(this, 1);
                  return function deregisterWatch() {
                    var index = arrayRemove(array, watcher);
                    if (index >= 0) {
                      incrementWatchersCount(scope, -1);
                      if (index < array.$$digestWatchIndex) {
                        array.$$digestWatchIndex--;
                      }
                    }
                    lastDirtyWatch = null;
                  };
                },
                $watchGroup: function(watchExpressions, listener) {
                  var oldValues = new Array(watchExpressions.length);
                  var newValues = new Array(watchExpressions.length);
                  var deregisterFns = [];
                  var self2 = this;
                  var changeReactionScheduled = false;
                  var firstRun = true;
                  if (!watchExpressions.length) {
                    var shouldCall = true;
                    self2.$evalAsync(function() {
                      if (shouldCall)
                        listener(newValues, newValues, self2);
                    });
                    return function deregisterWatchGroup() {
                      shouldCall = false;
                    };
                  }
                  if (watchExpressions.length === 1) {
                    return this.$watch(watchExpressions[0], function watchGroupAction2(value, oldValue, scope) {
                      newValues[0] = value;
                      oldValues[0] = oldValue;
                      listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    });
                  }
                  forEach(watchExpressions, function(expr, i) {
                    var unwatchFn = self2.$watch(expr, function watchGroupSubAction(value) {
                      newValues[i] = value;
                      if (!changeReactionScheduled) {
                        changeReactionScheduled = true;
                        self2.$evalAsync(watchGroupAction);
                      }
                    });
                    deregisterFns.push(unwatchFn);
                  });
                  function watchGroupAction() {
                    changeReactionScheduled = false;
                    try {
                      if (firstRun) {
                        firstRun = false;
                        listener(newValues, newValues, self2);
                      } else {
                        listener(newValues, oldValues, self2);
                      }
                    } finally {
                      for (var i = 0; i < watchExpressions.length; i++) {
                        oldValues[i] = newValues[i];
                      }
                    }
                  }
                  return function deregisterWatchGroup() {
                    while (deregisterFns.length) {
                      deregisterFns.shift()();
                    }
                  };
                },
                $watchCollection: function(obj, listener) {
                  $watchCollectionInterceptor.$$pure = $parse(obj).literal;
                  $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                  var self2 = this;
                  var newValue;
                  var oldValue;
                  var veryOldValue;
                  var trackVeryOldValue = listener.length > 1;
                  var changeDetected = 0;
                  var changeDetector = $parse(obj, $watchCollectionInterceptor);
                  var internalArray = [];
                  var internalObject = {};
                  var initRun = true;
                  var oldLength = 0;
                  function $watchCollectionInterceptor(_value) {
                    newValue = _value;
                    var newLength, key2, bothNaN, newItem, oldItem;
                    if (isUndefined(newValue))
                      return;
                    if (!isObject2(newValue)) {
                      if (oldValue !== newValue) {
                        oldValue = newValue;
                        changeDetected++;
                      }
                    } else if (isArrayLike2(newValue)) {
                      if (oldValue !== internalArray) {
                        oldValue = internalArray;
                        oldLength = oldValue.length = 0;
                        changeDetected++;
                      }
                      newLength = newValue.length;
                      if (oldLength !== newLength) {
                        changeDetected++;
                        oldValue.length = oldLength = newLength;
                      }
                      for (var i = 0; i < newLength; i++) {
                        oldItem = oldValue[i];
                        newItem = newValue[i];
                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                        if (!bothNaN && oldItem !== newItem) {
                          changeDetected++;
                          oldValue[i] = newItem;
                        }
                      }
                    } else {
                      if (oldValue !== internalObject) {
                        oldValue = internalObject = {};
                        oldLength = 0;
                        changeDetected++;
                      }
                      newLength = 0;
                      for (key2 in newValue) {
                        if (hasOwnProperty.call(newValue, key2)) {
                          newLength++;
                          newItem = newValue[key2];
                          oldItem = oldValue[key2];
                          if (key2 in oldValue) {
                            bothNaN = oldItem !== oldItem && newItem !== newItem;
                            if (!bothNaN && oldItem !== newItem) {
                              changeDetected++;
                              oldValue[key2] = newItem;
                            }
                          } else {
                            oldLength++;
                            oldValue[key2] = newItem;
                            changeDetected++;
                          }
                        }
                      }
                      if (oldLength > newLength) {
                        changeDetected++;
                        for (key2 in oldValue) {
                          if (!hasOwnProperty.call(newValue, key2)) {
                            oldLength--;
                            delete oldValue[key2];
                          }
                        }
                      }
                    }
                    return changeDetected;
                  }
                  function $watchCollectionAction() {
                    if (initRun) {
                      initRun = false;
                      listener(newValue, newValue, self2);
                    } else {
                      listener(newValue, veryOldValue, self2);
                    }
                    if (trackVeryOldValue) {
                      if (!isObject2(newValue)) {
                        veryOldValue = newValue;
                      } else if (isArrayLike2(newValue)) {
                        veryOldValue = new Array(newValue.length);
                        for (var i = 0; i < newValue.length; i++) {
                          veryOldValue[i] = newValue[i];
                        }
                      } else {
                        veryOldValue = {};
                        for (var key2 in newValue) {
                          if (hasOwnProperty.call(newValue, key2)) {
                            veryOldValue[key2] = newValue[key2];
                          }
                        }
                      }
                    }
                  }
                  return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                  var watch, value, last, fn2, get, watchers, dirty, ttl = TTL, next, current, target = asyncQueue.length ? $rootScope : this, watchLog = [], logIdx, asyncTask;
                  beginPhase("$digest");
                  $browser.$$checkUrlChange();
                  if (this === $rootScope && applyAsyncId !== null) {
                    $browser.defer.cancel(applyAsyncId);
                    flushApplyAsync();
                  }
                  lastDirtyWatch = null;
                  do {
                    dirty = false;
                    current = target;
                    for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                      try {
                        asyncTask = asyncQueue[asyncQueuePosition];
                        fn2 = asyncTask.fn;
                        fn2(asyncTask.scope, asyncTask.locals);
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                      lastDirtyWatch = null;
                    }
                    asyncQueue.length = 0;
                    traverseScopesLoop:
                      do {
                        if (watchers = !current.$$suspended && current.$$watchers) {
                          watchers.$$digestWatchIndex = watchers.length;
                          while (watchers.$$digestWatchIndex--) {
                            try {
                              watch = watchers[watchers.$$digestWatchIndex];
                              if (watch) {
                                get = watch.get;
                                if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                  dirty = true;
                                  lastDirtyWatch = watch;
                                  watch.last = watch.eq ? copy(value, null) : value;
                                  fn2 = watch.fn;
                                  fn2(value, last === initWatchVal ? value : last, current);
                                  if (ttl < 5) {
                                    logIdx = 4 - ttl;
                                    if (!watchLog[logIdx])
                                      watchLog[logIdx] = [];
                                    watchLog[logIdx].push({
                                      msg: isFunction2(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                      newVal: value,
                                      oldVal: last
                                    });
                                  }
                                } else if (watch === lastDirtyWatch) {
                                  dirty = false;
                                  break traverseScopesLoop;
                                }
                              }
                            } catch (e) {
                              $exceptionHandler(e);
                            }
                          }
                        }
                        if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                          while (current !== target && !(next = current.$$nextSibling)) {
                            current = current.$parent;
                          }
                        }
                      } while (current = next);
                    if ((dirty || asyncQueue.length) && !ttl--) {
                      clearPhase();
                      throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    }
                  } while (dirty || asyncQueue.length);
                  clearPhase();
                  while (postDigestQueuePosition < postDigestQueue.length) {
                    try {
                      postDigestQueue[postDigestQueuePosition++]();
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                  postDigestQueue.length = postDigestQueuePosition = 0;
                  $browser.$$checkUrlChange();
                },
                $suspend: function() {
                  this.$$suspended = true;
                },
                $isSuspended: function() {
                  return this.$$suspended;
                },
                $resume: function() {
                  this.$$suspended = false;
                },
                $destroy: function() {
                  if (this.$$destroyed)
                    return;
                  var parent = this.$parent;
                  this.$broadcast("$destroy");
                  this.$$destroyed = true;
                  if (this === $rootScope) {
                    $browser.$$applicationDestroyed();
                  }
                  incrementWatchersCount(this, -this.$$watchersCount);
                  for (var eventName in this.$$listenerCount) {
                    decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                  }
                  if (parent && parent.$$childHead === this)
                    parent.$$childHead = this.$$nextSibling;
                  if (parent && parent.$$childTail === this)
                    parent.$$childTail = this.$$prevSibling;
                  if (this.$$prevSibling)
                    this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                  if (this.$$nextSibling)
                    this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                  this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop3;
                  this.$on = this.$watch = this.$watchGroup = function() {
                    return noop3;
                  };
                  this.$$listeners = {};
                  this.$$nextSibling = null;
                  cleanUpScope(this);
                },
                $eval: function(expr, locals) {
                  return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                  if (!$rootScope.$$phase && !asyncQueue.length) {
                    $browser.defer(function() {
                      if (asyncQueue.length) {
                        $rootScope.$digest();
                      }
                    }, null, "$evalAsync");
                  }
                  asyncQueue.push({ scope: this, fn: $parse(expr), locals });
                },
                $$postDigest: function(fn2) {
                  postDigestQueue.push(fn2);
                },
                $apply: function(expr) {
                  try {
                    beginPhase("$apply");
                    try {
                      return this.$eval(expr);
                    } finally {
                      clearPhase();
                    }
                  } catch (e) {
                    $exceptionHandler(e);
                  } finally {
                    try {
                      $rootScope.$digest();
                    } catch (e) {
                      $exceptionHandler(e);
                      throw e;
                    }
                  }
                },
                $applyAsync: function(expr) {
                  var scope = this;
                  if (expr) {
                    applyAsyncQueue.push($applyAsyncExpression);
                  }
                  expr = $parse(expr);
                  scheduleApplyAsync();
                  function $applyAsyncExpression() {
                    scope.$eval(expr);
                  }
                },
                $on: function(name, listener) {
                  var namedListeners = this.$$listeners[name];
                  if (!namedListeners) {
                    this.$$listeners[name] = namedListeners = [];
                  }
                  namedListeners.push(listener);
                  var current = this;
                  do {
                    if (!current.$$listenerCount[name]) {
                      current.$$listenerCount[name] = 0;
                    }
                    current.$$listenerCount[name]++;
                  } while (current = current.$parent);
                  var self2 = this;
                  return function() {
                    var indexOfListener = namedListeners.indexOf(listener);
                    if (indexOfListener !== -1) {
                      delete namedListeners[indexOfListener];
                      decrementListenerCount(self2, 1, name);
                    }
                  };
                },
                $emit: function(name, args) {
                  var empty3 = [], namedListeners, scope = this, stopPropagation = false, event = {
                    name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  }, listenerArgs = concat([event], arguments, 1), i, length;
                  do {
                    namedListeners = scope.$$listeners[name] || empty3;
                    event.currentScope = scope;
                    for (i = 0, length = namedListeners.length; i < length; i++) {
                      if (!namedListeners[i]) {
                        namedListeners.splice(i, 1);
                        i--;
                        length--;
                        continue;
                      }
                      try {
                        namedListeners[i].apply(null, listenerArgs);
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                    if (stopPropagation) {
                      break;
                    }
                    scope = scope.$parent;
                  } while (scope);
                  event.currentScope = null;
                  return event;
                },
                $broadcast: function(name, args) {
                  var target = this, current = target, next = target, event = {
                    name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
                  if (!target.$$listenerCount[name])
                    return event;
                  var listenerArgs = concat([event], arguments, 1), listeners, i, length;
                  while (current = next) {
                    event.currentScope = current;
                    listeners = current.$$listeners[name] || [];
                    for (i = 0, length = listeners.length; i < length; i++) {
                      if (!listeners[i]) {
                        listeners.splice(i, 1);
                        i--;
                        length--;
                        continue;
                      }
                      try {
                        listeners[i].apply(null, listenerArgs);
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                    if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                      while (current !== target && !(next = current.$$nextSibling)) {
                        current = current.$parent;
                      }
                    }
                  }
                  event.currentScope = null;
                  return event;
                }
              };
              var $rootScope = new Scope();
              var asyncQueue = $rootScope.$$asyncQueue = [];
              var postDigestQueue = $rootScope.$$postDigestQueue = [];
              var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
              var postDigestQueuePosition = 0;
              return $rootScope;
              function beginPhase(phase) {
                if ($rootScope.$$phase) {
                  throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
              }
              function clearPhase() {
                $rootScope.$$phase = null;
              }
              function incrementWatchersCount(current, count) {
                do {
                  current.$$watchersCount += count;
                } while (current = current.$parent);
              }
              function decrementListenerCount(current, count, name) {
                do {
                  current.$$listenerCount[name] -= count;
                  if (current.$$listenerCount[name] === 0) {
                    delete current.$$listenerCount[name];
                  }
                } while (current = current.$parent);
              }
              function initWatchVal() {
              }
              function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                  try {
                    applyAsyncQueue.shift()();
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                applyAsyncId = null;
              }
              function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                  applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                  }, null, "$applyAsync");
                }
              }
            }
          ];
        }
        function $$SanitizeUriProvider() {
          var aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationTrustedUrlList = /^\s*((https?|ftp|file|blob):|data:image\/)/;
          this.aHrefSanitizationTrustedUrlList = function(regexp) {
            if (isDefined(regexp)) {
              aHrefSanitizationTrustedUrlList = regexp;
              return this;
            }
            return aHrefSanitizationTrustedUrlList;
          };
          this.imgSrcSanitizationTrustedUrlList = function(regexp) {
            if (isDefined(regexp)) {
              imgSrcSanitizationTrustedUrlList = regexp;
              return this;
            }
            return imgSrcSanitizationTrustedUrlList;
          };
          this.$get = function() {
            return function sanitizeUri(uri, isMediaUrl) {
              var regex = isMediaUrl ? imgSrcSanitizationTrustedUrlList : aHrefSanitizationTrustedUrlList;
              var normalizedVal = urlResolve(uri && uri.trim()).href;
              if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                return "unsafe:" + normalizedVal;
              }
              return uri;
            };
          };
        }
        var $sceMinErr = minErr("$sce");
        var SCE_CONTEXTS = {
          HTML: "html",
          CSS: "css",
          MEDIA_URL: "mediaUrl",
          URL: "url",
          RESOURCE_URL: "resourceUrl",
          JS: "js"
        };
        var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
        function snakeToCamel(name) {
          return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
        }
        function adjustMatcher(matcher) {
          if (matcher === "self") {
            return matcher;
          } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
              throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
          } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
          } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
          }
        }
        function adjustMatchers(matchers) {
          var adjustedMatchers = [];
          if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
              adjustedMatchers.push(adjustMatcher(matcher));
            });
          }
          return adjustedMatchers;
        }
        function $SceDelegateProvider() {
          this.SCE_CONTEXTS = SCE_CONTEXTS;
          var trustedResourceUrlList = ["self"], bannedResourceUrlList = [];
          this.trustedResourceUrlList = function(value) {
            if (arguments.length) {
              trustedResourceUrlList = adjustMatchers(value);
            }
            return trustedResourceUrlList;
          };
          Object.defineProperty(this, "resourceUrlWhitelist", {
            get: function() {
              return this.trustedResourceUrlList;
            },
            set: function(value) {
              this.trustedResourceUrlList = value;
            }
          });
          this.bannedResourceUrlList = function(value) {
            if (arguments.length) {
              bannedResourceUrlList = adjustMatchers(value);
            }
            return bannedResourceUrlList;
          };
          Object.defineProperty(this, "resourceUrlBlacklist", {
            get: function() {
              return this.bannedResourceUrlList;
            },
            set: function(value) {
              this.bannedResourceUrlList = value;
            }
          });
          this.$get = ["$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
            var htmlSanitizer = function htmlSanitizer2(html) {
              throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
              htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
              if (matcher === "self") {
                return urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl);
              } else {
                return !!matcher.exec(parsedUrl.href);
              }
            }
            function isResourceUrlAllowedByPolicy(url) {
              var parsedUrl = urlResolve(url.toString());
              var i, n, allowed = false;
              for (i = 0, n = trustedResourceUrlList.length; i < n; i++) {
                if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                  allowed = true;
                  break;
                }
              }
              if (allowed) {
                for (i = 0, n = bannedResourceUrlList.length; i < n; i++) {
                  if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                    allowed = false;
                    break;
                  }
                }
              }
              return allowed;
            }
            function generateHolderType(Base) {
              var holderType = function TrustedValueHolderType(trustedValue) {
                this.$$unwrapTrustedValue = function() {
                  return trustedValue;
                };
              };
              if (Base) {
                holderType.prototype = new Base();
              }
              holderType.prototype.valueOf = function sceValueOf() {
                return this.$$unwrapTrustedValue();
              };
              holderType.prototype.toString = function sceToString() {
                return this.$$unwrapTrustedValue().toString();
              };
              return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
              var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
              if (!Constructor) {
                throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
              }
              if (trustedValue === null || isUndefined(trustedValue) || trustedValue === "") {
                return trustedValue;
              }
              if (typeof trustedValue !== "string") {
                throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
              }
              return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
              if (maybeTrusted instanceof trustedValueHolderBase) {
                return maybeTrusted.$$unwrapTrustedValue();
              } else {
                return maybeTrusted;
              }
            }
            function getTrusted(type, maybeTrusted) {
              if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === "") {
                return maybeTrusted;
              }
              var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
              if (constructor && maybeTrusted instanceof constructor) {
                return maybeTrusted.$$unwrapTrustedValue();
              }
              if (isFunction2(maybeTrusted.$$unwrapTrustedValue)) {
                maybeTrusted = maybeTrusted.$$unwrapTrustedValue();
              }
              if (type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) {
                return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
              } else if (type === SCE_CONTEXTS.RESOURCE_URL) {
                if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                  return maybeTrusted;
                } else {
                  throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
              } else if (type === SCE_CONTEXTS.HTML) {
                return htmlSanitizer(maybeTrusted);
              }
              throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
              trustAs,
              getTrusted,
              valueOf
            };
          }];
        }
        function $SceProvider() {
          var enabled = true;
          this.enabled = function(value) {
            if (arguments.length) {
              enabled = !!value;
            }
            return enabled;
          };
          this.$get = ["$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
              throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
              return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
              sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
              };
              sce.valueOf = identity2;
            }
            sce.parseAs = function sceParseAs(type, expr) {
              var parsed = $parse(expr);
              if (parsed.literal && parsed.constant) {
                return parsed;
              } else {
                return $parse(expr, function(value) {
                  return sce.getTrusted(type, value);
                });
              }
            };
            var parse3 = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
              var lName = lowercase(name);
              sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                return parse3(enumValue, expr);
              };
              sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                return getTrusted(enumValue, value);
              };
              sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                return trustAs(enumValue, value);
              };
            });
            return sce;
          }];
        }
        function $SnifferProvider() {
          this.$get = ["$window", "$document", function($window, $document) {
            var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document2 = $document[0] || {}, bodyStyle = document2.body && document2.body.style, transitions = false, animations = false;
            if (bodyStyle) {
              transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle);
              animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle);
            }
            return {
              history: !!(hasHistoryPushState && !(android < 4) && !boxee),
              hasEvent: function(event) {
                if (event === "input" && msie)
                  return false;
                if (isUndefined(eventSupport[event])) {
                  var divElm = document2.createElement("div");
                  eventSupport[event] = "on" + event in divElm;
                }
                return eventSupport[event];
              },
              csp: csp(),
              transitions,
              animations,
              android
            };
          }];
        }
        function $$TaskTrackerFactoryProvider() {
          this.$get = valueFn(function(log) {
            return new TaskTracker(log);
          });
        }
        function TaskTracker(log) {
          var self2 = this;
          var taskCounts = {};
          var taskCallbacks = [];
          var ALL_TASKS_TYPE = self2.ALL_TASKS_TYPE = "$$all$$";
          var DEFAULT_TASK_TYPE = self2.DEFAULT_TASK_TYPE = "$$default$$";
          self2.completeTask = completeTask;
          self2.incTaskCount = incTaskCount;
          self2.notifyWhenNoPendingTasks = notifyWhenNoPendingTasks;
          function completeTask(fn2, taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            try {
              fn2();
            } finally {
              decTaskCount(taskType);
              var countForType = taskCounts[taskType];
              var countForAll = taskCounts[ALL_TASKS_TYPE];
              if (!countForAll || !countForType) {
                var getNextCallback = !countForAll ? getLastCallback : getLastCallbackForType;
                var nextCb;
                while (nextCb = getNextCallback(taskType)) {
                  try {
                    nextCb();
                  } catch (e) {
                    log.error(e);
                  }
                }
              }
            }
          }
          function decTaskCount(taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            if (taskCounts[taskType]) {
              taskCounts[taskType]--;
              taskCounts[ALL_TASKS_TYPE]--;
            }
          }
          function getLastCallback() {
            var cbInfo = taskCallbacks.pop();
            return cbInfo && cbInfo.cb;
          }
          function getLastCallbackForType(taskType) {
            for (var i = taskCallbacks.length - 1; i >= 0; --i) {
              var cbInfo = taskCallbacks[i];
              if (cbInfo.type === taskType) {
                taskCallbacks.splice(i, 1);
                return cbInfo.cb;
              }
            }
          }
          function incTaskCount(taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            taskCounts[taskType] = (taskCounts[taskType] || 0) + 1;
            taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1;
          }
          function notifyWhenNoPendingTasks(callback, taskType) {
            taskType = taskType || ALL_TASKS_TYPE;
            if (!taskCounts[taskType]) {
              callback();
            } else {
              taskCallbacks.push({ type: taskType, cb: callback });
            }
          }
        }
        var $templateRequestMinErr = minErr("$templateRequest");
        function $TemplateRequestProvider() {
          var httpOptions;
          this.httpOptions = function(val) {
            if (val) {
              httpOptions = val;
              return this;
            }
            return httpOptions;
          };
          this.$get = [
            "$exceptionHandler",
            "$templateCache",
            "$http",
            "$q",
            "$sce",
            function($exceptionHandler, $templateCache, $http, $q, $sce) {
              function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                  tpl = $sce.getTrustedResourceUrl(tpl);
                }
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray2(transformResponse)) {
                  transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                  });
                } else if (transformResponse === defaultHttpResponseTransform) {
                  transformResponse = null;
                }
                return $http.get(tpl, extend({
                  cache: $templateCache,
                  transformResponse
                }, httpOptions)).finally(function() {
                  handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                  return $templateCache.put(tpl, response.data);
                }, handleError2);
                function handleError2(resp) {
                  if (!ignoreRequestError) {
                    resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                    $exceptionHandler(resp);
                  }
                  return $q.reject(resp);
                }
              }
              handleRequestFn.totalPendingRequests = 0;
              return handleRequestFn;
            }
          ];
        }
        function $$TestabilityProvider() {
          this.$get = [
            "$rootScope",
            "$browser",
            "$location",
            function($rootScope, $browser, $location) {
              var testability = {};
              testability.findBindings = function(element2, expression, opt_exactMatch) {
                var bindings = element2.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                  var dataBinding = angular3.element(binding).data("$binding");
                  if (dataBinding) {
                    forEach(dataBinding, function(bindingName) {
                      if (opt_exactMatch) {
                        var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                        if (matcher.test(bindingName)) {
                          matches.push(binding);
                        }
                      } else {
                        if (bindingName.indexOf(expression) !== -1) {
                          matches.push(binding);
                        }
                      }
                    });
                  }
                });
                return matches;
              };
              testability.findModels = function(element2, expression, opt_exactMatch) {
                var prefixes = ["ng-", "data-ng-", "ng\\:"];
                for (var p = 0; p < prefixes.length; ++p) {
                  var attributeEquals = opt_exactMatch ? "=" : "*=";
                  var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                  var elements = element2.querySelectorAll(selector);
                  if (elements.length) {
                    return elements;
                  }
                }
              };
              testability.getLocation = function() {
                return $location.url();
              };
              testability.setLocation = function(url) {
                if (url !== $location.url()) {
                  $location.url(url);
                  $rootScope.$digest();
                }
              };
              testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
              };
              return testability;
            }
          ];
        }
        var $timeoutMinErr = minErr("$timeout");
        function $TimeoutProvider() {
          this.$get = [
            "$rootScope",
            "$browser",
            "$q",
            "$$q",
            "$exceptionHandler",
            function($rootScope, $browser, $q, $$q, $exceptionHandler) {
              var deferreds = {};
              function timeout(fn2, delay2, invokeApply) {
                if (!isFunction2(fn2)) {
                  invokeApply = delay2;
                  delay2 = fn2;
                  fn2 = noop3;
                }
                var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise2 = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                  try {
                    deferred.resolve(fn2.apply(null, args));
                  } catch (e) {
                    deferred.reject(e);
                    $exceptionHandler(e);
                  } finally {
                    delete deferreds[promise2.$$timeoutId];
                  }
                  if (!skipApply)
                    $rootScope.$apply();
                }, delay2, "$timeout");
                promise2.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise2;
              }
              timeout.cancel = function(promise2) {
                if (!promise2)
                  return false;
                if (!promise2.hasOwnProperty("$$timeoutId")) {
                  throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                }
                if (!deferreds.hasOwnProperty(promise2.$$timeoutId))
                  return false;
                var id = promise2.$$timeoutId;
                var deferred = deferreds[id];
                markQExceptionHandled(deferred.promise);
                deferred.reject("canceled");
                delete deferreds[id];
                return $browser.defer.cancel(id);
              };
              return timeout;
            }
          ];
        }
        var urlParsingNode = window2.document.createElement("a");
        var originUrl = urlResolve(window2.location.href);
        var baseUrlParsingNode;
        urlParsingNode.href = "http://[::1]";
        var ipv6InBrackets = urlParsingNode.hostname === "[::1]";
        function urlResolve(url) {
          if (!isString(url))
            return url;
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          var hostname = urlParsingNode.hostname;
          if (!ipv6InBrackets && hostname.indexOf(":") > -1) {
            hostname = "[" + hostname + "]";
          }
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        function urlIsSameOrigin(requestUrl) {
          return urlsAreSameOrigin(requestUrl, originUrl);
        }
        function urlIsSameOriginAsBaseUrl(requestUrl) {
          return urlsAreSameOrigin(requestUrl, getBaseUrl());
        }
        function urlIsAllowedOriginFactory(trustedOriginUrls) {
          var parsedAllowedOriginUrls = [originUrl].concat(trustedOriginUrls.map(urlResolve));
          return function urlIsAllowedOrigin(requestUrl) {
            var parsedUrl = urlResolve(requestUrl);
            return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl));
          };
        }
        function urlsAreSameOrigin(url1, url2) {
          url1 = urlResolve(url1);
          url2 = urlResolve(url2);
          return url1.protocol === url2.protocol && url1.host === url2.host;
        }
        function getBaseUrl() {
          if (window2.document.baseURI) {
            return window2.document.baseURI;
          }
          if (!baseUrlParsingNode) {
            baseUrlParsingNode = window2.document.createElement("a");
            baseUrlParsingNode.href = ".";
            baseUrlParsingNode = baseUrlParsingNode.cloneNode(false);
          }
          return baseUrlParsingNode.href;
        }
        function $WindowProvider() {
          this.$get = valueFn(window2);
        }
        function $$CookieReader($document) {
          var rawDocument = $document[0] || {};
          var lastCookies = {};
          var lastCookieString = "";
          function safeGetCookie(rawDocument2) {
            try {
              return rawDocument2.cookie || "";
            } catch (e) {
              return "";
            }
          }
          function safeDecodeURIComponent(str) {
            try {
              return decodeURIComponent(str);
            } catch (e) {
              return str;
            }
          }
          return function() {
            var cookieArray, cookie, i, index, name;
            var currentCookieString = safeGetCookie(rawDocument);
            if (currentCookieString !== lastCookieString) {
              lastCookieString = currentCookieString;
              cookieArray = lastCookieString.split("; ");
              lastCookies = {};
              for (i = 0; i < cookieArray.length; i++) {
                cookie = cookieArray[i];
                index = cookie.indexOf("=");
                if (index > 0) {
                  name = safeDecodeURIComponent(cookie.substring(0, index));
                  if (isUndefined(lastCookies[name])) {
                    lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                  }
                }
              }
            }
            return lastCookies;
          };
        }
        $$CookieReader.$inject = ["$document"];
        function $$CookieReaderProvider() {
          this.$get = $$CookieReader;
        }
        $FilterProvider.$inject = ["$provide"];
        function $FilterProvider($provide) {
          var suffix = "Filter";
          function register(name, factory) {
            if (isObject2(name)) {
              var filters = {};
              forEach(name, function(filter2, key2) {
                filters[key2] = register(key2, filter2);
              });
              return filters;
            } else {
              return $provide.factory(name + suffix, factory);
            }
          }
          this.register = register;
          this.$get = ["$injector", function($injector) {
            return function(name) {
              return $injector.get(name + suffix);
            };
          }];
          register("currency", currencyFilter);
          register("date", dateFilter);
          register("filter", filterFilter);
          register("json", jsonFilter);
          register("limitTo", limitToFilter);
          register("lowercase", lowercaseFilter);
          register("number", numberFilter);
          register("orderBy", orderByFilter);
          register("uppercase", uppercaseFilter);
        }
        function filterFilter() {
          return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike2(array)) {
              if (array == null) {
                return array;
              } else {
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
              }
            }
            anyPropertyKey = anyPropertyKey || "$";
            var expressionType2 = getTypeForFilter(expression);
            var predicateFn;
            var matchAgainstAnyProp;
            switch (expressionType2) {
              case "function":
                predicateFn = expression;
                break;
              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = true;
              case "object":
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;
              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
          };
        }
        function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
          var shouldMatchPrimitives = isObject2(expression) && anyPropertyKey in expression;
          var predicateFn;
          if (comparator === true) {
            comparator = equals;
          } else if (!isFunction2(comparator)) {
            comparator = function(actual, expected) {
              if (isUndefined(actual)) {
                return false;
              }
              if (actual === null || expected === null) {
                return actual === expected;
              }
              if (isObject2(expected) || isObject2(actual) && !hasCustomToString(actual)) {
                return false;
              }
              actual = lowercase("" + actual);
              expected = lowercase("" + expected);
              return actual.indexOf(expected) !== -1;
            };
          }
          predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject2(item)) {
              return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
            }
            return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
          };
          return predicateFn;
        }
        function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
          var actualType = getTypeForFilter(actual);
          var expectedType = getTypeForFilter(expected);
          if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
          } else if (isArray2(actual)) {
            return actual.some(function(item) {
              return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
            });
          }
          switch (actualType) {
            case "object":
              var key2;
              if (matchAgainstAnyProp) {
                for (key2 in actual) {
                  if (key2.charAt && key2.charAt(0) !== "$" && deepCompare(actual[key2], expected, comparator, anyPropertyKey, true)) {
                    return true;
                  }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
              } else if (expectedType === "object") {
                for (key2 in expected) {
                  var expectedVal = expected[key2];
                  if (isFunction2(expectedVal) || isUndefined(expectedVal)) {
                    continue;
                  }
                  var matchAnyProperty = key2 === anyPropertyKey;
                  var actualVal = matchAnyProperty ? actual : actual[key2];
                  if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                    return false;
                  }
                }
                return true;
              } else {
                return comparator(actual, expected);
              }
            case "function":
              return false;
            default:
              return comparator(actual, expected);
          }
        }
        function getTypeForFilter(val) {
          return val === null ? "null" : typeof val;
        }
        var MAX_DIGITS = 22;
        var DECIMAL_SEP = ".";
        var ZERO_CHAR = "0";
        currencyFilter.$inject = ["$locale"];
        function currencyFilter($locale) {
          var formats = $locale.NUMBER_FORMATS;
          return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
              currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
              fractionSize = formats.PATTERNS[1].maxFrac;
            }
            var currencySymbolRe = !currencySymbol ? /\s*\u00A4\s*/g : /\u00A4/g;
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);
          };
        }
        numberFilter.$inject = ["$locale"];
        function numberFilter($locale) {
          var formats = $locale.NUMBER_FORMATS;
          return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
          };
        }
        function parse2(numStr) {
          var exponent = 0, digits, numberOfIntegerDigits;
          var i, j, zeros;
          if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
            numStr = numStr.replace(DECIMAL_SEP, "");
          }
          if ((i = numStr.search(/e/i)) > 0) {
            if (numberOfIntegerDigits < 0)
              numberOfIntegerDigits = i;
            numberOfIntegerDigits += +numStr.slice(i + 1);
            numStr = numStr.substring(0, i);
          } else if (numberOfIntegerDigits < 0) {
            numberOfIntegerDigits = numStr.length;
          }
          for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
          }
          if (i === (zeros = numStr.length)) {
            digits = [0];
            numberOfIntegerDigits = 1;
          } else {
            zeros--;
            while (numStr.charAt(zeros) === ZERO_CHAR)
              zeros--;
            numberOfIntegerDigits -= i;
            digits = [];
            for (j = 0; i <= zeros; i++, j++) {
              digits[j] = +numStr.charAt(i);
            }
          }
          if (numberOfIntegerDigits > MAX_DIGITS) {
            digits = digits.splice(0, MAX_DIGITS - 1);
            exponent = numberOfIntegerDigits - 1;
            numberOfIntegerDigits = 1;
          }
          return { d: digits, e: exponent, i: numberOfIntegerDigits };
        }
        function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
          var digits = parsedNumber.d;
          var fractionLen = digits.length - parsedNumber.i;
          fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
          var roundAt = fractionSize + parsedNumber.i;
          var digit = digits[roundAt];
          if (roundAt > 0) {
            digits.splice(Math.max(parsedNumber.i, roundAt));
            for (var j = roundAt; j < digits.length; j++) {
              digits[j] = 0;
            }
          } else {
            fractionLen = Math.max(0, fractionLen);
            parsedNumber.i = 1;
            digits.length = Math.max(1, roundAt = fractionSize + 1);
            digits[0] = 0;
            for (var i = 1; i < roundAt; i++)
              digits[i] = 0;
          }
          if (digit >= 5) {
            if (roundAt - 1 < 0) {
              for (var k = 0; k > roundAt; k--) {
                digits.unshift(0);
                parsedNumber.i++;
              }
              digits.unshift(1);
              parsedNumber.i++;
            } else {
              digits[roundAt - 1]++;
            }
          }
          for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
            digits.push(0);
          var carry = digits.reduceRight(function(carry2, d, i2, digits2) {
            d = d + carry2;
            digits2[i2] = d % 10;
            return Math.floor(d / 10);
          }, 0);
          if (carry) {
            digits.unshift(carry);
            parsedNumber.i++;
          }
        }
        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
          if (!(isString(number) || isNumber(number)) || isNaN(number))
            return "";
          var isInfinity = !isFinite(number);
          var isZero = false;
          var numStr = Math.abs(number) + "", formattedText = "", parsedNumber;
          if (isInfinity) {
            formattedText = "\u221E";
          } else {
            parsedNumber = parse2(numStr);
            roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
            var digits = parsedNumber.d;
            var integerLen = parsedNumber.i;
            var exponent = parsedNumber.e;
            var decimals = [];
            isZero = digits.reduce(function(isZero2, d) {
              return isZero2 && !d;
            }, true);
            while (integerLen < 0) {
              digits.unshift(0);
              integerLen++;
            }
            if (integerLen > 0) {
              decimals = digits.splice(integerLen, digits.length);
            } else {
              decimals = digits;
              digits = [0];
            }
            var groups = [];
            if (digits.length >= pattern.lgSize) {
              groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
            }
            while (digits.length > pattern.gSize) {
              groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            }
            if (digits.length) {
              groups.unshift(digits.join(""));
            }
            formattedText = groups.join(groupSep);
            if (decimals.length) {
              formattedText += decimalSep + decimals.join("");
            }
            if (exponent) {
              formattedText += "e+" + exponent;
            }
          }
          if (number < 0 && !isZero) {
            return pattern.negPre + formattedText + pattern.negSuf;
          } else {
            return pattern.posPre + formattedText + pattern.posSuf;
          }
        }
        function padNumber(num, digits, trim2, negWrap) {
          var neg = "";
          if (num < 0 || negWrap && num <= 0) {
            if (negWrap) {
              num = -num + 1;
            } else {
              num = -num;
              neg = "-";
            }
          }
          num = "" + num;
          while (num.length < digits)
            num = ZERO_CHAR + num;
          if (trim2) {
            num = num.substr(num.length - digits);
          }
          return neg + num;
        }
        function dateGetter(name, size, offset, trim2, negWrap) {
          offset = offset || 0;
          return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) {
              value += offset;
            }
            if (value === 0 && offset === -12)
              value = 12;
            return padNumber(value, size, trim2, negWrap);
          };
        }
        function dateStrGetter(name, shortForm, standAlone) {
          return function(date, formats) {
            var value = date["get" + name]();
            var propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "");
            var get = uppercase(propPrefix + name);
            return formats[get][value];
          };
        }
        function timeZoneGetter(date, formats, offset) {
          var zone = -1 * offset;
          var paddedZone = zone >= 0 ? "+" : "";
          paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
          return paddedZone;
        }
        function getFirstThursdayOfYear(year) {
          var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
          return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
        }
        function getThursdayThisWeek(datetime) {
          return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
        }
        function weekGetter(size) {
          return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
          };
        }
        function ampmGetter(date, formats) {
          return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
        }
        function eraGetter(date, formats) {
          return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
        }
        function longEraGetter(date, formats) {
          return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
        }
        var DATE_FORMATS = {
          yyyy: dateGetter("FullYear", 4, 0, false, true),
          yy: dateGetter("FullYear", 2, 0, true, true),
          y: dateGetter("FullYear", 1, 0, false, true),
          MMMM: dateStrGetter("Month"),
          MMM: dateStrGetter("Month", true),
          MM: dateGetter("Month", 2, 1),
          M: dateGetter("Month", 1, 1),
          LLLL: dateStrGetter("Month", false, true),
          dd: dateGetter("Date", 2),
          d: dateGetter("Date", 1),
          HH: dateGetter("Hours", 2),
          H: dateGetter("Hours", 1),
          hh: dateGetter("Hours", 2, -12),
          h: dateGetter("Hours", 1, -12),
          mm: dateGetter("Minutes", 2),
          m: dateGetter("Minutes", 1),
          ss: dateGetter("Seconds", 2),
          s: dateGetter("Seconds", 1),
          sss: dateGetter("Milliseconds", 3),
          EEEE: dateStrGetter("Day"),
          EEE: dateStrGetter("Day", true),
          a: ampmGetter,
          Z: timeZoneGetter,
          ww: weekGetter(2),
          w: weekGetter(1),
          G: eraGetter,
          GG: eraGetter,
          GGG: eraGetter,
          GGGG: longEraGetter
        };
        var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
        dateFilter.$inject = ["$locale"];
        function dateFilter($locale) {
          var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
          function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
              var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
              if (match[9]) {
                tzHour = toInt(match[9] + match[10]);
                tzMin = toInt(match[9] + match[11]);
              }
              dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
              var h = toInt(match[4] || 0) - tzHour;
              var m = toInt(match[5] || 0) - tzMin;
              var s = toInt(match[6] || 0);
              var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
              timeSetter.call(date, h, m, s, ms);
              return date;
            }
            return string;
          }
          return function(date, format, timezone) {
            var text = "", parts = [], fn2, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
              date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
              date = new Date(date);
            }
            if (!isDate2(date) || !isFinite(date.getTime())) {
              return date;
            }
            while (format) {
              match = DATE_FORMATS_SPLIT.exec(format);
              if (match) {
                parts = concat(parts, match, 1);
                format = parts.pop();
              } else {
                parts.push(format);
                format = null;
              }
            }
            var dateTimezoneOffset = date.getTimezoneOffset();
            if (timezone) {
              dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
              date = convertTimezoneToLocal(date, timezone, true);
            }
            forEach(parts, function(value) {
              fn2 = DATE_FORMATS[value];
              text += fn2 ? fn2(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
          };
        }
        function jsonFilter() {
          return function(object, spacing) {
            if (isUndefined(spacing)) {
              spacing = 2;
            }
            return toJson(object, spacing);
          };
        }
        var lowercaseFilter = valueFn(lowercase);
        var uppercaseFilter = valueFn(uppercase);
        function limitToFilter() {
          return function(input, limit, begin) {
            if (Math.abs(Number(limit)) === Infinity) {
              limit = Number(limit);
            } else {
              limit = toInt(limit);
            }
            if (isNumberNaN(limit))
              return input;
            if (isNumber(input))
              input = input.toString();
            if (!isArrayLike2(input))
              return input;
            begin = !begin || isNaN(begin) ? 0 : toInt(begin);
            begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
            if (limit >= 0) {
              return sliceFn(input, begin, begin + limit);
            } else {
              if (begin === 0) {
                return sliceFn(input, limit, input.length);
              } else {
                return sliceFn(input, Math.max(0, begin + limit), begin);
              }
            }
          };
        }
        function sliceFn(input, begin, end) {
          if (isString(input))
            return input.slice(begin, end);
          return slice.call(input, begin, end);
        }
        orderByFilter.$inject = ["$parse"];
        function orderByFilter($parse) {
          return function(array, sortPredicate, reverseOrder, compareFn) {
            if (array == null)
              return array;
            if (!isArrayLike2(array)) {
              throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            }
            if (!isArray2(sortPredicate)) {
              sortPredicate = [sortPredicate];
            }
            if (sortPredicate.length === 0) {
              sortPredicate = ["+"];
            }
            var predicates = processPredicates(sortPredicate);
            var descending = reverseOrder ? -1 : 1;
            var compare = isFunction2(compareFn) ? compareFn : defaultCompare;
            var compareValues = Array.prototype.map.call(array, getComparisonObject);
            compareValues.sort(doComparison);
            array = compareValues.map(function(item) {
              return item.value;
            });
            return array;
            function getComparisonObject(value, index) {
              return {
                value,
                tieBreaker: { value: index, type: "number", index },
                predicateValues: predicates.map(function(predicate) {
                  return getPredicateValue(predicate.get(value), index);
                })
              };
            }
            function doComparison(v1, v2) {
              for (var i = 0, ii = predicates.length; i < ii; i++) {
                var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                if (result) {
                  return result * predicates[i].descending * descending;
                }
              }
              return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
            }
          };
          function processPredicates(sortPredicates) {
            return sortPredicates.map(function(predicate) {
              var descending = 1, get = identity2;
              if (isFunction2(predicate)) {
                get = predicate;
              } else if (isString(predicate)) {
                if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
                  descending = predicate.charAt(0) === "-" ? -1 : 1;
                  predicate = predicate.substring(1);
                }
                if (predicate !== "") {
                  get = $parse(predicate);
                  if (get.constant) {
                    var key2 = get();
                    get = function(value) {
                      return value[key2];
                    };
                  }
                }
              }
              return { get, descending };
            });
          }
          function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return true;
              default:
                return false;
            }
          }
          function objectValue(value) {
            if (isFunction2(value.valueOf)) {
              value = value.valueOf();
              if (isPrimitive(value))
                return value;
            }
            if (hasCustomToString(value)) {
              value = value.toString();
              if (isPrimitive(value))
                return value;
            }
            return value;
          }
          function getPredicateValue(value, index) {
            var type = typeof value;
            if (value === null) {
              type = "null";
            } else if (type === "object") {
              value = objectValue(value);
            }
            return { value, type, index };
          }
          function defaultCompare(v1, v2) {
            var result = 0;
            var type1 = v1.type;
            var type2 = v2.type;
            if (type1 === type2) {
              var value1 = v1.value;
              var value2 = v2.value;
              if (type1 === "string") {
                value1 = value1.toLowerCase();
                value2 = value2.toLowerCase();
              } else if (type1 === "object") {
                if (isObject2(value1))
                  value1 = v1.index;
                if (isObject2(value2))
                  value2 = v2.index;
              }
              if (value1 !== value2) {
                result = value1 < value2 ? -1 : 1;
              }
            } else {
              result = type1 === "undefined" ? 1 : type2 === "undefined" ? -1 : type1 === "null" ? 1 : type2 === "null" ? -1 : type1 < type2 ? -1 : 1;
            }
            return result;
          }
        }
        function ngDirective(directive) {
          if (isFunction2(directive)) {
            directive = {
              link: directive
            };
          }
          directive.restrict = directive.restrict || "AC";
          return valueFn(directive);
        }
        var htmlAnchorDirective = valueFn({
          restrict: "E",
          compile: function(element2, attr) {
            if (!attr.href && !attr.xlinkHref) {
              return function(scope, element3) {
                if (element3[0].nodeName.toLowerCase() !== "a")
                  return;
                var href = toString.call(element3.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                element3.on("click", function(event) {
                  if (!element3.attr(href)) {
                    event.preventDefault();
                  }
                });
              };
            }
          }
        });
        var ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function(propName, attrName) {
          if (propName === "multiple")
            return;
          function defaultLinkFn(scope, element2, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
              attr.$set(attrName, !!value);
            });
          }
          var normalized = directiveNormalize("ng-" + attrName);
          var linkFn = defaultLinkFn;
          if (propName === "checked") {
            linkFn = function(scope, element2, attr) {
              if (attr.ngModel !== attr[normalized]) {
                defaultLinkFn(scope, element2, attr);
              }
            };
          }
          ngAttributeAliasDirectives[normalized] = function() {
            return {
              restrict: "A",
              priority: 100,
              link: linkFn
            };
          };
        });
        forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
          ngAttributeAliasDirectives[ngAttr] = function() {
            return {
              priority: 100,
              link: function(scope, element2, attr) {
                if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
                  var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                  if (match) {
                    attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    return;
                  }
                }
                scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                  attr.$set(ngAttr, value);
                });
              }
            };
          };
        });
        forEach(["src", "srcset", "href"], function(attrName) {
          var normalized = directiveNormalize("ng-" + attrName);
          ngAttributeAliasDirectives[normalized] = ["$sce", function($sce) {
            return {
              priority: 99,
              link: function(scope, element2, attr) {
                var propName = attrName, name = attrName;
                if (attrName === "href" && toString.call(element2.prop("href")) === "[object SVGAnimatedString]") {
                  name = "xlinkHref";
                  attr.$attr[name] = "xlink:href";
                  propName = null;
                }
                attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized]));
                attr.$observe(normalized, function(value) {
                  if (!value) {
                    if (attrName === "href") {
                      attr.$set(name, null);
                    }
                    return;
                  }
                  attr.$set(name, value);
                  if (msie && propName)
                    element2.prop(propName, attr[name]);
                });
              }
            };
          }];
        });
        var nullFormCtrl = {
          $addControl: noop3,
          $getControls: valueFn([]),
          $$renameControl: nullFormRenameControl,
          $removeControl: noop3,
          $setValidity: noop3,
          $setDirty: noop3,
          $setPristine: noop3,
          $setSubmitted: noop3,
          $$setSubmitted: noop3
        }, PENDING_CLASS = "ng-pending", SUBMITTED_CLASS = "ng-submitted";
        function nullFormRenameControl(control, name) {
          control.$name = name;
        }
        FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];
        function FormController($element, $attrs, $scope, $animate, $interpolate) {
          this.$$controls = [];
          this.$error = {};
          this.$$success = {};
          this.$pending = void 0;
          this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope);
          this.$dirty = false;
          this.$pristine = true;
          this.$valid = true;
          this.$invalid = false;
          this.$submitted = false;
          this.$$parentForm = nullFormCtrl;
          this.$$element = $element;
          this.$$animate = $animate;
          setupValidity(this);
        }
        FormController.prototype = {
          $rollbackViewValue: function() {
            forEach(this.$$controls, function(control) {
              control.$rollbackViewValue();
            });
          },
          $commitViewValue: function() {
            forEach(this.$$controls, function(control) {
              control.$commitViewValue();
            });
          },
          $addControl: function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            this.$$controls.push(control);
            if (control.$name) {
              this[control.$name] = control;
            }
            control.$$parentForm = this;
          },
          $getControls: function() {
            return shallowCopy(this.$$controls);
          },
          $$renameControl: function(control, newName) {
            var oldName = control.$name;
            if (this[oldName] === control) {
              delete this[oldName];
            }
            this[newName] = control;
            control.$name = newName;
          },
          $removeControl: function(control) {
            if (control.$name && this[control.$name] === control) {
              delete this[control.$name];
            }
            forEach(this.$pending, function(value, name) {
              this.$setValidity(name, null, control);
            }, this);
            forEach(this.$error, function(value, name) {
              this.$setValidity(name, null, control);
            }, this);
            forEach(this.$$success, function(value, name) {
              this.$setValidity(name, null, control);
            }, this);
            arrayRemove(this.$$controls, control);
            control.$$parentForm = nullFormCtrl;
          },
          $setDirty: function() {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
            this.$$animate.addClass(this.$$element, DIRTY_CLASS);
            this.$dirty = true;
            this.$pristine = false;
            this.$$parentForm.$setDirty();
          },
          $setPristine: function() {
            this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            this.$dirty = false;
            this.$pristine = true;
            this.$submitted = false;
            forEach(this.$$controls, function(control) {
              control.$setPristine();
            });
          },
          $setUntouched: function() {
            forEach(this.$$controls, function(control) {
              control.$setUntouched();
            });
          },
          $setSubmitted: function() {
            var rootForm = this;
            while (rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl) {
              rootForm = rootForm.$$parentForm;
            }
            rootForm.$$setSubmitted();
          },
          $$setSubmitted: function() {
            this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
            this.$submitted = true;
            forEach(this.$$controls, function(control) {
              if (control.$$setSubmitted) {
                control.$$setSubmitted();
              }
            });
          }
        };
        addSetValidityMethod({
          clazz: FormController,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          }
        });
        var formDirectiveFactory = function(isNgForm) {
          return ["$timeout", "$parse", function($timeout, $parse) {
            var formDirective2 = {
              name: "form",
              restrict: isNgForm ? "EAC" : "E",
              require: ["form", "^^?form"],
              controller: FormController,
              compile: function ngFormCompile(formElement, attr) {
                formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                return {
                  pre: function ngFormPreLink(scope, formElement2, attr2, ctrls) {
                    var controller = ctrls[0];
                    if (!("action" in attr2)) {
                      var handleFormSubmission = function(event) {
                        scope.$apply(function() {
                          controller.$commitViewValue();
                          controller.$setSubmitted();
                        });
                        event.preventDefault();
                      };
                      formElement2[0].addEventListener("submit", handleFormSubmission);
                      formElement2.on("$destroy", function() {
                        $timeout(function() {
                          formElement2[0].removeEventListener("submit", handleFormSubmission);
                        }, 0, false);
                      });
                    }
                    var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                    parentFormCtrl.$addControl(controller);
                    var setter = nameAttr ? getSetter(controller.$name) : noop3;
                    if (nameAttr) {
                      setter(scope, controller);
                      attr2.$observe(nameAttr, function(newValue) {
                        if (controller.$name === newValue)
                          return;
                        setter(scope, void 0);
                        controller.$$parentForm.$$renameControl(controller, newValue);
                        setter = getSetter(controller.$name);
                        setter(scope, controller);
                      });
                    }
                    formElement2.on("$destroy", function() {
                      controller.$$parentForm.$removeControl(controller);
                      setter(scope, void 0);
                      extend(controller, nullFormCtrl);
                    });
                  }
                };
              }
            };
            return formDirective2;
            function getSetter(expression) {
              if (expression === "") {
                return $parse('this[""]').assign;
              }
              return $parse(expression).assign || noop3;
            }
          }];
        };
        var formDirective = formDirectiveFactory();
        var ngFormDirective = formDirectiveFactory(true);
        function setupValidity(instance) {
          instance.$$classCache = {};
          instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
        }
        function addSetValidityMethod(context) {
          var clazz = context.clazz, set = context.set, unset = context.unset;
          clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
            if (isUndefined(state)) {
              createAndSet(this, "$pending", validationErrorKey, controller);
            } else {
              unsetAndCleanup(this, "$pending", validationErrorKey, controller);
            }
            if (!isBoolean(state)) {
              unset(this.$error, validationErrorKey, controller);
              unset(this.$$success, validationErrorKey, controller);
            } else {
              if (state) {
                unset(this.$error, validationErrorKey, controller);
                set(this.$$success, validationErrorKey, controller);
              } else {
                set(this.$error, validationErrorKey, controller);
                unset(this.$$success, validationErrorKey, controller);
              }
            }
            if (this.$pending) {
              cachedToggleClass(this, PENDING_CLASS, true);
              this.$valid = this.$invalid = void 0;
              toggleValidationCss(this, "", null);
            } else {
              cachedToggleClass(this, PENDING_CLASS, false);
              this.$valid = isObjectEmpty(this.$error);
              this.$invalid = !this.$valid;
              toggleValidationCss(this, "", this.$valid);
            }
            var combinedState;
            if (this.$pending && this.$pending[validationErrorKey]) {
              combinedState = void 0;
            } else if (this.$error[validationErrorKey]) {
              combinedState = false;
            } else if (this.$$success[validationErrorKey]) {
              combinedState = true;
            } else {
              combinedState = null;
            }
            toggleValidationCss(this, validationErrorKey, combinedState);
            this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
          };
          function createAndSet(ctrl, name, value, controller) {
            if (!ctrl[name]) {
              ctrl[name] = {};
            }
            set(ctrl[name], value, controller);
          }
          function unsetAndCleanup(ctrl, name, value, controller) {
            if (ctrl[name]) {
              unset(ctrl[name], value, controller);
            }
            if (isObjectEmpty(ctrl[name])) {
              ctrl[name] = void 0;
            }
          }
          function cachedToggleClass(ctrl, className, switchValue) {
            if (switchValue && !ctrl.$$classCache[className]) {
              ctrl.$$animate.addClass(ctrl.$$element, className);
              ctrl.$$classCache[className] = true;
            } else if (!switchValue && ctrl.$$classCache[className]) {
              ctrl.$$animate.removeClass(ctrl.$$element, className);
              ctrl.$$classCache[className] = false;
            }
          }
          function toggleValidationCss(ctrl, validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);
          }
        }
        function isObjectEmpty(obj) {
          if (obj) {
            for (var prop in obj) {
              if (obj.hasOwnProperty(prop)) {
                return false;
              }
            }
          }
          return true;
        }
        var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
        var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
        var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
        var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
        var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
        var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
        var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
        var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
        var PARTIAL_VALIDATION_TYPES = createMap();
        forEach("date,datetime-local,month,time,week".split(","), function(type) {
          PARTIAL_VALIDATION_TYPES[type] = true;
        });
        var inputType = {
          "text": textInputType,
          "date": createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"),
          "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"),
          "time": createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"),
          "week": createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
          "month": createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"),
          "number": numberInputType,
          "url": urlInputType,
          "email": emailInputType,
          "radio": radioInputType,
          "range": rangeInputType,
          "checkbox": checkboxInputType,
          "hidden": noop3,
          "button": noop3,
          "submit": noop3,
          "reset": noop3,
          "file": noop3
        };
        function stringBasedInputType(ctrl) {
          ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
          });
        }
        function textInputType(scope, element2, attr, ctrl, $sniffer, $browser) {
          baseInputType(scope, element2, attr, ctrl, $sniffer, $browser);
          stringBasedInputType(ctrl);
        }
        function baseInputType(scope, element2, attr, ctrl, $sniffer, $browser) {
          var type = lowercase(element2[0].type);
          if (!$sniffer.android) {
            var composing = false;
            element2.on("compositionstart", function() {
              composing = true;
            });
            element2.on("compositionupdate", function(ev) {
              if (isUndefined(ev.data) || ev.data === "") {
                composing = false;
              }
            });
            element2.on("compositionend", function() {
              composing = false;
              listener();
            });
          }
          var timeout;
          var listener = function(ev) {
            if (timeout) {
              $browser.defer.cancel(timeout);
              timeout = null;
            }
            if (composing)
              return;
            var value = element2.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
              value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
              ctrl.$setViewValue(value, event);
            }
          };
          if ($sniffer.hasEvent("input")) {
            element2.on("input", listener);
          } else {
            var deferListener = function(ev, input, origValue) {
              if (!timeout) {
                timeout = $browser.defer(function() {
                  timeout = null;
                  if (!input || input.value !== origValue) {
                    listener(ev);
                  }
                });
              }
            };
            element2.on("keydown", function(event) {
              var key2 = event.keyCode;
              if (key2 === 91 || 15 < key2 && key2 < 19 || 37 <= key2 && key2 <= 40)
                return;
              deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
              element2.on("paste cut drop", deferListener);
            }
          }
          element2.on("change", listener);
          if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
            element2.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
              if (!timeout) {
                var validity = this[VALIDITY_STATE_PROPERTY];
                var origBadInput = validity.badInput;
                var origTypeMismatch = validity.typeMismatch;
                timeout = $browser.defer(function() {
                  timeout = null;
                  if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                    listener(ev);
                  }
                });
              }
            });
          }
          ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            if (element2.val() !== value) {
              element2.val(value);
            }
          };
        }
        function weekParser(isoWeek, existingDate) {
          if (isDate2(isoWeek)) {
            return isoWeek;
          }
          if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
              var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
              if (existingDate) {
                hours = existingDate.getHours();
                minutes = existingDate.getMinutes();
                seconds = existingDate.getSeconds();
                milliseconds = existingDate.getMilliseconds();
              }
              return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
          }
          return NaN;
        }
        function createDateParser(regexp, mapping) {
          return function(iso, previousDate) {
            var parts, map2;
            if (isDate2(iso)) {
              return iso;
            }
            if (isString(iso)) {
              if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
                iso = iso.substring(1, iso.length - 1);
              }
              if (ISO_DATE_REGEXP.test(iso)) {
                return new Date(iso);
              }
              regexp.lastIndex = 0;
              parts = regexp.exec(iso);
              if (parts) {
                parts.shift();
                if (previousDate) {
                  map2 = {
                    yyyy: previousDate.getFullYear(),
                    MM: previousDate.getMonth() + 1,
                    dd: previousDate.getDate(),
                    HH: previousDate.getHours(),
                    mm: previousDate.getMinutes(),
                    ss: previousDate.getSeconds(),
                    sss: previousDate.getMilliseconds() / 1e3
                  };
                } else {
                  map2 = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
                }
                forEach(parts, function(part, index) {
                  if (index < mapping.length) {
                    map2[mapping[index]] = +part;
                  }
                });
                var date = new Date(map2.yyyy, map2.MM - 1, map2.dd, map2.HH, map2.mm, map2.ss || 0, map2.sss * 1e3 || 0);
                if (map2.yyyy < 100) {
                  date.setFullYear(map2.yyyy);
                }
                return date;
              }
            }
            return NaN;
          };
        }
        function createDateInputType(type, regexp, parseDate, format) {
          return function dynamicDateInputType(scope, element2, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            badInputChecker(scope, element2, attr, ctrl, type);
            baseInputType(scope, element2, attr, ctrl, $sniffer, $browser);
            var isTimeType = type === "time" || type === "datetimelocal";
            var previousDate;
            var previousTimezone;
            ctrl.$parsers.push(function(value) {
              if (ctrl.$isEmpty(value))
                return null;
              if (regexp.test(value)) {
                return parseDateAndConvertTimeZoneToLocal(value, previousDate);
              }
              ctrl.$$parserName = type;
              return void 0;
            });
            ctrl.$formatters.push(function(value) {
              if (value && !isDate2(value)) {
                throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
              }
              if (isValidDate(value)) {
                previousDate = value;
                var timezone = ctrl.$options.getOption("timezone");
                if (timezone) {
                  previousTimezone = timezone;
                  previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                }
                return formatter(value, timezone);
              } else {
                previousDate = null;
                previousTimezone = null;
                return "";
              }
            });
            if (isDefined(attr.min) || attr.ngMin) {
              var minVal = attr.min || $parse(attr.ngMin)(scope);
              var parsedMinVal = parseObservedDateValue(minVal);
              ctrl.$validators.min = function(value) {
                return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal;
              };
              attr.$observe("min", function(val) {
                if (val !== minVal) {
                  parsedMinVal = parseObservedDateValue(val);
                  minVal = val;
                  ctrl.$validate();
                }
              });
            }
            if (isDefined(attr.max) || attr.ngMax) {
              var maxVal = attr.max || $parse(attr.ngMax)(scope);
              var parsedMaxVal = parseObservedDateValue(maxVal);
              ctrl.$validators.max = function(value) {
                return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal;
              };
              attr.$observe("max", function(val) {
                if (val !== maxVal) {
                  parsedMaxVal = parseObservedDateValue(val);
                  maxVal = val;
                  ctrl.$validate();
                }
              });
            }
            function isValidDate(value) {
              return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
              return isDefined(val) && !isDate2(val) ? parseDateAndConvertTimeZoneToLocal(val) || void 0 : val;
            }
            function parseDateAndConvertTimeZoneToLocal(value, previousDate2) {
              var timezone = ctrl.$options.getOption("timezone");
              if (previousTimezone && previousTimezone !== timezone) {
                previousDate2 = addDateMinutes(previousDate2, timezoneToOffset(previousTimezone));
              }
              var parsedDate = parseDate(value, previousDate2);
              if (!isNaN(parsedDate) && timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            function formatter(value, timezone) {
              var targetFormat = format;
              if (isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat"))) {
                targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, "");
              }
              var formatted = $filter("date")(value, targetFormat, timezone);
              if (isTimeType && ctrl.$options.getOption("timeStripZeroSeconds")) {
                formatted = formatted.replace(/(?::00)?(?:\.000)?$/, "");
              }
              return formatted;
            }
          };
        }
        function badInputChecker(scope, element2, attr, ctrl, parserName) {
          var node = element2[0];
          var nativeValidation = ctrl.$$hasNativeValidators = isObject2(node.validity);
          if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
              var validity = element2.prop(VALIDITY_STATE_PROPERTY) || {};
              if (validity.badInput || validity.typeMismatch) {
                ctrl.$$parserName = parserName;
                return void 0;
              }
              return value;
            });
          }
        }
        function numberFormatterParser(ctrl) {
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (NUMBER_REGEXP.test(value))
              return parseFloat(value);
            ctrl.$$parserName = "number";
            return void 0;
          });
          ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
              if (!isNumber(value)) {
                throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
              }
              value = value.toString();
            }
            return value;
          });
        }
        function parseNumberAttrVal(val) {
          if (isDefined(val) && !isNumber(val)) {
            val = parseFloat(val);
          }
          return !isNumberNaN(val) ? val : void 0;
        }
        function isNumberInteger(num) {
          return (num | 0) === num;
        }
        function countDecimals(num) {
          var numString = num.toString();
          var decimalSymbolIndex = numString.indexOf(".");
          if (decimalSymbolIndex === -1) {
            if (-1 < num && num < 1) {
              var match = /e-(\d+)$/.exec(numString);
              if (match) {
                return Number(match[1]);
              }
            }
            return 0;
          }
          return numString.length - decimalSymbolIndex - 1;
        }
        function isValidForStep(viewValue, stepBase, step) {
          var value = Number(viewValue);
          var isNonIntegerValue = !isNumberInteger(value);
          var isNonIntegerStepBase = !isNumberInteger(stepBase);
          var isNonIntegerStep = !isNumberInteger(step);
          if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
            var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
            var stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
            var stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
            var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
            var multiplier = Math.pow(10, decimalCount);
            value = value * multiplier;
            stepBase = stepBase * multiplier;
            step = step * multiplier;
            if (isNonIntegerValue)
              value = Math.round(value);
            if (isNonIntegerStepBase)
              stepBase = Math.round(stepBase);
            if (isNonIntegerStep)
              step = Math.round(step);
          }
          return (value - stepBase) % step === 0;
        }
        function numberInputType(scope, element2, attr, ctrl, $sniffer, $browser, $filter, $parse) {
          badInputChecker(scope, element2, attr, ctrl, "number");
          numberFormatterParser(ctrl);
          baseInputType(scope, element2, attr, ctrl, $sniffer, $browser);
          var parsedMinVal;
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal = attr.min || $parse(attr.ngMin)(scope);
            parsedMinVal = parseNumberAttrVal(minVal);
            ctrl.$validators.min = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal;
            };
            attr.$observe("min", function(val) {
              if (val !== minVal) {
                parsedMinVal = parseNumberAttrVal(val);
                minVal = val;
                ctrl.$validate();
              }
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal = attr.max || $parse(attr.ngMax)(scope);
            var parsedMaxVal = parseNumberAttrVal(maxVal);
            ctrl.$validators.max = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal;
            };
            attr.$observe("max", function(val) {
              if (val !== maxVal) {
                parsedMaxVal = parseNumberAttrVal(val);
                maxVal = val;
                ctrl.$validate();
              }
            });
          }
          if (isDefined(attr.step) || attr.ngStep) {
            var stepVal = attr.step || $parse(attr.ngStep)(scope);
            var parsedStepVal = parseNumberAttrVal(stepVal);
            ctrl.$validators.step = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal);
            };
            attr.$observe("step", function(val) {
              if (val !== stepVal) {
                parsedStepVal = parseNumberAttrVal(val);
                stepVal = val;
                ctrl.$validate();
              }
            });
          }
        }
        function rangeInputType(scope, element2, attr, ctrl, $sniffer, $browser) {
          badInputChecker(scope, element2, attr, ctrl, "range");
          numberFormatterParser(ctrl);
          baseInputType(scope, element2, attr, ctrl, $sniffer, $browser);
          var supportsRange = ctrl.$$hasNativeValidators && element2[0].type === "range", minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element2[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step);
          var originalRender = ctrl.$render;
          ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {
            originalRender();
            ctrl.$setViewValue(element2.val());
          } : originalRender;
          if (hasMinAttr) {
            minVal = parseNumberAttrVal(attr.min);
            ctrl.$validators.min = supportsRange ? function noopMinValidator() {
              return true;
            } : function minValidator(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
            };
            setInitialValueAndObserver("min", minChange);
          }
          if (hasMaxAttr) {
            maxVal = parseNumberAttrVal(attr.max);
            ctrl.$validators.max = supportsRange ? function noopMaxValidator() {
              return true;
            } : function maxValidator(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
            };
            setInitialValueAndObserver("max", maxChange);
          }
          if (hasStepAttr) {
            stepVal = parseNumberAttrVal(attr.step);
            ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
              return !validity.stepMismatch;
            } : function stepValidator(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            };
            setInitialValueAndObserver("step", stepChange);
          }
          function setInitialValueAndObserver(htmlAttrName, changeFn) {
            element2.attr(htmlAttrName, attr[htmlAttrName]);
            var oldVal = attr[htmlAttrName];
            attr.$observe(htmlAttrName, function wrappedObserver(val) {
              if (val !== oldVal) {
                oldVal = val;
                changeFn(val);
              }
            });
          }
          function minChange(val) {
            minVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
              return;
            }
            if (supportsRange) {
              var elVal = element2.val();
              if (minVal > elVal) {
                elVal = minVal;
                element2.val(elVal);
              }
              ctrl.$setViewValue(elVal);
            } else {
              ctrl.$validate();
            }
          }
          function maxChange(val) {
            maxVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
              return;
            }
            if (supportsRange) {
              var elVal = element2.val();
              if (maxVal < elVal) {
                element2.val(maxVal);
                elVal = maxVal < minVal ? minVal : maxVal;
              }
              ctrl.$setViewValue(elVal);
            } else {
              ctrl.$validate();
            }
          }
          function stepChange(val) {
            stepVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
              return;
            }
            if (!supportsRange) {
              ctrl.$validate();
            } else if (ctrl.$viewValue !== element2.val()) {
              ctrl.$setViewValue(element2.val());
            }
          }
        }
        function urlInputType(scope, element2, attr, ctrl, $sniffer, $browser) {
          baseInputType(scope, element2, attr, ctrl, $sniffer, $browser);
          stringBasedInputType(ctrl);
          ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
          };
        }
        function emailInputType(scope, element2, attr, ctrl, $sniffer, $browser) {
          baseInputType(scope, element2, attr, ctrl, $sniffer, $browser);
          stringBasedInputType(ctrl);
          ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
          };
        }
        function radioInputType(scope, element2, attr, ctrl) {
          var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
          if (isUndefined(attr.name)) {
            element2.attr("name", nextUid());
          }
          var listener = function(ev) {
            var value;
            if (element2[0].checked) {
              value = attr.value;
              if (doTrim) {
                value = trim(value);
              }
              ctrl.$setViewValue(value, ev && ev.type);
            }
          };
          element2.on("change", listener);
          ctrl.$render = function() {
            var value = attr.value;
            if (doTrim) {
              value = trim(value);
            }
            element2[0].checked = value === ctrl.$viewValue;
          };
          attr.$observe("value", ctrl.$render);
        }
        function parseConstantExpr($parse, context, name, expression, fallback) {
          var parseFn;
          if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
              throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            }
            return parseFn(context);
          }
          return fallback;
        }
        function checkboxInputType(scope, element2, attr, ctrl, $sniffer, $browser, $filter, $parse) {
          var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
          var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
          var listener = function(ev) {
            ctrl.$setViewValue(element2[0].checked, ev && ev.type);
          };
          element2.on("change", listener);
          ctrl.$render = function() {
            element2[0].checked = ctrl.$viewValue;
          };
          ctrl.$isEmpty = function(value) {
            return value === false;
          };
          ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
          });
          ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
          });
        }
        var inputDirective = [
          "$browser",
          "$sniffer",
          "$filter",
          "$parse",
          function($browser, $sniffer, $filter, $parse) {
            return {
              restrict: "E",
              require: ["?ngModel"],
              link: {
                pre: function(scope, element2, attr, ctrls) {
                  if (ctrls[0]) {
                    (inputType[lowercase(attr.type)] || inputType.text)(scope, element2, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                  }
                }
              }
            };
          }
        ];
        var hiddenInputBrowserCacheDirective = function() {
          var valueProperty = {
            configurable: true,
            enumerable: false,
            get: function() {
              return this.getAttribute("value") || "";
            },
            set: function(val) {
              this.setAttribute("value", val);
            }
          };
          return {
            restrict: "E",
            priority: 200,
            compile: function(_, attr) {
              if (lowercase(attr.type) !== "hidden") {
                return;
              }
              return {
                pre: function(scope, element2, attr2, ctrls) {
                  var node = element2[0];
                  if (node.parentNode) {
                    node.parentNode.insertBefore(node, node.nextSibling);
                  }
                  if (Object.defineProperty) {
                    Object.defineProperty(node, "value", valueProperty);
                  }
                }
              };
            }
          };
        };
        var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
        var ngValueDirective = function() {
          function updateElementValue(element2, attr, value) {
            var propValue = isDefined(value) ? value : msie === 9 ? "" : null;
            element2.prop("value", propValue);
            attr.$set("value", value);
          }
          return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
              if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                return function ngValueConstantLink(scope, elm, attr) {
                  var value = scope.$eval(attr.ngValue);
                  updateElementValue(elm, attr, value);
                };
              } else {
                return function ngValueLink(scope, elm, attr) {
                  scope.$watch(attr.ngValue, function valueWatchAction(value) {
                    updateElementValue(elm, attr, value);
                  });
                };
              }
            }
          };
        };
        var ngBindDirective = ["$compile", function($compile) {
          return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
              $compile.$$addBindingClass(templateElement);
              return function ngBindLink(scope, element2, attr) {
                $compile.$$addBindingInfo(element2, attr.ngBind);
                element2 = element2[0];
                scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                  element2.textContent = stringify3(value);
                });
              };
            }
          };
        }];
        var ngBindTemplateDirective = ["$interpolate", "$compile", function($interpolate, $compile) {
          return {
            compile: function ngBindTemplateCompile(templateElement) {
              $compile.$$addBindingClass(templateElement);
              return function ngBindTemplateLink(scope, element2, attr) {
                var interpolateFn = $interpolate(element2.attr(attr.$attr.ngBindTemplate));
                $compile.$$addBindingInfo(element2, interpolateFn.expressions);
                element2 = element2[0];
                attr.$observe("ngBindTemplate", function(value) {
                  element2.textContent = isUndefined(value) ? "" : value;
                });
              };
            }
          };
        }];
        var ngBindHtmlDirective = ["$sce", "$parse", "$compile", function($sce, $parse, $compile) {
          return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
              var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
              var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
                return $sce.valueOf(val);
              });
              $compile.$$addBindingClass(tElement);
              return function ngBindHtmlLink(scope, element2, attr) {
                $compile.$$addBindingInfo(element2, attr.ngBindHtml);
                scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                  var value = ngBindHtmlGetter(scope);
                  element2.html($sce.getTrustedHtml(value) || "");
                });
              };
            }
          };
        }];
        var ngChangeDirective = valueFn({
          restrict: "A",
          require: "ngModel",
          link: function(scope, element2, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
              scope.$eval(attr.ngChange);
            });
          }
        });
        function classDirective(name, selector) {
          name = "ngClass" + name;
          var indexWatchExpression;
          return ["$parse", function($parse) {
            return {
              restrict: "AC",
              link: function(scope, element2, attr) {
                var classCounts = element2.data("$classCounts");
                var oldModulo = true;
                var oldClassString;
                if (!classCounts) {
                  classCounts = createMap();
                  element2.data("$classCounts", classCounts);
                }
                if (name !== "ngClass") {
                  if (!indexWatchExpression) {
                    indexWatchExpression = $parse("$index", function moduloTwo($index) {
                      return $index & 1;
                    });
                  }
                  scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                }
                scope.$watch($parse(attr[name], toClassString), ngClassWatchAction);
                function addClasses(classString) {
                  classString = digestClassCounts(split(classString), 1);
                  attr.$addClass(classString);
                }
                function removeClasses(classString) {
                  classString = digestClassCounts(split(classString), -1);
                  attr.$removeClass(classString);
                }
                function updateClasses(oldClassString2, newClassString) {
                  var oldClassArray = split(oldClassString2);
                  var newClassArray = split(newClassString);
                  var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                  var toAddArray = arrayDifference(newClassArray, oldClassArray);
                  var toRemoveString = digestClassCounts(toRemoveArray, -1);
                  var toAddString = digestClassCounts(toAddArray, 1);
                  attr.$addClass(toAddString);
                  attr.$removeClass(toRemoveString);
                }
                function digestClassCounts(classArray, count) {
                  var classesToUpdate = [];
                  forEach(classArray, function(className) {
                    if (count > 0 || classCounts[className]) {
                      classCounts[className] = (classCounts[className] || 0) + count;
                      if (classCounts[className] === +(count > 0)) {
                        classesToUpdate.push(className);
                      }
                    }
                  });
                  return classesToUpdate.join(" ");
                }
                function ngClassIndexWatchAction(newModulo) {
                  if (newModulo === selector) {
                    addClasses(oldClassString);
                  } else {
                    removeClasses(oldClassString);
                  }
                  oldModulo = newModulo;
                }
                function ngClassWatchAction(newClassString) {
                  if (oldModulo === selector) {
                    updateClasses(oldClassString, newClassString);
                  }
                  oldClassString = newClassString;
                }
              }
            };
          }];
          function arrayDifference(tokens1, tokens2) {
            if (!tokens1 || !tokens1.length)
              return [];
            if (!tokens2 || !tokens2.length)
              return tokens1;
            var values = [];
            outer:
              for (var i = 0; i < tokens1.length; i++) {
                var token = tokens1[i];
                for (var j = 0; j < tokens2.length; j++) {
                  if (token === tokens2[j])
                    continue outer;
                }
                values.push(token);
              }
            return values;
          }
          function split(classString) {
            return classString && classString.split(" ");
          }
          function toClassString(classValue) {
            if (!classValue)
              return classValue;
            var classString = classValue;
            if (isArray2(classValue)) {
              classString = classValue.map(toClassString).join(" ");
            } else if (isObject2(classValue)) {
              classString = Object.keys(classValue).filter(function(key2) {
                return classValue[key2];
              }).join(" ");
            } else if (!isString(classValue)) {
              classString = classValue + "";
            }
            return classString;
          }
        }
        var ngClassDirective = classDirective("", true);
        var ngClassOddDirective = classDirective("Odd", 0);
        var ngClassEvenDirective = classDirective("Even", 1);
        var ngCloakDirective = ngDirective({
          compile: function(element2, attr) {
            attr.$set("ngCloak", void 0);
            element2.removeClass("ng-cloak");
          }
        });
        var ngControllerDirective = [function() {
          return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
          };
        }];
        var ngEventDirectives = {};
        var forceAsyncEvents = {
          "blur": true,
          "focus": true
        };
        forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
          var directiveName = directiveNormalize("ng-" + eventName);
          ngEventDirectives[directiveName] = ["$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
            return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName]);
          }];
        });
        function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
          return {
            restrict: "A",
            compile: function($element, attr) {
              var fn2 = $parse(attr[directiveName]);
              return function ngEventHandler(scope, element2) {
                element2.on(eventName, function(event) {
                  var callback = function() {
                    fn2(scope, { $event: event });
                  };
                  if (!$rootScope.$$phase) {
                    scope.$apply(callback);
                  } else if (forceAsync) {
                    scope.$evalAsync(callback);
                  } else {
                    try {
                      callback();
                    } catch (error3) {
                      $exceptionHandler(error3);
                    }
                  }
                });
              };
            }
          };
        }
        var ngIfDirective = ["$animate", "$compile", function($animate, $compile) {
          return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
              var block, childScope, previousElements;
              $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                if (value) {
                  if (!childScope) {
                    $transclude(function(clone, newScope) {
                      childScope = newScope;
                      clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf);
                      block = {
                        clone
                      };
                      $animate.enter(clone, $element.parent(), $element);
                    });
                  }
                } else {
                  if (previousElements) {
                    previousElements.remove();
                    previousElements = null;
                  }
                  if (childScope) {
                    childScope.$destroy();
                    childScope = null;
                  }
                  if (block) {
                    previousElements = getBlockNodes(block.clone);
                    $animate.leave(previousElements).done(function(response) {
                      if (response !== false)
                        previousElements = null;
                    });
                    block = null;
                  }
                }
              });
            }
          };
        }];
        var ngIncludeDirective = [
          "$templateRequest",
          "$anchorScroll",
          "$animate",
          function($templateRequest, $anchorScroll, $animate) {
            return {
              restrict: "ECA",
              priority: 400,
              terminal: true,
              transclude: "element",
              controller: angular3.noop,
              compile: function(element2, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                  var changeCounter = 0, currentScope, previousElement, currentElement;
                  var cleanupLastIncludeContent = function() {
                    if (previousElement) {
                      previousElement.remove();
                      previousElement = null;
                    }
                    if (currentScope) {
                      currentScope.$destroy();
                      currentScope = null;
                    }
                    if (currentElement) {
                      $animate.leave(currentElement).done(function(response) {
                        if (response !== false)
                          previousElement = null;
                      });
                      previousElement = currentElement;
                      currentElement = null;
                    }
                  };
                  scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                    var afterAnimation = function(response) {
                      if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                        $anchorScroll();
                      }
                    };
                    var thisChangeId = ++changeCounter;
                    if (src) {
                      $templateRequest(src, true).then(function(response) {
                        if (scope.$$destroyed)
                          return;
                        if (thisChangeId !== changeCounter)
                          return;
                        var newScope = scope.$new();
                        ctrl.template = response;
                        var clone = $transclude(newScope, function(clone2) {
                          cleanupLastIncludeContent();
                          $animate.enter(clone2, null, $element).done(afterAnimation);
                        });
                        currentScope = newScope;
                        currentElement = clone;
                        currentScope.$emit("$includeContentLoaded", src);
                        scope.$eval(onloadExp);
                      }, function() {
                        if (scope.$$destroyed)
                          return;
                        if (thisChangeId === changeCounter) {
                          cleanupLastIncludeContent();
                          scope.$emit("$includeContentError", src);
                        }
                      });
                      scope.$emit("$includeContentRequested", src);
                    } else {
                      cleanupLastIncludeContent();
                      ctrl.template = null;
                    }
                  });
                };
              }
            };
          }
        ];
        var ngIncludeFillContentDirective = [
          "$compile",
          function($compile) {
            return {
              restrict: "ECA",
              priority: -400,
              require: "ngInclude",
              link: function(scope, $element, $attr, ctrl) {
                if (toString.call($element[0]).match(/SVG/)) {
                  $element.empty();
                  $compile(jqLiteBuildFragment(ctrl.template, window2.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                    $element.append(clone);
                  }, { futureParentElement: $element });
                  return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
              }
            };
          }
        ];
        var ngInitDirective = ngDirective({
          priority: 450,
          compile: function() {
            return {
              pre: function(scope, element2, attrs) {
                scope.$eval(attrs.ngInit);
              }
            };
          }
        });
        var ngListDirective = function() {
          return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element2, attr, ctrl) {
              var ngList = attr.ngList || ", ";
              var trimValues = attr.ngTrim !== "false";
              var separator = trimValues ? trim(ngList) : ngList;
              var parse3 = function(viewValue) {
                if (isUndefined(viewValue))
                  return;
                var list = [];
                if (viewValue) {
                  forEach(viewValue.split(separator), function(value) {
                    if (value)
                      list.push(trimValues ? trim(value) : value);
                  });
                }
                return list;
              };
              ctrl.$parsers.push(parse3);
              ctrl.$formatters.push(function(value) {
                if (isArray2(value)) {
                  return value.join(ngList);
                }
                return void 0;
              });
              ctrl.$isEmpty = function(value) {
                return !value || !value.length;
              };
            }
          };
        };
        var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty";
        var ngModelMinErr = minErr("ngModel");
        NgModelController.$inject = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate"];
        function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
          this.$viewValue = Number.NaN;
          this.$modelValue = Number.NaN;
          this.$$rawModelValue = void 0;
          this.$validators = {};
          this.$asyncValidators = {};
          this.$parsers = [];
          this.$formatters = [];
          this.$viewChangeListeners = [];
          this.$untouched = true;
          this.$touched = false;
          this.$pristine = true;
          this.$dirty = false;
          this.$valid = true;
          this.$invalid = false;
          this.$error = {};
          this.$$success = {};
          this.$pending = void 0;
          this.$name = $interpolate($attr.name || "", false)($scope);
          this.$$parentForm = nullFormCtrl;
          this.$options = defaultModelOptions;
          this.$$updateEvents = "";
          this.$$updateEventHandler = this.$$updateEventHandler.bind(this);
          this.$$parsedNgModel = $parse($attr.ngModel);
          this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
          this.$$ngModelGet = this.$$parsedNgModel;
          this.$$ngModelSet = this.$$parsedNgModelAssign;
          this.$$pendingDebounce = null;
          this.$$parserValid = void 0;
          this.$$parserName = "parse";
          this.$$currentValidationRunId = 0;
          this.$$scope = $scope;
          this.$$rootScope = $scope.$root;
          this.$$attr = $attr;
          this.$$element = $element;
          this.$$animate = $animate;
          this.$$timeout = $timeout;
          this.$$parse = $parse;
          this.$$q = $q;
          this.$$exceptionHandler = $exceptionHandler;
          setupValidity(this);
          setupModelWatcher(this);
        }
        NgModelController.prototype = {
          $$initGetterSetters: function() {
            if (this.$options.getOption("getterSetter")) {
              var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
              this.$$ngModelGet = function($scope) {
                var modelValue = this.$$parsedNgModel($scope);
                if (isFunction2(modelValue)) {
                  modelValue = invokeModelGetter($scope);
                }
                return modelValue;
              };
              this.$$ngModelSet = function($scope, newValue) {
                if (isFunction2(this.$$parsedNgModel($scope))) {
                  invokeModelSetter($scope, { $$$p: newValue });
                } else {
                  this.$$parsedNgModelAssign($scope, newValue);
                }
              };
            } else if (!this.$$parsedNgModel.assign) {
              throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
            }
          },
          $render: noop3,
          $isEmpty: function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
          },
          $$updateEmptyClasses: function(value) {
            if (this.$isEmpty(value)) {
              this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
              this.$$animate.addClass(this.$$element, EMPTY_CLASS);
            } else {
              this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
              this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
            }
          },
          $setPristine: function() {
            this.$dirty = false;
            this.$pristine = true;
            this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
          },
          $setDirty: function() {
            this.$dirty = true;
            this.$pristine = false;
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
            this.$$animate.addClass(this.$$element, DIRTY_CLASS);
            this.$$parentForm.$setDirty();
          },
          $setUntouched: function() {
            this.$touched = false;
            this.$untouched = true;
            this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
          },
          $setTouched: function() {
            this.$touched = true;
            this.$untouched = false;
            this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
          },
          $rollbackViewValue: function() {
            this.$$timeout.cancel(this.$$pendingDebounce);
            this.$viewValue = this.$$lastCommittedViewValue;
            this.$render();
          },
          $validate: function() {
            if (isNumberNaN(this.$modelValue)) {
              return;
            }
            var viewValue = this.$$lastCommittedViewValue;
            var modelValue = this.$$rawModelValue;
            var prevValid = this.$valid;
            var prevModelValue = this.$modelValue;
            var allowInvalid = this.$options.getOption("allowInvalid");
            var that = this;
            this.$$runValidators(modelValue, viewValue, function(allValid) {
              if (!allowInvalid && prevValid !== allValid) {
                that.$modelValue = allValid ? modelValue : void 0;
                if (that.$modelValue !== prevModelValue) {
                  that.$$writeModelToScope();
                }
              }
            });
          },
          $$runValidators: function(modelValue, viewValue, doneCallback) {
            this.$$currentValidationRunId++;
            var localValidationRunId = this.$$currentValidationRunId;
            var that = this;
            if (!processParseErrors()) {
              validationDone(false);
              return;
            }
            if (!processSyncValidators()) {
              validationDone(false);
              return;
            }
            processAsyncValidators();
            function processParseErrors() {
              var errorKey = that.$$parserName;
              if (isUndefined(that.$$parserValid)) {
                setValidity(errorKey, null);
              } else {
                if (!that.$$parserValid) {
                  forEach(that.$validators, function(v, name) {
                    setValidity(name, null);
                  });
                  forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                  });
                }
                setValidity(errorKey, that.$$parserValid);
                return that.$$parserValid;
              }
              return true;
            }
            function processSyncValidators() {
              var syncValidatorsValid = true;
              forEach(that.$validators, function(validator, name) {
                var result = Boolean(validator(modelValue, viewValue));
                syncValidatorsValid = syncValidatorsValid && result;
                setValidity(name, result);
              });
              if (!syncValidatorsValid) {
                forEach(that.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
                return false;
              }
              return true;
            }
            function processAsyncValidators() {
              var validatorPromises = [];
              var allValid = true;
              forEach(that.$asyncValidators, function(validator, name) {
                var promise2 = validator(modelValue, viewValue);
                if (!isPromiseLike(promise2)) {
                  throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise2);
                }
                setValidity(name, void 0);
                validatorPromises.push(promise2.then(function() {
                  setValidity(name, true);
                }, function() {
                  allValid = false;
                  setValidity(name, false);
                }));
              });
              if (!validatorPromises.length) {
                validationDone(true);
              } else {
                that.$$q.all(validatorPromises).then(function() {
                  validationDone(allValid);
                }, noop3);
              }
            }
            function setValidity(name, isValid) {
              if (localValidationRunId === that.$$currentValidationRunId) {
                that.$setValidity(name, isValid);
              }
            }
            function validationDone(allValid) {
              if (localValidationRunId === that.$$currentValidationRunId) {
                doneCallback(allValid);
              }
            }
          },
          $commitViewValue: function() {
            var viewValue = this.$viewValue;
            this.$$timeout.cancel(this.$$pendingDebounce);
            if (this.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !this.$$hasNativeValidators)) {
              return;
            }
            this.$$updateEmptyClasses(viewValue);
            this.$$lastCommittedViewValue = viewValue;
            if (this.$pristine) {
              this.$setDirty();
            }
            this.$$parseAndValidate();
          },
          $$parseAndValidate: function() {
            var viewValue = this.$$lastCommittedViewValue;
            var modelValue = viewValue;
            var that = this;
            this.$$parserValid = isUndefined(modelValue) ? void 0 : true;
            this.$setValidity(this.$$parserName, null);
            this.$$parserName = "parse";
            if (this.$$parserValid) {
              for (var i = 0; i < this.$parsers.length; i++) {
                modelValue = this.$parsers[i](modelValue);
                if (isUndefined(modelValue)) {
                  this.$$parserValid = false;
                  break;
                }
              }
            }
            if (isNumberNaN(this.$modelValue)) {
              this.$modelValue = this.$$ngModelGet(this.$$scope);
            }
            var prevModelValue = this.$modelValue;
            var allowInvalid = this.$options.getOption("allowInvalid");
            this.$$rawModelValue = modelValue;
            if (allowInvalid) {
              this.$modelValue = modelValue;
              writeToModelIfNeeded();
            }
            this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
              if (!allowInvalid) {
                that.$modelValue = allValid ? modelValue : void 0;
                writeToModelIfNeeded();
              }
            });
            function writeToModelIfNeeded() {
              if (that.$modelValue !== prevModelValue) {
                that.$$writeModelToScope();
              }
            }
          },
          $$writeModelToScope: function() {
            this.$$ngModelSet(this.$$scope, this.$modelValue);
            forEach(this.$viewChangeListeners, function(listener) {
              try {
                listener();
              } catch (e) {
                this.$$exceptionHandler(e);
              }
            }, this);
          },
          $setViewValue: function(value, trigger) {
            this.$viewValue = value;
            if (this.$options.getOption("updateOnDefault")) {
              this.$$debounceViewValueCommit(trigger);
            }
          },
          $$debounceViewValueCommit: function(trigger) {
            var debounceDelay = this.$options.getOption("debounce");
            if (isNumber(debounceDelay[trigger])) {
              debounceDelay = debounceDelay[trigger];
            } else if (isNumber(debounceDelay["default"]) && this.$options.getOption("updateOn").indexOf(trigger) === -1) {
              debounceDelay = debounceDelay["default"];
            } else if (isNumber(debounceDelay["*"])) {
              debounceDelay = debounceDelay["*"];
            }
            this.$$timeout.cancel(this.$$pendingDebounce);
            var that = this;
            if (debounceDelay > 0) {
              this.$$pendingDebounce = this.$$timeout(function() {
                that.$commitViewValue();
              }, debounceDelay);
            } else if (this.$$rootScope.$$phase) {
              this.$commitViewValue();
            } else {
              this.$$scope.$apply(function() {
                that.$commitViewValue();
              });
            }
          },
          $overrideModelOptions: function(options) {
            this.$options = this.$options.createChild(options);
            this.$$setUpdateOnEvents();
          },
          $processModelValue: function() {
            var viewValue = this.$$format();
            if (this.$viewValue !== viewValue) {
              this.$$updateEmptyClasses(viewValue);
              this.$viewValue = this.$$lastCommittedViewValue = viewValue;
              this.$render();
              this.$$runValidators(this.$modelValue, this.$viewValue, noop3);
            }
          },
          $$format: function() {
            var formatters = this.$formatters, idx = formatters.length;
            var viewValue = this.$modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            return viewValue;
          },
          $$setModelValue: function(modelValue) {
            this.$modelValue = this.$$rawModelValue = modelValue;
            this.$$parserValid = void 0;
            this.$processModelValue();
          },
          $$setUpdateOnEvents: function() {
            if (this.$$updateEvents) {
              this.$$element.off(this.$$updateEvents, this.$$updateEventHandler);
            }
            this.$$updateEvents = this.$options.getOption("updateOn");
            if (this.$$updateEvents) {
              this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
            }
          },
          $$updateEventHandler: function(ev) {
            this.$$debounceViewValueCommit(ev && ev.type);
          }
        };
        function setupModelWatcher(ctrl) {
          ctrl.$$scope.$watch(function ngModelWatch(scope) {
            var modelValue = ctrl.$$ngModelGet(scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
              ctrl.$$setModelValue(modelValue);
            }
            return modelValue;
          });
        }
        addSetValidityMethod({
          clazz: NgModelController,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          }
        });
        var ngModelDirective = ["$rootScope", function($rootScope) {
          return {
            restrict: "A",
            require: ["ngModel", "^?form", "^?ngModelOptions"],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element2) {
              element2.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
              return {
                pre: function ngModelPreLink(scope, element3, attr, ctrls) {
                  var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                  if (optionsCtrl) {
                    modelCtrl.$options = optionsCtrl.$options;
                  }
                  modelCtrl.$$initGetterSetters();
                  formCtrl.$addControl(modelCtrl);
                  attr.$observe("name", function(newValue) {
                    if (modelCtrl.$name !== newValue) {
                      modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                    }
                  });
                  scope.$on("$destroy", function() {
                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                  });
                },
                post: function ngModelPostLink(scope, element3, attr, ctrls) {
                  var modelCtrl = ctrls[0];
                  modelCtrl.$$setUpdateOnEvents();
                  function setTouched() {
                    modelCtrl.$setTouched();
                  }
                  element3.on("blur", function() {
                    if (modelCtrl.$touched)
                      return;
                    if ($rootScope.$$phase) {
                      scope.$evalAsync(setTouched);
                    } else {
                      scope.$apply(setTouched);
                    }
                  });
                }
              };
            }
          };
        }];
        var defaultModelOptions;
        var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
        function ModelOptions(options) {
          this.$$options = options;
        }
        ModelOptions.prototype = {
          getOption: function(name) {
            return this.$$options[name];
          },
          createChild: function(options) {
            var inheritAll = false;
            options = extend({}, options);
            forEach(options, function(option, key2) {
              if (option === "$inherit") {
                if (key2 === "*") {
                  inheritAll = true;
                } else {
                  options[key2] = this.$$options[key2];
                  if (key2 === "updateOn") {
                    options.updateOnDefault = this.$$options.updateOnDefault;
                  }
                }
              } else {
                if (key2 === "updateOn") {
                  options.updateOnDefault = false;
                  options[key2] = trim(option.replace(DEFAULT_REGEXP, function() {
                    options.updateOnDefault = true;
                    return " ";
                  }));
                }
              }
            }, this);
            if (inheritAll) {
              delete options["*"];
              defaults(options, this.$$options);
            }
            defaults(options, defaultModelOptions.$$options);
            return new ModelOptions(options);
          }
        };
        defaultModelOptions = new ModelOptions({
          updateOn: "",
          updateOnDefault: true,
          debounce: 0,
          getterSetter: false,
          allowInvalid: false,
          timezone: null
        });
        var ngModelOptionsDirective = function() {
          NgModelOptionsController.$inject = ["$attrs", "$scope"];
          function NgModelOptionsController($attrs, $scope) {
            this.$$attrs = $attrs;
            this.$$scope = $scope;
          }
          NgModelOptionsController.prototype = {
            $onInit: function() {
              var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
              var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
              this.$options = parentOptions.createChild(modelOptionsDefinition);
            }
          };
          return {
            restrict: "A",
            priority: 10,
            require: { parentCtrl: "?^^ngModelOptions" },
            bindToController: true,
            controller: NgModelOptionsController
          };
        };
        function defaults(dst, src) {
          forEach(src, function(value, key2) {
            if (!isDefined(dst[key2])) {
              dst[key2] = value;
            }
          });
        }
        var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1e3 });
        var ngOptionsMinErr = minErr("ngOptions");
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
        var ngOptionsDirective = ["$compile", "$document", "$parse", function($compile, $document, $parse) {
          function parseOptionsExpression(optionsExp, selectElement, scope) {
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) {
              throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            }
            var valueName = match[5] || match[7];
            var keyName = match[6];
            var selectAs = / as /.test(match[0]) && match[1];
            var trackBy = match[9];
            var valueFn2 = $parse(match[2] ? match[1] : valueName);
            var selectAsFn = selectAs && $parse(selectAs);
            var viewValueFn = selectAsFn || valueFn2;
            var trackByFn = trackBy && $parse(trackBy);
            var getTrackByValueFn = trackBy ? function(value, locals2) {
              return trackByFn(scope, locals2);
            } : function getHashOfValue(value) {
              return hashKey(value);
            };
            var getTrackByValue = function(value, key2) {
              return getTrackByValueFn(value, getLocals(value, key2));
            };
            var displayFn = $parse(match[2] || match[1]);
            var groupByFn = $parse(match[3] || "");
            var disableWhenFn = $parse(match[4] || "");
            var valuesFn = $parse(match[8]);
            var locals = {};
            var getLocals = keyName ? function(value, key2) {
              locals[keyName] = key2;
              locals[valueName] = value;
              return locals;
            } : function(value) {
              locals[valueName] = value;
              return locals;
            };
            function Option(selectValue, viewValue, label, group, disabled) {
              this.selectValue = selectValue;
              this.viewValue = viewValue;
              this.label = label;
              this.group = group;
              this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
              var optionValuesKeys;
              if (!keyName && isArrayLike2(optionValues)) {
                optionValuesKeys = optionValues;
              } else {
                optionValuesKeys = [];
                for (var itemKey in optionValues) {
                  if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== "$") {
                    optionValuesKeys.push(itemKey);
                  }
                }
              }
              return optionValuesKeys;
            }
            return {
              trackBy,
              getTrackByValue,
              getWatchables: $parse(valuesFn, function(optionValues) {
                var watchedArray = [];
                optionValues = optionValues || [];
                var optionValuesKeys = getOptionValuesKeys(optionValues);
                var optionValuesLength = optionValuesKeys.length;
                for (var index = 0; index < optionValuesLength; index++) {
                  var key2 = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                  var value = optionValues[key2];
                  var locals2 = getLocals(value, key2);
                  var selectValue = getTrackByValueFn(value, locals2);
                  watchedArray.push(selectValue);
                  if (match[2] || match[1]) {
                    var label = displayFn(scope, locals2);
                    watchedArray.push(label);
                  }
                  if (match[4]) {
                    var disableWhen = disableWhenFn(scope, locals2);
                    watchedArray.push(disableWhen);
                  }
                }
                return watchedArray;
              }),
              getOptions: function() {
                var optionItems = [];
                var selectValueMap = {};
                var optionValues = valuesFn(scope) || [];
                var optionValuesKeys = getOptionValuesKeys(optionValues);
                var optionValuesLength = optionValuesKeys.length;
                for (var index = 0; index < optionValuesLength; index++) {
                  var key2 = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                  var value = optionValues[key2];
                  var locals2 = getLocals(value, key2);
                  var viewValue = viewValueFn(scope, locals2);
                  var selectValue = getTrackByValueFn(viewValue, locals2);
                  var label = displayFn(scope, locals2);
                  var group = groupByFn(scope, locals2);
                  var disabled = disableWhenFn(scope, locals2);
                  var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                  optionItems.push(optionItem);
                  selectValueMap[selectValue] = optionItem;
                }
                return {
                  items: optionItems,
                  selectValueMap,
                  getOptionFromViewValue: function(value2) {
                    return selectValueMap[getTrackByValue(value2)];
                  },
                  getViewValueFromOption: function(option) {
                    return trackBy ? copy(option.viewValue) : option.viewValue;
                  }
                };
              }
            };
          }
          var optionTemplate = window2.document.createElement("option"), optGroupTemplate = window2.document.createElement("optgroup");
          function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            var multiple = attr.multiple;
            for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
              if (children[i].value === "") {
                selectCtrl.hasEmptyOption = true;
                selectCtrl.emptyOption = children.eq(i);
                break;
              }
            }
            selectElement.empty();
            var providedEmptyOption = !!selectCtrl.emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val("?");
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var listFragment = $document[0].createDocumentFragment();
            selectCtrl.generateUnknownOptionValue = function(val) {
              return "?";
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                if (!options)
                  return;
                var selectedOption = selectElement[0].options[selectElement[0].selectedIndex];
                var option = options.getOptionFromViewValue(value);
                if (selectedOption)
                  selectedOption.removeAttribute("selected");
                if (option) {
                  if (selectElement[0].value !== option.selectValue) {
                    selectCtrl.removeUnknownOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                  }
                  option.element.setAttribute("selected", "selected");
                } else {
                  selectCtrl.selectUnknownOrEmptyOption(value);
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  selectCtrl.unselectEmptyOption();
                  selectCtrl.removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
                if (!options)
                  return;
                var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                options.items.forEach(function(option) {
                  if (option.element.selected && !includes(selectedOptions, option)) {
                    option.element.selected = false;
                  }
                });
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [], selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray2(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              $compile(selectCtrl.emptyOption)(scope);
              selectElement.prepend(selectCtrl.emptyOption);
              if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
                selectCtrl.hasEmptyOption = false;
                selectCtrl.registerOption = function(optionScope, optionEl) {
                  if (optionEl.val() === "") {
                    selectCtrl.hasEmptyOption = true;
                    selectCtrl.emptyOption = optionEl;
                    selectCtrl.emptyOption.removeClass("ng-scope");
                    ngModelCtrl.$render();
                    optionEl.on("$destroy", function() {
                      var needsRerender = selectCtrl.$isEmptyOptionSelected();
                      selectCtrl.hasEmptyOption = false;
                      selectCtrl.emptyOption = void 0;
                      if (needsRerender)
                        ngModelCtrl.$render();
                    });
                  }
                };
              } else {
                selectCtrl.emptyOption.removeClass("ng-scope");
              }
            }
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function addOptionElement(option, parent) {
              var optionElement = optionTemplate.cloneNode(false);
              parent.appendChild(optionElement);
              updateOptionElement(option, optionElement);
            }
            function getAndUpdateSelectedOption(viewValue) {
              var option = options.getOptionFromViewValue(viewValue);
              var element2 = option && option.element;
              if (element2 && !element2.selected)
                element2.selected = true;
              return option;
            }
            function updateOptionElement(option, element2) {
              option.element = element2;
              element2.disabled = option.disabled;
              if (option.label !== element2.label) {
                element2.label = option.label;
                element2.textContent = option.label;
              }
              element2.value = option.selectValue;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              if (options) {
                for (var i2 = options.items.length - 1; i2 >= 0; i2--) {
                  var option = options.items[i2];
                  if (isDefined(option.group)) {
                    jqLiteRemove(option.element.parentNode);
                  } else {
                    jqLiteRemove(option.element);
                  }
                }
              }
              options = ngOptions.getOptions();
              var groupElementMap = {};
              options.items.forEach(function addOption(option2) {
                var groupElement;
                if (isDefined(option2.group)) {
                  groupElement = groupElementMap[option2.group];
                  if (!groupElement) {
                    groupElement = optGroupTemplate.cloneNode(false);
                    listFragment.appendChild(groupElement);
                    groupElement.label = option2.group === null ? "null" : option2.group;
                    groupElementMap[option2.group] = groupElement;
                  }
                  addOptionElement(option2, groupElement);
                } else {
                  addOptionElement(option2, listFragment);
                }
              });
              selectElement[0].appendChild(listFragment);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                var isNotPrimitive = ngOptions.trackBy || multiple;
                if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
          return {
            restrict: "A",
            terminal: true,
            require: ["select", "ngModel"],
            link: {
              pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                ctrls[0].registerOption = noop3;
              },
              post: ngOptionsPostLink
            }
          };
        }];
        var ngPluralizeDirective = ["$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
          var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
          return {
            link: function(scope, element2, attr) {
              var numberExp = attr.count, whenExp = attr.$attr.when && element2.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular3.noop, lastCount;
              forEach(attr, function(expression, attributeName) {
                var tmpMatch = IS_WHEN.exec(attributeName);
                if (tmpMatch) {
                  var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                  whens[whenKey] = element2.attr(attr.$attr[attributeName]);
                }
              });
              forEach(whens, function(expression, key2) {
                whensExpFns[key2] = $interpolate(expression.replace(BRACE, braceReplacement));
              });
              scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                var count = parseFloat(newVal);
                var countIsNaN = isNumberNaN(count);
                if (!countIsNaN && !(count in whens)) {
                  count = $locale.pluralCat(count - offset);
                }
                if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                  watchRemover();
                  var whenExpFn = whensExpFns[count];
                  if (isUndefined(whenExpFn)) {
                    if (newVal != null) {
                      $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                    }
                    watchRemover = noop3;
                    updateElementText();
                  } else {
                    watchRemover = scope.$watch(whenExpFn, updateElementText);
                  }
                  lastCount = count;
                }
              });
              function updateElementText(newText) {
                element2.text(newText || "");
              }
            }
          };
        }];
        var ngRefMinErr = minErr("ngRef");
        var ngRefDirective = ["$parse", function($parse) {
          return {
            priority: -1,
            restrict: "A",
            compile: function(tElement, tAttrs) {
              var controllerName = directiveNormalize(nodeName_(tElement));
              var getter2 = $parse(tAttrs.ngRef);
              var setter = getter2.assign || function() {
                throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef);
              };
              return function(scope, element2, attrs) {
                var refValue;
                if (attrs.hasOwnProperty("ngRefRead")) {
                  if (attrs.ngRefRead === "$element") {
                    refValue = element2;
                  } else {
                    refValue = element2.data("$" + attrs.ngRefRead + "Controller");
                    if (!refValue) {
                      throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef);
                    }
                  }
                } else {
                  refValue = element2.data("$" + controllerName + "Controller");
                }
                refValue = refValue || element2;
                setter(scope, refValue);
                element2.on("$destroy", function() {
                  if (getter2(scope) === refValue) {
                    setter(scope, null);
                  }
                });
              };
            }
          };
        }];
        var ngRepeatDirective = ["$parse", "$animate", "$compile", function($parse, $animate, $compile) {
          var NG_REMOVED = "$$NG_REMOVED";
          var ngRepeatMinErr = minErr("ngRepeat");
          var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key2, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier)
              scope[keyIdentifier] = key2;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
          };
          var getBlockStart = function(block) {
            return block.clone[0];
          };
          var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
          };
          var trackByIdArrayFn = function($scope, key2, value) {
            return hashKey(value);
          };
          var trackByIdObjFn = function($scope, key2) {
            return key2;
          };
          return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
              var expression = $attr.ngRepeat;
              var ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression);
              var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
              if (!match) {
                throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
              }
              var lhs = match[1];
              var rhs = match[2];
              var aliasAs = match[3];
              var trackByExp = match[4];
              match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
              if (!match) {
                throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
              }
              var valueIdentifier = match[3] || match[1];
              var keyIdentifier = match[2];
              if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
              }
              var trackByIdExpFn;
              if (trackByExp) {
                var hashFnLocals = { $id: hashKey };
                var trackByExpGetter = $parse(trackByExp);
                trackByIdExpFn = function($scope, key2, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key2;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              return function ngRepeatLink($scope, $element2, $attr2, ctrl, $transclude) {
                var lastBlockMap = createMap();
                $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                  var index, length, previousNode = $element2[0], nextNode, nextBlockMap = createMap(), collectionLength, key2, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                  if (aliasAs) {
                    $scope[aliasAs] = collection;
                  }
                  if (isArrayLike2(collection)) {
                    collectionKeys = collection;
                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                  } else {
                    trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                    collectionKeys = [];
                    for (var itemKey in collection) {
                      if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== "$") {
                        collectionKeys.push(itemKey);
                      }
                    }
                  }
                  collectionLength = collectionKeys.length;
                  nextBlockOrder = new Array(collectionLength);
                  for (index = 0; index < collectionLength; index++) {
                    key2 = collection === collectionKeys ? index : collectionKeys[index];
                    value = collection[key2];
                    trackById = trackByIdFn($scope, key2, value, index);
                    if (lastBlockMap[trackById]) {
                      block = lastBlockMap[trackById];
                      delete lastBlockMap[trackById];
                      nextBlockMap[trackById] = block;
                      nextBlockOrder[index] = block;
                    } else if (nextBlockMap[trackById]) {
                      forEach(nextBlockOrder, function(block2) {
                        if (block2 && block2.scope)
                          lastBlockMap[block2.id] = block2;
                      });
                      throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                    } else {
                      nextBlockOrder[index] = { id: trackById, scope: void 0, clone: void 0 };
                      nextBlockMap[trackById] = true;
                    }
                  }
                  if (hashFnLocals) {
                    hashFnLocals[valueIdentifier] = void 0;
                  }
                  for (var blockKey in lastBlockMap) {
                    block = lastBlockMap[blockKey];
                    elementsToRemove = getBlockNodes(block.clone);
                    $animate.leave(elementsToRemove);
                    if (elementsToRemove[0].parentNode) {
                      for (index = 0, length = elementsToRemove.length; index < length; index++) {
                        elementsToRemove[index][NG_REMOVED] = true;
                      }
                    }
                    block.scope.$destroy();
                  }
                  for (index = 0; index < collectionLength; index++) {
                    key2 = collection === collectionKeys ? index : collectionKeys[index];
                    value = collection[key2];
                    block = nextBlockOrder[index];
                    if (block.scope) {
                      nextNode = previousNode;
                      do {
                        nextNode = nextNode.nextSibling;
                      } while (nextNode && nextNode[NG_REMOVED]);
                      if (getBlockStart(block) !== nextNode) {
                        $animate.move(getBlockNodes(block.clone), null, previousNode);
                      }
                      previousNode = getBlockEnd(block);
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key2, collectionLength);
                    } else {
                      $transclude(function ngRepeatTransclude(clone, scope) {
                        block.scope = scope;
                        var endNode = ngRepeatEndComment.cloneNode(false);
                        clone[clone.length++] = endNode;
                        $animate.enter(clone, null, previousNode);
                        previousNode = endNode;
                        block.clone = clone;
                        nextBlockMap[block.id] = block;
                        updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key2, collectionLength);
                      });
                    }
                  }
                  lastBlockMap = nextBlockMap;
                });
              };
            }
          };
        }];
        var NG_HIDE_CLASS = "ng-hide";
        var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
        var ngShowDirective = ["$animate", function($animate) {
          return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element2, attr) {
              scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                $animate[value ? "removeClass" : "addClass"](element2, NG_HIDE_CLASS, {
                  tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                });
              });
            }
          };
        }];
        var ngHideDirective = ["$animate", function($animate) {
          return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element2, attr) {
              scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                $animate[value ? "addClass" : "removeClass"](element2, NG_HIDE_CLASS, {
                  tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                });
              });
            }
          };
        }];
        var ngStyleDirective = ngDirective(function(scope, element2, attr) {
          scope.$watchCollection(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
              forEach(oldStyles, function(val, style) {
                element2.css(style, "");
              });
            }
            if (newStyles)
              element2.css(newStyles);
          });
        });
        var ngSwitchDirective = ["$animate", "$compile", function($animate, $compile) {
          return {
            require: "ngSwitch",
            controller: ["$scope", function NgSwitchController() {
              this.cases = {};
            }],
            link: function(scope, element2, attr, ngSwitchController) {
              var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
              var spliceFactory = function(array, index) {
                return function(response) {
                  if (response !== false)
                    array.splice(index, 1);
                };
              };
              scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                var i, ii;
                while (previousLeaveAnimations.length) {
                  $animate.cancel(previousLeaveAnimations.pop());
                }
                for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                  var selected = getBlockNodes(selectedElements[i].clone);
                  selectedScopes[i].$destroy();
                  var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                  runner.done(spliceFactory(previousLeaveAnimations, i));
                }
                selectedElements.length = 0;
                selectedScopes.length = 0;
                if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                  forEach(selectedTranscludes, function(selectedTransclude) {
                    selectedTransclude.transclude(function(caseElement, selectedScope) {
                      selectedScopes.push(selectedScope);
                      var anchor = selectedTransclude.element;
                      caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                      var block = { clone: caseElement };
                      selectedElements.push(block);
                      $animate.enter(caseElement, anchor.parent(), anchor);
                    });
                  });
                }
              });
            }
          };
        }];
        var ngSwitchWhenDirective = ngDirective({
          transclude: "element",
          priority: 1200,
          require: "^ngSwitch",
          multiElement: true,
          link: function(scope, element2, attrs, ctrl, $transclude) {
            var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element3, index, array) {
              return array[index - 1] !== element3;
            });
            forEach(cases, function(whenCase) {
              ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [];
              ctrl.cases["!" + whenCase].push({ transclude: $transclude, element: element2 });
            });
          }
        });
        var ngSwitchDefaultDirective = ngDirective({
          transclude: "element",
          priority: 1200,
          require: "^ngSwitch",
          multiElement: true,
          link: function(scope, element2, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({ transclude: $transclude, element: element2 });
          }
        });
        var ngTranscludeMinErr = minErr("ngTransclude");
        var ngTranscludeDirective = ["$compile", function($compile) {
          return {
            restrict: "EAC",
            compile: function ngTranscludeCompile(tElement) {
              var fallbackLinkFn = $compile(tElement.contents());
              tElement.empty();
              return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                if (!$transclude) {
                  throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                }
                if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                  $attrs.ngTransclude = "";
                }
                var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                $transclude(ngTranscludeCloneAttachFn, null, slotName);
                if (slotName && !$transclude.isSlotFilled(slotName)) {
                  useFallbackContent();
                }
                function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                  if (clone.length && notWhitespace(clone)) {
                    $element.append(clone);
                  } else {
                    useFallbackContent();
                    transcludedScope.$destroy();
                  }
                }
                function useFallbackContent() {
                  fallbackLinkFn($scope, function(clone) {
                    $element.append(clone);
                  });
                }
                function notWhitespace(nodes) {
                  for (var i = 0, ii = nodes.length; i < ii; i++) {
                    var node = nodes[i];
                    if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                      return true;
                    }
                  }
                }
              };
            }
          };
        }];
        var scriptDirective = ["$templateCache", function($templateCache) {
          return {
            restrict: "E",
            terminal: true,
            compile: function(element2, attr) {
              if (attr.type === "text/ng-template") {
                var templateUrl = attr.id, text = element2[0].text;
                $templateCache.put(templateUrl, text);
              }
            }
          };
        }];
        var noopNgModelController = { $setViewValue: noop3, $render: noop3 };
        function setOptionSelectedStatus(optionEl, value) {
          optionEl.prop("selected", value);
          optionEl.attr("selected", value);
        }
        var SelectController = ["$element", "$scope", function($element, $scope) {
          var self2 = this, optionsMap = new NgMap();
          self2.selectValueMap = {};
          self2.ngModelCtrl = noopNgModelController;
          self2.multiple = false;
          self2.unknownOption = jqLite(window2.document.createElement("option"));
          self2.hasEmptyOption = false;
          self2.emptyOption = void 0;
          self2.renderUnknownOption = function(val) {
            var unknownVal = self2.generateUnknownOptionValue(val);
            self2.unknownOption.val(unknownVal);
            $element.prepend(self2.unknownOption);
            setOptionSelectedStatus(self2.unknownOption, true);
            $element.val(unknownVal);
          };
          self2.updateUnknownOption = function(val) {
            var unknownVal = self2.generateUnknownOptionValue(val);
            self2.unknownOption.val(unknownVal);
            setOptionSelectedStatus(self2.unknownOption, true);
            $element.val(unknownVal);
          };
          self2.generateUnknownOptionValue = function(val) {
            return "? " + hashKey(val) + " ?";
          };
          self2.removeUnknownOption = function() {
            if (self2.unknownOption.parent())
              self2.unknownOption.remove();
          };
          self2.selectEmptyOption = function() {
            if (self2.emptyOption) {
              $element.val("");
              setOptionSelectedStatus(self2.emptyOption, true);
            }
          };
          self2.unselectEmptyOption = function() {
            if (self2.hasEmptyOption) {
              setOptionSelectedStatus(self2.emptyOption, false);
            }
          };
          $scope.$on("$destroy", function() {
            self2.renderUnknownOption = noop3;
          });
          self2.readValue = function readSingleValue() {
            var val = $element.val();
            var realVal = val in self2.selectValueMap ? self2.selectValueMap[val] : val;
            if (self2.hasOption(realVal)) {
              return realVal;
            }
            return null;
          };
          self2.writeValue = function writeSingleValue(value) {
            var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
            if (currentlySelectedOption)
              setOptionSelectedStatus(jqLite(currentlySelectedOption), false);
            if (self2.hasOption(value)) {
              self2.removeUnknownOption();
              var hashedVal = hashKey(value);
              $element.val(hashedVal in self2.selectValueMap ? hashedVal : value);
              var selectedOption = $element[0].options[$element[0].selectedIndex];
              setOptionSelectedStatus(jqLite(selectedOption), true);
            } else {
              self2.selectUnknownOrEmptyOption(value);
            }
          };
          self2.addOption = function(value, element2) {
            if (element2[0].nodeType === NODE_TYPE_COMMENT)
              return;
            assertNotHasOwnProperty(value, '"option value"');
            if (value === "") {
              self2.hasEmptyOption = true;
              self2.emptyOption = element2;
            }
            var count = optionsMap.get(value) || 0;
            optionsMap.set(value, count + 1);
            scheduleRender();
          };
          self2.removeOption = function(value) {
            var count = optionsMap.get(value);
            if (count) {
              if (count === 1) {
                optionsMap.delete(value);
                if (value === "") {
                  self2.hasEmptyOption = false;
                  self2.emptyOption = void 0;
                }
              } else {
                optionsMap.set(value, count - 1);
              }
            }
          };
          self2.hasOption = function(value) {
            return !!optionsMap.get(value);
          };
          self2.$hasEmptyOption = function() {
            return self2.hasEmptyOption;
          };
          self2.$isUnknownOptionSelected = function() {
            return $element[0].options[0] === self2.unknownOption[0];
          };
          self2.$isEmptyOptionSelected = function() {
            return self2.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self2.emptyOption[0];
          };
          self2.selectUnknownOrEmptyOption = function(value) {
            if (value == null && self2.emptyOption) {
              self2.removeUnknownOption();
              self2.selectEmptyOption();
            } else if (self2.unknownOption.parent().length) {
              self2.updateUnknownOption(value);
            } else {
              self2.renderUnknownOption(value);
            }
          };
          var renderScheduled = false;
          function scheduleRender() {
            if (renderScheduled)
              return;
            renderScheduled = true;
            $scope.$$postDigest(function() {
              renderScheduled = false;
              self2.ngModelCtrl.$render();
            });
          }
          var updateScheduled = false;
          function scheduleViewValueUpdate(renderAfter) {
            if (updateScheduled)
              return;
            updateScheduled = true;
            $scope.$$postDigest(function() {
              if ($scope.$$destroyed)
                return;
              updateScheduled = false;
              self2.ngModelCtrl.$setViewValue(self2.readValue());
              if (renderAfter)
                self2.ngModelCtrl.$render();
            });
          }
          self2.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            if (optionAttrs.$attr.ngValue) {
              var oldVal, hashedVal;
              optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                var removal;
                var previouslySelected = optionElement.prop("selected");
                if (isDefined(hashedVal)) {
                  self2.removeOption(oldVal);
                  delete self2.selectValueMap[hashedVal];
                  removal = true;
                }
                hashedVal = hashKey(newVal);
                oldVal = newVal;
                self2.selectValueMap[hashedVal] = newVal;
                self2.addOption(newVal, optionElement);
                optionElement.attr("value", hashedVal);
                if (removal && previouslySelected) {
                  scheduleViewValueUpdate();
                }
              });
            } else if (interpolateValueFn) {
              optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                self2.readValue();
                var removal;
                var previouslySelected = optionElement.prop("selected");
                if (isDefined(oldVal)) {
                  self2.removeOption(oldVal);
                  removal = true;
                }
                oldVal = newVal;
                self2.addOption(newVal, optionElement);
                if (removal && previouslySelected) {
                  scheduleViewValueUpdate();
                }
              });
            } else if (interpolateTextFn) {
              optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal2) {
                optionAttrs.$set("value", newVal);
                var previouslySelected = optionElement.prop("selected");
                if (oldVal2 !== newVal) {
                  self2.removeOption(oldVal2);
                }
                self2.addOption(newVal, optionElement);
                if (oldVal2 && previouslySelected) {
                  scheduleViewValueUpdate();
                }
              });
            } else {
              self2.addOption(optionAttrs.value, optionElement);
            }
            optionAttrs.$observe("disabled", function(newVal) {
              if (newVal === "true" || newVal && optionElement.prop("selected")) {
                if (self2.multiple) {
                  scheduleViewValueUpdate(true);
                } else {
                  self2.ngModelCtrl.$setViewValue(null);
                  self2.ngModelCtrl.$render();
                }
              }
            });
            optionElement.on("$destroy", function() {
              var currentValue = self2.readValue();
              var removeValue = optionAttrs.value;
              self2.removeOption(removeValue);
              scheduleRender();
              if (self2.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) {
                scheduleViewValueUpdate(true);
              }
            });
          };
        }];
        var selectDirective = function() {
          return {
            restrict: "E",
            require: ["select", "?ngModel"],
            controller: SelectController,
            priority: 1,
            link: {
              pre: selectPreLink,
              post: selectPostLink
            }
          };
          function selectPreLink(scope, element2, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) {
              selectCtrl.registerOption = noop3;
              return;
            }
            selectCtrl.ngModelCtrl = ngModelCtrl;
            element2.on("change", function() {
              selectCtrl.removeUnknownOption();
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.multiple = true;
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element2.find("option"), function(option) {
                  if (option.selected && !option.disabled) {
                    var val = option.value;
                    array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                forEach(element2.find("option"), function(option) {
                  var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                  var currentlySelected = option.selected;
                  if (shouldBeSelected !== currentlySelected) {
                    setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                  }
                });
              };
              var lastView, lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
          function selectPostLink(scope, element2, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
          }
        };
        var optionDirective = ["$interpolate", function($interpolate) {
          return {
            restrict: "E",
            priority: 100,
            compile: function(element2, attr) {
              var interpolateValueFn, interpolateTextFn;
              if (isDefined(attr.ngValue)) {
              } else if (isDefined(attr.value)) {
                interpolateValueFn = $interpolate(attr.value, true);
              } else {
                interpolateTextFn = $interpolate(element2.text(), true);
                if (!interpolateTextFn) {
                  attr.$set("value", element2.text());
                }
              }
              return function(scope, element3, attr2) {
                var selectCtrlName = "$selectController", parent = element3.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                if (selectCtrl) {
                  selectCtrl.registerOption(scope, element3, attr2, interpolateValueFn, interpolateTextFn);
                }
              };
            }
          };
        }];
        var requiredDirective = ["$parse", function($parse) {
          return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
              if (!ctrl)
                return;
              var value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope);
              if (!attr.ngRequired) {
                attr.required = true;
              }
              ctrl.$validators.required = function(modelValue, viewValue) {
                return !value || !ctrl.$isEmpty(viewValue);
              };
              attr.$observe("required", function(newVal) {
                if (value !== newVal) {
                  value = newVal;
                  ctrl.$validate();
                }
              });
            }
          };
        }];
        var patternDirective = ["$parse", function($parse) {
          return {
            restrict: "A",
            require: "?ngModel",
            compile: function(tElm, tAttr) {
              var patternExp;
              var parseFn;
              if (tAttr.ngPattern) {
                patternExp = tAttr.ngPattern;
                if (tAttr.ngPattern.charAt(0) === "/" && REGEX_STRING_REGEXP.test(tAttr.ngPattern)) {
                  parseFn = function() {
                    return tAttr.ngPattern;
                  };
                } else {
                  parseFn = $parse(tAttr.ngPattern);
                }
              }
              return function(scope, elm, attr, ctrl) {
                if (!ctrl)
                  return;
                var attrVal = attr.pattern;
                if (attr.ngPattern) {
                  attrVal = parseFn(scope);
                } else {
                  patternExp = attr.pattern;
                }
                var regexp = parsePatternAttr(attrVal, patternExp, elm);
                attr.$observe("pattern", function(newVal) {
                  var oldRegexp = regexp;
                  regexp = parsePatternAttr(newVal, patternExp, elm);
                  if ((oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString())) {
                    ctrl.$validate();
                  }
                });
                ctrl.$validators.pattern = function(modelValue, viewValue) {
                  return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                };
              };
            }
          };
        }];
        var maxlengthDirective = ["$parse", function($parse) {
          return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
              if (!ctrl)
                return;
              var maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope);
              var maxlengthParsed = parseLength(maxlength);
              attr.$observe("maxlength", function(value) {
                if (maxlength !== value) {
                  maxlengthParsed = parseLength(value);
                  maxlength = value;
                  ctrl.$validate();
                }
              });
              ctrl.$validators.maxlength = function(modelValue, viewValue) {
                return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed;
              };
            }
          };
        }];
        var minlengthDirective = ["$parse", function($parse) {
          return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
              if (!ctrl)
                return;
              var minlength = attr.minlength || $parse(attr.ngMinlength)(scope);
              var minlengthParsed = parseLength(minlength) || -1;
              attr.$observe("minlength", function(value) {
                if (minlength !== value) {
                  minlengthParsed = parseLength(value) || -1;
                  minlength = value;
                  ctrl.$validate();
                }
              });
              ctrl.$validators.minlength = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
              };
            }
          };
        }];
        function parsePatternAttr(regex, patternExp, elm) {
          if (!regex)
            return void 0;
          if (isString(regex)) {
            regex = new RegExp("^" + regex + "$");
          }
          if (!regex.test) {
            throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
          }
          return regex;
        }
        function parseLength(val) {
          var intVal = toInt(val);
          return isNumberNaN(intVal) ? -1 : intVal;
        }
        if (window2.angular.bootstrap) {
          if (window2.console) {
            console.log("WARNING: Tried to load AngularJS more than once.");
          }
          return;
        }
        bindJQuery();
        publishExternalAPI(angular3);
        angular3.module("ngLocale", [], ["$provide", function($provide) {
          var PLURAL_CATEGORY = { ZERO: "zero", ONE: "one", TWO: "two", FEW: "few", MANY: "many", OTHER: "other" };
          function getDecimals(n) {
            n = n + "";
            var i = n.indexOf(".");
            return i == -1 ? 0 : n.length - i - 1;
          }
          function getVF(n, opt_precision) {
            var v = opt_precision;
            if (v === void 0) {
              v = Math.min(getDecimals(n), 3);
            }
            var base = Math.pow(10, v);
            var f = (n * base | 0) % base;
            return { v, f };
          }
          $provide.value("$locale", {
            "DATETIME_FORMATS": {
              "AMPMS": [
                "AM",
                "PM"
              ],
              "DAY": [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday"
              ],
              "ERANAMES": [
                "Before Christ",
                "Anno Domini"
              ],
              "ERAS": [
                "BC",
                "AD"
              ],
              "FIRSTDAYOFWEEK": 6,
              "MONTH": [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December"
              ],
              "SHORTDAY": [
                "Sun",
                "Mon",
                "Tue",
                "Wed",
                "Thu",
                "Fri",
                "Sat"
              ],
              "SHORTMONTH": [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ],
              "STANDALONEMONTH": [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December"
              ],
              "WEEKENDRANGE": [
                5,
                6
              ],
              "fullDate": "EEEE, MMMM d, y",
              "longDate": "MMMM d, y",
              "medium": "MMM d, y h:mm:ss a",
              "mediumDate": "MMM d, y",
              "mediumTime": "h:mm:ss a",
              "short": "M/d/yy h:mm a",
              "shortDate": "M/d/yy",
              "shortTime": "h:mm a"
            },
            "NUMBER_FORMATS": {
              "CURRENCY_SYM": "$",
              "DECIMAL_SEP": ".",
              "GROUP_SEP": ",",
              "PATTERNS": [
                {
                  "gSize": 3,
                  "lgSize": 3,
                  "maxFrac": 3,
                  "minFrac": 0,
                  "minInt": 1,
                  "negPre": "-",
                  "negSuf": "",
                  "posPre": "",
                  "posSuf": ""
                },
                {
                  "gSize": 3,
                  "lgSize": 3,
                  "maxFrac": 2,
                  "minFrac": 2,
                  "minInt": 1,
                  "negPre": "-\xA4",
                  "negSuf": "",
                  "posPre": "\xA4",
                  "posSuf": ""
                }
              ]
            },
            "id": "en-us",
            "localeID": "en_US",
            "pluralCat": function(n, opt_precision) {
              var i = n | 0;
              var vf = getVF(n, opt_precision);
              if (i == 1 && vf.v == 0) {
                return PLURAL_CATEGORY.ONE;
              }
              return PLURAL_CATEGORY.OTHER;
            }
          });
        }]);
        jqLite(function() {
          angularInit(window2.document, bootstrap);
        });
      })(window);
      !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(window.angular.element("<style>").text('@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}'));
    }
  });

  // node_modules/angular/index.js
  var require_angular2 = __commonJS({
    "node_modules/angular/index.js"(exports, module) {
      require_angular();
      module.exports = angular;
    }
  });

  // node_modules/zone.js/fesm2015/zone.js
  (function(global2) {
    const performance = global2["performance"];
    function mark(name) {
      performance && performance["mark"] && performance["mark"](name);
    }
    function performanceMeasure(name, label) {
      performance && performance["measure"] && performance["measure"](name, label);
    }
    mark("Zone");
    const symbolPrefix = global2["__Zone_symbol_prefix"] || "__zone_symbol__";
    function __symbol__(name) {
      return symbolPrefix + name;
    }
    const checkDuplicate = global2[__symbol__("forceDuplicateZoneCheck")] === true;
    if (global2["Zone"]) {
      if (checkDuplicate || typeof global2["Zone"].__symbol__ !== "function") {
        throw new Error("Zone already loaded.");
      } else {
        return global2["Zone"];
      }
    }
    class Zone2 {
      constructor(parent, zoneSpec) {
        this._parent = parent;
        this._name = zoneSpec ? zoneSpec.name || "unnamed" : "<root>";
        this._properties = zoneSpec && zoneSpec.properties || {};
        this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
      }
      static assertZonePatched() {
        if (global2["Promise"] !== patches["ZoneAwarePromise"]) {
          throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
        }
      }
      static get root() {
        let zone = Zone2.current;
        while (zone.parent) {
          zone = zone.parent;
        }
        return zone;
      }
      static get current() {
        return _currentZoneFrame.zone;
      }
      static get currentTask() {
        return _currentTask;
      }
      static __load_patch(name, fn2, ignoreDuplicate = false) {
        if (patches.hasOwnProperty(name)) {
          if (!ignoreDuplicate && checkDuplicate) {
            throw Error("Already loaded patch: " + name);
          }
        } else if (!global2["__Zone_disable_" + name]) {
          const perfName = "Zone:" + name;
          mark(perfName);
          patches[name] = fn2(global2, Zone2, _api);
          performanceMeasure(perfName, perfName);
        }
      }
      get parent() {
        return this._parent;
      }
      get name() {
        return this._name;
      }
      get(key) {
        const zone = this.getZoneWith(key);
        if (zone)
          return zone._properties[key];
      }
      getZoneWith(key) {
        let current = this;
        while (current) {
          if (current._properties.hasOwnProperty(key)) {
            return current;
          }
          current = current._parent;
        }
        return null;
      }
      fork(zoneSpec) {
        if (!zoneSpec)
          throw new Error("ZoneSpec required!");
        return this._zoneDelegate.fork(this, zoneSpec);
      }
      wrap(callback, source) {
        if (typeof callback !== "function") {
          throw new Error("Expecting function got: " + callback);
        }
        const _callback = this._zoneDelegate.intercept(this, callback, source);
        const zone = this;
        return function() {
          return zone.runGuarded(_callback, this, arguments, source);
        };
      }
      run(callback, applyThis, applyArgs, source) {
        _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
        try {
          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      }
      runGuarded(callback, applyThis = null, applyArgs, source) {
        _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
        try {
          try {
            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
          } catch (error3) {
            if (this._zoneDelegate.handleError(this, error3)) {
              throw error3;
            }
          }
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      }
      runTask(task, applyThis, applyArgs) {
        if (task.zone != this) {
          throw new Error("A task can only be run in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
        }
        if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {
          return;
        }
        const reEntryGuard = task.state != running;
        reEntryGuard && task._transitionTo(running, scheduled2);
        task.runCount++;
        const previousTask = _currentTask;
        _currentTask = task;
        _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
        try {
          if (task.type == macroTask && task.data && !task.data.isPeriodic) {
            task.cancelFn = void 0;
          }
          try {
            return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
          } catch (error3) {
            if (this._zoneDelegate.handleError(this, error3)) {
              throw error3;
            }
          }
        } finally {
          if (task.state !== notScheduled && task.state !== unknown) {
            if (task.type == eventTask || task.data && task.data.isPeriodic) {
              reEntryGuard && task._transitionTo(scheduled2, running);
            } else {
              task.runCount = 0;
              this._updateTaskCount(task, -1);
              reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);
            }
          }
          _currentZoneFrame = _currentZoneFrame.parent;
          _currentTask = previousTask;
        }
      }
      scheduleTask(task) {
        if (task.zone && task.zone !== this) {
          let newZone = this;
          while (newZone) {
            if (newZone === task.zone) {
              throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
            }
            newZone = newZone.parent;
          }
        }
        task._transitionTo(scheduling, notScheduled);
        const zoneDelegates = [];
        task._zoneDelegates = zoneDelegates;
        task._zone = this;
        try {
          task = this._zoneDelegate.scheduleTask(this, task);
        } catch (err) {
          task._transitionTo(unknown, scheduling, notScheduled);
          this._zoneDelegate.handleError(this, err);
          throw err;
        }
        if (task._zoneDelegates === zoneDelegates) {
          this._updateTaskCount(task, 1);
        }
        if (task.state == scheduling) {
          task._transitionTo(scheduled2, scheduling);
        }
        return task;
      }
      scheduleMicroTask(source, callback, data, customSchedule) {
        return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));
      }
      scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
      }
      scheduleEventTask(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
      }
      cancelTask(task) {
        if (task.zone != this)
          throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
        task._transitionTo(canceling, scheduled2, running);
        try {
          this._zoneDelegate.cancelTask(this, task);
        } catch (err) {
          task._transitionTo(unknown, canceling);
          this._zoneDelegate.handleError(this, err);
          throw err;
        }
        this._updateTaskCount(task, -1);
        task._transitionTo(notScheduled, canceling);
        task.runCount = 0;
        return task;
      }
      _updateTaskCount(task, count) {
        const zoneDelegates = task._zoneDelegates;
        if (count == -1) {
          task._zoneDelegates = null;
        }
        for (let i = 0; i < zoneDelegates.length; i++) {
          zoneDelegates[i]._updateTaskCount(task.type, count);
        }
      }
    }
    Zone2.__symbol__ = __symbol__;
    const DELEGATE_ZS = {
      name: "",
      onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
      onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),
      onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
      onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)
    };
    class _ZoneDelegate {
      constructor(zone, parentDelegate, zoneSpec) {
        this._taskCounts = { "microTask": 0, "macroTask": 0, "eventTask": 0 };
        this.zone = zone;
        this._parentDelegate = parentDelegate;
        this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
        this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
        this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);
        this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
        this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
        this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);
        this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
        this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
        this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);
        this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
        this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
        this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);
        this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
        this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
        this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);
        this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
        this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
        this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);
        this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
        this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
        this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);
        this._hasTaskZS = null;
        this._hasTaskDlgt = null;
        this._hasTaskDlgtOwner = null;
        this._hasTaskCurrZone = null;
        const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
        const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
        if (zoneSpecHasTask || parentHasTask) {
          this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
          this._hasTaskDlgt = parentDelegate;
          this._hasTaskDlgtOwner = this;
          this._hasTaskCurrZone = zone;
          if (!zoneSpec.onScheduleTask) {
            this._scheduleTaskZS = DELEGATE_ZS;
            this._scheduleTaskDlgt = parentDelegate;
            this._scheduleTaskCurrZone = this.zone;
          }
          if (!zoneSpec.onInvokeTask) {
            this._invokeTaskZS = DELEGATE_ZS;
            this._invokeTaskDlgt = parentDelegate;
            this._invokeTaskCurrZone = this.zone;
          }
          if (!zoneSpec.onCancelTask) {
            this._cancelTaskZS = DELEGATE_ZS;
            this._cancelTaskDlgt = parentDelegate;
            this._cancelTaskCurrZone = this.zone;
          }
        }
      }
      fork(targetZone, zoneSpec) {
        return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone2(targetZone, zoneSpec);
      }
      intercept(targetZone, callback, source) {
        return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
      }
      invoke(targetZone, callback, applyThis, applyArgs, source) {
        return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
      }
      handleError(targetZone, error3) {
        return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error3) : true;
      }
      scheduleTask(targetZone, task) {
        let returnTask = task;
        if (this._scheduleTaskZS) {
          if (this._hasTaskZS) {
            returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
          }
          returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
          if (!returnTask)
            returnTask = task;
        } else {
          if (task.scheduleFn) {
            task.scheduleFn(task);
          } else if (task.type == microTask) {
            scheduleMicroTask3(task);
          } else {
            throw new Error("Task is missing scheduleFn.");
          }
        }
        return returnTask;
      }
      invokeTask(targetZone, task, applyThis, applyArgs) {
        return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
      }
      cancelTask(targetZone, task) {
        let value;
        if (this._cancelTaskZS) {
          value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
        } else {
          if (!task.cancelFn) {
            throw Error("Task is not cancelable");
          }
          value = task.cancelFn(task);
        }
        return value;
      }
      hasTask(targetZone, isEmpty) {
        try {
          this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
        } catch (err) {
          this.handleError(targetZone, err);
        }
      }
      _updateTaskCount(type, count) {
        const counts = this._taskCounts;
        const prev = counts[type];
        const next = counts[type] = prev + count;
        if (next < 0) {
          throw new Error("More tasks executed then were scheduled.");
        }
        if (prev == 0 || next == 0) {
          const isEmpty = {
            microTask: counts["microTask"] > 0,
            macroTask: counts["macroTask"] > 0,
            eventTask: counts["eventTask"] > 0,
            change: type
          };
          this.hasTask(this.zone, isEmpty);
        }
      }
    }
    class ZoneTask {
      constructor(type, source, callback, options, scheduleFn, cancelFn) {
        this._zone = null;
        this.runCount = 0;
        this._zoneDelegates = null;
        this._state = "notScheduled";
        this.type = type;
        this.source = source;
        this.data = options;
        this.scheduleFn = scheduleFn;
        this.cancelFn = cancelFn;
        if (!callback) {
          throw new Error("callback is not defined");
        }
        this.callback = callback;
        const self2 = this;
        if (type === eventTask && options && options.useG) {
          this.invoke = ZoneTask.invokeTask;
        } else {
          this.invoke = function() {
            return ZoneTask.invokeTask.call(global2, self2, this, arguments);
          };
        }
      }
      static invokeTask(task, target, args) {
        if (!task) {
          task = this;
        }
        _numberOfNestedTaskFrames++;
        try {
          task.runCount++;
          return task.zone.runTask(task, target, args);
        } finally {
          if (_numberOfNestedTaskFrames == 1) {
            drainMicroTaskQueue();
          }
          _numberOfNestedTaskFrames--;
        }
      }
      get zone() {
        return this._zone;
      }
      get state() {
        return this._state;
      }
      cancelScheduleRequest() {
        this._transitionTo(notScheduled, scheduling);
      }
      _transitionTo(toState, fromState1, fromState2) {
        if (this._state === fromState1 || this._state === fromState2) {
          this._state = toState;
          if (toState == notScheduled) {
            this._zoneDelegates = null;
          }
        } else {
          throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ""}, was '${this._state}'.`);
        }
      }
      toString() {
        if (this.data && typeof this.data.handleId !== "undefined") {
          return this.data.handleId.toString();
        } else {
          return Object.prototype.toString.call(this);
        }
      }
      toJSON() {
        return {
          type: this.type,
          state: this.state,
          source: this.source,
          zone: this.zone.name,
          runCount: this.runCount
        };
      }
    }
    const symbolSetTimeout = __symbol__("setTimeout");
    const symbolPromise = __symbol__("Promise");
    const symbolThen = __symbol__("then");
    let _microTaskQueue = [];
    let _isDrainingMicrotaskQueue = false;
    let nativeMicroTaskQueuePromise;
    function nativeScheduleMicroTask(func) {
      if (!nativeMicroTaskQueuePromise) {
        if (global2[symbolPromise]) {
          nativeMicroTaskQueuePromise = global2[symbolPromise].resolve(0);
        }
      }
      if (nativeMicroTaskQueuePromise) {
        let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
        if (!nativeThen) {
          nativeThen = nativeMicroTaskQueuePromise["then"];
        }
        nativeThen.call(nativeMicroTaskQueuePromise, func);
      } else {
        global2[symbolSetTimeout](func, 0);
      }
    }
    function scheduleMicroTask3(task) {
      if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
        nativeScheduleMicroTask(drainMicroTaskQueue);
      }
      task && _microTaskQueue.push(task);
    }
    function drainMicroTaskQueue() {
      if (!_isDrainingMicrotaskQueue) {
        _isDrainingMicrotaskQueue = true;
        while (_microTaskQueue.length) {
          const queue2 = _microTaskQueue;
          _microTaskQueue = [];
          for (let i = 0; i < queue2.length; i++) {
            const task = queue2[i];
            try {
              task.zone.runTask(task, null, null);
            } catch (error3) {
              _api.onUnhandledError(error3);
            }
          }
        }
        _api.microtaskDrainDone();
        _isDrainingMicrotaskQueue = false;
      }
    }
    const NO_ZONE = { name: "NO ZONE" };
    const notScheduled = "notScheduled", scheduling = "scheduling", scheduled2 = "scheduled", running = "running", canceling = "canceling", unknown = "unknown";
    const microTask = "microTask", macroTask = "macroTask", eventTask = "eventTask";
    const patches = {};
    const _api = {
      symbol: __symbol__,
      currentZoneFrame: () => _currentZoneFrame,
      onUnhandledError: noop3,
      microtaskDrainDone: noop3,
      scheduleMicroTask: scheduleMicroTask3,
      showUncaughtError: () => !Zone2[__symbol__("ignoreConsoleErrorUncaughtError")],
      patchEventTarget: () => [],
      patchOnProperties: noop3,
      patchMethod: () => noop3,
      bindArguments: () => [],
      patchThen: () => noop3,
      patchMacroTask: () => noop3,
      patchEventPrototype: () => noop3,
      isIEOrEdge: () => false,
      getGlobalObjects: () => void 0,
      ObjectDefineProperty: () => noop3,
      ObjectGetOwnPropertyDescriptor: () => void 0,
      ObjectCreate: () => void 0,
      ArraySlice: () => [],
      patchClass: () => noop3,
      wrapWithCurrentZone: () => noop3,
      filterProperties: () => [],
      attachOriginToPatched: () => noop3,
      _redefineProperty: () => noop3,
      patchCallbacks: () => noop3,
      nativeScheduleMicroTask
    };
    let _currentZoneFrame = { parent: null, zone: new Zone2(null, null) };
    let _currentTask = null;
    let _numberOfNestedTaskFrames = 0;
    function noop3() {
    }
    performanceMeasure("Zone", "Zone");
    return global2["Zone"] = Zone2;
  })(typeof window !== "undefined" && window || typeof self !== "undefined" && self || global);
  var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ObjectDefineProperty = Object.defineProperty;
  var ObjectGetPrototypeOf = Object.getPrototypeOf;
  var ObjectCreate = Object.create;
  var ArraySlice = Array.prototype.slice;
  var ADD_EVENT_LISTENER_STR = "addEventListener";
  var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
  var ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);
  var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);
  var TRUE_STR = "true";
  var FALSE_STR = "false";
  var ZONE_SYMBOL_PREFIX = Zone.__symbol__("");
  function wrapWithCurrentZone(callback, source) {
    return Zone.current.wrap(callback, source);
  }
  function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
  }
  var zoneSymbol = Zone.__symbol__;
  var isWindowExists = typeof window !== "undefined";
  var internalWindow = isWindowExists ? window : void 0;
  var _global = isWindowExists && internalWindow || typeof self === "object" && self || global;
  var REMOVE_ATTRIBUTE = "removeAttribute";
  function bindArguments(args, source) {
    for (let i = args.length - 1; i >= 0; i--) {
      if (typeof args[i] === "function") {
        args[i] = wrapWithCurrentZone(args[i], source + "_" + i);
      }
    }
    return args;
  }
  function patchPrototype(prototype, fnNames) {
    const source = prototype.constructor["name"];
    for (let i = 0; i < fnNames.length; i++) {
      const name = fnNames[i];
      const delegate = prototype[name];
      if (delegate) {
        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
        if (!isPropertyWritable(prototypeDesc)) {
          continue;
        }
        prototype[name] = ((delegate2) => {
          const patched = function() {
            return delegate2.apply(this, bindArguments(arguments, source + "." + name));
          };
          attachOriginToPatched(patched, delegate2);
          return patched;
        })(delegate);
      }
    }
  }
  function isPropertyWritable(propertyDesc) {
    if (!propertyDesc) {
      return true;
    }
    if (propertyDesc.writable === false) {
      return false;
    }
    return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
  }
  var isWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
  var isNode = !("nw" in _global) && typeof _global.process !== "undefined" && {}.toString.call(_global.process) === "[object process]";
  var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
  var isMix = typeof _global.process !== "undefined" && {}.toString.call(_global.process) === "[object process]" && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
  var zoneSymbolEventNames$1 = {};
  var wrapFn = function(event) {
    event = event || _global.event;
    if (!event) {
      return;
    }
    let eventNameSymbol = zoneSymbolEventNames$1[event.type];
    if (!eventNameSymbol) {
      eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol("ON_PROPERTY" + event.type);
    }
    const target = this || event.target || _global;
    const listener = target[eventNameSymbol];
    let result;
    if (isBrowser && target === internalWindow && event.type === "error") {
      const errorEvent = event;
      result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
      if (result === true) {
        event.preventDefault();
      }
    } else {
      result = listener && listener.apply(this, arguments);
      if (result != void 0 && !result) {
        event.preventDefault();
      }
    }
    return result;
  };
  function patchProperty(obj, prop, prototype) {
    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
    if (!desc && prototype) {
      const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
      if (prototypeDesc) {
        desc = { enumerable: true, configurable: true };
      }
    }
    if (!desc || !desc.configurable) {
      return;
    }
    const onPropPatchedSymbol = zoneSymbol("on" + prop + "patched");
    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
      return;
    }
    delete desc.writable;
    delete desc.value;
    const originalDescGet = desc.get;
    const originalDescSet = desc.set;
    const eventName = prop.substr(2);
    let eventNameSymbol = zoneSymbolEventNames$1[eventName];
    if (!eventNameSymbol) {
      eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol("ON_PROPERTY" + eventName);
    }
    desc.set = function(newValue) {
      let target = this;
      if (!target && obj === _global) {
        target = _global;
      }
      if (!target) {
        return;
      }
      const previousValue = target[eventNameSymbol];
      if (typeof previousValue === "function") {
        target.removeEventListener(eventName, wrapFn);
      }
      originalDescSet && originalDescSet.call(target, null);
      target[eventNameSymbol] = newValue;
      if (typeof newValue === "function") {
        target.addEventListener(eventName, wrapFn, false);
      }
    };
    desc.get = function() {
      let target = this;
      if (!target && obj === _global) {
        target = _global;
      }
      if (!target) {
        return null;
      }
      const listener = target[eventNameSymbol];
      if (listener) {
        return listener;
      } else if (originalDescGet) {
        let value = originalDescGet.call(this);
        if (value) {
          desc.set.call(this, value);
          if (typeof target[REMOVE_ATTRIBUTE] === "function") {
            target.removeAttribute(prop);
          }
          return value;
        }
      }
      return null;
    };
    ObjectDefineProperty(obj, prop, desc);
    obj[onPropPatchedSymbol] = true;
  }
  function patchOnProperties(obj, properties, prototype) {
    if (properties) {
      for (let i = 0; i < properties.length; i++) {
        patchProperty(obj, "on" + properties[i], prototype);
      }
    } else {
      const onProperties = [];
      for (const prop in obj) {
        if (prop.substr(0, 2) == "on") {
          onProperties.push(prop);
        }
      }
      for (let j = 0; j < onProperties.length; j++) {
        patchProperty(obj, onProperties[j], prototype);
      }
    }
  }
  var originalInstanceKey = zoneSymbol("originalInstance");
  function patchClass(className) {
    const OriginalClass = _global[className];
    if (!OriginalClass)
      return;
    _global[zoneSymbol(className)] = OriginalClass;
    _global[className] = function() {
      const a = bindArguments(arguments, className);
      switch (a.length) {
        case 0:
          this[originalInstanceKey] = new OriginalClass();
          break;
        case 1:
          this[originalInstanceKey] = new OriginalClass(a[0]);
          break;
        case 2:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
          break;
        case 3:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
          break;
        case 4:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
          break;
        default:
          throw new Error("Arg list too long.");
      }
    };
    attachOriginToPatched(_global[className], OriginalClass);
    const instance = new OriginalClass(function() {
    });
    let prop;
    for (prop in instance) {
      if (className === "XMLHttpRequest" && prop === "responseBlob")
        continue;
      (function(prop2) {
        if (typeof instance[prop2] === "function") {
          _global[className].prototype[prop2] = function() {
            return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);
          };
        } else {
          ObjectDefineProperty(_global[className].prototype, prop2, {
            set: function(fn2) {
              if (typeof fn2 === "function") {
                this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn2, className + "." + prop2);
                attachOriginToPatched(this[originalInstanceKey][prop2], fn2);
              } else {
                this[originalInstanceKey][prop2] = fn2;
              }
            },
            get: function() {
              return this[originalInstanceKey][prop2];
            }
          });
        }
      })(prop);
    }
    for (prop in OriginalClass) {
      if (prop !== "prototype" && OriginalClass.hasOwnProperty(prop)) {
        _global[className][prop] = OriginalClass[prop];
      }
    }
  }
  function patchMethod(target, name, patchFn) {
    let proto = target;
    while (proto && !proto.hasOwnProperty(name)) {
      proto = ObjectGetPrototypeOf(proto);
    }
    if (!proto && target[name]) {
      proto = target;
    }
    const delegateName = zoneSymbol(name);
    let delegate = null;
    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
      delegate = proto[delegateName] = proto[name];
      const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
      if (isPropertyWritable(desc)) {
        const patchDelegate = patchFn(delegate, delegateName, name);
        proto[name] = function() {
          return patchDelegate(this, arguments);
        };
        attachOriginToPatched(proto[name], delegate);
      }
    }
    return delegate;
  }
  function patchMacroTask(obj, funcName, metaCreator) {
    let setNative = null;
    function scheduleTask(task) {
      const data = task.data;
      data.args[data.cbIdx] = function() {
        task.invoke.apply(this, arguments);
      };
      setNative.apply(data.target, data.args);
      return task;
    }
    setNative = patchMethod(obj, funcName, (delegate) => function(self2, args) {
      const meta = metaCreator(self2, args);
      if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === "function") {
        return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
      } else {
        return delegate.apply(self2, args);
      }
    });
  }
  function attachOriginToPatched(patched, original) {
    patched[zoneSymbol("OriginalDelegate")] = original;
  }
  var isDetectedIEOrEdge = false;
  var ieOrEdge = false;
  function isIE() {
    try {
      const ua = internalWindow.navigator.userAgent;
      if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1) {
        return true;
      }
    } catch (error3) {
    }
    return false;
  }
  function isIEOrEdge() {
    if (isDetectedIEOrEdge) {
      return ieOrEdge;
    }
    isDetectedIEOrEdge = true;
    try {
      const ua = internalWindow.navigator.userAgent;
      if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1 || ua.indexOf("Edge/") !== -1) {
        ieOrEdge = true;
      }
    } catch (error3) {
    }
    return ieOrEdge;
  }
  Zone.__load_patch("ZoneAwarePromise", (global2, Zone2, api) => {
    const ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    const ObjectDefineProperty2 = Object.defineProperty;
    function readableObjectToString(obj) {
      if (obj && obj.toString === Object.prototype.toString) {
        const className = obj.constructor && obj.constructor.name;
        return (className ? className : "") + ": " + JSON.stringify(obj);
      }
      return obj ? obj.toString() : Object.prototype.toString.call(obj);
    }
    const __symbol__ = api.symbol;
    const _uncaughtPromiseErrors = [];
    const isDisableWrappingUncaughtPromiseRejection = global2[__symbol__("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] === true;
    const symbolPromise = __symbol__("Promise");
    const symbolThen = __symbol__("then");
    const creationTrace2 = "__creationTrace__";
    api.onUnhandledError = (e) => {
      if (api.showUncaughtError()) {
        const rejection = e && e.rejection;
        if (rejection) {
          console.error("Unhandled Promise rejection:", rejection instanceof Error ? rejection.message : rejection, "; Zone:", e.zone.name, "; Task:", e.task && e.task.source, "; Value:", rejection, rejection instanceof Error ? rejection.stack : void 0);
        } else {
          console.error(e);
        }
      }
    };
    api.microtaskDrainDone = () => {
      while (_uncaughtPromiseErrors.length) {
        const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
        try {
          uncaughtPromiseError.zone.runGuarded(() => {
            if (uncaughtPromiseError.throwOriginal) {
              throw uncaughtPromiseError.rejection;
            }
            throw uncaughtPromiseError;
          });
        } catch (error3) {
          handleUnhandledRejection(error3);
        }
      }
    };
    const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__("unhandledPromiseRejectionHandler");
    function handleUnhandledRejection(e) {
      api.onUnhandledError(e);
      try {
        const handler = Zone2[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
        if (typeof handler === "function") {
          handler.call(this, e);
        }
      } catch (err) {
      }
    }
    function isThenable(value) {
      return value && value.then;
    }
    function forwardResolution(value) {
      return value;
    }
    function forwardRejection(rejection) {
      return ZoneAwarePromise.reject(rejection);
    }
    const symbolState = __symbol__("state");
    const symbolValue = __symbol__("value");
    const symbolFinally = __symbol__("finally");
    const symbolParentPromiseValue = __symbol__("parentPromiseValue");
    const symbolParentPromiseState = __symbol__("parentPromiseState");
    const source = "Promise.then";
    const UNRESOLVED = null;
    const RESOLVED = true;
    const REJECTED = false;
    const REJECTED_NO_CATCH = 0;
    function makeResolver(promise2, state) {
      return (v) => {
        try {
          resolvePromise(promise2, state, v);
        } catch (err) {
          resolvePromise(promise2, false, err);
        }
      };
    }
    const once = function() {
      let wasCalled = false;
      return function wrapper(wrappedFunction) {
        return function() {
          if (wasCalled) {
            return;
          }
          wasCalled = true;
          wrappedFunction.apply(null, arguments);
        };
      };
    };
    const TYPE_ERROR = "Promise resolved with itself";
    const CURRENT_TASK_TRACE_SYMBOL = __symbol__("currentTaskTrace");
    function resolvePromise(promise2, state, value) {
      const onceWrapper = once();
      if (promise2 === value) {
        throw new TypeError(TYPE_ERROR);
      }
      if (promise2[symbolState] === UNRESOLVED) {
        let then = null;
        try {
          if (typeof value === "object" || typeof value === "function") {
            then = value && value.then;
          }
        } catch (err) {
          onceWrapper(() => {
            resolvePromise(promise2, false, err);
          })();
          return promise2;
        }
        if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
          clearRejectedNoCatch(value);
          resolvePromise(promise2, value[symbolState], value[symbolValue]);
        } else if (state !== REJECTED && typeof then === "function") {
          try {
            then.call(value, onceWrapper(makeResolver(promise2, state)), onceWrapper(makeResolver(promise2, false)));
          } catch (err) {
            onceWrapper(() => {
              resolvePromise(promise2, false, err);
            })();
          }
        } else {
          promise2[symbolState] = state;
          const queue2 = promise2[symbolValue];
          promise2[symbolValue] = value;
          if (promise2[symbolFinally] === symbolFinally) {
            if (state === RESOLVED) {
              promise2[symbolState] = promise2[symbolParentPromiseState];
              promise2[symbolValue] = promise2[symbolParentPromiseValue];
            }
          }
          if (state === REJECTED && value instanceof Error) {
            const trace = Zone2.currentTask && Zone2.currentTask.data && Zone2.currentTask.data[creationTrace2];
            if (trace) {
              ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });
            }
          }
          for (let i = 0; i < queue2.length; ) {
            scheduleResolveOrReject(promise2, queue2[i++], queue2[i++], queue2[i++], queue2[i++]);
          }
          if (queue2.length == 0 && state == REJECTED) {
            promise2[symbolState] = REJECTED_NO_CATCH;
            let uncaughtPromiseError = value;
            try {
              throw new Error("Uncaught (in promise): " + readableObjectToString(value) + (value && value.stack ? "\n" + value.stack : ""));
            } catch (err) {
              uncaughtPromiseError = err;
            }
            if (isDisableWrappingUncaughtPromiseRejection) {
              uncaughtPromiseError.throwOriginal = true;
            }
            uncaughtPromiseError.rejection = value;
            uncaughtPromiseError.promise = promise2;
            uncaughtPromiseError.zone = Zone2.current;
            uncaughtPromiseError.task = Zone2.currentTask;
            _uncaughtPromiseErrors.push(uncaughtPromiseError);
            api.scheduleMicroTask();
          }
        }
      }
      return promise2;
    }
    const REJECTION_HANDLED_HANDLER = __symbol__("rejectionHandledHandler");
    function clearRejectedNoCatch(promise2) {
      if (promise2[symbolState] === REJECTED_NO_CATCH) {
        try {
          const handler = Zone2[REJECTION_HANDLED_HANDLER];
          if (handler && typeof handler === "function") {
            handler.call(this, { rejection: promise2[symbolValue], promise: promise2 });
          }
        } catch (err) {
        }
        promise2[symbolState] = REJECTED;
        for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
          if (promise2 === _uncaughtPromiseErrors[i].promise) {
            _uncaughtPromiseErrors.splice(i, 1);
          }
        }
      }
    }
    function scheduleResolveOrReject(promise2, zone, chainPromise, onFulfilled, onRejected) {
      clearRejectedNoCatch(promise2);
      const promiseState = promise2[symbolState];
      const delegate = promiseState ? typeof onFulfilled === "function" ? onFulfilled : forwardResolution : typeof onRejected === "function" ? onRejected : forwardRejection;
      zone.scheduleMicroTask(source, () => {
        try {
          const parentPromiseValue = promise2[symbolValue];
          const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
          if (isFinallyPromise) {
            chainPromise[symbolParentPromiseValue] = parentPromiseValue;
            chainPromise[symbolParentPromiseState] = promiseState;
          }
          const value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
          resolvePromise(chainPromise, true, value);
        } catch (error3) {
          resolvePromise(chainPromise, false, error3);
        }
      }, chainPromise);
    }
    const ZONE_AWARE_PROMISE_TO_STRING = "function ZoneAwarePromise() { [native code] }";
    const noop3 = function() {
    };
    const AggregateError = global2.AggregateError;
    class ZoneAwarePromise {
      static toString() {
        return ZONE_AWARE_PROMISE_TO_STRING;
      }
      static resolve(value) {
        return resolvePromise(new this(null), RESOLVED, value);
      }
      static reject(error3) {
        return resolvePromise(new this(null), REJECTED, error3);
      }
      static any(values) {
        if (!values || typeof values[Symbol.iterator] !== "function") {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        const promises = [];
        let count = 0;
        try {
          for (let v of values) {
            count++;
            promises.push(ZoneAwarePromise.resolve(v));
          }
        } catch (err) {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        if (count === 0) {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        let finished = false;
        const errors = [];
        return new ZoneAwarePromise((resolve, reject) => {
          for (let i = 0; i < promises.length; i++) {
            promises[i].then((v) => {
              if (finished) {
                return;
              }
              finished = true;
              resolve(v);
            }, (err) => {
              errors.push(err);
              count--;
              if (count === 0) {
                finished = true;
                reject(new AggregateError(errors, "All promises were rejected"));
              }
            });
          }
        });
      }
      static race(values) {
        let resolve;
        let reject;
        let promise2 = new this((res, rej) => {
          resolve = res;
          reject = rej;
        });
        function onResolve(value) {
          resolve(value);
        }
        function onReject(error3) {
          reject(error3);
        }
        for (let value of values) {
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          value.then(onResolve, onReject);
        }
        return promise2;
      }
      static all(values) {
        return ZoneAwarePromise.allWithCallback(values);
      }
      static allSettled(values) {
        const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
        return P.allWithCallback(values, {
          thenCallback: (value) => ({ status: "fulfilled", value }),
          errorCallback: (err) => ({ status: "rejected", reason: err })
        });
      }
      static allWithCallback(values, callback) {
        let resolve;
        let reject;
        let promise2 = new this((res, rej) => {
          resolve = res;
          reject = rej;
        });
        let unresolvedCount = 2;
        let valueIndex = 0;
        const resolvedValues = [];
        for (let value of values) {
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          const curValueIndex = valueIndex;
          try {
            value.then((value2) => {
              resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;
              unresolvedCount--;
              if (unresolvedCount === 0) {
                resolve(resolvedValues);
              }
            }, (err) => {
              if (!callback) {
                reject(err);
              } else {
                resolvedValues[curValueIndex] = callback.errorCallback(err);
                unresolvedCount--;
                if (unresolvedCount === 0) {
                  resolve(resolvedValues);
                }
              }
            });
          } catch (thenErr) {
            reject(thenErr);
          }
          unresolvedCount++;
          valueIndex++;
        }
        unresolvedCount -= 2;
        if (unresolvedCount === 0) {
          resolve(resolvedValues);
        }
        return promise2;
      }
      constructor(executor) {
        const promise2 = this;
        if (!(promise2 instanceof ZoneAwarePromise)) {
          throw new Error("Must be an instanceof Promise.");
        }
        promise2[symbolState] = UNRESOLVED;
        promise2[symbolValue] = [];
        try {
          executor && executor(makeResolver(promise2, RESOLVED), makeResolver(promise2, REJECTED));
        } catch (error3) {
          resolvePromise(promise2, false, error3);
        }
      }
      get [Symbol.toStringTag]() {
        return "Promise";
      }
      get [Symbol.species]() {
        return ZoneAwarePromise;
      }
      then(onFulfilled, onRejected) {
        let C = this.constructor[Symbol.species];
        if (!C || typeof C !== "function") {
          C = this.constructor || ZoneAwarePromise;
        }
        const chainPromise = new C(noop3);
        const zone = Zone2.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
        }
        return chainPromise;
      }
      catch(onRejected) {
        return this.then(null, onRejected);
      }
      finally(onFinally) {
        let C = this.constructor[Symbol.species];
        if (!C || typeof C !== "function") {
          C = ZoneAwarePromise;
        }
        const chainPromise = new C(noop3);
        chainPromise[symbolFinally] = symbolFinally;
        const zone = Zone2.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
        }
        return chainPromise;
      }
    }
    ZoneAwarePromise["resolve"] = ZoneAwarePromise.resolve;
    ZoneAwarePromise["reject"] = ZoneAwarePromise.reject;
    ZoneAwarePromise["race"] = ZoneAwarePromise.race;
    ZoneAwarePromise["all"] = ZoneAwarePromise.all;
    const NativePromise = global2[symbolPromise] = global2["Promise"];
    global2["Promise"] = ZoneAwarePromise;
    const symbolThenPatched = __symbol__("thenPatched");
    function patchThen(Ctor) {
      const proto = Ctor.prototype;
      const prop = ObjectGetOwnPropertyDescriptor2(proto, "then");
      if (prop && (prop.writable === false || !prop.configurable)) {
        return;
      }
      const originalThen = proto.then;
      proto[symbolThen] = originalThen;
      Ctor.prototype.then = function(onResolve, onReject) {
        const wrapped = new ZoneAwarePromise((resolve, reject) => {
          originalThen.call(this, resolve, reject);
        });
        return wrapped.then(onResolve, onReject);
      };
      Ctor[symbolThenPatched] = true;
    }
    api.patchThen = patchThen;
    function zoneify(fn2) {
      return function(self2, args) {
        let resultPromise = fn2.apply(self2, args);
        if (resultPromise instanceof ZoneAwarePromise) {
          return resultPromise;
        }
        let ctor = resultPromise.constructor;
        if (!ctor[symbolThenPatched]) {
          patchThen(ctor);
        }
        return resultPromise;
      };
    }
    if (NativePromise) {
      patchThen(NativePromise);
      patchMethod(global2, "fetch", (delegate) => zoneify(delegate));
    }
    Promise[Zone2.__symbol__("uncaughtPromiseErrors")] = _uncaughtPromiseErrors;
    return ZoneAwarePromise;
  });
  Zone.__load_patch("toString", (global2) => {
    const originalFunctionToString = Function.prototype.toString;
    const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol("OriginalDelegate");
    const PROMISE_SYMBOL = zoneSymbol("Promise");
    const ERROR_SYMBOL = zoneSymbol("Error");
    const newFunctionToString = function toString() {
      if (typeof this === "function") {
        const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
        if (originalDelegate) {
          if (typeof originalDelegate === "function") {
            return originalFunctionToString.call(originalDelegate);
          } else {
            return Object.prototype.toString.call(originalDelegate);
          }
        }
        if (this === Promise) {
          const nativePromise = global2[PROMISE_SYMBOL];
          if (nativePromise) {
            return originalFunctionToString.call(nativePromise);
          }
        }
        if (this === Error) {
          const nativeError = global2[ERROR_SYMBOL];
          if (nativeError) {
            return originalFunctionToString.call(nativeError);
          }
        }
      }
      return originalFunctionToString.call(this);
    };
    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
    Function.prototype.toString = newFunctionToString;
    const originalObjectToString = Object.prototype.toString;
    const PROMISE_OBJECT_TO_STRING = "[object Promise]";
    Object.prototype.toString = function() {
      if (typeof Promise === "function" && this instanceof Promise) {
        return PROMISE_OBJECT_TO_STRING;
      }
      return originalObjectToString.call(this);
    };
  });
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      const options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
    useG: true
  };
  var zoneSymbolEventNames = {};
  var globalSources = {};
  var EVENT_NAME_SYMBOL_REGX = new RegExp("^" + ZONE_SYMBOL_PREFIX + "(\\w+)(true|false)$");
  var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol("propagationStopped");
  function prepareEventNames(eventName, eventNameToString) {
    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
    zoneSymbolEventNames[eventName] = {};
    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
  }
  function patchEventTarget(_global5, api, apis, patchOptions) {
    const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
    const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
    const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || "eventListeners";
    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || "removeAllListeners";
    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
    const ADD_EVENT_LISTENER_SOURCE = "." + ADD_EVENT_LISTENER + ":";
    const PREPEND_EVENT_LISTENER = "prependListener";
    const PREPEND_EVENT_LISTENER_SOURCE = "." + PREPEND_EVENT_LISTENER + ":";
    const invokeTask = function(task, target, event) {
      if (task.isRemoved) {
        return;
      }
      const delegate = task.callback;
      if (typeof delegate === "object" && delegate.handleEvent) {
        task.callback = (event2) => delegate.handleEvent(event2);
        task.originalDelegate = delegate;
      }
      let error3;
      try {
        task.invoke(task, target, [event]);
      } catch (err) {
        error3 = err;
      }
      const options = task.options;
      if (options && typeof options === "object" && options.once) {
        const delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;
        target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);
      }
      return error3;
    };
    function globalCallback(context, event, isCapture) {
      event = event || _global5.event;
      if (!event) {
        return;
      }
      const target = context || event.target || _global5;
      const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
      if (tasks) {
        const errors = [];
        if (tasks.length === 1) {
          const err = invokeTask(tasks[0], target, event);
          err && errors.push(err);
        } else {
          const copyTasks = tasks.slice();
          for (let i = 0; i < copyTasks.length; i++) {
            if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
              break;
            }
            const err = invokeTask(copyTasks[i], target, event);
            err && errors.push(err);
          }
        }
        if (errors.length === 1) {
          throw errors[0];
        } else {
          for (let i = 0; i < errors.length; i++) {
            const err = errors[i];
            api.nativeScheduleMicroTask(() => {
              throw err;
            });
          }
        }
      }
    }
    const globalZoneAwareCallback = function(event) {
      return globalCallback(this, event, false);
    };
    const globalZoneAwareCaptureCallback = function(event) {
      return globalCallback(this, event, true);
    };
    function patchEventTargetMethods(obj, patchOptions2) {
      if (!obj) {
        return false;
      }
      let useGlobalCallback = true;
      if (patchOptions2 && patchOptions2.useG !== void 0) {
        useGlobalCallback = patchOptions2.useG;
      }
      const validateHandler = patchOptions2 && patchOptions2.vh;
      let checkDuplicate = true;
      if (patchOptions2 && patchOptions2.chkDup !== void 0) {
        checkDuplicate = patchOptions2.chkDup;
      }
      let returnTarget = false;
      if (patchOptions2 && patchOptions2.rt !== void 0) {
        returnTarget = patchOptions2.rt;
      }
      let proto = obj;
      while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
        proto = ObjectGetPrototypeOf(proto);
      }
      if (!proto && obj[ADD_EVENT_LISTENER]) {
        proto = obj;
      }
      if (!proto) {
        return false;
      }
      if (proto[zoneSymbolAddEventListener]) {
        return false;
      }
      const eventNameToString = patchOptions2 && patchOptions2.eventNameToString;
      const taskData = {};
      const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
      const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
      const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
      const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
      let nativePrependEventListener;
      if (patchOptions2 && patchOptions2.prepend) {
        nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];
      }
      function buildEventListenerOptions(options, passive) {
        if (!passiveSupported && typeof options === "object" && options) {
          return !!options.capture;
        }
        if (!passiveSupported || !passive) {
          return options;
        }
        if (typeof options === "boolean") {
          return { capture: options, passive: true };
        }
        if (!options) {
          return { passive: true };
        }
        if (typeof options === "object" && options.passive !== false) {
          return Object.assign(Object.assign({}, options), { passive: true });
        }
        return options;
      }
      const customScheduleGlobal = function(task) {
        if (taskData.isExisting) {
          return;
        }
        return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
      };
      const customCancelGlobal = function(task) {
        if (!task.isRemoved) {
          const symbolEventNames = zoneSymbolEventNames[task.eventName];
          let symbolEventName;
          if (symbolEventNames) {
            symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
          }
          const existingTasks = symbolEventName && task.target[symbolEventName];
          if (existingTasks) {
            for (let i = 0; i < existingTasks.length; i++) {
              const existingTask = existingTasks[i];
              if (existingTask === task) {
                existingTasks.splice(i, 1);
                task.isRemoved = true;
                if (existingTasks.length === 0) {
                  task.allRemoved = true;
                  task.target[symbolEventName] = null;
                }
                break;
              }
            }
          }
        }
        if (!task.allRemoved) {
          return;
        }
        return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
      };
      const customScheduleNonGlobal = function(task) {
        return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
      };
      const customSchedulePrepend = function(task) {
        return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
      };
      const customCancelNonGlobal = function(task) {
        return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
      };
      const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
      const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
      const compareTaskCallbackVsDelegate = function(task, delegate) {
        const typeOfDelegate = typeof delegate;
        return typeOfDelegate === "function" && task.callback === delegate || typeOfDelegate === "object" && task.originalDelegate === delegate;
      };
      const compare = patchOptions2 && patchOptions2.diff ? patchOptions2.diff : compareTaskCallbackVsDelegate;
      const unpatchedEvents = Zone[zoneSymbol("UNPATCHED_EVENTS")];
      const passiveEvents = _global5[zoneSymbol("PASSIVE_EVENTS")];
      const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2 = false, prepend = false) {
        return function() {
          const target = this || _global5;
          let eventName = arguments[0];
          if (patchOptions2 && patchOptions2.transferEventName) {
            eventName = patchOptions2.transferEventName(eventName);
          }
          let delegate = arguments[1];
          if (!delegate) {
            return nativeListener.apply(this, arguments);
          }
          if (isNode && eventName === "uncaughtException") {
            return nativeListener.apply(this, arguments);
          }
          let isHandleEvent = false;
          if (typeof delegate !== "function") {
            if (!delegate.handleEvent) {
              return nativeListener.apply(this, arguments);
            }
            isHandleEvent = true;
          }
          if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
            return;
          }
          const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
          const options = buildEventListenerOptions(arguments[2], passive);
          if (unpatchedEvents) {
            for (let i = 0; i < unpatchedEvents.length; i++) {
              if (eventName === unpatchedEvents[i]) {
                if (passive) {
                  return nativeListener.call(target, eventName, delegate, options);
                } else {
                  return nativeListener.apply(this, arguments);
                }
              }
            }
          }
          const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
          const once = options && typeof options === "object" ? options.once : false;
          const zone = Zone.current;
          let symbolEventNames = zoneSymbolEventNames[eventName];
          if (!symbolEventNames) {
            prepareEventNames(eventName, eventNameToString);
            symbolEventNames = zoneSymbolEventNames[eventName];
          }
          const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
          let existingTasks = target[symbolEventName];
          let isExisting = false;
          if (existingTasks) {
            isExisting = true;
            if (checkDuplicate) {
              for (let i = 0; i < existingTasks.length; i++) {
                if (compare(existingTasks[i], delegate)) {
                  return;
                }
              }
            }
          } else {
            existingTasks = target[symbolEventName] = [];
          }
          let source;
          const constructorName = target.constructor["name"];
          const targetSource = globalSources[constructorName];
          if (targetSource) {
            source = targetSource[eventName];
          }
          if (!source) {
            source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
          }
          taskData.options = options;
          if (once) {
            taskData.options.once = false;
          }
          taskData.target = target;
          taskData.capture = capture;
          taskData.eventName = eventName;
          taskData.isExisting = isExisting;
          const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;
          if (data) {
            data.taskData = taskData;
          }
          const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
          taskData.target = null;
          if (data) {
            data.taskData = null;
          }
          if (once) {
            options.once = true;
          }
          if (!(!passiveSupported && typeof task.options === "boolean")) {
            task.options = options;
          }
          task.target = target;
          task.capture = capture;
          task.eventName = eventName;
          if (isHandleEvent) {
            task.originalDelegate = delegate;
          }
          if (!prepend) {
            existingTasks.push(task);
          } else {
            existingTasks.unshift(task);
          }
          if (returnTarget2) {
            return target;
          }
        };
      };
      proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
      if (nativePrependEventListener) {
        proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
      }
      proto[REMOVE_EVENT_LISTENER] = function() {
        const target = this || _global5;
        let eventName = arguments[0];
        if (patchOptions2 && patchOptions2.transferEventName) {
          eventName = patchOptions2.transferEventName(eventName);
        }
        const options = arguments[2];
        const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
        const delegate = arguments[1];
        if (!delegate) {
          return nativeRemoveEventListener.apply(this, arguments);
        }
        if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
          return;
        }
        const symbolEventNames = zoneSymbolEventNames[eventName];
        let symbolEventName;
        if (symbolEventNames) {
          symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
        }
        const existingTasks = symbolEventName && target[symbolEventName];
        if (existingTasks) {
          for (let i = 0; i < existingTasks.length; i++) {
            const existingTask = existingTasks[i];
            if (compare(existingTask, delegate)) {
              existingTasks.splice(i, 1);
              existingTask.isRemoved = true;
              if (existingTasks.length === 0) {
                existingTask.allRemoved = true;
                target[symbolEventName] = null;
                if (typeof eventName === "string") {
                  const onPropertySymbol = ZONE_SYMBOL_PREFIX + "ON_PROPERTY" + eventName;
                  target[onPropertySymbol] = null;
                }
              }
              existingTask.zone.cancelTask(existingTask);
              if (returnTarget) {
                return target;
              }
              return;
            }
          }
        }
        return nativeRemoveEventListener.apply(this, arguments);
      };
      proto[LISTENERS_EVENT_LISTENER] = function() {
        const target = this || _global5;
        let eventName = arguments[0];
        if (patchOptions2 && patchOptions2.transferEventName) {
          eventName = patchOptions2.transferEventName(eventName);
        }
        const listeners = [];
        const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
        for (let i = 0; i < tasks.length; i++) {
          const task = tasks[i];
          let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
          listeners.push(delegate);
        }
        return listeners;
      };
      proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
        const target = this || _global5;
        let eventName = arguments[0];
        if (!eventName) {
          const keys = Object.keys(target);
          for (let i = 0; i < keys.length; i++) {
            const prop = keys[i];
            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
            let evtName = match && match[1];
            if (evtName && evtName !== "removeListener") {
              this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
            }
          }
          this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, "removeListener");
        } else {
          if (patchOptions2 && patchOptions2.transferEventName) {
            eventName = patchOptions2.transferEventName(eventName);
          }
          const symbolEventNames = zoneSymbolEventNames[eventName];
          if (symbolEventNames) {
            const symbolEventName = symbolEventNames[FALSE_STR];
            const symbolCaptureEventName = symbolEventNames[TRUE_STR];
            const tasks = target[symbolEventName];
            const captureTasks = target[symbolCaptureEventName];
            if (tasks) {
              const removeTasks = tasks.slice();
              for (let i = 0; i < removeTasks.length; i++) {
                const task = removeTasks[i];
                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
              }
            }
            if (captureTasks) {
              const removeTasks = captureTasks.slice();
              for (let i = 0; i < removeTasks.length; i++) {
                const task = removeTasks[i];
                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
              }
            }
          }
        }
        if (returnTarget) {
          return this;
        }
      };
      attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
      attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
      if (nativeRemoveAllListeners) {
        attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
      }
      if (nativeListeners) {
        attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
      }
      return true;
    }
    let results = [];
    for (let i = 0; i < apis.length; i++) {
      results[i] = patchEventTargetMethods(apis[i], patchOptions);
    }
    return results;
  }
  function findEventTasks(target, eventName) {
    if (!eventName) {
      const foundTasks = [];
      for (let prop in target) {
        const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
        let evtName = match && match[1];
        if (evtName && (!eventName || evtName === eventName)) {
          const tasks = target[prop];
          if (tasks) {
            for (let i = 0; i < tasks.length; i++) {
              foundTasks.push(tasks[i]);
            }
          }
        }
      }
      return foundTasks;
    }
    let symbolEventName = zoneSymbolEventNames[eventName];
    if (!symbolEventName) {
      prepareEventNames(eventName);
      symbolEventName = zoneSymbolEventNames[eventName];
    }
    const captureFalseTasks = target[symbolEventName[FALSE_STR]];
    const captureTrueTasks = target[symbolEventName[TRUE_STR]];
    if (!captureFalseTasks) {
      return captureTrueTasks ? captureTrueTasks.slice() : [];
    } else {
      return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
    }
  }
  function patchEventPrototype(global2, api) {
    const Event2 = global2["Event"];
    if (Event2 && Event2.prototype) {
      api.patchMethod(Event2.prototype, "stopImmediatePropagation", (delegate) => function(self2, args) {
        self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;
        delegate && delegate.apply(self2, args);
      });
    }
  }
  function patchCallbacks(api, target, targetName, method, callbacks) {
    const symbol = Zone.__symbol__(method);
    if (target[symbol]) {
      return;
    }
    const nativeDelegate = target[symbol] = target[method];
    target[method] = function(name, opts, options) {
      if (opts && opts.prototype) {
        callbacks.forEach(function(callback) {
          const source = `${targetName}.${method}::` + callback;
          const prototype = opts.prototype;
          if (prototype.hasOwnProperty(callback)) {
            const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
            if (descriptor && descriptor.value) {
              descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
              api._redefineProperty(opts.prototype, callback, descriptor);
            } else if (prototype[callback]) {
              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
            }
          } else if (prototype[callback]) {
            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
          }
        });
      }
      return nativeDelegate.call(target, name, opts, options);
    };
    api.attachOriginToPatched(target[method], nativeDelegate);
  }
  function filterProperties(target, onProperties, ignoreProperties) {
    if (!ignoreProperties || ignoreProperties.length === 0) {
      return onProperties;
    }
    const tip = ignoreProperties.filter((ip) => ip.target === target);
    if (!tip || tip.length === 0) {
      return onProperties;
    }
    const targetIgnoreProperties = tip[0].ignoreProperties;
    return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);
  }
  function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
    if (!target) {
      return;
    }
    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
    patchOnProperties(target, filteredProperties, prototype);
  }
  function getOnEventNames(target) {
    return Object.getOwnPropertyNames(target).filter((name) => name.startsWith("on") && name.length > 2).map((name) => name.substring(2));
  }
  function propertyDescriptorPatch(api, _global5) {
    if (isNode && !isMix) {
      return;
    }
    if (Zone[api.symbol("patchEvents")]) {
      return;
    }
    const ignoreProperties = _global5["__Zone_ignore_on_properties"];
    let patchTargets = [];
    if (isBrowser) {
      const internalWindow2 = window;
      patchTargets = patchTargets.concat([
        "Document",
        "SVGElement",
        "Element",
        "HTMLElement",
        "HTMLBodyElement",
        "HTMLMediaElement",
        "HTMLFrameSetElement",
        "HTMLFrameElement",
        "HTMLIFrameElement",
        "HTMLMarqueeElement",
        "Worker"
      ]);
      const ignoreErrorProperties = isIE() ? [{ target: internalWindow2, ignoreProperties: ["error"] }] : [];
      patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow2));
    }
    patchTargets = patchTargets.concat([
      "XMLHttpRequest",
      "XMLHttpRequestEventTarget",
      "IDBIndex",
      "IDBRequest",
      "IDBOpenDBRequest",
      "IDBDatabase",
      "IDBTransaction",
      "IDBCursor",
      "WebSocket"
    ]);
    for (let i = 0; i < patchTargets.length; i++) {
      const target = _global5[patchTargets[i]];
      target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
    }
  }
  Zone.__load_patch("util", (global2, Zone2, api) => {
    const eventNames = getOnEventNames(global2);
    api.patchOnProperties = patchOnProperties;
    api.patchMethod = patchMethod;
    api.bindArguments = bindArguments;
    api.patchMacroTask = patchMacroTask;
    const SYMBOL_BLACK_LISTED_EVENTS = Zone2.__symbol__("BLACK_LISTED_EVENTS");
    const SYMBOL_UNPATCHED_EVENTS = Zone2.__symbol__("UNPATCHED_EVENTS");
    if (global2[SYMBOL_UNPATCHED_EVENTS]) {
      global2[SYMBOL_BLACK_LISTED_EVENTS] = global2[SYMBOL_UNPATCHED_EVENTS];
    }
    if (global2[SYMBOL_BLACK_LISTED_EVENTS]) {
      Zone2[SYMBOL_BLACK_LISTED_EVENTS] = Zone2[SYMBOL_UNPATCHED_EVENTS] = global2[SYMBOL_BLACK_LISTED_EVENTS];
    }
    api.patchEventPrototype = patchEventPrototype;
    api.patchEventTarget = patchEventTarget;
    api.isIEOrEdge = isIEOrEdge;
    api.ObjectDefineProperty = ObjectDefineProperty;
    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
    api.ObjectCreate = ObjectCreate;
    api.ArraySlice = ArraySlice;
    api.patchClass = patchClass;
    api.wrapWithCurrentZone = wrapWithCurrentZone;
    api.filterProperties = filterProperties;
    api.attachOriginToPatched = attachOriginToPatched;
    api._redefineProperty = Object.defineProperty;
    api.patchCallbacks = patchCallbacks;
    api.getGlobalObjects = () => ({
      globalSources,
      zoneSymbolEventNames,
      eventNames,
      isBrowser,
      isMix,
      isNode,
      TRUE_STR,
      FALSE_STR,
      ZONE_SYMBOL_PREFIX,
      ADD_EVENT_LISTENER_STR,
      REMOVE_EVENT_LISTENER_STR
    });
  });
  var taskSymbol = zoneSymbol("zoneTask");
  function patchTimer(window2, setName, cancelName, nameSuffix2) {
    let setNative = null;
    let clearNative = null;
    setName += nameSuffix2;
    cancelName += nameSuffix2;
    const tasksByHandleId = {};
    function scheduleTask(task) {
      const data = task.data;
      data.args[0] = function() {
        return task.invoke.apply(this, arguments);
      };
      data.handleId = setNative.apply(window2, data.args);
      return task;
    }
    function clearTask(task) {
      return clearNative.call(window2, task.data.handleId);
    }
    setNative = patchMethod(window2, setName, (delegate) => function(self2, args) {
      if (typeof args[0] === "function") {
        const options = {
          isPeriodic: nameSuffix2 === "Interval",
          delay: nameSuffix2 === "Timeout" || nameSuffix2 === "Interval" ? args[1] || 0 : void 0,
          args
        };
        const callback = args[0];
        args[0] = function timer() {
          try {
            return callback.apply(this, arguments);
          } finally {
            if (!options.isPeriodic) {
              if (typeof options.handleId === "number") {
                delete tasksByHandleId[options.handleId];
              } else if (options.handleId) {
                options.handleId[taskSymbol] = null;
              }
            }
          }
        };
        const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
        if (!task) {
          return task;
        }
        const handle = task.data.handleId;
        if (typeof handle === "number") {
          tasksByHandleId[handle] = task;
        } else if (handle) {
          handle[taskSymbol] = task;
        }
        if (handle && handle.ref && handle.unref && typeof handle.ref === "function" && typeof handle.unref === "function") {
          task.ref = handle.ref.bind(handle);
          task.unref = handle.unref.bind(handle);
        }
        if (typeof handle === "number" || handle) {
          return handle;
        }
        return task;
      } else {
        return delegate.apply(window2, args);
      }
    });
    clearNative = patchMethod(window2, cancelName, (delegate) => function(self2, args) {
      const id = args[0];
      let task;
      if (typeof id === "number") {
        task = tasksByHandleId[id];
      } else {
        task = id && id[taskSymbol];
        if (!task) {
          task = id;
        }
      }
      if (task && typeof task.type === "string") {
        if (task.state !== "notScheduled" && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
          if (typeof id === "number") {
            delete tasksByHandleId[id];
          } else if (id) {
            id[taskSymbol] = null;
          }
          task.zone.cancelTask(task);
        }
      } else {
        delegate.apply(window2, args);
      }
    });
  }
  function patchCustomElements(_global5, api) {
    const { isBrowser: isBrowser2, isMix: isMix2 } = api.getGlobalObjects();
    if (!isBrowser2 && !isMix2 || !_global5["customElements"] || !("customElements" in _global5)) {
      return;
    }
    const callbacks = ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"];
    api.patchCallbacks(api, _global5.customElements, "customElements", "define", callbacks);
  }
  function eventTargetPatch(_global5, api) {
    if (Zone[api.symbol("patchEventTarget")]) {
      return;
    }
    const { eventNames, zoneSymbolEventNames: zoneSymbolEventNames2, TRUE_STR: TRUE_STR2, FALSE_STR: FALSE_STR2, ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX2 } = api.getGlobalObjects();
    for (let i = 0; i < eventNames.length; i++) {
      const eventName = eventNames[i];
      const falseEventName = eventName + FALSE_STR2;
      const trueEventName = eventName + TRUE_STR2;
      const symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
      const symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
      zoneSymbolEventNames2[eventName] = {};
      zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
      zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
    }
    const EVENT_TARGET = _global5["EventTarget"];
    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
      return;
    }
    api.patchEventTarget(_global5, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
    return true;
  }
  function patchEvent(global2, api) {
    api.patchEventPrototype(global2, api);
  }
  Zone.__load_patch("legacy", (global2) => {
    const legacyPatch = global2[Zone.__symbol__("legacyPatch")];
    if (legacyPatch) {
      legacyPatch();
    }
  });
  Zone.__load_patch("queueMicrotask", (global2, Zone2, api) => {
    api.patchMethod(global2, "queueMicrotask", (delegate) => {
      return function(self2, args) {
        Zone2.current.scheduleMicroTask("queueMicrotask", args[0]);
      };
    });
  });
  Zone.__load_patch("timers", (global2) => {
    const set = "set";
    const clear = "clear";
    patchTimer(global2, set, clear, "Timeout");
    patchTimer(global2, set, clear, "Interval");
    patchTimer(global2, set, clear, "Immediate");
  });
  Zone.__load_patch("requestAnimationFrame", (global2) => {
    patchTimer(global2, "request", "cancel", "AnimationFrame");
    patchTimer(global2, "mozRequest", "mozCancel", "AnimationFrame");
    patchTimer(global2, "webkitRequest", "webkitCancel", "AnimationFrame");
  });
  Zone.__load_patch("blocking", (global2, Zone2) => {
    const blockingMethods = ["alert", "prompt", "confirm"];
    for (let i = 0; i < blockingMethods.length; i++) {
      const name = blockingMethods[i];
      patchMethod(global2, name, (delegate, symbol, name2) => {
        return function(s, args) {
          return Zone2.current.run(delegate, global2, args, name2);
        };
      });
    }
  });
  Zone.__load_patch("EventTarget", (global2, Zone2, api) => {
    patchEvent(global2, api);
    eventTargetPatch(global2, api);
    const XMLHttpRequestEventTarget = global2["XMLHttpRequestEventTarget"];
    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
      api.patchEventTarget(global2, api, [XMLHttpRequestEventTarget.prototype]);
    }
  });
  Zone.__load_patch("MutationObserver", (global2, Zone2, api) => {
    patchClass("MutationObserver");
    patchClass("WebKitMutationObserver");
  });
  Zone.__load_patch("IntersectionObserver", (global2, Zone2, api) => {
    patchClass("IntersectionObserver");
  });
  Zone.__load_patch("FileReader", (global2, Zone2, api) => {
    patchClass("FileReader");
  });
  Zone.__load_patch("on_property", (global2, Zone2, api) => {
    propertyDescriptorPatch(api, global2);
  });
  Zone.__load_patch("customElements", (global2, Zone2, api) => {
    patchCustomElements(global2, api);
  });
  Zone.__load_patch("XHR", (global2, Zone2) => {
    patchXHR(global2);
    const XHR_TASK = zoneSymbol("xhrTask");
    const XHR_SYNC = zoneSymbol("xhrSync");
    const XHR_LISTENER = zoneSymbol("xhrListener");
    const XHR_SCHEDULED = zoneSymbol("xhrScheduled");
    const XHR_URL = zoneSymbol("xhrURL");
    const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol("xhrErrorBeforeScheduled");
    function patchXHR(window2) {
      const XMLHttpRequest = window2["XMLHttpRequest"];
      if (!XMLHttpRequest) {
        return;
      }
      const XMLHttpRequestPrototype = XMLHttpRequest.prototype;
      function findPendingTask(target) {
        return target[XHR_TASK];
      }
      let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
      let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
      if (!oriAddListener) {
        const XMLHttpRequestEventTarget = window2["XMLHttpRequestEventTarget"];
        if (XMLHttpRequestEventTarget) {
          const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
          oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        }
      }
      const READY_STATE_CHANGE = "readystatechange";
      const SCHEDULED = "scheduled";
      function scheduleTask(task) {
        const data = task.data;
        const target = data.target;
        target[XHR_SCHEDULED] = false;
        target[XHR_ERROR_BEFORE_SCHEDULED] = false;
        const listener = target[XHR_LISTENER];
        if (!oriAddListener) {
          oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        }
        if (listener) {
          oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
        }
        const newListener = target[XHR_LISTENER] = () => {
          if (target.readyState === target.DONE) {
            if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
              const loadTasks = target[Zone2.__symbol__("loadfalse")];
              if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
                const oriInvoke = task.invoke;
                task.invoke = function() {
                  const loadTasks2 = target[Zone2.__symbol__("loadfalse")];
                  for (let i = 0; i < loadTasks2.length; i++) {
                    if (loadTasks2[i] === task) {
                      loadTasks2.splice(i, 1);
                    }
                  }
                  if (!data.aborted && task.state === SCHEDULED) {
                    oriInvoke.call(task);
                  }
                };
                loadTasks.push(task);
              } else {
                task.invoke();
              }
            } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
              target[XHR_ERROR_BEFORE_SCHEDULED] = true;
            }
          }
        };
        oriAddListener.call(target, READY_STATE_CHANGE, newListener);
        const storedTask = target[XHR_TASK];
        if (!storedTask) {
          target[XHR_TASK] = task;
        }
        sendNative.apply(target, data.args);
        target[XHR_SCHEDULED] = true;
        return task;
      }
      function placeholderCallback() {
      }
      function clearTask(task) {
        const data = task.data;
        data.aborted = true;
        return abortNative.apply(data.target, data.args);
      }
      const openNative = patchMethod(XMLHttpRequestPrototype, "open", () => function(self2, args) {
        self2[XHR_SYNC] = args[2] == false;
        self2[XHR_URL] = args[1];
        return openNative.apply(self2, args);
      });
      const XMLHTTPREQUEST_SOURCE = "XMLHttpRequest.send";
      const fetchTaskAborting = zoneSymbol("fetchTaskAborting");
      const fetchTaskScheduling = zoneSymbol("fetchTaskScheduling");
      const sendNative = patchMethod(XMLHttpRequestPrototype, "send", () => function(self2, args) {
        if (Zone2.current[fetchTaskScheduling] === true) {
          return sendNative.apply(self2, args);
        }
        if (self2[XHR_SYNC]) {
          return sendNative.apply(self2, args);
        } else {
          const options = { target: self2, url: self2[XHR_URL], isPeriodic: false, args, aborted: false };
          const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
          if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {
            task.invoke();
          }
        }
      });
      const abortNative = patchMethod(XMLHttpRequestPrototype, "abort", () => function(self2, args) {
        const task = findPendingTask(self2);
        if (task && typeof task.type == "string") {
          if (task.cancelFn == null || task.data && task.data.aborted) {
            return;
          }
          task.zone.cancelTask(task);
        } else if (Zone2.current[fetchTaskAborting] === true) {
          return abortNative.apply(self2, args);
        }
      });
    }
  });
  Zone.__load_patch("geolocation", (global2) => {
    if (global2["navigator"] && global2["navigator"].geolocation) {
      patchPrototype(global2["navigator"].geolocation, ["getCurrentPosition", "watchPosition"]);
    }
  });
  Zone.__load_patch("PromiseRejectionEvent", (global2, Zone2) => {
    function findPromiseRejectionHandler(evtName) {
      return function(e) {
        const eventTasks = findEventTasks(global2, evtName);
        eventTasks.forEach((eventTask) => {
          const PromiseRejectionEvent = global2["PromiseRejectionEvent"];
          if (PromiseRejectionEvent) {
            const evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });
            eventTask.invoke(evt);
          }
        });
      };
    }
    if (global2["PromiseRejectionEvent"]) {
      Zone2[zoneSymbol("unhandledPromiseRejectionHandler")] = findPromiseRejectionHandler("unhandledrejection");
      Zone2[zoneSymbol("rejectionHandledHandler")] = findPromiseRejectionHandler("rejectionhandled");
    }
  });

  // node_modules/zone.js/fesm2015/zone-testing.js
  var NEWLINE = "\n";
  var IGNORE_FRAMES = {};
  var creationTrace = "__creationTrace__";
  var ERROR_TAG = "STACKTRACE TRACKING";
  var SEP_TAG = "__SEP_TAG__";
  var sepTemplate = SEP_TAG + "@[native]";
  var LongStackTrace = class {
    constructor() {
      this.error = getStacktrace();
      this.timestamp = new Date();
    }
  };
  function getStacktraceWithUncaughtError() {
    return new Error(ERROR_TAG);
  }
  function getStacktraceWithCaughtError() {
    try {
      throw getStacktraceWithUncaughtError();
    } catch (err) {
      return err;
    }
  }
  var error = getStacktraceWithUncaughtError();
  var caughtError = getStacktraceWithCaughtError();
  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;
  function getFrames(error3) {
    return error3.stack ? error3.stack.split(NEWLINE) : [];
  }
  function addErrorStack(lines, error3) {
    let trace = getFrames(error3);
    for (let i = 0; i < trace.length; i++) {
      const frame = trace[i];
      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {
        lines.push(trace[i]);
      }
    }
  }
  function renderLongStackTrace(frames, stack) {
    const longTrace = [stack ? stack.trim() : ""];
    if (frames) {
      let timestamp = new Date().getTime();
      for (let i = 0; i < frames.length; i++) {
        const traceFrames = frames[i];
        const lastTime = traceFrames.timestamp;
        let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;
        separator = separator.replace(/[^\w\d]/g, "_");
        longTrace.push(sepTemplate.replace(SEP_TAG, separator));
        addErrorStack(longTrace, traceFrames.error);
        timestamp = lastTime.getTime();
      }
    }
    return longTrace.join(NEWLINE);
  }
  function stackTracesEnabled() {
    return Error.stackTraceLimit > 0;
  }
  Zone["longStackTraceZoneSpec"] = {
    name: "long-stack-trace",
    longStackTraceLimit: 10,
    getLongStackTrace: function(error3) {
      if (!error3) {
        return void 0;
      }
      const trace = error3[Zone.__symbol__("currentTaskTrace")];
      if (!trace) {
        return error3.stack;
      }
      return renderLongStackTrace(trace, error3.stack);
    },
    onScheduleTask: function(parentZoneDelegate, currentZone, targetZone, task) {
      if (stackTracesEnabled()) {
        const currentTask = Zone.currentTask;
        let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];
        trace = [new LongStackTrace()].concat(trace);
        if (trace.length > this.longStackTraceLimit) {
          trace.length = this.longStackTraceLimit;
        }
        if (!task.data)
          task.data = {};
        if (task.type === "eventTask") {
          task.data = Object.assign({}, task.data);
        }
        task.data[creationTrace] = trace;
      }
      return parentZoneDelegate.scheduleTask(targetZone, task);
    },
    onHandleError: function(parentZoneDelegate, currentZone, targetZone, error3) {
      if (stackTracesEnabled()) {
        const parentTask = Zone.currentTask || error3.task;
        if (error3 instanceof Error && parentTask) {
          const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error3.stack);
          try {
            error3.stack = error3.longStack = longStack;
          } catch (err) {
          }
        }
      }
      return parentZoneDelegate.handleError(targetZone, error3);
    }
  };
  function captureStackTraces(stackTraces, count) {
    if (count > 0) {
      stackTraces.push(getFrames(new LongStackTrace().error));
      captureStackTraces(stackTraces, count - 1);
    }
  }
  function computeIgnoreFrames() {
    if (!stackTracesEnabled()) {
      return;
    }
    const frames = [];
    captureStackTraces(frames, 2);
    const frames1 = frames[0];
    const frames2 = frames[1];
    for (let i = 0; i < frames1.length; i++) {
      const frame1 = frames1[i];
      if (frame1.indexOf(ERROR_TAG) == -1) {
        let match = frame1.match(/^\s*at\s+/);
        if (match) {
          sepTemplate = match[0] + SEP_TAG + " (http://localhost)";
          break;
        }
      }
    }
    for (let i = 0; i < frames1.length; i++) {
      const frame1 = frames1[i];
      const frame2 = frames2[i];
      if (frame1 === frame2) {
        IGNORE_FRAMES[frame1] = true;
      } else {
        break;
      }
    }
  }
  computeIgnoreFrames();
  var ProxyZoneSpec = class {
    constructor(defaultSpecDelegate = null) {
      this.defaultSpecDelegate = defaultSpecDelegate;
      this.name = "ProxyZone";
      this._delegateSpec = null;
      this.properties = { "ProxyZoneSpec": this };
      this.propertyKeys = null;
      this.lastTaskState = null;
      this.isNeedToTriggerHasTask = false;
      this.tasks = [];
      this.setDelegate(defaultSpecDelegate);
    }
    static get() {
      return Zone.current.get("ProxyZoneSpec");
    }
    static isLoaded() {
      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;
    }
    static assertPresent() {
      if (!ProxyZoneSpec.isLoaded()) {
        throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);
      }
      return ProxyZoneSpec.get();
    }
    setDelegate(delegateSpec) {
      const isNewDelegate = this._delegateSpec !== delegateSpec;
      this._delegateSpec = delegateSpec;
      this.propertyKeys && this.propertyKeys.forEach((key) => delete this.properties[key]);
      this.propertyKeys = null;
      if (delegateSpec && delegateSpec.properties) {
        this.propertyKeys = Object.keys(delegateSpec.properties);
        this.propertyKeys.forEach((k) => this.properties[k] = delegateSpec.properties[k]);
      }
      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {
        this.isNeedToTriggerHasTask = true;
      }
    }
    getDelegate() {
      return this._delegateSpec;
    }
    resetDelegate() {
      this.getDelegate();
      this.setDelegate(this.defaultSpecDelegate);
    }
    tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {
      if (this.isNeedToTriggerHasTask && this.lastTaskState) {
        this.isNeedToTriggerHasTask = false;
        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);
      }
    }
    removeFromTasks(task) {
      if (!this.tasks) {
        return;
      }
      for (let i = 0; i < this.tasks.length; i++) {
        if (this.tasks[i] === task) {
          this.tasks.splice(i, 1);
          return;
        }
      }
    }
    getAndClearPendingTasksInfo() {
      if (this.tasks.length === 0) {
        return "";
      }
      const taskInfo = this.tasks.map((task) => {
        const dataInfo = task.data && Object.keys(task.data).map((key) => {
          return key + ":" + task.data[key];
        }).join(",");
        return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;
      });
      const pendingTasksInfo = "--Pending async tasks are: [" + taskInfo + "]";
      this.tasks = [];
      return pendingTasksInfo;
    }
    onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {
      if (this._delegateSpec && this._delegateSpec.onFork) {
        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);
      } else {
        return parentZoneDelegate.fork(targetZone, zoneSpec);
      }
    }
    onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {
      if (this._delegateSpec && this._delegateSpec.onIntercept) {
        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);
      } else {
        return parentZoneDelegate.intercept(targetZone, delegate, source);
      }
    }
    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {
      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);
      if (this._delegateSpec && this._delegateSpec.onInvoke) {
        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);
      } else {
        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);
      }
    }
    onHandleError(parentZoneDelegate, currentZone, targetZone, error3) {
      if (this._delegateSpec && this._delegateSpec.onHandleError) {
        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error3);
      } else {
        return parentZoneDelegate.handleError(targetZone, error3);
      }
    }
    onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {
      if (task.type !== "eventTask") {
        this.tasks.push(task);
      }
      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {
        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);
      } else {
        return parentZoneDelegate.scheduleTask(targetZone, task);
      }
    }
    onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {
      if (task.type !== "eventTask") {
        this.removeFromTasks(task);
      }
      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);
      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {
        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);
      } else {
        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);
      }
    }
    onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {
      if (task.type !== "eventTask") {
        this.removeFromTasks(task);
      }
      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);
      if (this._delegateSpec && this._delegateSpec.onCancelTask) {
        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);
      } else {
        return parentZoneDelegate.cancelTask(targetZone, task);
      }
    }
    onHasTask(delegate, current, target, hasTaskState) {
      this.lastTaskState = hasTaskState;
      if (this._delegateSpec && this._delegateSpec.onHasTask) {
        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);
      } else {
        delegate.hasTask(target, hasTaskState);
      }
    }
  };
  Zone["ProxyZoneSpec"] = ProxyZoneSpec;
  var SyncTestZoneSpec = class {
    constructor(namePrefix) {
      this.runZone = Zone.current;
      this.name = "syncTestZone for " + namePrefix;
    }
    onScheduleTask(delegate, current, target, task) {
      switch (task.type) {
        case "microTask":
        case "macroTask":
          throw new Error(`Cannot call ${task.source} from within a sync test.`);
        case "eventTask":
          task = delegate.scheduleTask(target, task);
          break;
      }
      return task;
    }
  };
  Zone["SyncTestZoneSpec"] = SyncTestZoneSpec;
  Zone.__load_patch("jasmine", (global2, Zone2, api) => {
    const __extends2 = function(d, b) {
      for (const p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    if (!Zone2)
      throw new Error("Missing: zone.js");
    if (typeof jest !== "undefined") {
      return;
    }
    if (typeof jasmine == "undefined" || jasmine["__zone_patch__"]) {
      return;
    }
    jasmine["__zone_patch__"] = true;
    const SyncTestZoneSpec2 = Zone2["SyncTestZoneSpec"];
    const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
    if (!SyncTestZoneSpec2)
      throw new Error("Missing: SyncTestZoneSpec");
    if (!ProxyZoneSpec2)
      throw new Error("Missing: ProxyZoneSpec");
    const ambientZone = Zone2.current;
    const syncZone = ambientZone.fork(new SyncTestZoneSpec2("jasmine.describe"));
    const symbol = Zone2.__symbol__;
    const disablePatchingJasmineClock = global2[symbol("fakeAsyncDisablePatchingClock")] === true;
    const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global2[symbol("fakeAsyncPatchLock")] === true || global2[symbol("fakeAsyncAutoFakeAsyncWhenClockPatched")] === true);
    const ignoreUnhandledRejection = global2[symbol("ignoreUnhandledRejection")] === true;
    if (!ignoreUnhandledRejection) {
      const globalErrors = jasmine.GlobalErrors;
      if (globalErrors && !jasmine[symbol("GlobalErrors")]) {
        jasmine[symbol("GlobalErrors")] = globalErrors;
        jasmine.GlobalErrors = function() {
          const instance = new globalErrors();
          const originalInstall = instance.install;
          if (originalInstall && !instance[symbol("install")]) {
            instance[symbol("install")] = originalInstall;
            instance.install = function() {
              const originalHandlers = process.listeners("unhandledRejection");
              const r = originalInstall.apply(this, arguments);
              process.removeAllListeners("unhandledRejection");
              if (originalHandlers) {
                originalHandlers.forEach((h) => process.on("unhandledRejection", h));
              }
              return r;
            };
          }
          return instance;
        };
      }
    }
    const jasmineEnv = jasmine.getEnv();
    ["describe", "xdescribe", "fdescribe"].forEach((methodName) => {
      let originalJasmineFn = jasmineEnv[methodName];
      jasmineEnv[methodName] = function(description, specDefinitions) {
        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));
      };
    });
    ["it", "xit", "fit"].forEach((methodName) => {
      let originalJasmineFn = jasmineEnv[methodName];
      jasmineEnv[symbol(methodName)] = originalJasmineFn;
      jasmineEnv[methodName] = function(description, specDefinitions, timeout) {
        arguments[1] = wrapTestInZone(specDefinitions);
        return originalJasmineFn.apply(this, arguments);
      };
    });
    ["beforeEach", "afterEach", "beforeAll", "afterAll"].forEach((methodName) => {
      let originalJasmineFn = jasmineEnv[methodName];
      jasmineEnv[symbol(methodName)] = originalJasmineFn;
      jasmineEnv[methodName] = function(specDefinitions, timeout) {
        arguments[0] = wrapTestInZone(specDefinitions);
        return originalJasmineFn.apply(this, arguments);
      };
    });
    if (!disablePatchingJasmineClock) {
      const originalClockFn = jasmine[symbol("clock")] = jasmine["clock"];
      jasmine["clock"] = function() {
        const clock = originalClockFn.apply(this, arguments);
        if (!clock[symbol("patched")]) {
          clock[symbol("patched")] = symbol("patched");
          const originalTick = clock[symbol("tick")] = clock.tick;
          clock.tick = function() {
            const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
            if (fakeAsyncZoneSpec) {
              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);
            }
            return originalTick.apply(this, arguments);
          };
          const originalMockDate = clock[symbol("mockDate")] = clock.mockDate;
          clock.mockDate = function() {
            const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
            if (fakeAsyncZoneSpec) {
              const dateTime = arguments.length > 0 ? arguments[0] : new Date();
              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === "function" ? [dateTime.getTime()] : arguments);
            }
            return originalMockDate.apply(this, arguments);
          };
          if (enableAutoFakeAsyncWhenClockPatched) {
            ["install", "uninstall"].forEach((methodName) => {
              const originalClockFn2 = clock[symbol(methodName)] = clock[methodName];
              clock[methodName] = function() {
                const FakeAsyncTestZoneSpec = Zone2["FakeAsyncTestZoneSpec"];
                if (FakeAsyncTestZoneSpec) {
                  jasmine[symbol("clockInstalled")] = methodName === "install";
                  return;
                }
                return originalClockFn2.apply(this, arguments);
              };
            });
          }
        }
        return clock;
      };
    }
    if (!jasmine[Zone2.__symbol__("createSpyObj")]) {
      const originalCreateSpyObj = jasmine.createSpyObj;
      jasmine[Zone2.__symbol__("createSpyObj")] = originalCreateSpyObj;
      jasmine.createSpyObj = function() {
        const args = Array.prototype.slice.call(arguments);
        const propertyNames = args.length >= 3 ? args[2] : null;
        let spyObj;
        if (propertyNames) {
          const defineProperty = Object.defineProperty;
          Object.defineProperty = function(obj, p, attributes) {
            return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));
          };
          try {
            spyObj = originalCreateSpyObj.apply(this, args);
          } finally {
            Object.defineProperty = defineProperty;
          }
        } else {
          spyObj = originalCreateSpyObj.apply(this, args);
        }
        return spyObj;
      };
    }
    function wrapDescribeInZone(describeBody) {
      return function() {
        return syncZone.run(describeBody, this, arguments);
      };
    }
    function runInTestZone(testBody, applyThis, queueRunner, done) {
      const isClockInstalled = !!jasmine[symbol("clockInstalled")];
      queueRunner.testProxyZoneSpec;
      const testProxyZone = queueRunner.testProxyZone;
      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {
        const fakeAsyncModule = Zone2[Zone2.__symbol__("fakeAsyncTest")];
        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === "function") {
          testBody = fakeAsyncModule.fakeAsync(testBody);
        }
      }
      if (done) {
        return testProxyZone.run(testBody, applyThis, [done]);
      } else {
        return testProxyZone.run(testBody, applyThis);
      }
    }
    function wrapTestInZone(testBody) {
      return testBody && (testBody.length ? function(done) {
        return runInTestZone(testBody, this, this.queueRunner, done);
      } : function() {
        return runInTestZone(testBody, this, this.queueRunner);
      });
    }
    const QueueRunner = jasmine.QueueRunner;
    jasmine.QueueRunner = function(_super) {
      __extends2(ZoneQueueRunner, _super);
      function ZoneQueueRunner(attrs) {
        if (attrs.onComplete) {
          attrs.onComplete = ((fn2) => () => {
            this.testProxyZone = null;
            this.testProxyZoneSpec = null;
            ambientZone.scheduleMicroTask("jasmine.onComplete", fn2);
          })(attrs.onComplete);
        }
        const nativeSetTimeout = global2[Zone2.__symbol__("setTimeout")];
        const nativeClearTimeout = global2[Zone2.__symbol__("clearTimeout")];
        if (nativeSetTimeout) {
          attrs.timeout = {
            setTimeout: nativeSetTimeout ? nativeSetTimeout : global2.setTimeout,
            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global2.clearTimeout
          };
        }
        if (jasmine.UserContext) {
          if (!attrs.userContext) {
            attrs.userContext = new jasmine.UserContext();
          }
          attrs.userContext.queueRunner = this;
        } else {
          if (!attrs.userContext) {
            attrs.userContext = {};
          }
          attrs.userContext.queueRunner = this;
        }
        const onException = attrs.onException;
        attrs.onException = function(error3) {
          if (error3 && error3.message === "Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.") {
            const proxyZoneSpec = this && this.testProxyZoneSpec;
            if (proxyZoneSpec) {
              const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();
              try {
                error3.message += pendingTasksInfo;
              } catch (err) {
              }
            }
          }
          if (onException) {
            onException.call(this, error3);
          }
        };
        _super.call(this, attrs);
      }
      ZoneQueueRunner.prototype.execute = function() {
        let zone = Zone2.current;
        let isChildOfAmbientZone = false;
        while (zone) {
          if (zone === ambientZone) {
            isChildOfAmbientZone = true;
            break;
          }
          zone = zone.parent;
        }
        if (!isChildOfAmbientZone)
          throw new Error("Unexpected Zone: " + Zone2.current.name);
        this.testProxyZoneSpec = new ProxyZoneSpec2();
        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);
        if (!Zone2.currentTask) {
          Zone2.current.scheduleMicroTask("jasmine.execute().forceTask", () => QueueRunner.prototype.execute.call(this));
        } else {
          _super.prototype.execute.call(this);
        }
      };
      return ZoneQueueRunner;
    }(QueueRunner);
  });
  Zone.__load_patch("jest", (context, Zone2, api) => {
    if (typeof jest === "undefined" || jest["__zone_patch__"]) {
      return;
    }
    jest["__zone_patch__"] = true;
    const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
    const SyncTestZoneSpec2 = Zone2["SyncTestZoneSpec"];
    if (!ProxyZoneSpec2) {
      throw new Error("Missing ProxyZoneSpec");
    }
    const rootZone = Zone2.current;
    const syncZone = rootZone.fork(new SyncTestZoneSpec2("jest.describe"));
    const proxyZoneSpec = new ProxyZoneSpec2();
    const proxyZone = rootZone.fork(proxyZoneSpec);
    function wrapDescribeFactoryInZone(originalJestFn) {
      return function(...tableArgs) {
        const originalDescribeFn = originalJestFn.apply(this, tableArgs);
        return function(...args) {
          args[1] = wrapDescribeInZone(args[1]);
          return originalDescribeFn.apply(this, args);
        };
      };
    }
    function wrapTestFactoryInZone(originalJestFn) {
      return function(...tableArgs) {
        return function(...args) {
          args[1] = wrapTestInZone(args[1]);
          return originalJestFn.apply(this, tableArgs).apply(this, args);
        };
      };
    }
    function wrapDescribeInZone(describeBody) {
      return function(...args) {
        return syncZone.run(describeBody, this, args);
      };
    }
    function wrapTestInZone(testBody, isTestFunc = false) {
      if (typeof testBody !== "function") {
        return testBody;
      }
      const wrappedFunc = function() {
        if (Zone2[api.symbol("useFakeTimersCalled")] === true && testBody && !testBody.isFakeAsync) {
          const fakeAsyncModule = Zone2[Zone2.__symbol__("fakeAsyncTest")];
          if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === "function") {
            testBody = fakeAsyncModule.fakeAsync(testBody);
          }
        }
        proxyZoneSpec.isTestFunc = isTestFunc;
        return proxyZone.run(testBody, null, arguments);
      };
      Object.defineProperty(wrappedFunc, "length", { configurable: true, writable: true, enumerable: false });
      wrappedFunc.length = testBody.length;
      return wrappedFunc;
    }
    ["describe", "xdescribe", "fdescribe"].forEach((methodName) => {
      let originalJestFn = context[methodName];
      if (context[Zone2.__symbol__(methodName)]) {
        return;
      }
      context[Zone2.__symbol__(methodName)] = originalJestFn;
      context[methodName] = function(...args) {
        args[1] = wrapDescribeInZone(args[1]);
        return originalJestFn.apply(this, args);
      };
      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);
    });
    context.describe.only = context.fdescribe;
    context.describe.skip = context.xdescribe;
    ["it", "xit", "fit", "test", "xtest"].forEach((methodName) => {
      let originalJestFn = context[methodName];
      if (context[Zone2.__symbol__(methodName)]) {
        return;
      }
      context[Zone2.__symbol__(methodName)] = originalJestFn;
      context[methodName] = function(...args) {
        args[1] = wrapTestInZone(args[1], true);
        return originalJestFn.apply(this, args);
      };
      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);
      context[methodName].todo = originalJestFn.todo;
    });
    context.it.only = context.fit;
    context.it.skip = context.xit;
    context.test.only = context.fit;
    context.test.skip = context.xit;
    ["beforeEach", "afterEach", "beforeAll", "afterAll"].forEach((methodName) => {
      let originalJestFn = context[methodName];
      if (context[Zone2.__symbol__(methodName)]) {
        return;
      }
      context[Zone2.__symbol__(methodName)] = originalJestFn;
      context[methodName] = function(...args) {
        args[0] = wrapTestInZone(args[0]);
        return originalJestFn.apply(this, args);
      };
    });
    Zone2.patchJestObject = function patchJestObject(Timer, isModern = false) {
      function isPatchingFakeTimer() {
        const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
        return !!fakeAsyncZoneSpec;
      }
      function isInTestFunc() {
        const proxyZoneSpec2 = Zone2.current.get("ProxyZoneSpec");
        return proxyZoneSpec2 && proxyZoneSpec2.isTestFunc;
      }
      if (Timer[api.symbol("fakeTimers")]) {
        return;
      }
      Timer[api.symbol("fakeTimers")] = true;
      api.patchMethod(Timer, "_checkFakeTimers", (delegate) => {
        return function(self2, args) {
          if (isPatchingFakeTimer()) {
            return true;
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "useFakeTimers", (delegate) => {
        return function(self2, args) {
          Zone2[api.symbol("useFakeTimersCalled")] = true;
          if (isModern || isInTestFunc()) {
            return delegate.apply(self2, args);
          }
          return self2;
        };
      });
      api.patchMethod(Timer, "useRealTimers", (delegate) => {
        return function(self2, args) {
          Zone2[api.symbol("useFakeTimersCalled")] = false;
          if (isModern || isInTestFunc()) {
            return delegate.apply(self2, args);
          }
          return self2;
        };
      });
      api.patchMethod(Timer, "setSystemTime", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {
            fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "getRealSystemTime", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {
            return fakeAsyncZoneSpec.getRealSystemTime();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "runAllTicks", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.flushMicrotasks();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "runAllTimers", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.flush(100, true);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "advanceTimersByTime", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.tick(args[0]);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "runOnlyPendingTimers", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.flushOnlyPendingTimers();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "advanceTimersToNextTimer", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.tickToNext(args[0]);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "clearAllTimers", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.removeAllTimers();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "getTimerCount", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            return fakeAsyncZoneSpec.getTimerCount();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
    };
  });
  Zone.__load_patch("mocha", (global2, Zone2) => {
    const Mocha = global2.Mocha;
    if (typeof Mocha === "undefined") {
      return;
    }
    if (typeof Zone2 === "undefined") {
      throw new Error("Missing Zone.js");
    }
    const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
    const SyncTestZoneSpec2 = Zone2["SyncTestZoneSpec"];
    if (!ProxyZoneSpec2) {
      throw new Error("Missing ProxyZoneSpec");
    }
    if (Mocha["__zone_patch__"]) {
      throw new Error('"Mocha" has already been patched with "Zone".');
    }
    Mocha["__zone_patch__"] = true;
    const rootZone = Zone2.current;
    const syncZone = rootZone.fork(new SyncTestZoneSpec2("Mocha.describe"));
    let testZone = null;
    const suiteZone = rootZone.fork(new ProxyZoneSpec2());
    const mochaOriginal = {
      after: global2.after,
      afterEach: global2.afterEach,
      before: global2.before,
      beforeEach: global2.beforeEach,
      describe: global2.describe,
      it: global2.it
    };
    function modifyArguments(args, syncTest, asyncTest) {
      for (let i = 0; i < args.length; i++) {
        let arg = args[i];
        if (typeof arg === "function") {
          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg);
          args[i].toString = function() {
            return arg.toString();
          };
        }
      }
      return args;
    }
    function wrapDescribeInZone(args) {
      const syncTest = function(fn2) {
        return function() {
          return syncZone.run(fn2, this, arguments);
        };
      };
      return modifyArguments(args, syncTest);
    }
    function wrapTestInZone(args) {
      const asyncTest = function(fn2) {
        return function(done) {
          return testZone.run(fn2, this, [done]);
        };
      };
      const syncTest = function(fn2) {
        return function() {
          return testZone.run(fn2, this);
        };
      };
      return modifyArguments(args, syncTest, asyncTest);
    }
    function wrapSuiteInZone(args) {
      const asyncTest = function(fn2) {
        return function(done) {
          return suiteZone.run(fn2, this, [done]);
        };
      };
      const syncTest = function(fn2) {
        return function() {
          return suiteZone.run(fn2, this);
        };
      };
      return modifyArguments(args, syncTest, asyncTest);
    }
    global2.describe = global2.suite = function() {
      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));
    };
    global2.xdescribe = global2.suite.skip = function() {
      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));
    };
    global2.describe.only = global2.suite.only = function() {
      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));
    };
    global2.it = global2.specify = global2.test = function() {
      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));
    };
    global2.xit = global2.xspecify = function() {
      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));
    };
    global2.it.only = global2.test.only = function() {
      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));
    };
    global2.after = global2.suiteTeardown = function() {
      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));
    };
    global2.afterEach = global2.teardown = function() {
      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));
    };
    global2.before = global2.suiteSetup = function() {
      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));
    };
    global2.beforeEach = global2.setup = function() {
      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));
    };
    ((originalRunTest, originalRun) => {
      Mocha.Runner.prototype.runTest = function(fn2) {
        Zone2.current.scheduleMicroTask("mocha.forceTask", () => {
          originalRunTest.call(this, fn2);
        });
      };
      Mocha.Runner.prototype.run = function(fn2) {
        this.on("test", (e) => {
          testZone = rootZone.fork(new ProxyZoneSpec2());
        });
        this.on("fail", (test, err) => {
          const proxyZoneSpec = testZone && testZone.get("ProxyZoneSpec");
          if (proxyZoneSpec && err) {
            try {
              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();
            } catch (error3) {
            }
          }
        });
        return originalRun.call(this, fn2);
      };
    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);
  });
  (function(_global5) {
    class AsyncTestZoneSpec {
      constructor(finishCallback, failCallback, namePrefix) {
        this.finishCallback = finishCallback;
        this.failCallback = failCallback;
        this._pendingMicroTasks = false;
        this._pendingMacroTasks = false;
        this._alreadyErrored = false;
        this._isSync = false;
        this.entryFunction = null;
        this.runZone = Zone.current;
        this.unresolvedChainedPromiseCount = 0;
        this.supportWaitUnresolvedChainedPromise = false;
        this.name = "asyncTestZone for " + namePrefix;
        this.properties = { "AsyncTestZoneSpec": this };
        this.supportWaitUnresolvedChainedPromise = _global5[Zone.__symbol__("supportWaitUnResolvedChainedPromise")] === true;
      }
      isUnresolvedChainedPromisePending() {
        return this.unresolvedChainedPromiseCount > 0;
      }
      _finishCallbackIfDone() {
        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {
          this.runZone.run(() => {
            setTimeout(() => {
              if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {
                this.finishCallback();
              }
            }, 0);
          });
        }
      }
      patchPromiseForTest() {
        if (!this.supportWaitUnresolvedChainedPromise) {
          return;
        }
        const patchPromiseForTest = Promise[Zone.__symbol__("patchPromiseForTest")];
        if (patchPromiseForTest) {
          patchPromiseForTest();
        }
      }
      unPatchPromiseForTest() {
        if (!this.supportWaitUnresolvedChainedPromise) {
          return;
        }
        const unPatchPromiseForTest = Promise[Zone.__symbol__("unPatchPromiseForTest")];
        if (unPatchPromiseForTest) {
          unPatchPromiseForTest();
        }
      }
      onScheduleTask(delegate, current, target, task) {
        if (task.type !== "eventTask") {
          this._isSync = false;
        }
        if (task.type === "microTask" && task.data && task.data instanceof Promise) {
          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {
            this.unresolvedChainedPromiseCount--;
          }
        }
        return delegate.scheduleTask(target, task);
      }
      onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {
        if (task.type !== "eventTask") {
          this._isSync = false;
        }
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      onCancelTask(delegate, current, target, task) {
        if (task.type !== "eventTask") {
          this._isSync = false;
        }
        return delegate.cancelTask(target, task);
      }
      onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {
        if (!this.entryFunction) {
          this.entryFunction = delegate;
        }
        try {
          this._isSync = true;
          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);
        } finally {
          parentZoneDelegate._taskCounts;
          if (this._isSync && this.entryFunction === delegate) {
            this._finishCallbackIfDone();
          }
        }
      }
      onHandleError(parentZoneDelegate, currentZone, targetZone, error3) {
        const result = parentZoneDelegate.handleError(targetZone, error3);
        if (result) {
          this.failCallback(error3);
          this._alreadyErrored = true;
        }
        return false;
      }
      onHasTask(delegate, current, target, hasTaskState) {
        delegate.hasTask(target, hasTaskState);
        if (current !== target) {
          return;
        }
        if (hasTaskState.change == "microTask") {
          this._pendingMicroTasks = hasTaskState.microTask;
          this._finishCallbackIfDone();
        } else if (hasTaskState.change == "macroTask") {
          this._pendingMacroTasks = hasTaskState.macroTask;
          this._finishCallbackIfDone();
        }
      }
    }
    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__("parentUnresolved");
    Zone["AsyncTestZoneSpec"] = AsyncTestZoneSpec;
  })(typeof window !== "undefined" && window || typeof self !== "undefined" && self || global);
  Zone.__load_patch("asynctest", (global2, Zone2, api) => {
    Zone2[api.symbol("asyncTest")] = function asyncTest(fn2) {
      if (global2.jasmine) {
        return function(done) {
          if (!done) {
            done = function() {
            };
            done.fail = function(e) {
              throw e;
            };
          }
          runInTestZone(fn2, this, done, (err) => {
            if (typeof err === "string") {
              return done.fail(new Error(err));
            } else {
              done.fail(err);
            }
          });
        };
      }
      return function() {
        return new Promise((finishCallback, failCallback) => {
          runInTestZone(fn2, this, finishCallback, failCallback);
        });
      };
    };
    function runInTestZone(fn2, context, finishCallback, failCallback) {
      const currentZone = Zone2.current;
      const AsyncTestZoneSpec = Zone2["AsyncTestZoneSpec"];
      if (AsyncTestZoneSpec === void 0) {
        throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/async-test");
      }
      const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
      if (!ProxyZoneSpec2) {
        throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");
      }
      const proxyZoneSpec = ProxyZoneSpec2.get();
      ProxyZoneSpec2.assertPresent();
      const proxyZone = Zone2.current.getZoneWith("ProxyZoneSpec");
      const previousDelegate = proxyZoneSpec.getDelegate();
      proxyZone.parent.run(() => {
        const testZoneSpec = new AsyncTestZoneSpec(() => {
          if (proxyZoneSpec.getDelegate() == testZoneSpec) {
            proxyZoneSpec.setDelegate(previousDelegate);
          }
          testZoneSpec.unPatchPromiseForTest();
          currentZone.run(() => {
            finishCallback();
          });
        }, (error3) => {
          if (proxyZoneSpec.getDelegate() == testZoneSpec) {
            proxyZoneSpec.setDelegate(previousDelegate);
          }
          testZoneSpec.unPatchPromiseForTest();
          currentZone.run(() => {
            failCallback(error3);
          });
        }, "test");
        proxyZoneSpec.setDelegate(testZoneSpec);
        testZoneSpec.patchPromiseForTest();
      });
      return Zone2.current.runGuarded(fn2, context);
    }
  });
  (function(global2) {
    const OriginalDate = global2.Date;
    function FakeDate() {
      if (arguments.length === 0) {
        const d = new OriginalDate();
        d.setTime(FakeDate.now());
        return d;
      } else {
        const args = Array.prototype.slice.call(arguments);
        return new OriginalDate(...args);
      }
    }
    FakeDate.now = function() {
      const fakeAsyncTestZoneSpec2 = Zone.current.get("FakeAsyncTestZoneSpec");
      if (fakeAsyncTestZoneSpec2) {
        return fakeAsyncTestZoneSpec2.getFakeSystemTime();
      }
      return OriginalDate.now.apply(this, arguments);
    };
    FakeDate.UTC = OriginalDate.UTC;
    FakeDate.parse = OriginalDate.parse;
    const timers = {
      setTimeout: global2.setTimeout,
      setInterval: global2.setInterval,
      clearTimeout: global2.clearTimeout,
      clearInterval: global2.clearInterval
    };
    class Scheduler2 {
      constructor() {
        this._schedulerQueue = [];
        this._currentTickTime = 0;
        this._currentFakeBaseSystemTime = OriginalDate.now();
        this._currentTickRequeuePeriodicEntries = [];
      }
      getCurrentTickTime() {
        return this._currentTickTime;
      }
      getFakeSystemTime() {
        return this._currentFakeBaseSystemTime + this._currentTickTime;
      }
      setFakeBaseSystemTime(fakeBaseSystemTime) {
        this._currentFakeBaseSystemTime = fakeBaseSystemTime;
      }
      getRealSystemTime() {
        return OriginalDate.now();
      }
      scheduleFunction(cb, delay2, options) {
        options = Object.assign({
          args: [],
          isPeriodic: false,
          isRequestAnimationFrame: false,
          id: -1,
          isRequeuePeriodic: false
        }, options);
        let currentId = options.id < 0 ? Scheduler2.nextId++ : options.id;
        let endTime = this._currentTickTime + delay2;
        let newEntry = {
          endTime,
          id: currentId,
          func: cb,
          args: options.args,
          delay: delay2,
          isPeriodic: options.isPeriodic,
          isRequestAnimationFrame: options.isRequestAnimationFrame
        };
        if (options.isRequeuePeriodic) {
          this._currentTickRequeuePeriodicEntries.push(newEntry);
        }
        let i = 0;
        for (; i < this._schedulerQueue.length; i++) {
          let currentEntry = this._schedulerQueue[i];
          if (newEntry.endTime < currentEntry.endTime) {
            break;
          }
        }
        this._schedulerQueue.splice(i, 0, newEntry);
        return currentId;
      }
      removeScheduledFunctionWithId(id) {
        for (let i = 0; i < this._schedulerQueue.length; i++) {
          if (this._schedulerQueue[i].id == id) {
            this._schedulerQueue.splice(i, 1);
            break;
          }
        }
      }
      removeAll() {
        this._schedulerQueue = [];
      }
      getTimerCount() {
        return this._schedulerQueue.length;
      }
      tickToNext(step = 1, doTick, tickOptions) {
        if (this._schedulerQueue.length < step) {
          return;
        }
        const startTime = this._currentTickTime;
        const targetTask = this._schedulerQueue[step - 1];
        this.tick(targetTask.endTime - startTime, doTick, tickOptions);
      }
      tick(millis = 0, doTick, tickOptions) {
        let finalTime = this._currentTickTime + millis;
        let lastCurrentTime = 0;
        tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);
        const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();
        if (schedulerQueue.length === 0 && doTick) {
          doTick(millis);
          return;
        }
        while (schedulerQueue.length > 0) {
          this._currentTickRequeuePeriodicEntries = [];
          let current = schedulerQueue[0];
          if (finalTime < current.endTime) {
            break;
          } else {
            let current2 = schedulerQueue.shift();
            if (!tickOptions.processNewMacroTasksSynchronously) {
              const idx = this._schedulerQueue.indexOf(current2);
              if (idx >= 0) {
                this._schedulerQueue.splice(idx, 1);
              }
            }
            lastCurrentTime = this._currentTickTime;
            this._currentTickTime = current2.endTime;
            if (doTick) {
              doTick(this._currentTickTime - lastCurrentTime);
            }
            let retval = current2.func.apply(global2, current2.isRequestAnimationFrame ? [this._currentTickTime] : current2.args);
            if (!retval) {
              break;
            }
            if (!tickOptions.processNewMacroTasksSynchronously) {
              this._currentTickRequeuePeriodicEntries.forEach((newEntry) => {
                let i = 0;
                for (; i < schedulerQueue.length; i++) {
                  const currentEntry = schedulerQueue[i];
                  if (newEntry.endTime < currentEntry.endTime) {
                    break;
                  }
                }
                schedulerQueue.splice(i, 0, newEntry);
              });
            }
          }
        }
        lastCurrentTime = this._currentTickTime;
        this._currentTickTime = finalTime;
        if (doTick) {
          doTick(this._currentTickTime - lastCurrentTime);
        }
      }
      flushOnlyPendingTimers(doTick) {
        if (this._schedulerQueue.length === 0) {
          return 0;
        }
        const startTime = this._currentTickTime;
        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];
        this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });
        return this._currentTickTime - startTime;
      }
      flush(limit = 20, flushPeriodic = false, doTick) {
        if (flushPeriodic) {
          return this.flushPeriodic(doTick);
        } else {
          return this.flushNonPeriodic(limit, doTick);
        }
      }
      flushPeriodic(doTick) {
        if (this._schedulerQueue.length === 0) {
          return 0;
        }
        const startTime = this._currentTickTime;
        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];
        this.tick(lastTask.endTime - startTime, doTick);
        return this._currentTickTime - startTime;
      }
      flushNonPeriodic(limit, doTick) {
        const startTime = this._currentTickTime;
        let lastCurrentTime = 0;
        let count = 0;
        while (this._schedulerQueue.length > 0) {
          count++;
          if (count > limit) {
            throw new Error("flush failed after reaching the limit of " + limit + " tasks. Does your code use a polling timeout?");
          }
          if (this._schedulerQueue.filter((task) => !task.isPeriodic && !task.isRequestAnimationFrame).length === 0) {
            break;
          }
          const current = this._schedulerQueue.shift();
          lastCurrentTime = this._currentTickTime;
          this._currentTickTime = current.endTime;
          if (doTick) {
            doTick(this._currentTickTime - lastCurrentTime);
          }
          const retval = current.func.apply(global2, current.args);
          if (!retval) {
            break;
          }
        }
        return this._currentTickTime - startTime;
      }
    }
    Scheduler2.nextId = 1;
    class FakeAsyncTestZoneSpec {
      constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {
        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;
        this.macroTaskOptions = macroTaskOptions;
        this._scheduler = new Scheduler2();
        this._microtasks = [];
        this._lastError = null;
        this._uncaughtPromiseErrors = Promise[Zone.__symbol__("uncaughtPromiseErrors")];
        this.pendingPeriodicTimers = [];
        this.pendingTimers = [];
        this.patchDateLocked = false;
        this.properties = { "FakeAsyncTestZoneSpec": this };
        this.name = "fakeAsyncTestZone for " + namePrefix;
        if (!this.macroTaskOptions) {
          this.macroTaskOptions = global2[Zone.__symbol__("FakeAsyncTestMacroTask")];
        }
      }
      static assertInZone() {
        if (Zone.current.get("FakeAsyncTestZoneSpec") == null) {
          throw new Error("The code should be running in the fakeAsync zone to call this function");
        }
      }
      _fnAndFlush(fn2, completers) {
        return (...args) => {
          fn2.apply(global2, args);
          if (this._lastError === null) {
            if (completers.onSuccess != null) {
              completers.onSuccess.apply(global2);
            }
            this.flushMicrotasks();
          } else {
            if (completers.onError != null) {
              completers.onError.apply(global2);
            }
          }
          return this._lastError === null;
        };
      }
      static _removeTimer(timers2, id) {
        let index = timers2.indexOf(id);
        if (index > -1) {
          timers2.splice(index, 1);
        }
      }
      _dequeueTimer(id) {
        return () => {
          FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);
        };
      }
      _requeuePeriodicTimer(fn2, interval, args, id) {
        return () => {
          if (this.pendingPeriodicTimers.indexOf(id) !== -1) {
            this._scheduler.scheduleFunction(fn2, interval, { args, isPeriodic: true, id, isRequeuePeriodic: true });
          }
        };
      }
      _dequeuePeriodicTimer(id) {
        return () => {
          FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);
        };
      }
      _setTimeout(fn2, delay2, args, isTimer = true) {
        let removeTimerFn = this._dequeueTimer(Scheduler2.nextId);
        let cb = this._fnAndFlush(fn2, { onSuccess: removeTimerFn, onError: removeTimerFn });
        let id = this._scheduler.scheduleFunction(cb, delay2, { args, isRequestAnimationFrame: !isTimer });
        if (isTimer) {
          this.pendingTimers.push(id);
        }
        return id;
      }
      _clearTimeout(id) {
        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);
        this._scheduler.removeScheduledFunctionWithId(id);
      }
      _setInterval(fn2, interval, args) {
        let id = Scheduler2.nextId;
        let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };
        let cb = this._fnAndFlush(fn2, completers);
        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);
        this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });
        this.pendingPeriodicTimers.push(id);
        return id;
      }
      _clearInterval(id) {
        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);
        this._scheduler.removeScheduledFunctionWithId(id);
      }
      _resetLastErrorAndThrow() {
        let error3 = this._lastError || this._uncaughtPromiseErrors[0];
        this._uncaughtPromiseErrors.length = 0;
        this._lastError = null;
        throw error3;
      }
      getCurrentTickTime() {
        return this._scheduler.getCurrentTickTime();
      }
      getFakeSystemTime() {
        return this._scheduler.getFakeSystemTime();
      }
      setFakeBaseSystemTime(realTime) {
        this._scheduler.setFakeBaseSystemTime(realTime);
      }
      getRealSystemTime() {
        return this._scheduler.getRealSystemTime();
      }
      static patchDate() {
        if (!!global2[Zone.__symbol__("disableDatePatching")]) {
          return;
        }
        if (global2["Date"] === FakeDate) {
          return;
        }
        global2["Date"] = FakeDate;
        FakeDate.prototype = OriginalDate.prototype;
        FakeAsyncTestZoneSpec.checkTimerPatch();
      }
      static resetDate() {
        if (global2["Date"] === FakeDate) {
          global2["Date"] = OriginalDate;
        }
      }
      static checkTimerPatch() {
        if (global2.setTimeout !== timers.setTimeout) {
          global2.setTimeout = timers.setTimeout;
          global2.clearTimeout = timers.clearTimeout;
        }
        if (global2.setInterval !== timers.setInterval) {
          global2.setInterval = timers.setInterval;
          global2.clearInterval = timers.clearInterval;
        }
      }
      lockDatePatch() {
        this.patchDateLocked = true;
        FakeAsyncTestZoneSpec.patchDate();
      }
      unlockDatePatch() {
        this.patchDateLocked = false;
        FakeAsyncTestZoneSpec.resetDate();
      }
      tickToNext(steps = 1, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {
        if (steps <= 0) {
          return;
        }
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        this._scheduler.tickToNext(steps, doTick, tickOptions);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
      }
      tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        this._scheduler.tick(millis, doTick, tickOptions);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
      }
      flushMicrotasks() {
        FakeAsyncTestZoneSpec.assertInZone();
        const flushErrors = () => {
          if (this._lastError !== null || this._uncaughtPromiseErrors.length) {
            this._resetLastErrorAndThrow();
          }
        };
        while (this._microtasks.length > 0) {
          let microtask = this._microtasks.shift();
          microtask.func.apply(microtask.target, microtask.args);
        }
        flushErrors();
      }
      flush(limit, flushPeriodic, doTick) {
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
        return elapsed;
      }
      flushOnlyPendingTimers(doTick) {
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
        return elapsed;
      }
      removeAllTimers() {
        FakeAsyncTestZoneSpec.assertInZone();
        this._scheduler.removeAll();
        this.pendingPeriodicTimers = [];
        this.pendingTimers = [];
      }
      getTimerCount() {
        return this._scheduler.getTimerCount() + this._microtasks.length;
      }
      onScheduleTask(delegate, current, target, task) {
        switch (task.type) {
          case "microTask":
            let args = task.data && task.data.args;
            let additionalArgs;
            if (args) {
              let callbackIndex = task.data.cbIdx;
              if (typeof args.length === "number" && args.length > callbackIndex + 1) {
                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);
              }
            }
            this._microtasks.push({
              func: task.invoke,
              args: additionalArgs,
              target: task.data && task.data.target
            });
            break;
          case "macroTask":
            switch (task.source) {
              case "setTimeout":
                task.data["handleId"] = this._setTimeout(task.invoke, task.data["delay"], Array.prototype.slice.call(task.data["args"], 2));
                break;
              case "setImmediate":
                task.data["handleId"] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data["args"], 1));
                break;
              case "setInterval":
                task.data["handleId"] = this._setInterval(task.invoke, task.data["delay"], Array.prototype.slice.call(task.data["args"], 2));
                break;
              case "XMLHttpRequest.send":
                throw new Error("Cannot make XHRs from within a fake async test. Request URL: " + task.data["url"]);
              case "requestAnimationFrame":
              case "webkitRequestAnimationFrame":
              case "mozRequestAnimationFrame":
                task.data["handleId"] = this._setTimeout(task.invoke, 16, task.data["args"], this.trackPendingRequestAnimationFrame);
                break;
              default:
                const macroTaskOption = this.findMacroTaskOption(task);
                if (macroTaskOption) {
                  const args2 = task.data && task.data["args"];
                  const delay2 = args2 && args2.length > 1 ? args2[1] : 0;
                  let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args2;
                  if (!!macroTaskOption.isPeriodic) {
                    task.data["handleId"] = this._setInterval(task.invoke, delay2, callbackArgs);
                    task.data.isPeriodic = true;
                  } else {
                    task.data["handleId"] = this._setTimeout(task.invoke, delay2, callbackArgs);
                  }
                  break;
                }
                throw new Error("Unknown macroTask scheduled in fake async test: " + task.source);
            }
            break;
          case "eventTask":
            task = delegate.scheduleTask(target, task);
            break;
        }
        return task;
      }
      onCancelTask(delegate, current, target, task) {
        switch (task.source) {
          case "setTimeout":
          case "requestAnimationFrame":
          case "webkitRequestAnimationFrame":
          case "mozRequestAnimationFrame":
            return this._clearTimeout(task.data["handleId"]);
          case "setInterval":
            return this._clearInterval(task.data["handleId"]);
          default:
            const macroTaskOption = this.findMacroTaskOption(task);
            if (macroTaskOption) {
              const handleId = task.data["handleId"];
              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);
            }
            return delegate.cancelTask(target, task);
        }
      }
      onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {
        try {
          FakeAsyncTestZoneSpec.patchDate();
          return delegate.invoke(target, callback, applyThis, applyArgs, source);
        } finally {
          if (!this.patchDateLocked) {
            FakeAsyncTestZoneSpec.resetDate();
          }
        }
      }
      findMacroTaskOption(task) {
        if (!this.macroTaskOptions) {
          return null;
        }
        for (let i = 0; i < this.macroTaskOptions.length; i++) {
          const macroTaskOption = this.macroTaskOptions[i];
          if (macroTaskOption.source === task.source) {
            return macroTaskOption;
          }
        }
        return null;
      }
      onHandleError(parentZoneDelegate, currentZone, targetZone, error3) {
        this._lastError = error3;
        return false;
      }
    }
    Zone["FakeAsyncTestZoneSpec"] = FakeAsyncTestZoneSpec;
  })(typeof window === "object" && window || typeof self === "object" && self || global);
  Zone.__load_patch("fakeasync", (global2, Zone2, api) => {
    const FakeAsyncTestZoneSpec = Zone2 && Zone2["FakeAsyncTestZoneSpec"];
    function getProxyZoneSpec() {
      return Zone2 && Zone2["ProxyZoneSpec"];
    }
    let _fakeAsyncTestZoneSpec = null;
    function resetFakeAsyncZone3() {
      if (_fakeAsyncTestZoneSpec) {
        _fakeAsyncTestZoneSpec.unlockDatePatch();
      }
      _fakeAsyncTestZoneSpec = null;
      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();
    }
    function fakeAsync(fn2) {
      const fakeAsyncFn = function(...args) {
        const ProxyZoneSpec2 = getProxyZoneSpec();
        if (!ProxyZoneSpec2) {
          throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");
        }
        const proxyZoneSpec = ProxyZoneSpec2.assertPresent();
        if (Zone2.current.get("FakeAsyncTestZoneSpec")) {
          throw new Error("fakeAsync() calls can not be nested");
        }
        try {
          if (!_fakeAsyncTestZoneSpec) {
            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {
              throw new Error("fakeAsync() calls can not be nested");
            }
            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();
          }
          let res;
          const lastProxyZoneSpec = proxyZoneSpec.getDelegate();
          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);
          _fakeAsyncTestZoneSpec.lockDatePatch();
          try {
            res = fn2.apply(this, args);
            flushMicrotasks();
          } finally {
            proxyZoneSpec.setDelegate(lastProxyZoneSpec);
          }
          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {
            throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);
          }
          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {
            throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);
          }
          return res;
        } finally {
          resetFakeAsyncZone3();
        }
      };
      fakeAsyncFn.isFakeAsync = true;
      return fakeAsyncFn;
    }
    function _getFakeAsyncZoneSpec() {
      if (_fakeAsyncTestZoneSpec == null) {
        _fakeAsyncTestZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
        if (_fakeAsyncTestZoneSpec == null) {
          throw new Error("The code should be running in the fakeAsync zone to call this function");
        }
      }
      return _fakeAsyncTestZoneSpec;
    }
    function tick(millis = 0, ignoreNestedTimeout = false) {
      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);
    }
    function flush3(maxTurns) {
      return _getFakeAsyncZoneSpec().flush(maxTurns);
    }
    function discardPeriodicTasks() {
      const zoneSpec = _getFakeAsyncZoneSpec();
      zoneSpec.pendingPeriodicTimers;
      zoneSpec.pendingPeriodicTimers.length = 0;
    }
    function flushMicrotasks() {
      _getFakeAsyncZoneSpec().flushMicrotasks();
    }
    Zone2[api.symbol("fakeAsyncTest")] = { resetFakeAsyncZone: resetFakeAsyncZone3, flushMicrotasks, discardPeriodicTasks, tick, flush: flush3, fakeAsync };
  }, true);
  Zone.__load_patch("promisefortest", (global2, Zone2, api) => {
    const symbolState = api.symbol("state");
    const UNRESOLVED = null;
    const symbolParentUnresolved = api.symbol("parentUnresolved");
    Promise[api.symbol("patchPromiseForTest")] = function patchPromiseForTest() {
      let oriThen = Promise[Zone2.__symbol__("ZonePromiseThen")];
      if (oriThen) {
        return;
      }
      oriThen = Promise[Zone2.__symbol__("ZonePromiseThen")] = Promise.prototype.then;
      Promise.prototype.then = function() {
        const chained = oriThen.apply(this, arguments);
        if (this[symbolState] === UNRESOLVED) {
          const asyncTestZoneSpec = Zone2.current.get("AsyncTestZoneSpec");
          if (asyncTestZoneSpec) {
            asyncTestZoneSpec.unresolvedChainedPromiseCount++;
            chained[symbolParentUnresolved] = true;
          }
        }
        return chained;
      };
    };
    Promise[api.symbol("unPatchPromiseForTest")] = function unpatchPromiseForTest() {
      const oriThen = Promise[Zone2.__symbol__("ZonePromiseThen")];
      if (oriThen) {
        Promise.prototype.then = oriThen;
        Promise[Zone2.__symbol__("ZonePromiseThen")] = void 0;
      }
    };
  });

  // node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // node_modules/rxjs/_esm5/internal/util/isFunction.js
  function isFunction(x) {
    return typeof x === "function";
  }

  // node_modules/rxjs/_esm5/internal/config.js
  var _enable_super_gross_mode_that_will_cause_bad_things = false;
  var config = {
    Promise: void 0,
    set useDeprecatedSynchronousErrorHandling(value) {
      if (value) {
        var error3 = /* @__PURE__ */ new Error();
        /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error3.stack);
      } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
        /* @__PURE__ */ console.log("RxJS: Back to a better error behavior. Thank you. <3");
      }
      _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
      return _enable_super_gross_mode_that_will_cause_bad_things;
    }
  };

  // node_modules/rxjs/_esm5/internal/util/hostReportError.js
  function hostReportError(err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }

  // node_modules/rxjs/_esm5/internal/Observer.js
  var empty = {
    closed: true,
    next: function(value) {
    },
    error: function(err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    },
    complete: function() {
    }
  };

  // node_modules/rxjs/_esm5/internal/util/isArray.js
  var isArray = /* @__PURE__ */ function() {
    return Array.isArray || function(x) {
      return x && typeof x.length === "number";
    };
  }();

  // node_modules/rxjs/_esm5/internal/util/isObject.js
  function isObject(x) {
    return x !== null && typeof x === "object";
  }

  // node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
    function UnsubscriptionErrorImpl2(errors) {
      Error.call(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
      return this;
    }
    UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl2;
  }();
  var UnsubscriptionError = UnsubscriptionErrorImpl;

  // node_modules/rxjs/_esm5/internal/Subscription.js
  var Subscription = /* @__PURE__ */ function() {
    function Subscription2(unsubscribe) {
      this.closed = false;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (unsubscribe) {
        this._ctorUnsubscribe = true;
        this._unsubscribe = unsubscribe;
      }
    }
    Subscription2.prototype.unsubscribe = function() {
      var errors;
      if (this.closed) {
        return;
      }
      var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
      this.closed = true;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (_parentOrParents instanceof Subscription2) {
        _parentOrParents.remove(this);
      } else if (_parentOrParents !== null) {
        for (var index = 0; index < _parentOrParents.length; ++index) {
          var parent_1 = _parentOrParents[index];
          parent_1.remove(this);
        }
      }
      if (isFunction(_unsubscribe)) {
        if (_ctorUnsubscribe) {
          this._unsubscribe = void 0;
        }
        try {
          _unsubscribe.call(this);
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
        }
      }
      if (isArray(_subscriptions)) {
        var index = -1;
        var len = _subscriptions.length;
        while (++index < len) {
          var sub = _subscriptions[index];
          if (isObject(sub)) {
            try {
              sub.unsubscribe();
            } catch (e) {
              errors = errors || [];
              if (e instanceof UnsubscriptionError) {
                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
              } else {
                errors.push(e);
              }
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var subscription = teardown;
      if (!teardown) {
        return Subscription2.EMPTY;
      }
      switch (typeof teardown) {
        case "function":
          subscription = new Subscription2(teardown);
        case "object":
          if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
            return subscription;
          } else if (this.closed) {
            subscription.unsubscribe();
            return subscription;
          } else if (!(subscription instanceof Subscription2)) {
            var tmp = subscription;
            subscription = new Subscription2();
            subscription._subscriptions = [tmp];
          }
          break;
        default: {
          throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
        }
      }
      var _parentOrParents = subscription._parentOrParents;
      if (_parentOrParents === null) {
        subscription._parentOrParents = this;
      } else if (_parentOrParents instanceof Subscription2) {
        if (_parentOrParents === this) {
          return subscription;
        }
        subscription._parentOrParents = [_parentOrParents, this];
      } else if (_parentOrParents.indexOf(this) === -1) {
        _parentOrParents.push(this);
      } else {
        return subscription;
      }
      var subscriptions = this._subscriptions;
      if (subscriptions === null) {
        this._subscriptions = [subscription];
      } else {
        subscriptions.push(subscription);
      }
      return subscription;
    };
    Subscription2.prototype.remove = function(subscription) {
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    Subscription2.EMPTY = function(empty3) {
      empty3.closed = true;
      return empty3;
    }(new Subscription2());
    return Subscription2;
  }();
  function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function(errs, err) {
      return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
    }, []);
  }

  // node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
  var rxSubscriber = /* @__PURE__ */ function() {
    return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
  }();

  // node_modules/rxjs/_esm5/internal/Subscriber.js
  var Subscriber = /* @__PURE__ */ function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destinationOrNext, error3, complete) {
      var _this = _super.call(this) || this;
      _this.syncErrorValue = null;
      _this.syncErrorThrown = false;
      _this.syncErrorThrowable = false;
      _this.isStopped = false;
      switch (arguments.length) {
        case 0:
          _this.destination = empty;
          break;
        case 1:
          if (!destinationOrNext) {
            _this.destination = empty;
            break;
          }
          if (typeof destinationOrNext === "object") {
            if (destinationOrNext instanceof Subscriber2) {
              _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
              _this.destination = destinationOrNext;
              destinationOrNext.add(_this);
            } else {
              _this.syncErrorThrowable = true;
              _this.destination = new SafeSubscriber(_this, destinationOrNext);
            }
            break;
          }
        default:
          _this.syncErrorThrowable = true;
          _this.destination = new SafeSubscriber(_this, destinationOrNext, error3, complete);
          break;
      }
      return _this;
    }
    Subscriber2.prototype[rxSubscriber] = function() {
      return this;
    };
    Subscriber2.create = function(next, error3, complete) {
      var subscriber = new Subscriber2(next, error3, complete);
      subscriber.syncErrorThrowable = false;
      return subscriber;
    };
    Subscriber2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      this.destination.error(err);
      this.unsubscribe();
    };
    Subscriber2.prototype._complete = function() {
      this.destination.complete();
      this.unsubscribe();
    };
    Subscriber2.prototype._unsubscribeAndRecycle = function() {
      var _parentOrParents = this._parentOrParents;
      this._parentOrParents = null;
      this.unsubscribe();
      this.closed = false;
      this.isStopped = false;
      this._parentOrParents = _parentOrParents;
      return this;
    };
    return Subscriber2;
  }(Subscription);
  var SafeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(_parentSubscriber, observerOrNext, error3, complete) {
      var _this = _super.call(this) || this;
      _this._parentSubscriber = _parentSubscriber;
      var next;
      var context = _this;
      if (isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next;
        error3 = observerOrNext.error;
        complete = observerOrNext.complete;
        if (observerOrNext !== empty) {
          context = Object.create(observerOrNext);
          if (isFunction(context.unsubscribe)) {
            _this.add(context.unsubscribe.bind(context));
          }
          context.unsubscribe = _this.unsubscribe.bind(_this);
        }
      }
      _this._context = context;
      _this._next = next;
      _this._error = error3;
      _this._complete = complete;
      return _this;
    }
    SafeSubscriber2.prototype.next = function(value) {
      if (!this.isStopped && this._next) {
        var _parentSubscriber = this._parentSubscriber;
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._next, value);
        } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
        if (this._error) {
          if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._error, err);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, this._error, err);
            this.unsubscribe();
          }
        } else if (!_parentSubscriber.syncErrorThrowable) {
          this.unsubscribe();
          if (useDeprecatedSynchronousErrorHandling) {
            throw err;
          }
          hostReportError(err);
        } else {
          if (useDeprecatedSynchronousErrorHandling) {
            _parentSubscriber.syncErrorValue = err;
            _parentSubscriber.syncErrorThrown = true;
          } else {
            hostReportError(err);
          }
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.complete = function() {
      var _this = this;
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        if (this._complete) {
          var wrappedComplete = function() {
            return _this._complete.call(_this._context);
          };
          if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(wrappedComplete);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, wrappedComplete);
            this.unsubscribe();
          }
        } else {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
      try {
        fn2.call(this._context, value);
      } catch (err) {
        this.unsubscribe();
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
      if (!config.useDeprecatedSynchronousErrorHandling) {
        throw new Error("bad call");
      }
      try {
        fn2.call(this._context, value);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          parent.syncErrorValue = err;
          parent.syncErrorThrown = true;
          return true;
        } else {
          hostReportError(err);
          return true;
        }
      }
      return false;
    };
    SafeSubscriber2.prototype._unsubscribe = function() {
      var _parentSubscriber = this._parentSubscriber;
      this._context = null;
      this._parentSubscriber = null;
      _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/_esm5/internal/util/canReportError.js
  function canReportError(observer) {
    while (observer) {
      var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
      if (closed_1 || isStopped) {
        return false;
      } else if (destination && destination instanceof Subscriber) {
        observer = destination;
      } else {
        observer = null;
      }
    }
    return true;
  }

  // node_modules/rxjs/_esm5/internal/util/toSubscriber.js
  function toSubscriber(nextOrObserver, error3, complete) {
    if (nextOrObserver) {
      if (nextOrObserver instanceof Subscriber) {
        return nextOrObserver;
      }
      if (nextOrObserver[rxSubscriber]) {
        return nextOrObserver[rxSubscriber]();
      }
    }
    if (!nextOrObserver && !error3 && !complete) {
      return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error3, complete);
  }

  // node_modules/rxjs/_esm5/internal/symbol/observable.js
  var observable = /* @__PURE__ */ function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // node_modules/rxjs/_esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // node_modules/rxjs/_esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn2) {
        return fn2(prev);
      }, input);
    };
  }

  // node_modules/rxjs/_esm5/internal/Observable.js
  var Observable = /* @__PURE__ */ function() {
    function Observable2(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error3, complete) {
      var operator = this.operator;
      var sink = toSubscriber(observerOrNext, error3, complete);
      if (operator) {
        sink.add(operator.call(sink, this.source));
      } else {
        sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
      }
      if (config.useDeprecatedSynchronousErrorHandling) {
        if (sink.syncErrorThrowable) {
          sink.syncErrorThrowable = false;
          if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
          }
        }
      }
      return sink;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          sink.syncErrorThrown = true;
          sink.syncErrorValue = err;
        }
        if (canReportError(sink)) {
          sink.error(err);
        } else {
          console.warn(err);
        }
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscription;
        subscription = _this.subscribe(function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            if (subscription) {
              subscription.unsubscribe();
            }
          }
        }, reject, resolve);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      return source && source.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      if (operations.length === 0) {
        return this;
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
      promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
      throw new Error("no Promise impl found");
    }
    return promiseCtor;
  }

  // node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
    function ObjectUnsubscribedErrorImpl2() {
      Error.call(this);
      this.message = "object unsubscribed";
      this.name = "ObjectUnsubscribedError";
      return this;
    }
    ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl2;
  }();
  var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

  // node_modules/rxjs/_esm5/internal/SubjectSubscription.js
  var SubjectSubscription = /* @__PURE__ */ function(_super) {
    __extends(SubjectSubscription2, _super);
    function SubjectSubscription2(subject, subscriber) {
      var _this = _super.call(this) || this;
      _this.subject = subject;
      _this.subscriber = subscriber;
      _this.closed = false;
      return _this;
    }
    SubjectSubscription2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.closed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;
      if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
        return;
      }
      var subscriberIndex = observers.indexOf(this.subscriber);
      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };
    return SubjectSubscription2;
  }(Subscription);

  // node_modules/rxjs/_esm5/internal/Subject.js
  var SubjectSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SubjectSubscriber2, _super);
    function SubjectSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      return _this;
    }
    return SubjectSubscriber2;
  }(Subscriber);
  var Subject = /* @__PURE__ */ function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.observers = [];
      _this.closed = false;
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype[rxSubscriber] = function() {
      return new SubjectSubscriber(this);
    };
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype.next = function(value) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      if (!this.isStopped) {
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
          copy[i].next(value);
        }
      }
    };
    Subject2.prototype.error = function(err) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.hasError = true;
      this.thrownError = err;
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i = 0; i < len; i++) {
        copy[i].error(err);
      }
      this.observers.length = 0;
    };
    Subject2.prototype.complete = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i = 0; i < len; i++) {
        copy[i].complete();
      }
      this.observers.length = 0;
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = true;
      this.closed = true;
      this.observers = null;
    };
    Subject2.prototype._trySubscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return _super.prototype._trySubscribe.call(this, subscriber);
      }
    };
    Subject2.prototype._subscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.isStopped) {
        subscriber.complete();
        return Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        return new SubjectSubscription(this, subscriber);
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = /* @__PURE__ */ function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var destination = this.destination;
      if (destination && destination.next) {
        destination.next(value);
      }
    };
    AnonymousSubject2.prototype.error = function(err) {
      var destination = this.destination;
      if (destination && destination.error) {
        this.destination.error(err);
      }
    };
    AnonymousSubject2.prototype.complete = function() {
      var destination = this.destination;
      if (destination && destination.complete) {
        this.destination.complete();
      }
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      if (source) {
        return this.source.subscribe(subscriber);
      } else {
        return Subscription.EMPTY;
      }
    };
    return AnonymousSubject2;
  }(Subject);

  // node_modules/rxjs/_esm5/internal/operators/refCount.js
  function refCount() {
    return function refCountOperatorFunction(source) {
      return source.lift(new RefCountOperator(source));
    };
  }
  var RefCountOperator = /* @__PURE__ */ function() {
    function RefCountOperator2(connectable) {
      this.connectable = connectable;
    }
    RefCountOperator2.prototype.call = function(subscriber, source) {
      var connectable = this.connectable;
      connectable._refCount++;
      var refCounter = new RefCountSubscriber(subscriber, connectable);
      var subscription = source.subscribe(refCounter);
      if (!refCounter.closed) {
        refCounter.connection = connectable.connect();
      }
      return subscription;
    };
    return RefCountOperator2;
  }();
  var RefCountSubscriber = /* @__PURE__ */ function(_super) {
    __extends(RefCountSubscriber2, _super);
    function RefCountSubscriber2(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    RefCountSubscriber2.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (!connectable) {
        this.connection = null;
        return;
      }
      this.connectable = null;
      var refCount2 = connectable._refCount;
      if (refCount2 <= 0) {
        this.connection = null;
        return;
      }
      connectable._refCount = refCount2 - 1;
      if (refCount2 > 1) {
        this.connection = null;
        return;
      }
      var connection = this.connection;
      var sharedConnection = connectable._connection;
      this.connection = null;
      if (sharedConnection && (!connection || sharedConnection === connection)) {
        sharedConnection.unsubscribe();
      }
    };
    return RefCountSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
  var ConnectableObservable = /* @__PURE__ */ function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._refCount = 0;
      _this._isComplete = false;
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype.connect = function() {
      var connection = this._connection;
      if (!connection) {
        this._isComplete = false;
        connection = this._connection = new Subscription();
        connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable);
  var connectableObservableDescriptor = /* @__PURE__ */ function() {
    var connectableProto = ConnectableObservable.prototype;
    return {
      operator: { value: null },
      _refCount: { value: 0, writable: true },
      _subject: { value: null, writable: true },
      _connection: { value: null, writable: true },
      _subscribe: { value: connectableProto._subscribe },
      _isComplete: { value: connectableProto._isComplete, writable: true },
      getSubject: { value: connectableProto.getSubject },
      connect: { value: connectableProto.connect },
      refCount: { value: connectableProto.refCount }
    };
  }();
  var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ConnectableSubscriber2, _super);
    function ConnectableSubscriber2(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    ConnectableSubscriber2.prototype._error = function(err) {
      this._unsubscribe();
      _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber2.prototype._complete = function() {
      this.connectable._isComplete = true;
      this._unsubscribe();
      _super.prototype._complete.call(this);
    };
    ConnectableSubscriber2.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (connectable) {
        this.connectable = null;
        var connection = connectable._connection;
        connectable._refCount = 0;
        connectable._subject = null;
        connectable._connection = null;
        if (connection) {
          connection.unsubscribe();
        }
      }
    };
    return ConnectableSubscriber2;
  }(SubjectSubscriber);

  // node_modules/rxjs/_esm5/internal/BehaviorSubject.js
  var BehaviorSubject = /* @__PURE__ */ function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: true,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this._value);
      }
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      if (this.hasError) {
        throw this.thrownError;
      } else if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return this._value;
      }
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);

  // node_modules/rxjs/_esm5/internal/scheduler/Action.js
  var Action = /* @__PURE__ */ function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription);

  // node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
  var AsyncAction = /* @__PURE__ */ function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && this.delay === delay2 && this.pending === false) {
        return id;
      }
      clearInterval(id);
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error3 = this._execute(state, delay2);
      if (error3) {
        return error3;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, delay2) {
      var errored = false;
      var errorValue = void 0;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = !!e && e || new Error(e);
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype._unsubscribe = function() {
      var id = this.id;
      var scheduler = this.scheduler;
      var actions = scheduler.actions;
      var index = actions.indexOf(this);
      this.work = null;
      this.state = null;
      this.pending = false;
      this.scheduler = null;
      if (index !== -1) {
        actions.splice(index, 1);
      }
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
    };
    return AsyncAction2;
  }(Action);

  // node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
  var QueueAction = /* @__PURE__ */ function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 > 0) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.delay = delay2;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay2) {
      return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      return scheduler.flush(this);
    };
    return QueueAction2;
  }(AsyncAction);

  // node_modules/rxjs/_esm5/internal/Scheduler.js
  var Scheduler = /* @__PURE__ */ function() {
    function Scheduler2(SchedulerAction, now2) {
      if (now2 === void 0) {
        now2 = Scheduler2.now;
      }
      this.SchedulerAction = SchedulerAction;
      this.now = now2;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.SchedulerAction(this, work).schedule(state, delay2);
    };
    Scheduler2.now = function() {
      return Date.now();
    };
    return Scheduler2;
  }();

  // node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
  var AsyncScheduler = /* @__PURE__ */ function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now2) {
      if (now2 === void 0) {
        now2 = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, function() {
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
          return AsyncScheduler2.delegate.now();
        } else {
          return now2();
        }
      }) || this;
      _this.actions = [];
      _this.active = false;
      _this.scheduled = void 0;
      return _this;
    }
    AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
        return AsyncScheduler2.delegate.schedule(work, delay2, state);
      } else {
        return _super.prototype.schedule.call(this, work, delay2, state);
      }
    };
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this.active) {
        actions.push(action);
        return;
      }
      var error3;
      this.active = true;
      do {
        if (error3 = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this.active = false;
      if (error3) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error3;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);

  // node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
  var QueueScheduler = /* @__PURE__ */ function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler);

  // node_modules/rxjs/_esm5/internal/scheduler/queue.js
  var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
  var queue = queueScheduler;

  // node_modules/rxjs/_esm5/internal/observable/empty.js
  var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty2(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
  }
  function emptyScheduled(scheduler) {
    return new Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }

  // node_modules/rxjs/_esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && typeof value.schedule === "function";
  }

  // node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
  var subscribeToArray = function(array) {
    return function(subscriber) {
      for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    };
  };

  // node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      var i = 0;
      sub.add(scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
          return;
        }
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          sub.add(this.schedule());
        }
      }));
      return sub;
    });
  }

  // node_modules/rxjs/_esm5/internal/observable/fromArray.js
  function fromArray(input, scheduler) {
    if (!scheduler) {
      return new Observable(subscribeToArray(input));
    } else {
      return scheduleArray(input, scheduler);
    }
  }

  // node_modules/rxjs/_esm5/internal/observable/of.js
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
      args.pop();
      return scheduleArray(args, scheduler);
    } else {
      return fromArray(args);
    }
  }

  // node_modules/rxjs/_esm5/internal/observable/throwError.js
  function throwError(error3, scheduler) {
    if (!scheduler) {
      return new Observable(function(subscriber) {
        return subscriber.error(error3);
      });
    } else {
      return new Observable(function(subscriber) {
        return scheduler.schedule(dispatch, 0, { error: error3, subscriber });
      });
    }
  }
  function dispatch(_a) {
    var error3 = _a.error, subscriber = _a.subscriber;
    subscriber.error(error3);
  }

  // node_modules/rxjs/_esm5/internal/Notification.js
  var NotificationKind;
  /* @__PURE__ */ (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind || (NotificationKind = {}));
  var Notification = /* @__PURE__ */ function() {
    function Notification2(kind, value, error3) {
      this.kind = kind;
      this.value = value;
      this.error = error3;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      switch (this.kind) {
        case "N":
          return observer.next && observer.next(this.value);
        case "E":
          return observer.error && observer.error(this.error);
        case "C":
          return observer.complete && observer.complete();
      }
    };
    Notification2.prototype.do = function(next, error3, complete) {
      var kind = this.kind;
      switch (kind) {
        case "N":
          return next && next(this.value);
        case "E":
          return error3 && error3(this.error);
        case "C":
          return complete && complete();
      }
    };
    Notification2.prototype.accept = function(nextOrObserver, error3, complete) {
      if (nextOrObserver && typeof nextOrObserver.next === "function") {
        return this.observe(nextOrObserver);
      } else {
        return this.do(nextOrObserver, error3, complete);
      }
    };
    Notification2.prototype.toObservable = function() {
      var kind = this.kind;
      switch (kind) {
        case "N":
          return of(this.value);
        case "E":
          return throwError(this.error);
        case "C":
          return empty2();
      }
      throw new Error("unexpected notification kind value");
    };
    Notification2.createNext = function(value) {
      if (typeof value !== "undefined") {
        return new Notification2("N", value);
      }
      return Notification2.undefinedValueNotification;
    };
    Notification2.createError = function(err) {
      return new Notification2("E", void 0, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    Notification2.undefinedValueNotification = new Notification2("N", void 0);
    return Notification2;
  }();

  // node_modules/rxjs/_esm5/internal/operators/observeOn.js
  var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ObserveOnSubscriber2, _super);
    function ObserveOnSubscriber2(destination, scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      var _this = _super.call(this, destination) || this;
      _this.scheduler = scheduler;
      _this.delay = delay2;
      return _this;
    }
    ObserveOnSubscriber2.dispatch = function(arg) {
      var notification = arg.notification, destination = arg.destination;
      notification.observe(destination);
      this.unsubscribe();
    };
    ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
      var destination = this.destination;
      destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber2.prototype._next = function(value) {
      this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber2.prototype._error = function(err) {
      this.scheduleMessage(Notification.createError(err));
      this.unsubscribe();
    };
    ObserveOnSubscriber2.prototype._complete = function() {
      this.scheduleMessage(Notification.createComplete());
      this.unsubscribe();
    };
    return ObserveOnSubscriber2;
  }(Subscriber);
  var ObserveOnMessage = /* @__PURE__ */ function() {
    function ObserveOnMessage2(notification, destination) {
      this.notification = notification;
      this.destination = destination;
    }
    return ObserveOnMessage2;
  }();

  // node_modules/rxjs/_esm5/internal/ReplaySubject.js
  var ReplaySubject = /* @__PURE__ */ function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(bufferSize, windowTime, scheduler) {
      if (bufferSize === void 0) {
        bufferSize = Number.POSITIVE_INFINITY;
      }
      if (windowTime === void 0) {
        windowTime = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this) || this;
      _this.scheduler = scheduler;
      _this._events = [];
      _this._infiniteTimeWindow = false;
      _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
      _this._windowTime = windowTime < 1 ? 1 : windowTime;
      if (windowTime === Number.POSITIVE_INFINITY) {
        _this._infiniteTimeWindow = true;
        _this.next = _this.nextInfiniteTimeWindow;
      } else {
        _this.next = _this.nextTimeWindow;
      }
      return _this;
    }
    ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
      if (!this.isStopped) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
          _events.shift();
        }
      }
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype.nextTimeWindow = function(value) {
      if (!this.isStopped) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
      }
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      var _infiniteTimeWindow = this._infiniteTimeWindow;
      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
      var scheduler = this.scheduler;
      var len = _events.length;
      var subscription;
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.isStopped || this.hasError) {
        subscription = Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        subscription = new SubjectSubscription(this, subscriber);
      }
      if (scheduler) {
        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
      }
      if (_infiniteTimeWindow) {
        for (var i = 0; i < len && !subscriber.closed; i++) {
          subscriber.next(_events[i]);
        }
      } else {
        for (var i = 0; i < len && !subscriber.closed; i++) {
          subscriber.next(_events[i].value);
        }
      }
      if (this.hasError) {
        subscriber.error(this.thrownError);
      } else if (this.isStopped) {
        subscriber.complete();
      }
      return subscription;
    };
    ReplaySubject2.prototype._getNow = function() {
      return (this.scheduler || queue).now();
    };
    ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
      var now2 = this._getNow();
      var _bufferSize = this._bufferSize;
      var _windowTime = this._windowTime;
      var _events = this._events;
      var eventsCount = _events.length;
      var spliceCount = 0;
      while (spliceCount < eventsCount) {
        if (now2 - _events[spliceCount].time < _windowTime) {
          break;
        }
        spliceCount++;
      }
      if (eventsCount > _bufferSize) {
        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
      }
      if (spliceCount > 0) {
        _events.splice(0, spliceCount);
      }
      return _events;
    };
    return ReplaySubject2;
  }(Subject);
  var ReplayEvent = /* @__PURE__ */ function() {
    function ReplayEvent2(time, value) {
      this.time = time;
      this.value = value;
    }
    return ReplayEvent2;
  }();

  // node_modules/rxjs/_esm5/internal/scheduler/async.js
  var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  // node_modules/rxjs/_esm5/internal/util/noop.js
  function noop() {
  }

  // node_modules/rxjs/_esm5/internal/operators/map.js
  function map(project, thisArg) {
    return function mapOperation(source) {
      if (typeof project !== "function") {
        throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
      }
      return source.lift(new MapOperator(project, thisArg));
    };
  }
  var MapOperator = /* @__PURE__ */ function() {
    function MapOperator2(project, thisArg) {
      this.project = project;
      this.thisArg = thisArg;
    }
    MapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator2;
  }();
  var MapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MapSubscriber2, _super);
    function MapSubscriber2(destination, project, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.count = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    }
    MapSubscriber2.prototype._next = function(value) {
      var result;
      try {
        result = this.project.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return MapSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
  var subscribeToPromise = function(promise2) {
    return function(subscriber) {
      promise2.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, hostReportError);
      return subscriber;
    };
  };

  // node_modules/rxjs/_esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = /* @__PURE__ */ getSymbolIterator();

  // node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
  var subscribeToIterable = function(iterable) {
    return function(subscriber) {
      var iterator2 = iterable[iterator]();
      do {
        var item = void 0;
        try {
          item = iterator2.next();
        } catch (err) {
          subscriber.error(err);
          return subscriber;
        }
        if (item.done) {
          subscriber.complete();
          break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
          break;
        }
      } while (true);
      if (typeof iterator2.return === "function") {
        subscriber.add(function() {
          if (iterator2.return) {
            iterator2.return();
          }
        });
      }
      return subscriber;
    };
  };

  // node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
  var subscribeToObservable = function(obj) {
    return function(subscriber) {
      var obs = obj[observable]();
      if (typeof obs.subscribe !== "function") {
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      } else {
        return obs.subscribe(subscriber);
      }
    };
  };

  // node_modules/rxjs/_esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };

  // node_modules/rxjs/_esm5/internal/util/isPromise.js
  function isPromise(value) {
    return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
  }

  // node_modules/rxjs/_esm5/internal/util/subscribeTo.js
  var subscribeTo = function(result) {
    if (!!result && typeof result[observable] === "function") {
      return subscribeToObservable(result);
    } else if (isArrayLike(result)) {
      return subscribeToArray(result);
    } else if (isPromise(result)) {
      return subscribeToPromise(result);
    } else if (!!result && typeof result[iterator] === "function") {
      return subscribeToIterable(result);
    } else {
      var value = isObject(result) ? "an invalid object" : "'" + result + "'";
      var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
      throw new TypeError(msg);
    }
  };

  // node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      sub.add(scheduler.schedule(function() {
        var observable2 = input[observable]();
        sub.add(observable2.subscribe({
          next: function(value) {
            sub.add(scheduler.schedule(function() {
              return subscriber.next(value);
            }));
          },
          error: function(err) {
            sub.add(scheduler.schedule(function() {
              return subscriber.error(err);
            }));
          },
          complete: function() {
            sub.add(scheduler.schedule(function() {
              return subscriber.complete();
            }));
          }
        }));
      }));
      return sub;
    });
  }

  // node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      sub.add(scheduler.schedule(function() {
        return input.then(function(value) {
          sub.add(scheduler.schedule(function() {
            subscriber.next(value);
            sub.add(scheduler.schedule(function() {
              return subscriber.complete();
            }));
          }));
        }, function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        });
      }));
      return sub;
    });
  }

  // node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      var iterator2;
      sub.add(function() {
        if (iterator2 && typeof iterator2.return === "function") {
          iterator2.return();
        }
      });
      sub.add(scheduler.schedule(function() {
        iterator2 = input[iterator]();
        sub.add(scheduler.schedule(function() {
          if (subscriber.closed) {
            return;
          }
          var value;
          var done;
          try {
            var result = iterator2.next();
            value = result.value;
            done = result.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
            this.schedule();
          }
        }));
      }));
      return sub;
    });
  }

  // node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return input && typeof input[observable] === "function";
  }

  // node_modules/rxjs/_esm5/internal/util/isIterable.js
  function isIterable(input) {
    return input && typeof input[iterator] === "function";
  }

  // node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      } else if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      } else if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      } else if (isIterable(input) || typeof input === "string") {
        return scheduleIterable(input, scheduler);
      }
    }
    throw new TypeError((input !== null && typeof input || input) + " is not observable");
  }

  // node_modules/rxjs/_esm5/internal/observable/from.js
  function from(input, scheduler) {
    if (!scheduler) {
      if (input instanceof Observable) {
        return input;
      }
      return new Observable(subscribeTo(input));
    } else {
      return scheduled(input, scheduler);
    }
  }

  // node_modules/rxjs/_esm5/internal/innerSubscribe.js
  var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SimpleInnerSubscriber2, _super);
    function SimpleInnerSubscriber2(parent) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      return _this;
    }
    SimpleInnerSubscriber2.prototype._next = function(value) {
      this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber2.prototype._error = function(error3) {
      this.parent.notifyError(error3);
      this.unsubscribe();
    };
    SimpleInnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete();
      this.unsubscribe();
    };
    return SimpleInnerSubscriber2;
  }(Subscriber);
  var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SimpleOuterSubscriber2, _super);
    function SimpleOuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    SimpleOuterSubscriber2.prototype.notifyError = function(err) {
      this.destination.error(err);
    };
    SimpleOuterSubscriber2.prototype.notifyComplete = function() {
      this.destination.complete();
    };
    return SimpleOuterSubscriber2;
  }(Subscriber);
  function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
      return void 0;
    }
    if (result instanceof Observable) {
      return result.subscribe(innerSubscriber);
    }
    var subscription;
    try {
      subscription = subscribeTo(result)(innerSubscriber);
    } catch (error3) {
      innerSubscriber.error(error3);
    }
    return subscription;
  }

  // node_modules/rxjs/_esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === "function") {
      return function(source) {
        return source.pipe(mergeMap(function(a, i) {
          return from(project(a, i)).pipe(map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }, concurrent));
      };
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return function(source) {
      return source.lift(new MergeMapOperator(project, concurrent));
    };
  }
  var MergeMapOperator = /* @__PURE__ */ function() {
    function MergeMapOperator2(project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      this.project = project;
      this.concurrent = concurrent;
    }
    MergeMapOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator2;
  }();
  var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MergeMapSubscriber2, _super);
    function MergeMapSubscriber2(destination, project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.concurrent = concurrent;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }
    MergeMapSubscriber2.prototype._next = function(value) {
      if (this.active < this.concurrent) {
        this._tryNext(value);
      } else {
        this.buffer.push(value);
      }
    };
    MergeMapSubscriber2.prototype._tryNext = function(value) {
      var result;
      var index = this.index++;
      try {
        result = this.project(value, index);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.active++;
      this._innerSub(result);
    };
    MergeMapSubscriber2.prototype._innerSub = function(ish) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(ish, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    MergeMapSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.active === 0 && this.buffer.length === 0) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    MergeMapSubscriber2.prototype.notifyComplete = function() {
      var buffer = this.buffer;
      this.active--;
      if (buffer.length > 0) {
        this._next(buffer.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        this.destination.complete();
      }
    };
    return MergeMapSubscriber2;
  }(SimpleOuterSubscriber);

  // node_modules/rxjs/_esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
  }

  // node_modules/rxjs/_esm5/internal/observable/merge.js
  function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler(last)) {
      scheduler = observables.pop();
      if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
        concurrent = observables.pop();
      }
    } else if (typeof last === "number") {
      concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
      return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
  }

  // node_modules/rxjs/_esm5/internal/observable/never.js
  var NEVER = /* @__PURE__ */ new Observable(noop);

  // node_modules/rxjs/_esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
      return source.lift(new FilterOperator(predicate, thisArg));
    };
  }
  var FilterOperator = /* @__PURE__ */ function() {
    function FilterOperator2(predicate, thisArg) {
      this.predicate = predicate;
      this.thisArg = thisArg;
    }
    FilterOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator2;
  }();
  var FilterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(FilterSubscriber2, _super);
    function FilterSubscriber2(destination, predicate, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.count = 0;
      return _this;
    }
    FilterSubscriber2.prototype._next = function(value) {
      var result;
      try {
        result = this.predicate.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (result) {
        this.destination.next(value);
      }
    };
    return FilterSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/_esm5/internal/operators/catchError.js
  function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
      var operator = new CatchOperator(selector);
      var caught = source.lift(operator);
      return operator.caught = caught;
    };
  }
  var CatchOperator = /* @__PURE__ */ function() {
    function CatchOperator2(selector) {
      this.selector = selector;
    }
    CatchOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator2;
  }();
  var CatchSubscriber = /* @__PURE__ */ function(_super) {
    __extends(CatchSubscriber2, _super);
    function CatchSubscriber2(destination, selector, caught) {
      var _this = _super.call(this, destination) || this;
      _this.selector = selector;
      _this.caught = caught;
      return _this;
    }
    CatchSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var result = void 0;
        try {
          result = this.selector(err, this.caught);
        } catch (err2) {
          _super.prototype.error.call(this, err2);
          return;
        }
        this._unsubscribeAndRecycle();
        var innerSubscriber = new SimpleInnerSubscriber(this);
        this.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          this.add(innerSubscription);
        }
      }
    };
    return CatchSubscriber2;
  }(SimpleOuterSubscriber);

  // node_modules/rxjs/_esm5/internal/util/isDate.js
  function isDate(value) {
    return value instanceof Date && !isNaN(+value);
  }

  // node_modules/rxjs/_esm5/internal/operators/delay.js
  function delay(delay2, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    var absoluteDelay = isDate(delay2);
    var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
    return function(source) {
      return source.lift(new DelayOperator(delayFor, scheduler));
    };
  }
  var DelayOperator = /* @__PURE__ */ function() {
    function DelayOperator2(delay2, scheduler) {
      this.delay = delay2;
      this.scheduler = scheduler;
    }
    DelayOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator2;
  }();
  var DelaySubscriber = /* @__PURE__ */ function(_super) {
    __extends(DelaySubscriber2, _super);
    function DelaySubscriber2(destination, delay2, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.delay = delay2;
      _this.scheduler = scheduler;
      _this.queue = [];
      _this.active = false;
      _this.errored = false;
      return _this;
    }
    DelaySubscriber2.dispatch = function(state) {
      var source = state.source;
      var queue2 = source.queue;
      var scheduler = state.scheduler;
      var destination = state.destination;
      while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
        queue2.shift().notification.observe(destination);
      }
      if (queue2.length > 0) {
        var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
        this.schedule(state, delay_1);
      } else {
        this.unsubscribe();
        source.active = false;
      }
    };
    DelaySubscriber2.prototype._schedule = function(scheduler) {
      this.active = true;
      var destination = this.destination;
      destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
        source: this,
        destination: this.destination,
        scheduler
      }));
    };
    DelaySubscriber2.prototype.scheduleNotification = function(notification) {
      if (this.errored === true) {
        return;
      }
      var scheduler = this.scheduler;
      var message = new DelayMessage(scheduler.now() + this.delay, notification);
      this.queue.push(message);
      if (this.active === false) {
        this._schedule(scheduler);
      }
    };
    DelaySubscriber2.prototype._next = function(value) {
      this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber2.prototype._error = function(err) {
      this.errored = true;
      this.queue = [];
      this.destination.error(err);
      this.unsubscribe();
    };
    DelaySubscriber2.prototype._complete = function() {
      this.scheduleNotification(Notification.createComplete());
      this.unsubscribe();
    };
    return DelaySubscriber2;
  }(Subscriber);
  var DelayMessage = /* @__PURE__ */ function() {
    function DelayMessage2(time, notification) {
      this.time = time;
      this.notification = notification;
    }
    return DelayMessage2;
  }();

  // node_modules/rxjs/_esm5/internal/operators/multicast.js
  function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
      var subjectFactory;
      if (typeof subjectOrSubjectFactory === "function") {
        subjectFactory = subjectOrSubjectFactory;
      } else {
        subjectFactory = function subjectFactory2() {
          return subjectOrSubjectFactory;
        };
      }
      if (typeof selector === "function") {
        return source.lift(new MulticastOperator(subjectFactory, selector));
      }
      var connectable = Object.create(source, connectableObservableDescriptor);
      connectable.source = source;
      connectable.subjectFactory = subjectFactory;
      return connectable;
    };
  }
  var MulticastOperator = /* @__PURE__ */ function() {
    function MulticastOperator2(subjectFactory, selector) {
      this.subjectFactory = subjectFactory;
      this.selector = selector;
    }
    MulticastOperator2.prototype.call = function(subscriber, source) {
      var selector = this.selector;
      var subject = this.subjectFactory();
      var subscription = selector(subject).subscribe(subscriber);
      subscription.add(source.subscribe(subject));
      return subscription;
    };
    return MulticastOperator2;
  }();

  // node_modules/rxjs/_esm5/internal/operators/share.js
  function shareSubjectFactory() {
    return new Subject();
  }
  function share() {
    return function(source) {
      return refCount()(multicast(shareSubjectFactory)(source));
    };
  }

  // node_modules/rxjs/_esm5/internal/operators/switchMap.js
  function switchMap(project, resultSelector) {
    if (typeof resultSelector === "function") {
      return function(source) {
        return source.pipe(switchMap(function(a, i) {
          return from(project(a, i)).pipe(map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }));
      };
    }
    return function(source) {
      return source.lift(new SwitchMapOperator(project));
    };
  }
  var SwitchMapOperator = /* @__PURE__ */ function() {
    function SwitchMapOperator2(project) {
      this.project = project;
    }
    SwitchMapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator2;
  }();
  var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SwitchMapSubscriber2, _super);
    function SwitchMapSubscriber2(destination, project) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.index = 0;
      return _this;
    }
    SwitchMapSubscriber2.prototype._next = function(value) {
      var result;
      var index = this.index++;
      try {
        result = this.project(value, index);
      } catch (error3) {
        this.destination.error(error3);
        return;
      }
      this._innerSub(result);
    };
    SwitchMapSubscriber2.prototype._innerSub = function(result) {
      var innerSubscription = this.innerSubscription;
      if (innerSubscription) {
        innerSubscription.unsubscribe();
      }
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      this.innerSubscription = innerSubscribe(result, innerSubscriber);
      if (this.innerSubscription !== innerSubscriber) {
        destination.add(this.innerSubscription);
      }
    };
    SwitchMapSubscriber2.prototype._complete = function() {
      var innerSubscription = this.innerSubscription;
      if (!innerSubscription || innerSubscription.closed) {
        _super.prototype._complete.call(this);
      }
      this.unsubscribe();
    };
    SwitchMapSubscriber2.prototype._unsubscribe = function() {
      this.innerSubscription = void 0;
    };
    SwitchMapSubscriber2.prototype.notifyComplete = function() {
      this.innerSubscription = void 0;
      if (this.isStopped) {
        _super.prototype._complete.call(this);
      }
    };
    SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    return SwitchMapSubscriber2;
  }(SimpleOuterSubscriber);

  // node_modules/@angular/core/fesm2020/core.mjs
  function getClosureSafeProperty(objWithPropertyToExtract) {
    for (let key in objWithPropertyToExtract) {
      if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
        return key;
      }
    }
    throw Error("Could not find renamed property on target object.");
  }
  function fillProperties(target, source) {
    for (const key in source) {
      if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
  }
  function stringify(token) {
    if (typeof token === "string") {
      return token;
    }
    if (Array.isArray(token)) {
      return "[" + token.map(stringify).join(", ") + "]";
    }
    if (token == null) {
      return "" + token;
    }
    if (token.overriddenName) {
      return `${token.overriddenName}`;
    }
    if (token.name) {
      return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
      return "" + res;
    }
    const newLineIndex = res.indexOf("\n");
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  function concatStringsWithSpace(before, after) {
    return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
  }
  var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return stringify(this());
    };
    return forwardRefFn;
  }
  function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
  }
  function isForwardRef(fn2) {
    return typeof fn2 === "function" && fn2.hasOwnProperty(__forward_ref__) && fn2.__forward_ref__ === forwardRef;
  }
  var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.io/errors";
  var RuntimeError = class extends Error {
    constructor(code, message) {
      super(formatRuntimeError(code, message));
      this.code = code;
    }
  };
  function formatRuntimeError(code, message) {
    const fullCode = `NG0${Math.abs(code)}`;
    let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
    if (ngDevMode && code < 0) {
      errorMessage = `${errorMessage}. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
    }
    return errorMessage;
  }
  function renderStringify(value) {
    if (typeof value === "string")
      return value;
    if (value == null)
      return "";
    return String(value);
  }
  function stringifyForError(value) {
    if (typeof value === "function")
      return value.name || value.toString();
    if (typeof value === "object" && value != null && typeof value.type === "function") {
      return value.type.name || value.type.toString();
    }
    return renderStringify(value);
  }
  function throwCyclicDependencyError(token, path) {
    const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
    throw new RuntimeError(-200, `Circular dependency in DI detected for ${token}${depPath}`);
  }
  function throwMixedMultiProviderError() {
    throw new Error(`Cannot mix multi providers and regular providers`);
  }
  function throwInvalidProviderError(ngModuleType, providers, provider) {
    let ngModuleDetail = "";
    if (ngModuleType && providers) {
      const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
      ngModuleDetail = ` - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`;
    }
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);
  }
  function throwProviderNotFoundError(token, injectorName) {
    const injectorDetails = injectorName ? ` in ${injectorName}` : "";
    throw new RuntimeError(-201, `No provider for ${stringifyForError(token)} found${injectorDetails}`);
  }
  function assertNumber(actual, msg) {
    if (!(typeof actual === "number")) {
      throwError2(msg, typeof actual, "number", "===");
    }
  }
  function assertNumberInRange(actual, minInclusive, maxInclusive) {
    assertNumber(actual, "Expected a number");
    assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
    assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
  }
  function assertString(actual, msg) {
    if (!(typeof actual === "string")) {
      throwError2(msg, actual === null ? "null" : typeof actual, "string", "===");
    }
  }
  function assertFunction(actual, msg) {
    if (!(typeof actual === "function")) {
      throwError2(msg, actual === null ? "null" : typeof actual, "function", "===");
    }
  }
  function assertEqual(actual, expected, msg) {
    if (!(actual == expected)) {
      throwError2(msg, actual, expected, "==");
    }
  }
  function assertNotEqual(actual, expected, msg) {
    if (!(actual != expected)) {
      throwError2(msg, actual, expected, "!=");
    }
  }
  function assertSame(actual, expected, msg) {
    if (!(actual === expected)) {
      throwError2(msg, actual, expected, "===");
    }
  }
  function assertNotSame(actual, expected, msg) {
    if (!(actual !== expected)) {
      throwError2(msg, actual, expected, "!==");
    }
  }
  function assertLessThan(actual, expected, msg) {
    if (!(actual < expected)) {
      throwError2(msg, actual, expected, "<");
    }
  }
  function assertLessThanOrEqual(actual, expected, msg) {
    if (!(actual <= expected)) {
      throwError2(msg, actual, expected, "<=");
    }
  }
  function assertGreaterThan(actual, expected, msg) {
    if (!(actual > expected)) {
      throwError2(msg, actual, expected, ">");
    }
  }
  function assertGreaterThanOrEqual(actual, expected, msg) {
    if (!(actual >= expected)) {
      throwError2(msg, actual, expected, ">=");
    }
  }
  function assertDefined(actual, msg) {
    if (actual == null) {
      throwError2(msg, actual, null, "!=");
    }
  }
  function throwError2(msg, actual, expected, comparison) {
    throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
  }
  function assertDomNode(node) {
    if (!(typeof Node !== "undefined" && node instanceof Node) && !(typeof node === "object" && node != null && node.constructor.name === "WebWorkerRenderNode")) {
      throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
    }
  }
  function assertIndexInRange(arr, index) {
    assertDefined(arr, "Array must be defined.");
    const maxLen = arr.length;
    if (index < 0 || index >= maxLen) {
      throwError2(`Index expected to be less than ${maxLen} but got ${index}`);
    }
  }
  function assertOneOf(value, ...validValues) {
    if (validValues.indexOf(value) !== -1)
      return true;
    throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
  }
  function \u0275\u0275defineInjectable(opts) {
    return {
      token: opts.token,
      providedIn: opts.providedIn || null,
      factory: opts.factory,
      value: void 0
    };
  }
  function \u0275\u0275defineInjector(options) {
    return { providers: options.providers || [], imports: options.imports || [] };
  }
  function getInjectableDef(type) {
    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
  }
  function getOwnDefinition(type, field) {
    return type.hasOwnProperty(field) ? type[field] : null;
  }
  function getInheritedInjectableDef(type) {
    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
    if (def) {
      const typeName = getTypeName(type);
      console.warn(`DEPRECATED: DI is instantiating a token "${typeName}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${typeName}" class.`);
      return def;
    } else {
      return null;
    }
  }
  function getTypeName(type) {
    if (type.hasOwnProperty("name")) {
      return type.name;
    }
    const match = ("" + type).match(/^function\s*([^\s(]+)/);
    return match === null ? "" : match[1];
  }
  function getInjectorDef(type) {
    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
  }
  var NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });
  var NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });
  var NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
  var NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });
  var InjectFlags;
  (function(InjectFlags2) {
    InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
    InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
    InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
    InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
    InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
  })(InjectFlags || (InjectFlags = {}));
  var _injectImplementation;
  function getInjectImplementation() {
    return _injectImplementation;
  }
  function setInjectImplementation(impl) {
    const previous = _injectImplementation;
    _injectImplementation = impl;
    return previous;
  }
  function injectRootLimpMode(token, notFoundValue, flags) {
    const injectableDef = getInjectableDef(token);
    if (injectableDef && injectableDef.providedIn == "root") {
      return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
    }
    if (flags & InjectFlags.Optional)
      return null;
    if (notFoundValue !== void 0)
      return notFoundValue;
    throwProviderNotFoundError(stringify(token), "Injector");
  }
  function assertInjectImplementationNotEqual(fn2) {
    ngDevMode && assertNotEqual(_injectImplementation, fn2, "Calling \u0275\u0275inject would cause infinite recursion");
  }
  function noSideEffects(fn2) {
    return { toString: fn2 }.toString();
  }
  var ChangeDetectionStrategy;
  (function(ChangeDetectionStrategy3) {
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["OnPush"] = 0] = "OnPush";
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["Default"] = 1] = "Default";
  })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
  var ChangeDetectorStatus;
  (function(ChangeDetectorStatus2) {
    ChangeDetectorStatus2[ChangeDetectorStatus2["CheckOnce"] = 0] = "CheckOnce";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Checked"] = 1] = "Checked";
    ChangeDetectorStatus2[ChangeDetectorStatus2["CheckAlways"] = 2] = "CheckAlways";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Detached"] = 3] = "Detached";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Errored"] = 4] = "Errored";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Destroyed"] = 5] = "Destroyed";
  })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
  var ViewEncapsulation$1;
  (function(ViewEncapsulation3) {
    ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
    ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
    ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
  var __globalThis = typeof globalThis !== "undefined" && globalThis;
  var __window = typeof window !== "undefined" && window;
  var __self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
  var __global = typeof global !== "undefined" && global;
  var _global2 = __globalThis || __global || __window || __self;
  function ngDevModeResetPerfCounters() {
    const locationString = typeof location !== "undefined" ? location.toString() : "";
    const newCounters = {
      namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
      firstCreatePass: 0,
      tNode: 0,
      tView: 0,
      rendererCreateTextNode: 0,
      rendererSetText: 0,
      rendererCreateElement: 0,
      rendererAddEventListener: 0,
      rendererSetAttribute: 0,
      rendererRemoveAttribute: 0,
      rendererSetProperty: 0,
      rendererSetClassName: 0,
      rendererAddClass: 0,
      rendererRemoveClass: 0,
      rendererSetStyle: 0,
      rendererRemoveStyle: 0,
      rendererDestroy: 0,
      rendererDestroyNode: 0,
      rendererMoveNode: 0,
      rendererRemoveNode: 0,
      rendererAppendChild: 0,
      rendererInsertBefore: 0,
      rendererCreateComment: 0
    };
    const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
    _global2["ngDevMode"] = allowNgDevModeTrue && newCounters;
    return newCounters;
  }
  function initNgDevMode() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (typeof ngDevMode !== "object") {
        ngDevModeResetPerfCounters();
      }
      return typeof ngDevMode !== "undefined" && !!ngDevMode;
    }
    return false;
  }
  var EMPTY_OBJ = {};
  var EMPTY_ARRAY = [];
  if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
    Object.freeze(EMPTY_OBJ);
    Object.freeze(EMPTY_ARRAY);
  }
  var NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });
  var NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });
  var NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });
  var NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });
  var NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });
  var NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });
  var _renderCompCount = 0;
  function \u0275\u0275defineComponent(componentDefinition) {
    return noSideEffects(() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
      const type = componentDefinition.type;
      const declaredInputs = {};
      const def = {
        type,
        providersResolver: null,
        decls: componentDefinition.decls,
        vars: componentDefinition.vars,
        factory: null,
        template: componentDefinition.template || null,
        consts: componentDefinition.consts || null,
        ngContentSelectors: componentDefinition.ngContentSelectors,
        hostBindings: componentDefinition.hostBindings || null,
        hostVars: componentDefinition.hostVars || 0,
        hostAttrs: componentDefinition.hostAttrs || null,
        contentQueries: componentDefinition.contentQueries || null,
        declaredInputs,
        inputs: null,
        outputs: null,
        exportAs: componentDefinition.exportAs || null,
        onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
        directiveDefs: null,
        pipeDefs: null,
        selectors: componentDefinition.selectors || EMPTY_ARRAY,
        viewQuery: componentDefinition.viewQuery || null,
        features: componentDefinition.features || null,
        data: componentDefinition.data || {},
        encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
        id: "c",
        styles: componentDefinition.styles || EMPTY_ARRAY,
        _: null,
        setInput: null,
        schemas: componentDefinition.schemas || null,
        tView: null
      };
      const directiveTypes = componentDefinition.directives;
      const feature = componentDefinition.features;
      const pipeTypes = componentDefinition.pipes;
      def.id += _renderCompCount++;
      def.inputs = invertObject(componentDefinition.inputs, declaredInputs), def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach((fn2) => fn2(def));
      def.directiveDefs = directiveTypes ? () => (typeof directiveTypes === "function" ? directiveTypes() : directiveTypes).map(extractDirectiveDef) : null;
      def.pipeDefs = pipeTypes ? () => (typeof pipeTypes === "function" ? pipeTypes() : pipeTypes).map(extractPipeDef) : null;
      return def;
    });
  }
  function \u0275\u0275setComponentScope(type, directives, pipes) {
    const def = type.\u0275cmp;
    def.directiveDefs = () => directives.map(extractDirectiveDef);
    def.pipeDefs = () => pipes.map(extractPipeDef);
  }
  function extractDirectiveDef(type) {
    const def = getComponentDef(type) || getDirectiveDef(type);
    if (ngDevMode && !def) {
      throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);
    }
    return def;
  }
  function extractPipeDef(type) {
    const def = getPipeDef$1(type);
    if (ngDevMode && !def) {
      throw new Error(`'${type.name}' is not a 'PipeType'.`);
    }
    return def;
  }
  var autoRegisterModuleById = {};
  function \u0275\u0275defineNgModule(def) {
    return noSideEffects(() => {
      const res = {
        type: def.type,
        bootstrap: def.bootstrap || EMPTY_ARRAY,
        declarations: def.declarations || EMPTY_ARRAY,
        imports: def.imports || EMPTY_ARRAY,
        exports: def.exports || EMPTY_ARRAY,
        transitiveCompileScopes: null,
        schemas: def.schemas || null,
        id: def.id || null
      };
      if (def.id != null) {
        autoRegisterModuleById[def.id] = def.type;
      }
      return res;
    });
  }
  function \u0275\u0275setNgModuleScope(type, scope) {
    return noSideEffects(() => {
      const ngModuleDef = getNgModuleDef(type, true);
      ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
      ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
      ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
    });
  }
  function invertObject(obj, secondary) {
    if (obj == null)
      return EMPTY_OBJ;
    const newLookup = {};
    for (const minifiedKey in obj) {
      if (obj.hasOwnProperty(minifiedKey)) {
        let publicName = obj[minifiedKey];
        let declaredName = publicName;
        if (Array.isArray(publicName)) {
          declaredName = publicName[1];
          publicName = publicName[0];
        }
        newLookup[publicName] = minifiedKey;
        if (secondary) {
          secondary[publicName] = declaredName;
        }
      }
    }
    return newLookup;
  }
  var \u0275\u0275defineDirective = \u0275\u0275defineComponent;
  function \u0275\u0275definePipe(pipeDef) {
    return {
      type: pipeDef.type,
      name: pipeDef.name,
      factory: null,
      pure: pipeDef.pure !== false,
      onDestroy: pipeDef.type.prototype.ngOnDestroy || null
    };
  }
  function getComponentDef(type) {
    return type[NG_COMP_DEF] || null;
  }
  function getDirectiveDef(type) {
    return type[NG_DIR_DEF] || null;
  }
  function getPipeDef$1(type) {
    return type[NG_PIPE_DEF] || null;
  }
  function getNgModuleDef(type, throwNotFound) {
    const ngModuleDef = type[NG_MOD_DEF] || null;
    if (!ngModuleDef && throwNotFound === true) {
      throw new Error(`Type ${stringify(type)} does not have '\u0275mod' property.`);
    }
    return ngModuleDef;
  }
  var HOST = 0;
  var TVIEW = 1;
  var FLAGS = 2;
  var PARENT = 3;
  var NEXT = 4;
  var TRANSPLANTED_VIEWS_TO_REFRESH = 5;
  var T_HOST = 6;
  var CLEANUP = 7;
  var CONTEXT = 8;
  var INJECTOR$1 = 9;
  var RENDERER_FACTORY = 10;
  var RENDERER = 11;
  var SANITIZER = 12;
  var CHILD_HEAD = 13;
  var CHILD_TAIL = 14;
  var DECLARATION_VIEW = 15;
  var DECLARATION_COMPONENT_VIEW = 16;
  var DECLARATION_LCONTAINER = 17;
  var PREORDER_HOOK_FLAGS = 18;
  var QUERIES = 19;
  var HEADER_OFFSET = 20;
  var TViewTypeAsString = [
    "Root",
    "Component",
    "Embedded"
  ];
  var unusedValueExportToPlacateAjd$8 = 1;
  var TYPE = 1;
  var HAS_TRANSPLANTED_VIEWS = 2;
  var NATIVE = 7;
  var VIEW_REFS = 8;
  var MOVED_VIEWS = 9;
  var CONTAINER_HEADER_OFFSET = 10;
  var unusedValueExportToPlacateAjd$7 = 1;
  function isLView(value) {
    return Array.isArray(value) && typeof value[TYPE] === "object";
  }
  function isLContainer(value) {
    return Array.isArray(value) && value[TYPE] === true;
  }
  function isContentQueryHost(tNode) {
    return (tNode.flags & 8) !== 0;
  }
  function isComponentHost(tNode) {
    return (tNode.flags & 2) === 2;
  }
  function isDirectiveHost(tNode) {
    return (tNode.flags & 1) === 1;
  }
  function isComponentDef(def) {
    return def.template !== null;
  }
  function isRootView(target) {
    return (target[FLAGS] & 512) !== 0;
  }
  function assertTNodeForLView(tNode, lView) {
    assertTNodeForTView(tNode, lView[TVIEW]);
  }
  function assertTNodeForTView(tNode, tView) {
    assertTNode(tNode);
    tNode.hasOwnProperty("tView_") && assertEqual(tNode.tView_, tView, "This TNode does not belong to this TView.");
  }
  function assertTNode(tNode) {
    assertDefined(tNode, "TNode must be defined");
    if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
      throwError2("Not of type TNode, got: " + tNode);
    }
  }
  function assertTIcu(tIcu) {
    assertDefined(tIcu, "Expected TIcu to be defined");
    if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
      throwError2("Object is not of TIcu type.");
    }
  }
  function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
    if (!getComponentDef(actual)) {
      throwError2(msg);
    }
  }
  function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
    if (!getNgModuleDef(actual)) {
      throwError2(msg);
    }
  }
  function assertHasParent(tNode) {
    assertDefined(tNode, "currentTNode should exist!");
    assertDefined(tNode.parent, "currentTNode should have a parent");
  }
  function assertLContainer(value) {
    assertDefined(value, "LContainer must be defined");
    assertEqual(isLContainer(value), true, "Expecting LContainer");
  }
  function assertLViewOrUndefined(value) {
    value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
  }
  function assertLView(value) {
    assertDefined(value, "LView must be defined");
    assertEqual(isLView(value), true, "Expecting LView");
  }
  function assertFirstCreatePass(tView, errMessage) {
    assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
  }
  function assertFirstUpdatePass(tView, errMessage) {
    assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
  }
  function assertDirectiveDef(obj) {
    if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
      throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
    }
  }
  function assertIndexInDeclRange(lView, index) {
    const tView = lView[1];
    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
  }
  function assertIndexInExpandoRange(lView, index) {
    const tView = lView[1];
    assertBetween(tView.expandoStartIndex, lView.length, index);
  }
  function assertBetween(lower, upper, index) {
    if (!(lower <= index && index < upper)) {
      throwError2(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
    }
  }
  function assertProjectionSlots(lView, errMessage) {
    assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
  }
  function assertParentView(lView, errMessage) {
    assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
  }
  function assertNodeInjector(lView, injectorIndex) {
    assertIndexInExpandoRange(lView, injectorIndex);
    assertIndexInExpandoRange(lView, injectorIndex + 8);
    assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 8], "injectorIndex should point to parent injector");
  }
  function getFactoryDef(type, throwNotFound) {
    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
      throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
    }
    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
  }
  var SimpleChange = class {
    constructor(previousValue, currentValue, firstChange) {
      this.previousValue = previousValue;
      this.currentValue = currentValue;
      this.firstChange = firstChange;
    }
    isFirstChange() {
      return this.firstChange;
    }
  };
  function \u0275\u0275NgOnChangesFeature() {
    return NgOnChangesFeatureImpl;
  }
  function NgOnChangesFeatureImpl(definition) {
    if (definition.type.prototype.ngOnChanges) {
      definition.setInput = ngOnChangesSetInput;
    }
    return rememberChangeHistoryAndInvokeOnChangesHook;
  }
  \u0275\u0275NgOnChangesFeature.ngInherit = true;
  function rememberChangeHistoryAndInvokeOnChangesHook() {
    const simpleChangesStore = getSimpleChangesStore(this);
    const current = simpleChangesStore?.current;
    if (current) {
      const previous = simpleChangesStore.previous;
      if (previous === EMPTY_OBJ) {
        simpleChangesStore.previous = current;
      } else {
        for (let key in current) {
          previous[key] = current[key];
        }
      }
      simpleChangesStore.current = null;
      this.ngOnChanges(current);
    }
  }
  function ngOnChangesSetInput(instance, value, publicName, privateName) {
    const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
    const current = simpleChangesStore.current || (simpleChangesStore.current = {});
    const previous = simpleChangesStore.previous;
    const declaredName = this.declaredInputs[publicName];
    const previousChange = previous[declaredName];
    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
    instance[privateName] = value;
  }
  var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
  function getSimpleChangesStore(instance) {
    return instance[SIMPLE_CHANGES_STORE] || null;
  }
  function setSimpleChangesStore(instance, store2) {
    return instance[SIMPLE_CHANGES_STORE] = store2;
  }
  var profilerCallback = null;
  var setProfiler = (profiler2) => {
    profilerCallback = profiler2;
  };
  var profiler = function(event, instance, hookOrListener) {
    if (profilerCallback != null) {
      profilerCallback(event, instance, hookOrListener);
    }
  };
  var SVG_NAMESPACE = "svg";
  var SVG_NAMESPACE_URI = "http://www.w3.org/2000/svg";
  var MATH_ML_NAMESPACE = "math";
  var MATH_ML_NAMESPACE_URI = "http://www.w3.org/1998/MathML/";
  function getNamespaceUri(namespace) {
    const name = namespace.toLowerCase();
    return name === SVG_NAMESPACE ? SVG_NAMESPACE_URI : name === MATH_ML_NAMESPACE ? MATH_ML_NAMESPACE_URI : null;
  }
  var DOCUMENT = void 0;
  function getDocument() {
    if (DOCUMENT !== void 0) {
      return DOCUMENT;
    } else if (typeof document !== "undefined") {
      return document;
    }
    return void 0;
  }
  var RendererStyleFlags3;
  (function(RendererStyleFlags32) {
    RendererStyleFlags32[RendererStyleFlags32["Important"] = 1] = "Important";
    RendererStyleFlags32[RendererStyleFlags32["DashCase"] = 2] = "DashCase";
  })(RendererStyleFlags3 || (RendererStyleFlags3 = {}));
  function isProceduralRenderer(renderer) {
    return !!renderer.listen;
  }
  var domRendererFactory3 = {
    createRenderer: (hostElement, rendererType) => {
      return getDocument();
    }
  };
  var unusedValueExportToPlacateAjd$6 = 1;
  function unwrapRNode(value) {
    while (Array.isArray(value)) {
      value = value[HOST];
    }
    return value;
  }
  function unwrapLView(value) {
    while (Array.isArray(value)) {
      if (typeof value[TYPE] === "object")
        return value;
      value = value[HOST];
    }
    return null;
  }
  function getNativeByIndex(index, lView) {
    ngDevMode && assertIndexInRange(lView, index);
    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
    return unwrapRNode(lView[index]);
  }
  function getNativeByTNode(tNode, lView) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    ngDevMode && assertIndexInRange(lView, tNode.index);
    const node = unwrapRNode(lView[tNode.index]);
    ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);
    return node;
  }
  function getNativeByTNodeOrNull(tNode, lView) {
    const index = tNode === null ? -1 : tNode.index;
    if (index !== -1) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      const node = unwrapRNode(lView[index]);
      ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);
      return node;
    }
    return null;
  }
  function getTNode(tView, index) {
    ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
    ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
    const tNode = tView.data[index];
    ngDevMode && tNode !== null && assertTNode(tNode);
    return tNode;
  }
  function load(view, index) {
    ngDevMode && assertIndexInRange(view, index);
    return view[index];
  }
  function getComponentLViewByIndex(nodeIndex, hostView) {
    ngDevMode && assertIndexInRange(hostView, nodeIndex);
    const slotValue = hostView[nodeIndex];
    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
    return lView;
  }
  function isCreationMode(view) {
    return (view[FLAGS] & 4) === 4;
  }
  function viewAttachedToChangeDetector(view) {
    return (view[FLAGS] & 128) === 128;
  }
  function viewAttachedToContainer(view) {
    return isLContainer(view[PARENT]);
  }
  function getConstant(consts, index) {
    if (index === null || index === void 0)
      return null;
    ngDevMode && assertIndexInRange(consts, index);
    return consts[index];
  }
  function resetPreOrderHookFlags(lView) {
    lView[PREORDER_HOOK_FLAGS] = 0;
  }
  function updateTransplantedViewCount(lContainer, amount) {
    lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
    let viewOrContainer = lContainer;
    let parent = lContainer[PARENT];
    while (parent !== null && (amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0)) {
      parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
      viewOrContainer = parent;
      parent = parent[PARENT];
    }
  }
  var instructionState = {
    lFrame: createLFrame(null),
    bindingsEnabled: true,
    isInCheckNoChangesMode: false
  };
  function getElementDepthCount() {
    return instructionState.lFrame.elementDepthCount;
  }
  function increaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount++;
  }
  function decreaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount--;
  }
  function getBindingsEnabled() {
    return instructionState.bindingsEnabled;
  }
  function \u0275\u0275enableBindings() {
    instructionState.bindingsEnabled = true;
  }
  function \u0275\u0275disableBindings() {
    instructionState.bindingsEnabled = false;
  }
  function getLView() {
    return instructionState.lFrame.lView;
  }
  function getTView() {
    return instructionState.lFrame.tView;
  }
  function \u0275\u0275restoreView(viewToRestore) {
    instructionState.lFrame.contextLView = viewToRestore;
    return viewToRestore[CONTEXT];
  }
  function getCurrentTNode() {
    let currentTNode = getCurrentTNodePlaceholderOk();
    while (currentTNode !== null && currentTNode.type === 64) {
      currentTNode = currentTNode.parent;
    }
    return currentTNode;
  }
  function getCurrentTNodePlaceholderOk() {
    return instructionState.lFrame.currentTNode;
  }
  function getCurrentParentTNode() {
    const lFrame = instructionState.lFrame;
    const currentTNode = lFrame.currentTNode;
    return lFrame.isParent ? currentTNode : currentTNode.parent;
  }
  function setCurrentTNode(tNode, isParent) {
    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
    const lFrame = instructionState.lFrame;
    lFrame.currentTNode = tNode;
    lFrame.isParent = isParent;
  }
  function isCurrentTNodeParent() {
    return instructionState.lFrame.isParent;
  }
  function setCurrentTNodeAsNotParent() {
    instructionState.lFrame.isParent = false;
  }
  function getContextLView() {
    return instructionState.lFrame.contextLView;
  }
  function isInCheckNoChangesMode() {
    return instructionState.isInCheckNoChangesMode;
  }
  function setIsInCheckNoChangesMode(mode) {
    instructionState.isInCheckNoChangesMode = mode;
  }
  function getBindingRoot() {
    const lFrame = instructionState.lFrame;
    let index = lFrame.bindingRootIndex;
    if (index === -1) {
      index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
    }
    return index;
  }
  function getBindingIndex() {
    return instructionState.lFrame.bindingIndex;
  }
  function setBindingIndex(value) {
    return instructionState.lFrame.bindingIndex = value;
  }
  function nextBindingIndex() {
    return instructionState.lFrame.bindingIndex++;
  }
  function incrementBindingIndex(count) {
    const lFrame = instructionState.lFrame;
    const index = lFrame.bindingIndex;
    lFrame.bindingIndex = lFrame.bindingIndex + count;
    return index;
  }
  function isInI18nBlock() {
    return instructionState.lFrame.inI18n;
  }
  function setInI18nBlock(isInI18nBlock2) {
    instructionState.lFrame.inI18n = isInI18nBlock2;
  }
  function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
    const lFrame = instructionState.lFrame;
    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
  function getCurrentDirectiveIndex() {
    return instructionState.lFrame.currentDirectiveIndex;
  }
  function setCurrentDirectiveIndex(currentDirectiveIndex) {
    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
  }
  function getCurrentDirectiveDef(tData) {
    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
  }
  function getCurrentQueryIndex() {
    return instructionState.lFrame.currentQueryIndex;
  }
  function setCurrentQueryIndex(value) {
    instructionState.lFrame.currentQueryIndex = value;
  }
  function getDeclarationTNode(lView) {
    const tView = lView[TVIEW];
    if (tView.type === 2) {
      ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
      return tView.declTNode;
    }
    if (tView.type === 1) {
      return lView[T_HOST];
    }
    return null;
  }
  function enterDI(lView, tNode, flags) {
    ngDevMode && assertLViewOrUndefined(lView);
    if (flags & InjectFlags.SkipSelf) {
      ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
      let parentTNode = tNode;
      let parentLView = lView;
      while (true) {
        ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
        parentTNode = parentTNode.parent;
        if (parentTNode === null && !(flags & InjectFlags.Host)) {
          parentTNode = getDeclarationTNode(parentLView);
          if (parentTNode === null)
            break;
          ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
          parentLView = parentLView[DECLARATION_VIEW];
          if (parentTNode.type & (2 | 8)) {
            break;
          }
        } else {
          break;
        }
      }
      if (parentTNode === null) {
        return false;
      } else {
        tNode = parentTNode;
        lView = parentLView;
      }
    }
    ngDevMode && assertTNodeForLView(tNode, lView);
    const lFrame = instructionState.lFrame = allocLFrame();
    lFrame.currentTNode = tNode;
    lFrame.lView = lView;
    return true;
  }
  function enterView(newView) {
    ngDevMode && assertNotEqual(newView[0], newView[1], "????");
    ngDevMode && assertLViewOrUndefined(newView);
    const newLFrame = allocLFrame();
    if (ngDevMode) {
      assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
      assertEqual(newLFrame.lView, null, "Expected clean LFrame");
      assertEqual(newLFrame.tView, null, "Expected clean LFrame");
      assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
      assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
      assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
      assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
      assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
      assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
    }
    const tView = newView[TVIEW];
    instructionState.lFrame = newLFrame;
    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
    newLFrame.currentTNode = tView.firstChild;
    newLFrame.lView = newView;
    newLFrame.tView = tView;
    newLFrame.contextLView = newView;
    newLFrame.bindingIndex = tView.bindingStartIndex;
    newLFrame.inI18n = false;
  }
  function allocLFrame() {
    const currentLFrame = instructionState.lFrame;
    const childLFrame = currentLFrame === null ? null : currentLFrame.child;
    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
    return newLFrame;
  }
  function createLFrame(parent) {
    const lFrame = {
      currentTNode: null,
      isParent: true,
      lView: null,
      tView: null,
      selectedIndex: -1,
      contextLView: null,
      elementDepthCount: 0,
      currentNamespace: null,
      currentDirectiveIndex: -1,
      bindingRootIndex: -1,
      bindingIndex: -1,
      currentQueryIndex: 0,
      parent,
      child: null,
      inI18n: false
    };
    parent !== null && (parent.child = lFrame);
    return lFrame;
  }
  function leaveViewLight() {
    const oldLFrame = instructionState.lFrame;
    instructionState.lFrame = oldLFrame.parent;
    oldLFrame.currentTNode = null;
    oldLFrame.lView = null;
    return oldLFrame;
  }
  var leaveDI = leaveViewLight;
  function leaveView() {
    const oldLFrame = leaveViewLight();
    oldLFrame.isParent = true;
    oldLFrame.tView = null;
    oldLFrame.selectedIndex = -1;
    oldLFrame.contextLView = null;
    oldLFrame.elementDepthCount = 0;
    oldLFrame.currentDirectiveIndex = -1;
    oldLFrame.currentNamespace = null;
    oldLFrame.bindingRootIndex = -1;
    oldLFrame.bindingIndex = -1;
    oldLFrame.currentQueryIndex = 0;
  }
  function nextContextImpl(level) {
    const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
    return contextLView[CONTEXT];
  }
  function walkUpViews(nestingLevel, currentView) {
    while (nestingLevel > 0) {
      ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
      currentView = currentView[DECLARATION_VIEW];
      nestingLevel--;
    }
    return currentView;
  }
  function getSelectedIndex() {
    return instructionState.lFrame.selectedIndex;
  }
  function setSelectedIndex(index) {
    ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
    ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
    instructionState.lFrame.selectedIndex = index;
  }
  function getSelectedTNode() {
    const lFrame = instructionState.lFrame;
    return getTNode(lFrame.tView, lFrame.selectedIndex);
  }
  function \u0275\u0275namespaceSVG() {
    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
  }
  function \u0275\u0275namespaceMathML() {
    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
  }
  function \u0275\u0275namespaceHTML() {
    namespaceHTMLInternal();
  }
  function namespaceHTMLInternal() {
    instructionState.lFrame.currentNamespace = null;
  }
  function getNamespace$1() {
    return instructionState.lFrame.currentNamespace;
  }
  function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
    ngDevMode && assertFirstCreatePass(tView);
    const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
    if (ngOnChanges) {
      const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);
      (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, wrappedOnChanges);
    }
    if (ngOnInit) {
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);
    }
    if (ngDoCheck) {
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);
      (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);
    }
  }
  function registerPostOrderHooks(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
      const directiveDef = tView.data[i];
      ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
      const lifecycleHooks = directiveDef.type.prototype;
      const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
      if (ngAfterContentInit) {
        (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);
      }
      if (ngAfterContentChecked) {
        (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);
        (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);
      }
      if (ngAfterViewInit) {
        (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);
      }
      if (ngAfterViewChecked) {
        (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);
        (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);
      }
      if (ngOnDestroy != null) {
        (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);
      }
    }
  }
  function executeCheckHooks(lView, hooks, nodeIndex) {
    callHooks(lView, hooks, 3, nodeIndex);
  }
  function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
    ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
    if ((lView[FLAGS] & 3) === initPhase) {
      callHooks(lView, hooks, initPhase, nodeIndex);
    }
  }
  function incrementInitPhaseFlags(lView, initPhase) {
    ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
    let flags = lView[FLAGS];
    if ((flags & 3) === initPhase) {
      flags &= 2047;
      flags += 1;
      lView[FLAGS] = flags;
    }
  }
  function callHooks(currentView, arr, initPhase, currentNodeIndex) {
    ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
    const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
    const max = arr.length - 1;
    let lastNodeIndexFound = 0;
    for (let i = startIndex; i < max; i++) {
      const hook = arr[i + 1];
      if (typeof hook === "number") {
        lastNodeIndexFound = arr[i];
        if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
          break;
        }
      } else {
        const isInitHook = arr[i] < 0;
        if (isInitHook)
          currentView[PREORDER_HOOK_FLAGS] += 65536;
        if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
          callHook(currentView, initPhase, arr, i);
          currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
        }
        i++;
      }
    }
  }
  function callHook(currentView, initPhase, arr, i) {
    const isInitHook = arr[i] < 0;
    const hook = arr[i + 1];
    const directiveIndex = isInitHook ? -arr[i] : arr[i];
    const directive = currentView[directiveIndex];
    if (isInitHook) {
      const indexWithintInitPhase = currentView[FLAGS] >> 11;
      if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
        currentView[FLAGS] += 2048;
        profiler(4, directive, hook);
        try {
          hook.call(directive);
        } finally {
          profiler(5, directive, hook);
        }
      }
    } else {
      profiler(4, directive, hook);
      try {
        hook.call(directive);
      } finally {
        profiler(5, directive, hook);
      }
    }
  }
  var NO_PARENT_INJECTOR = -1;
  var NodeInjectorFactory = class {
    constructor(factory, isViewProvider, injectImplementation) {
      this.factory = factory;
      this.resolving = false;
      ngDevMode && assertDefined(factory, "Factory not specified");
      ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
      this.canSeeViewProviders = isViewProvider;
      this.injectImpl = injectImplementation;
    }
  };
  function isFactory(obj) {
    return obj instanceof NodeInjectorFactory;
  }
  var unusedValueExportToPlacateAjd$5 = 1;
  function toTNodeTypeAsString(tNodeType) {
    let text = "";
    tNodeType & 1 && (text += "|Text");
    tNodeType & 2 && (text += "|Element");
    tNodeType & 4 && (text += "|Container");
    tNodeType & 8 && (text += "|ElementContainer");
    tNodeType & 16 && (text += "|Projection");
    tNodeType & 32 && (text += "|IcuContainer");
    tNodeType & 64 && (text += "|Placeholder");
    return text.length > 0 ? text.substring(1) : text;
  }
  var unusedValueExportToPlacateAjd$4 = 1;
  function hasClassInput(tNode) {
    return (tNode.flags & 16) !== 0;
  }
  function hasStyleInput(tNode) {
    return (tNode.flags & 32) !== 0;
  }
  function assertTNodeType(tNode, expectedTypes, message) {
    assertDefined(tNode, "should be called with a TNode");
    if ((tNode.type & expectedTypes) === 0) {
      throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
    }
  }
  function assertPureTNodeType(type) {
    if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64)) {
      throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
    }
  }
  function setUpAttributes(renderer, native, attrs) {
    const isProc = isProceduralRenderer(renderer);
    let i = 0;
    while (i < attrs.length) {
      const value = attrs[i];
      if (typeof value === "number") {
        if (value !== 0) {
          break;
        }
        i++;
        const namespaceURI = attrs[i++];
        const attrName = attrs[i++];
        const attrVal = attrs[i++];
        ngDevMode && ngDevMode.rendererSetAttribute++;
        isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);
      } else {
        const attrName = value;
        const attrVal = attrs[++i];
        ngDevMode && ngDevMode.rendererSetAttribute++;
        if (isAnimationProp(attrName)) {
          if (isProc) {
            renderer.setProperty(native, attrName, attrVal);
          }
        } else {
          isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal);
        }
        i++;
      }
    }
    return i;
  }
  function isNameOnlyAttributeMarker(marker) {
    return marker === 3 || marker === 4 || marker === 6;
  }
  function isAnimationProp(name) {
    return name.charCodeAt(0) === 64;
  }
  function mergeHostAttrs(dst, src) {
    if (src === null || src.length === 0) {
    } else if (dst === null || dst.length === 0) {
      dst = src.slice();
    } else {
      let srcMarker = -1;
      for (let i = 0; i < src.length; i++) {
        const item = src[i];
        if (typeof item === "number") {
          srcMarker = item;
        } else {
          if (srcMarker === 0) {
          } else if (srcMarker === -1 || srcMarker === 2) {
            mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
          } else {
            mergeHostAttribute(dst, srcMarker, item, null, null);
          }
        }
      }
    }
    return dst;
  }
  function mergeHostAttribute(dst, marker, key1, key2, value) {
    let i = 0;
    let markerInsertPosition = dst.length;
    if (marker === -1) {
      markerInsertPosition = -1;
    } else {
      while (i < dst.length) {
        const dstValue = dst[i++];
        if (typeof dstValue === "number") {
          if (dstValue === marker) {
            markerInsertPosition = -1;
            break;
          } else if (dstValue > marker) {
            markerInsertPosition = i - 1;
            break;
          }
        }
      }
    }
    while (i < dst.length) {
      const item = dst[i];
      if (typeof item === "number") {
        break;
      } else if (item === key1) {
        if (key2 === null) {
          if (value !== null) {
            dst[i + 1] = value;
          }
          return;
        } else if (key2 === dst[i + 1]) {
          dst[i + 2] = value;
          return;
        }
      }
      i++;
      if (key2 !== null)
        i++;
      if (value !== null)
        i++;
    }
    if (markerInsertPosition !== -1) {
      dst.splice(markerInsertPosition, 0, marker);
      i = markerInsertPosition + 1;
    }
    dst.splice(i++, 0, key1);
    if (key2 !== null) {
      dst.splice(i++, 0, key2);
    }
    if (value !== null) {
      dst.splice(i++, 0, value);
    }
  }
  function hasParentInjector(parentLocation) {
    return parentLocation !== NO_PARENT_INJECTOR;
  }
  function getParentInjectorIndex(parentLocation) {
    ngDevMode && assertNumber(parentLocation, "Number expected");
    ngDevMode && assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    ngDevMode && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
    return parentLocation & 32767;
  }
  function getParentInjectorViewOffset(parentLocation) {
    return parentLocation >> 16;
  }
  function getParentInjectorView(location2, startView) {
    let viewOffset = getParentInjectorViewOffset(location2);
    let parentView = startView;
    while (viewOffset > 0) {
      parentView = parentView[DECLARATION_VIEW];
      viewOffset--;
    }
    return parentView;
  }
  var includeViewProviders = true;
  function setIncludeViewProviders(v) {
    const oldValue = includeViewProviders;
    includeViewProviders = v;
    return oldValue;
  }
  var BLOOM_SIZE = 256;
  var BLOOM_MASK = BLOOM_SIZE - 1;
  var BLOOM_BUCKET_BITS = 5;
  var nextNgElementId = 0;
  function bloomAdd(injectorIndex, tView, type) {
    ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
    let id;
    if (typeof type === "string") {
      id = type.charCodeAt(0) || 0;
    } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
      id = type[NG_ELEMENT_ID];
    }
    if (id == null) {
      id = type[NG_ELEMENT_ID] = nextNgElementId++;
    }
    const bloomHash = id & BLOOM_MASK;
    const mask = 1 << bloomHash;
    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
  }
  function getOrCreateNodeInjectorForNode(tNode, lView) {
    const existingInjectorIndex = getInjectorIndex(tNode, lView);
    if (existingInjectorIndex !== -1) {
      return existingInjectorIndex;
    }
    const tView = lView[TVIEW];
    if (tView.firstCreatePass) {
      tNode.injectorIndex = lView.length;
      insertBloom(tView.data, tNode);
      insertBloom(lView, null);
      insertBloom(tView.blueprint, null);
    }
    const parentLoc = getParentInjectorLocation(tNode, lView);
    const injectorIndex = tNode.injectorIndex;
    if (hasParentInjector(parentLoc)) {
      const parentIndex = getParentInjectorIndex(parentLoc);
      const parentLView = getParentInjectorView(parentLoc, lView);
      const parentData = parentLView[TVIEW].data;
      for (let i = 0; i < 8; i++) {
        lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
      }
    }
    lView[injectorIndex + 8] = parentLoc;
    return injectorIndex;
  }
  function insertBloom(arr, footer) {
    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
  }
  function getInjectorIndex(tNode, lView) {
    if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) {
      return -1;
    } else {
      ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
      return tNode.injectorIndex;
    }
  }
  function getParentInjectorLocation(tNode, lView) {
    if (tNode.parent && tNode.parent.injectorIndex !== -1) {
      return tNode.parent.injectorIndex;
    }
    let declarationViewOffset = 0;
    let parentTNode = null;
    let lViewCursor = lView;
    while (lViewCursor !== null) {
      const tView = lViewCursor[TVIEW];
      const tViewType = tView.type;
      if (tViewType === 2) {
        ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
        parentTNode = tView.declTNode;
      } else if (tViewType === 1) {
        parentTNode = lViewCursor[T_HOST];
      } else {
        ngDevMode && assertEqual(tView.type, 0, "Root type expected");
        parentTNode = null;
      }
      if (parentTNode === null) {
        return NO_PARENT_INJECTOR;
      }
      ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
      declarationViewOffset++;
      lViewCursor = lViewCursor[DECLARATION_VIEW];
      if (parentTNode.injectorIndex !== -1) {
        return parentTNode.injectorIndex | declarationViewOffset << 16;
      }
    }
    return NO_PARENT_INJECTOR;
  }
  function diPublicInInjector(injectorIndex, tView, token) {
    bloomAdd(injectorIndex, tView, token);
  }
  function injectAttributeImpl(tNode, attrNameToInject) {
    ngDevMode && assertTNodeType(tNode, 12 | 3);
    ngDevMode && assertDefined(tNode, "expecting tNode");
    if (attrNameToInject === "class") {
      return tNode.classes;
    }
    if (attrNameToInject === "style") {
      return tNode.styles;
    }
    const attrs = tNode.attrs;
    if (attrs) {
      const attrsLength = attrs.length;
      let i = 0;
      while (i < attrsLength) {
        const value = attrs[i];
        if (isNameOnlyAttributeMarker(value))
          break;
        if (value === 0) {
          i = i + 2;
        } else if (typeof value === "number") {
          i++;
          while (i < attrsLength && typeof attrs[i] === "string") {
            i++;
          }
        } else if (value === attrNameToInject) {
          return attrs[i + 1];
        } else {
          i = i + 2;
        }
      }
    }
    return null;
  }
  function notFoundValueOrThrow(notFoundValue, token, flags) {
    if (flags & InjectFlags.Optional) {
      return notFoundValue;
    } else {
      throwProviderNotFoundError(token, "NodeInjector");
    }
  }
  function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
    if (flags & InjectFlags.Optional && notFoundValue === void 0) {
      notFoundValue = null;
    }
    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
      const moduleInjector = lView[INJECTOR$1];
      const previousInjectImplementation = setInjectImplementation(void 0);
      try {
        if (moduleInjector) {
          return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
        } else {
          return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
        }
      } finally {
        setInjectImplementation(previousInjectImplementation);
      }
    }
    return notFoundValueOrThrow(notFoundValue, token, flags);
  }
  function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
    if (tNode !== null) {
      const bloomHash = bloomHashBitOrFactory(token);
      if (typeof bloomHash === "function") {
        if (!enterDI(lView, tNode, flags)) {
          return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
        }
        try {
          const value = bloomHash(flags);
          if (value == null && !(flags & InjectFlags.Optional)) {
            throwProviderNotFoundError(token);
          } else {
            return value;
          }
        } finally {
          leaveDI();
        }
      } else if (typeof bloomHash === "number") {
        let previousTView = null;
        let injectorIndex = getInjectorIndex(tNode, lView);
        let parentLocation = NO_PARENT_INJECTOR;
        let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
          parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
          if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
            injectorIndex = -1;
          } else {
            previousTView = lView[TVIEW];
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          }
        }
        while (injectorIndex !== -1) {
          ngDevMode && assertNodeInjector(lView, injectorIndex);
          const tView = lView[TVIEW];
          ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8], lView);
          if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
            const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
            if (instance !== NOT_FOUND) {
              return instance;
            }
          }
          parentLocation = lView[injectorIndex + 8];
          if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
            previousTView = tView;
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          } else {
            injectorIndex = -1;
          }
        }
      }
    }
    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
  }
  var NOT_FOUND = {};
  function createNodeInjector() {
    return new NodeInjector(getCurrentTNode(), getLView());
  }
  function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
    const currentTView = lView[TVIEW];
    const tNode = currentTView.data[injectorIndex + 8];
    const canAccessViewProviders = previousTView == null ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
    const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
    if (injectableIdx !== null) {
      return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
    } else {
      return NOT_FOUND;
    }
  }
  function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
    const nodeProviderIndexes = tNode.providerIndexes;
    const tInjectables = tView.data;
    const injectablesStart = nodeProviderIndexes & 1048575;
    const directivesStart = tNode.directiveStart;
    const directiveEnd = tNode.directiveEnd;
    const cptViewProvidersCount = nodeProviderIndexes >> 20;
    const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
    for (let i = startingIndex; i < endIndex; i++) {
      const providerTokenOrDef = tInjectables[i];
      if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
        return i;
      }
    }
    if (isHostSpecialCase) {
      const dirDef = tInjectables[directivesStart];
      if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
        return directivesStart;
      }
    }
    return null;
  }
  function getNodeInjectable(lView, tView, index, tNode) {
    let value = lView[index];
    const tData = tView.data;
    if (isFactory(value)) {
      const factory = value;
      if (factory.resolving) {
        throwCyclicDependencyError(stringifyForError(tData[index]));
      }
      const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
      factory.resolving = true;
      const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
      const success = enterDI(lView, tNode, InjectFlags.Default);
      ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
      try {
        value = lView[index] = factory.factory(void 0, tData, lView, tNode);
        if (tView.firstCreatePass && index >= tNode.directiveStart) {
          ngDevMode && assertDirectiveDef(tData[index]);
          registerPreOrderHooks(index, tData[index], tView);
        }
      } finally {
        previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
        setIncludeViewProviders(previousIncludeViewProviders);
        factory.resolving = false;
        leaveDI();
      }
    }
    return value;
  }
  function bloomHashBitOrFactory(token) {
    ngDevMode && assertDefined(token, "token must be defined");
    if (typeof token === "string") {
      return token.charCodeAt(0) || 0;
    }
    const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0;
    if (typeof tokenId === "number") {
      if (tokenId >= 0) {
        return tokenId & BLOOM_MASK;
      } else {
        ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
        return createNodeInjector;
      }
    } else {
      return tokenId;
    }
  }
  function bloomHasToken(bloomHash, injectorIndex, injectorView) {
    const mask = 1 << bloomHash;
    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
    return !!(value & mask);
  }
  function shouldSearchParent(flags, isFirstHostTNode) {
    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
  }
  var NodeInjector = class {
    constructor(_tNode, _lView) {
      this._tNode = _tNode;
      this._lView = _lView;
    }
    get(token, notFoundValue, flags) {
      return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);
    }
  };
  function \u0275\u0275getInheritedFactory(type) {
    return noSideEffects(() => {
      const ownConstructor = type.prototype.constructor;
      const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
      const objectPrototype = Object.prototype;
      let parent = Object.getPrototypeOf(type.prototype).constructor;
      while (parent && parent !== objectPrototype) {
        const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
        if (factory && factory !== ownFactory) {
          return factory;
        }
        parent = Object.getPrototypeOf(parent);
      }
      return (t) => new t();
    });
  }
  function getFactoryOf(type) {
    if (isForwardRef(type)) {
      return () => {
        const factory = getFactoryOf(resolveForwardRef(type));
        return factory && factory();
      };
    }
    return getFactoryDef(type);
  }
  function \u0275\u0275injectAttribute(attrNameToInject) {
    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
  }
  var ANNOTATIONS = "__annotations__";
  var PARAMETERS = "__parameters__";
  var PROP_METADATA = "__prop__metadata__";
  function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
          metaCtor.call(this, ...args);
          return this;
        }
        const annotationInstance = new DecoratorFactory(...args);
        return function TypeDecorator(cls) {
          if (typeFn)
            typeFn(cls, ...args);
          const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
          annotations.push(annotationInstance);
          if (additionalProcessing)
            additionalProcessing(cls);
          return cls;
        };
      }
      if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      DecoratorFactory.prototype.ngMetadataName = name;
      DecoratorFactory.annotationCls = DecoratorFactory;
      return DecoratorFactory;
    });
  }
  function makeMetadataCtor(props) {
    return function ctor(...args) {
      if (props) {
        const values = props(...args);
        for (const propName in values) {
          this[propName] = values[propName];
        }
      }
    };
  }
  function makeParamDecorator(name, props, parentClass) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }
        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
        function ParamDecorator(cls, unusedKey, index) {
          const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
          while (parameters.length <= index) {
            parameters.push(null);
          }
          (parameters[index] = parameters[index] || []).push(annotationInstance);
          return cls;
        }
      }
      if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      ParamDecoratorFactory.prototype.ngMetadataName = name;
      ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
      return ParamDecoratorFactory;
    });
  }
  function makePropDecorator(name, props, parentClass, additionalProcessing) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }
        const decoratorInstance = new PropDecoratorFactory(...args);
        function PropDecorator(target, name2) {
          const constructor = target.constructor;
          const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
          meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
          meta[name2].unshift(decoratorInstance);
          if (additionalProcessing)
            additionalProcessing(target, name2, ...args);
        }
        return PropDecorator;
      }
      if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      PropDecoratorFactory.prototype.ngMetadataName = name;
      PropDecoratorFactory.annotationCls = PropDecoratorFactory;
      return PropDecoratorFactory;
    });
  }
  var Attribute = makeParamDecorator("Attribute", (attributeName) => ({ attributeName, __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName) }));
  var InjectionToken = class {
    constructor(_desc, options) {
      this._desc = _desc;
      this.ngMetadataName = "InjectionToken";
      this.\u0275prov = void 0;
      if (typeof options == "number") {
        (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
        this.__NG_ELEMENT_ID__ = options;
      } else if (options !== void 0) {
        this.\u0275prov = \u0275\u0275defineInjectable({
          token: this,
          providedIn: options.providedIn || "root",
          factory: options.factory
        });
      }
    }
    toString() {
      return `InjectionToken ${this._desc}`;
    }
  };
  var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
  var emitDistinctChangesOnlyDefaultValue = true;
  var Query = class {
  };
  var ContentChildren = makePropDecorator("ContentChildren", (selector, data = {}) => ({
    selector,
    first: false,
    isViewQuery: false,
    descendants: false,
    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
    ...data
  }), Query);
  var ContentChild = makePropDecorator("ContentChild", (selector, data = {}) => ({ selector, first: true, isViewQuery: false, descendants: true, ...data }), Query);
  var ViewChildren = makePropDecorator("ViewChildren", (selector, data = {}) => ({
    selector,
    first: false,
    isViewQuery: true,
    descendants: true,
    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
    ...data
  }), Query);
  var ViewChild = makePropDecorator("ViewChild", (selector, data) => ({ selector, first: true, isViewQuery: true, descendants: true, ...data }), Query);
  var FactoryTarget;
  (function(FactoryTarget3) {
    FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
    FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
    FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
    FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
    FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
  })(FactoryTarget || (FactoryTarget = {}));
  var ViewEncapsulation;
  (function(ViewEncapsulation3) {
    ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
    ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
    ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation || (ViewEncapsulation = {}));
  function getCompilerFacade(request) {
    const globalNg = _global2["ng"];
    if (globalNg && globalNg.\u0275compilerFacade) {
      return globalNg.\u0275compilerFacade;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(`JIT compilation failed for ${request.kind}`, request.type);
      let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
      if (request.usage === 1) {
        message += `The ${request.kind} is part of a library that has been partially compiled.
`;
        message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
        message += "\n";
        message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
      } else {
        message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
      }
      message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
      message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
      throw new Error(message);
    } else {
      throw new Error("JIT compiler unavailable");
    }
  }
  var Type = Function;
  function isType(v) {
    return typeof v === "function";
  }
  function arrayEquals(a, b, identityAccessor) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let valueA = a[i];
      let valueB = b[i];
      if (identityAccessor) {
        valueA = identityAccessor(valueA);
        valueB = identityAccessor(valueB);
      }
      if (valueB !== valueA) {
        return false;
      }
    }
    return true;
  }
  function flatten(list, dst) {
    if (dst === void 0)
      dst = list;
    for (let i = 0; i < list.length; i++) {
      let item = list[i];
      if (Array.isArray(item)) {
        if (dst === list) {
          dst = list.slice(0, i);
        }
        flatten(item, dst);
      } else if (dst !== list) {
        dst.push(item);
      }
    }
    return dst;
  }
  function deepForEach(input, fn2) {
    input.forEach((value) => Array.isArray(value) ? deepForEach(value, fn2) : fn2(value));
  }
  function addToArray(arr, index, value) {
    if (index >= arr.length) {
      arr.push(value);
    } else {
      arr.splice(index, 0, value);
    }
  }
  function removeFromArray(arr, index) {
    if (index >= arr.length - 1) {
      return arr.pop();
    } else {
      return arr.splice(index, 1)[0];
    }
  }
  function newArray(size, value) {
    const list = [];
    for (let i = 0; i < size; i++) {
      list.push(value);
    }
    return list;
  }
  function arrayInsert2(array, index, value1, value2) {
    ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
    let end = array.length;
    if (end == index) {
      array.push(value1, value2);
    } else if (end === 1) {
      array.push(value2, array[0]);
      array[0] = value1;
    } else {
      end--;
      array.push(array[end - 1], array[end]);
      while (end > index) {
        const previousEnd = end - 2;
        array[end] = array[previousEnd];
        end--;
      }
      array[index] = value1;
      array[index + 1] = value2;
    }
  }
  function keyValueArraySet(keyValueArray, key, value) {
    let index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) {
      keyValueArray[index | 1] = value;
    } else {
      index = ~index;
      arrayInsert2(keyValueArray, index, key, value);
    }
    return index;
  }
  function keyValueArrayGet(keyValueArray, key) {
    const index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) {
      return keyValueArray[index | 1];
    }
    return void 0;
  }
  function keyValueArrayIndexOf(keyValueArray, key) {
    return _arrayIndexOfSorted(keyValueArray, key, 1);
  }
  function _arrayIndexOfSorted(array, value, shift) {
    ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
    let start = 0;
    let end = array.length >> shift;
    while (end !== start) {
      const middle = start + (end - start >> 1);
      const current = array[middle << shift];
      if (value === current) {
        return middle << shift;
      } else if (current > value) {
        end = middle;
      } else {
        start = middle + 1;
      }
    }
    return ~(end << shift);
  }
  var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
  var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
  var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
  var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
  function isDelegateCtor(typeStr) {
    return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
  }
  var ReflectionCapabilities = class {
    constructor(reflect) {
      this._reflect = reflect || _global2["Reflect"];
    }
    isReflectionEnabled() {
      return true;
    }
    factory(t) {
      return (...args) => new t(...args);
    }
    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
      let result;
      if (typeof paramTypes === "undefined") {
        result = newArray(paramAnnotations.length);
      } else {
        result = newArray(paramTypes.length);
      }
      for (let i = 0; i < result.length; i++) {
        if (typeof paramTypes === "undefined") {
          result[i] = [];
        } else if (paramTypes[i] && paramTypes[i] != Object) {
          result[i] = [paramTypes[i]];
        } else {
          result[i] = [];
        }
        if (paramAnnotations && paramAnnotations[i] != null) {
          result[i] = result[i].concat(paramAnnotations[i]);
        }
      }
      return result;
    }
    _ownParameters(type, parentCtor) {
      const typeStr = type.toString();
      if (isDelegateCtor(typeStr)) {
        return null;
      }
      if (type.parameters && type.parameters !== parentCtor.parameters) {
        return type.parameters;
      }
      const tsickleCtorParams = type.ctorParameters;
      if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
        const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
        const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
        const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
        return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
      }
      const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
      const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
      if (paramTypes || paramAnnotations) {
        return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
      }
      return newArray(type.length);
    }
    parameters(type) {
      if (!isType(type)) {
        return [];
      }
      const parentCtor = getParentCtor(type);
      let parameters = this._ownParameters(type, parentCtor);
      if (!parameters && parentCtor !== Object) {
        parameters = this.parameters(parentCtor);
      }
      return parameters || [];
    }
    _ownAnnotations(typeOrFunc, parentCtor) {
      if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
        let annotations = typeOrFunc.annotations;
        if (typeof annotations === "function" && annotations.annotations) {
          annotations = annotations.annotations;
        }
        return annotations;
      }
      if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
        return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
      }
      if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
        return typeOrFunc[ANNOTATIONS];
      }
      return null;
    }
    annotations(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return [];
      }
      const parentCtor = getParentCtor(typeOrFunc);
      const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
      const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
      return parentAnnotations.concat(ownAnnotations);
    }
    _ownPropMetadata(typeOrFunc, parentCtor) {
      if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
        let propMetadata = typeOrFunc.propMetadata;
        if (typeof propMetadata === "function" && propMetadata.propMetadata) {
          propMetadata = propMetadata.propMetadata;
        }
        return propMetadata;
      }
      if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
        const propDecorators = typeOrFunc.propDecorators;
        const propMetadata = {};
        Object.keys(propDecorators).forEach((prop) => {
          propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
        });
        return propMetadata;
      }
      if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
        return typeOrFunc[PROP_METADATA];
      }
      return null;
    }
    propMetadata(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      const parentCtor = getParentCtor(typeOrFunc);
      const propMetadata = {};
      if (parentCtor !== Object) {
        const parentPropMetadata = this.propMetadata(parentCtor);
        Object.keys(parentPropMetadata).forEach((propName) => {
          propMetadata[propName] = parentPropMetadata[propName];
        });
      }
      const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
      if (ownPropMetadata) {
        Object.keys(ownPropMetadata).forEach((propName) => {
          const decorators = [];
          if (propMetadata.hasOwnProperty(propName)) {
            decorators.push(...propMetadata[propName]);
          }
          decorators.push(...ownPropMetadata[propName]);
          propMetadata[propName] = decorators;
        });
      }
      return propMetadata;
    }
    ownPropMetadata(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
    }
    hasLifecycleHook(type, lcProperty) {
      return type instanceof Type && lcProperty in type.prototype;
    }
    guards(type) {
      return {};
    }
    getter(name) {
      return new Function("o", "return o." + name + ";");
    }
    setter(name) {
      return new Function("o", "v", "return o." + name + " = v;");
    }
    method(name) {
      const functionBody = `if (!o.${name}) throw new Error('"${name}" is undefined');
        return o.${name}.apply(o, args);`;
      return new Function("o", "args", functionBody);
    }
    importUri(type) {
      if (typeof type === "object" && type["filePath"]) {
        return type["filePath"];
      }
      return `./${stringify(type)}`;
    }
    resourceUri(type) {
      return `./${stringify(type)}`;
    }
    resolveIdentifier(name, moduleUrl, members, runtime) {
      return runtime;
    }
    resolveEnum(enumIdentifier, name) {
      return enumIdentifier[name];
    }
  };
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
      return [];
    }
    return decoratorInvocations.map((decoratorInvocation) => {
      const decoratorType = decoratorInvocation.type;
      const annotationCls = decoratorType.annotationCls;
      const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
      return new annotationCls(...annotationArgs);
    });
  }
  function getParentCtor(ctor) {
    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
    const parentCtor = parentProto ? parentProto.constructor : null;
    return parentCtor || Object;
  }
  var _THROW_IF_NOT_FOUND = {};
  var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
  var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
  var NG_TOKEN_PATH = "ngTokenPath";
  var NEW_LINE = /\n/gm;
  var NO_NEW_LINE = "\u0275";
  var SOURCE = "__source";
  var USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
  var _currentInjector = void 0;
  function setCurrentInjector(injector2) {
    const former = _currentInjector;
    _currentInjector = injector2;
    return former;
  }
  function injectInjectorOnly(token, flags = InjectFlags.Default) {
    if (_currentInjector === void 0) {
      const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `inject() must be called from an injection context` : "";
      throw new RuntimeError(203, errorMessage);
    } else if (_currentInjector === null) {
      return injectRootLimpMode(token, void 0, flags);
    } else {
      return _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    }
  }
  function \u0275\u0275inject(token, flags = InjectFlags.Default) {
    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
  }
  function \u0275\u0275invalidFactoryDep(index) {
    const msg = ngDevMode ? `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` : "invalid";
    throw new Error(msg);
  }
  var inject = \u0275\u0275inject;
  function injectArgs(types) {
    const args = [];
    for (let i = 0; i < types.length; i++) {
      const arg = resolveForwardRef(types[i]);
      if (Array.isArray(arg)) {
        if (arg.length === 0) {
          const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "Arguments array must have arguments." : "";
          throw new RuntimeError(900, errorMessage);
        }
        let type = void 0;
        let flags = InjectFlags.Default;
        for (let j = 0; j < arg.length; j++) {
          const meta = arg[j];
          const flag = getInjectFlag(meta);
          if (typeof flag === "number") {
            if (flag === -1) {
              type = meta.token;
            } else {
              flags |= flag;
            }
          } else {
            type = meta;
          }
        }
        args.push(\u0275\u0275inject(type, flags));
      } else {
        args.push(\u0275\u0275inject(arg));
      }
    }
    return args;
  }
  function attachInjectFlag(decorator, flag) {
    decorator[DI_DECORATOR_FLAG] = flag;
    decorator.prototype[DI_DECORATOR_FLAG] = flag;
    return decorator;
  }
  function getInjectFlag(token) {
    return token[DI_DECORATOR_FLAG];
  }
  function catchInjectorError(e, token, injectorErrorName, source) {
    const tokenPath = e[NG_TEMP_TOKEN_PATH];
    if (token[SOURCE]) {
      tokenPath.unshift(token[SOURCE]);
    }
    e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
    e[NG_TOKEN_PATH] = tokenPath;
    e[NG_TEMP_TOKEN_PATH] = null;
    throw e;
  }
  function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) {
      context = obj.map(stringify).join(" -> ");
    } else if (typeof obj === "object") {
      let parts = [];
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          let value = obj[key];
          parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
        }
      }
      context = `{${parts.join(", ")}}`;
    }
    return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
  }
  var Inject = attachInjectFlag(makeParamDecorator("Inject", (token) => ({ token })), -1);
  var Optional = attachInjectFlag(makeParamDecorator("Optional"), 8);
  var Self = attachInjectFlag(makeParamDecorator("Self"), 2);
  var SkipSelf = attachInjectFlag(makeParamDecorator("SkipSelf"), 4);
  var Host = attachInjectFlag(makeParamDecorator("Host"), 1);
  var _reflect = null;
  function getReflect() {
    return _reflect = _reflect || new ReflectionCapabilities();
  }
  function reflectDependencies(type) {
    return convertDependencies(getReflect().parameters(type));
  }
  function convertDependencies(deps) {
    return deps.map((dep) => reflectDependency(dep));
  }
  function reflectDependency(dep) {
    const meta = {
      token: null,
      attribute: null,
      host: false,
      optional: false,
      self: false,
      skipSelf: false
    };
    if (Array.isArray(dep) && dep.length > 0) {
      for (let j = 0; j < dep.length; j++) {
        const param = dep[j];
        if (param === void 0) {
          continue;
        }
        const proto = Object.getPrototypeOf(param);
        if (param instanceof Optional || proto.ngMetadataName === "Optional") {
          meta.optional = true;
        } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
          meta.skipSelf = true;
        } else if (param instanceof Self || proto.ngMetadataName === "Self") {
          meta.self = true;
        } else if (param instanceof Host || proto.ngMetadataName === "Host") {
          meta.host = true;
        } else if (param instanceof Inject) {
          meta.token = param.token;
        } else if (param instanceof Attribute) {
          if (param.attributeName === void 0) {
            throw new Error(`Attribute name must be defined.`);
          }
          meta.attribute = param.attributeName;
        } else {
          meta.token = param;
        }
      }
    } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
      meta.token = null;
    } else {
      meta.token = dep;
    }
    return meta;
  }
  function resolveComponentResources(resourceResolver) {
    const componentResolved = [];
    const urlMap = /* @__PURE__ */ new Map();
    function cachedResourceResolve(url) {
      let promise2 = urlMap.get(url);
      if (!promise2) {
        const resp = resourceResolver(url);
        urlMap.set(url, promise2 = resp.then(unwrapResponse));
      }
      return promise2;
    }
    componentResourceResolutionQueue.forEach((component, type) => {
      const promises = [];
      if (component.templateUrl) {
        promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
          component.template = template;
        }));
      }
      const styleUrls = component.styleUrls;
      const styles = component.styles || (component.styles = []);
      const styleOffset = component.styles.length;
      styleUrls && styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
      const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
      componentResolved.push(fullyResolved);
    });
    clearResolutionOfComponentResourcesQueue();
    return Promise.all(componentResolved).then(() => void 0);
  }
  var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  var componentDefPendingResolution = /* @__PURE__ */ new Set();
  function maybeQueueResolutionOfComponentResources(type, metadata) {
    if (componentNeedsResolution(metadata)) {
      componentResourceResolutionQueue.set(type, metadata);
      componentDefPendingResolution.add(type);
    }
  }
  function componentNeedsResolution(component) {
    return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length);
  }
  function clearResolutionOfComponentResourcesQueue() {
    const old = componentResourceResolutionQueue;
    componentResourceResolutionQueue = /* @__PURE__ */ new Map();
    return old;
  }
  function isComponentResourceResolutionQueueEmpty() {
    return componentResourceResolutionQueue.size === 0;
  }
  function unwrapResponse(response) {
    return typeof response == "string" ? response : response.text();
  }
  function componentDefResolved(type) {
    componentDefPendingResolution.delete(type);
  }
  var policy$1;
  function getPolicy$1() {
    if (policy$1 === void 0) {
      policy$1 = null;
      if (_global2.trustedTypes) {
        try {
          policy$1 = _global2.trustedTypes.createPolicy("angular", {
            createHTML: (s) => s,
            createScript: (s) => s,
            createScriptURL: (s) => s
          });
        } catch {
        }
      }
    }
    return policy$1;
  }
  function trustedHTMLFromString(html) {
    return getPolicy$1()?.createHTML(html) || html;
  }
  function trustedScriptFromString(script) {
    return getPolicy$1()?.createScript(script) || script;
  }
  function trustedScriptURLFromString(url) {
    return getPolicy$1()?.createScriptURL(url) || url;
  }
  function newTrustedFunctionForDev(...args) {
    if (typeof ngDevMode === "undefined") {
      throw new Error("newTrustedFunctionForDev should never be called in production");
    }
    if (!_global2.trustedTypes) {
      return new Function(...args);
    }
    const fnArgs = args.slice(0, -1).join(",");
    const fnBody = args[args.length - 1];
    const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
    const fn2 = _global2["eval"](trustedScriptFromString(body));
    if (fn2.bind === void 0) {
      return new Function(...args);
    }
    fn2.toString = () => body;
    return fn2.bind(_global2);
  }
  var policy;
  function getPolicy() {
    if (policy === void 0) {
      policy = null;
      if (_global2.trustedTypes) {
        try {
          policy = _global2.trustedTypes.createPolicy("angular#unsafe-bypass", {
            createHTML: (s) => s,
            createScript: (s) => s,
            createScriptURL: (s) => s
          });
        } catch {
        }
      }
    }
    return policy;
  }
  function trustedHTMLFromStringBypass(html) {
    return getPolicy()?.createHTML(html) || html;
  }
  function trustedScriptFromStringBypass(script) {
    return getPolicy()?.createScript(script) || script;
  }
  function trustedScriptURLFromStringBypass(url) {
    return getPolicy()?.createScriptURL(url) || url;
  }
  var SafeValueImpl = class {
    constructor(changingThisBreaksApplicationSecurity) {
      this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
    toString() {
      return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
    }
  };
  function unwrapSafeValue(value) {
    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
  }
  function allowSanitizationBypassAndThrow(value, type) {
    const actualType = getSanitizationBypassType(value);
    if (actualType != null && actualType !== type) {
      if (actualType === "ResourceURL" && type === "URL")
        return true;
      throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);
    }
    return actualType === type;
  }
  function getSanitizationBypassType(value) {
    return value instanceof SafeValueImpl && value.getTypeName() || null;
  }
  function getInertBodyHelper(defaultDoc) {
    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
  }
  var DOMParserHelper = class {
    constructor(inertDocumentHelper) {
      this.inertDocumentHelper = inertDocumentHelper;
    }
    getInertBodyElement(html) {
      html = "<body><remove></remove>" + html;
      try {
        const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
        if (body === null) {
          return this.inertDocumentHelper.getInertBodyElement(html);
        }
        body.removeChild(body.firstChild);
        return body;
      } catch {
        return null;
      }
    }
  };
  var InertDocumentHelper = class {
    constructor(defaultDoc) {
      this.defaultDoc = defaultDoc;
      this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
      if (this.inertDocument.body == null) {
        const inertHtml = this.inertDocument.createElement("html");
        this.inertDocument.appendChild(inertHtml);
        const inertBodyElement = this.inertDocument.createElement("body");
        inertHtml.appendChild(inertBodyElement);
      }
    }
    getInertBodyElement(html) {
      const templateEl = this.inertDocument.createElement("template");
      if ("content" in templateEl) {
        templateEl.innerHTML = trustedHTMLFromString(html);
        return templateEl;
      }
      const inertBody = this.inertDocument.createElement("body");
      inertBody.innerHTML = trustedHTMLFromString(html);
      if (this.defaultDoc.documentMode) {
        this.stripCustomNsAttrs(inertBody);
      }
      return inertBody;
    }
    stripCustomNsAttrs(el) {
      const elAttrs = el.attributes;
      for (let i = elAttrs.length - 1; 0 < i; i--) {
        const attrib = elAttrs.item(i);
        const attrName = attrib.name;
        if (attrName === "xmlns:ns1" || attrName.indexOf("ns1:") === 0) {
          el.removeAttribute(attrName);
        }
      }
      let childNode = el.firstChild;
      while (childNode) {
        if (childNode.nodeType === Node.ELEMENT_NODE)
          this.stripCustomNsAttrs(childNode);
        childNode = childNode.nextSibling;
      }
    }
  };
  function isDOMParserAvailable() {
    try {
      return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
    } catch {
      return false;
    }
  }
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
  function _sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
      return url;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);
    }
    return "unsafe:" + url;
  }
  function sanitizeSrcset(srcset) {
    srcset = String(srcset);
    return srcset.split(",").map((srcset2) => _sanitizeUrl(srcset2.trim())).join(", ");
  }
  function tagSet(tags) {
    const res = {};
    for (const t of tags.split(","))
      res[t] = true;
    return res;
  }
  function merge2(...sets) {
    const res = {};
    for (const s of sets) {
      for (const v in s) {
        if (s.hasOwnProperty(v))
          res[v] = true;
      }
    }
    return res;
  }
  var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
  var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
  var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
  var OPTIONAL_END_TAG_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
  var BLOCK_ELEMENTS = merge2(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
  var INLINE_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
  var VALID_ELEMENTS = merge2(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
  var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
  var SRCSET_ATTRS = tagSet("srcset");
  var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
  var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
  var VALID_ATTRS = merge2(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);
  var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
  var SanitizingHtmlSerializer = class {
    constructor() {
      this.sanitizedSomething = false;
      this.buf = [];
    }
    sanitizeChildren(el) {
      let current = el.firstChild;
      let traverseContent = true;
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          traverseContent = this.startElement(current);
        } else if (current.nodeType === Node.TEXT_NODE) {
          this.chars(current.nodeValue);
        } else {
          this.sanitizedSomething = true;
        }
        if (traverseContent && current.firstChild) {
          current = current.firstChild;
          continue;
        }
        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            this.endElement(current);
          }
          let next = this.checkClobberedElement(current, current.nextSibling);
          if (next) {
            current = next;
            break;
          }
          current = this.checkClobberedElement(current, current.parentNode);
        }
      }
      return this.buf.join("");
    }
    startElement(element2) {
      const tagName = element2.nodeName.toLowerCase();
      if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
        this.sanitizedSomething = true;
        return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
      }
      this.buf.push("<");
      this.buf.push(tagName);
      const elAttrs = element2.attributes;
      for (let i = 0; i < elAttrs.length; i++) {
        const elAttr = elAttrs.item(i);
        const attrName = elAttr.name;
        const lower = attrName.toLowerCase();
        if (!VALID_ATTRS.hasOwnProperty(lower)) {
          this.sanitizedSomething = true;
          continue;
        }
        let value = elAttr.value;
        if (URI_ATTRS[lower])
          value = _sanitizeUrl(value);
        if (SRCSET_ATTRS[lower])
          value = sanitizeSrcset(value);
        this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
      }
      this.buf.push(">");
      return true;
    }
    endElement(current) {
      const tagName = current.nodeName.toLowerCase();
      if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
        this.buf.push("</");
        this.buf.push(tagName);
        this.buf.push(">");
      }
    }
    chars(chars) {
      this.buf.push(encodeEntities(chars));
    }
    checkClobberedElement(node, nextNode) {
      if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {
        throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
      }
      return nextNode;
    }
  };
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  function encodeEntities(value) {
    return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match) {
      const hi = match.charCodeAt(0);
      const low = match.charCodeAt(1);
      return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
    }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
      return "&#" + match.charCodeAt(0) + ";";
    }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  var inertBodyHelper;
  function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
    let inertBodyElement = null;
    try {
      inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
      let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
      let mXSSAttempts = 5;
      let parsedHtml = unsafeHtml;
      do {
        if (mXSSAttempts === 0) {
          throw new Error("Failed to sanitize html because the input is unstable");
        }
        mXSSAttempts--;
        unsafeHtml = parsedHtml;
        parsedHtml = inertBodyElement.innerHTML;
        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
      } while (unsafeHtml !== parsedHtml);
      const sanitizer = new SanitizingHtmlSerializer();
      const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
      if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
        console.warn("WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss");
      }
      return trustedHTMLFromString(safeHtml);
    } finally {
      if (inertBodyElement) {
        const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
        while (parent.firstChild) {
          parent.removeChild(parent.firstChild);
        }
      }
    }
  }
  function getTemplateContent(el) {
    return "content" in el && isTemplateElement(el) ? el.content : null;
  }
  function isTemplateElement(el) {
    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
  }
  var SecurityContext;
  (function(SecurityContext3) {
    SecurityContext3[SecurityContext3["NONE"] = 0] = "NONE";
    SecurityContext3[SecurityContext3["HTML"] = 1] = "HTML";
    SecurityContext3[SecurityContext3["STYLE"] = 2] = "STYLE";
    SecurityContext3[SecurityContext3["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext3[SecurityContext3["URL"] = 4] = "URL";
    SecurityContext3[SecurityContext3["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(SecurityContext || (SecurityContext = {}));
  function \u0275\u0275sanitizeHtml(unsafeHtml) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
    }
    if (allowSanitizationBypassAndThrow(unsafeHtml, "HTML")) {
      return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
    }
    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
  }
  function \u0275\u0275sanitizeStyle(unsafeStyle) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
    }
    if (allowSanitizationBypassAndThrow(unsafeStyle, "Style")) {
      return unwrapSafeValue(unsafeStyle);
    }
    return renderStringify(unsafeStyle);
  }
  function \u0275\u0275sanitizeUrl(unsafeUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
    }
    if (allowSanitizationBypassAndThrow(unsafeUrl, "URL")) {
      return unwrapSafeValue(unsafeUrl);
    }
    return _sanitizeUrl(renderStringify(unsafeUrl));
  }
  function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
    }
    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, "ResourceURL")) {
      return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
    }
    const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "unsafe value used in a resource URL context (see https://g.co/ng/security#xss)" : "";
    throw new RuntimeError(904, errorMessage);
  }
  function \u0275\u0275sanitizeScript(unsafeScript) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
    }
    if (allowSanitizationBypassAndThrow(unsafeScript, "Script")) {
      return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
    }
    const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "unsafe value used in a script context" : "";
    throw new RuntimeError(905, errorMessage);
  }
  function \u0275\u0275trustConstantHtml(html) {
    if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
      throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
    }
    return trustedHTMLFromString(html[0]);
  }
  function \u0275\u0275trustConstantResourceUrl(url) {
    if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
      throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
    }
    return trustedScriptURLFromString(url[0]);
  }
  function getUrlSanitizer(tag, prop) {
    if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
      return \u0275\u0275sanitizeResourceUrl;
    }
    return \u0275\u0275sanitizeUrl;
  }
  function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
    return getUrlSanitizer(tag, prop)(unsafeUrl);
  }
  function validateAgainstEventProperties(name) {
    if (name.toLowerCase().startsWith("on")) {
      const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
      throw new RuntimeError(306, errorMessage);
    }
  }
  function validateAgainstEventAttributes(name) {
    if (name.toLowerCase().startsWith("on")) {
      const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
      throw new RuntimeError(306, errorMessage);
    }
  }
  function getSanitizer() {
    const lView = getLView();
    return lView && lView[SANITIZER];
  }
  function getLContext(target) {
    let mpValue = readPatchedData(target);
    if (mpValue) {
      if (Array.isArray(mpValue)) {
        const lView = mpValue;
        let nodeIndex;
        let component = void 0;
        let directives = void 0;
        if (isComponentInstance(target)) {
          nodeIndex = findViaComponent(lView, target);
          if (nodeIndex == -1) {
            throw new Error("The provided component was not found in the application");
          }
          component = target;
        } else if (isDirectiveInstance(target)) {
          nodeIndex = findViaDirective(lView, target);
          if (nodeIndex == -1) {
            throw new Error("The provided directive was not found in the application");
          }
          directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
        } else {
          nodeIndex = findViaNativeElement(lView, target);
          if (nodeIndex == -1) {
            return null;
          }
        }
        const native = unwrapRNode(lView[nodeIndex]);
        const existingCtx = readPatchedData(native);
        const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
        if (component && context.component === void 0) {
          context.component = component;
          attachPatchData(context.component, context);
        }
        if (directives && context.directives === void 0) {
          context.directives = directives;
          for (let i = 0; i < directives.length; i++) {
            attachPatchData(directives[i], context);
          }
        }
        attachPatchData(context.native, context);
        mpValue = context;
      }
    } else {
      const rElement = target;
      ngDevMode && assertDomNode(rElement);
      let parent = rElement;
      while (parent = parent.parentNode) {
        const parentContext = readPatchedData(parent);
        if (parentContext) {
          let lView;
          if (Array.isArray(parentContext)) {
            lView = parentContext;
          } else {
            lView = parentContext.lView;
          }
          if (!lView) {
            return null;
          }
          const index = findViaNativeElement(lView, rElement);
          if (index >= 0) {
            const native = unwrapRNode(lView[index]);
            const context = createLContext(lView, index, native);
            attachPatchData(native, context);
            mpValue = context;
            break;
          }
        }
      }
    }
    return mpValue || null;
  }
  function createLContext(lView, nodeIndex, native) {
    return {
      lView,
      nodeIndex,
      native,
      component: void 0,
      directives: void 0,
      localRefs: void 0
    };
  }
  function getComponentViewByInstance(componentInstance2) {
    let lView = readPatchedData(componentInstance2);
    let view;
    if (Array.isArray(lView)) {
      const nodeIndex = findViaComponent(lView, componentInstance2);
      view = getComponentLViewByIndex(nodeIndex, lView);
      const context = createLContext(lView, nodeIndex, view[HOST]);
      context.component = componentInstance2;
      attachPatchData(componentInstance2, context);
      attachPatchData(context.native, context);
    } else {
      const context = lView;
      view = getComponentLViewByIndex(context.nodeIndex, context.lView);
    }
    return view;
  }
  var MONKEY_PATCH_KEY_NAME = "__ngContext__";
  function attachPatchData(target, data) {
    ngDevMode && assertDefined(target, "Target expected");
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
  function readPatchedData(target) {
    ngDevMode && assertDefined(target, "Target expected");
    return target[MONKEY_PATCH_KEY_NAME] || null;
  }
  function readPatchedLView(target) {
    const value = readPatchedData(target);
    if (value) {
      return Array.isArray(value) ? value : value.lView;
    }
    return null;
  }
  function isComponentInstance(instance) {
    return instance && instance.constructor && instance.constructor.\u0275cmp;
  }
  function isDirectiveInstance(instance) {
    return instance && instance.constructor && instance.constructor.\u0275dir;
  }
  function findViaNativeElement(lView, target) {
    const tView = lView[TVIEW];
    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
      if (unwrapRNode(lView[i]) === target) {
        return i;
      }
    }
    return -1;
  }
  function traverseNextElement(tNode) {
    if (tNode.child) {
      return tNode.child;
    } else if (tNode.next) {
      return tNode.next;
    } else {
      while (tNode.parent && !tNode.parent.next) {
        tNode = tNode.parent;
      }
      return tNode.parent && tNode.parent.next;
    }
  }
  function findViaComponent(lView, componentInstance2) {
    const componentIndices = lView[TVIEW].components;
    if (componentIndices) {
      for (let i = 0; i < componentIndices.length; i++) {
        const elementComponentIndex = componentIndices[i];
        const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
        if (componentView[CONTEXT] === componentInstance2) {
          return elementComponentIndex;
        }
      }
    } else {
      const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
      const rootComponent = rootComponentView[CONTEXT];
      if (rootComponent === componentInstance2) {
        return HEADER_OFFSET;
      }
    }
    return -1;
  }
  function findViaDirective(lView, directiveInstance) {
    let tNode = lView[TVIEW].firstChild;
    while (tNode) {
      const directiveIndexStart = tNode.directiveStart;
      const directiveIndexEnd = tNode.directiveEnd;
      for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
        if (lView[i] === directiveInstance) {
          return tNode.index;
        }
      }
      tNode = traverseNextElement(tNode);
    }
    return -1;
  }
  function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {
    const tNode = lView[TVIEW].data[nodeIndex];
    let directiveStartIndex = tNode.directiveStart;
    if (directiveStartIndex == 0)
      return EMPTY_ARRAY;
    const directiveEndIndex = tNode.directiveEnd;
    if (!includeComponents && tNode.flags & 2)
      directiveStartIndex++;
    return lView.slice(directiveStartIndex, directiveEndIndex);
  }
  function getComponentAtNodeIndex(nodeIndex, lView) {
    const tNode = lView[TVIEW].data[nodeIndex];
    let directiveStartIndex = tNode.directiveStart;
    return tNode.flags & 2 ? lView[directiveStartIndex] : null;
  }
  function discoverLocalRefs(lView, nodeIndex) {
    const tNode = lView[TVIEW].data[nodeIndex];
    if (tNode && tNode.localNames) {
      const result = {};
      let localIndex = tNode.index + 1;
      for (let i = 0; i < tNode.localNames.length; i += 2) {
        result[tNode.localNames[i]] = lView[localIndex];
        localIndex++;
      }
      return result;
    }
    return null;
  }
  var ERROR_ORIGINAL_ERROR = "ngOriginalError";
  var ERROR_LOGGER = "ngErrorLogger";
  function wrappedError(message, originalError) {
    const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;
    const error3 = Error(msg);
    error3[ERROR_ORIGINAL_ERROR] = originalError;
    return error3;
  }
  function getOriginalError(error3) {
    return error3[ERROR_ORIGINAL_ERROR];
  }
  function getErrorLogger(error3) {
    return error3 && error3[ERROR_LOGGER] || defaultErrorLogger;
  }
  function defaultErrorLogger(console2, ...values) {
    console2.error(...values);
  }
  var ErrorHandler = class {
    constructor() {
      this._console = console;
    }
    handleError(error3) {
      const originalError = this._findOriginalError(error3);
      const errorLogger = getErrorLogger(error3);
      errorLogger(this._console, `ERROR`, error3);
      if (originalError) {
        errorLogger(this._console, `ORIGINAL ERROR`, originalError);
      }
    }
    _findOriginalError(error3) {
      let e = error3 && getOriginalError(error3);
      while (e && getOriginalError(e)) {
        e = getOriginalError(e);
      }
      return e || null;
    }
  };
  var CUSTOM_ELEMENTS_SCHEMA = {
    name: "custom-elements"
  };
  var NO_ERRORS_SCHEMA = {
    name: "no-errors-schema"
  };
  var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
  var COMMENT_DELIMITER = /(<|>)/;
  var COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
  function escapeCommentText(value) {
    return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
  }
  function normalizeDebugBindingName(name) {
    name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
    return `ng-reflect-${name}`;
  }
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
  }
  function normalizeDebugBindingValue(value) {
    try {
      return value != null ? value.toString().slice(0, 30) : value;
    } catch (e) {
      return "[ERROR] Exception while trying to serialize the value";
    }
  }
  var defaultScheduler = (() => (typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || setTimeout).bind(_global2))();
  function \u0275\u0275resolveWindow(element2) {
    return element2.ownerDocument.defaultView;
  }
  function \u0275\u0275resolveDocument(element2) {
    return element2.ownerDocument;
  }
  function \u0275\u0275resolveBody(element2) {
    return element2.ownerDocument.body;
  }
  var INTERPOLATION_DELIMITER = `\uFFFD`;
  function maybeUnwrapFn(value) {
    if (value instanceof Function) {
      return value();
    } else {
      return value;
    }
  }
  function throwMultipleComponentError(tNode) {
    throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}`);
  }
  function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {
    const field = propName ? ` for '${propName}'` : "";
    let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;
    if (creationMode) {
      msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
    }
    throw new RuntimeError(-100, msg);
  }
  function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
    let oldValue = prefix, newValue = prefix;
    for (let i = 0; i < chunks.length; i++) {
      const slotIdx = rootIndex + i;
      oldValue += `${lView[slotIdx]}${chunks[i]}`;
      newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
    }
    return { propName, oldValue, newValue };
  }
  function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
    const tData = lView[TVIEW].data;
    const metadata = tData[bindingIndex];
    if (typeof metadata === "string") {
      if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
        return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
      }
      return { propName: metadata, oldValue, newValue };
    }
    if (metadata === null) {
      let idx = bindingIndex - 1;
      while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
        idx--;
      }
      const meta = tData[idx];
      if (typeof meta === "string") {
        const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
        if (matches && matches.length - 1 > bindingIndex - idx) {
          return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
        }
      }
    }
    return { propName: void 0, oldValue, newValue };
  }
  var RendererStyleFlags2;
  (function(RendererStyleFlags22) {
    RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
    RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
  })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
  var _icuContainerIterate;
  function icuContainerIterate(tIcuContainerNode, lView) {
    return _icuContainerIterate(tIcuContainerNode, lView);
  }
  function ensureIcuContainerVisitorLoaded(loader) {
    if (_icuContainerIterate === void 0) {
      _icuContainerIterate = loader();
    }
  }
  var unusedValueExportToPlacateAjd$3 = 1;
  function getLViewParent(lView) {
    ngDevMode && assertLView(lView);
    const parent = lView[PARENT];
    return isLContainer(parent) ? parent[PARENT] : parent;
  }
  function getRootView(componentOrLView) {
    ngDevMode && assertDefined(componentOrLView, "component");
    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
    while (lView && !(lView[FLAGS] & 512)) {
      lView = getLViewParent(lView);
    }
    ngDevMode && assertLView(lView);
    return lView;
  }
  function getRootContext(viewOrComponent) {
    const rootView = getRootView(viewOrComponent);
    ngDevMode && assertDefined(rootView[CONTEXT], "RootView has no context. Perhaps it is disconnected?");
    return rootView[CONTEXT];
  }
  function getFirstLContainer(lView) {
    return getNearestLContainer(lView[CHILD_HEAD]);
  }
  function getNextLContainer(container) {
    return getNearestLContainer(container[NEXT]);
  }
  function getNearestLContainer(viewOrContainer) {
    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
      viewOrContainer = viewOrContainer[NEXT];
    }
    return viewOrContainer;
  }
  var unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$8;
  function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
    if (lNodeToHandle != null) {
      let lContainer;
      let isComponent = false;
      if (isLContainer(lNodeToHandle)) {
        lContainer = lNodeToHandle;
      } else if (isLView(lNodeToHandle)) {
        isComponent = true;
        ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
        lNodeToHandle = lNodeToHandle[HOST];
      }
      const rNode = unwrapRNode(lNodeToHandle);
      ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);
      if (action === 0 && parent !== null) {
        if (beforeNode == null) {
          nativeAppendChild(renderer, parent, rNode);
        } else {
          nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
        }
      } else if (action === 1 && parent !== null) {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      } else if (action === 2) {
        nativeRemoveNode(renderer, rNode, isComponent);
      } else if (action === 3) {
        ngDevMode && ngDevMode.rendererDestroyNode++;
        renderer.destroyNode(rNode);
      }
      if (lContainer != null) {
        applyContainer(renderer, action, lContainer, parent, beforeNode);
      }
    }
  }
  function createTextNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateTextNode++;
    ngDevMode && ngDevMode.rendererSetText++;
    return isProceduralRenderer(renderer) ? renderer.createText(value) : renderer.createTextNode(value);
  }
  function updateTextNode(renderer, rNode, value) {
    ngDevMode && ngDevMode.rendererSetText++;
    isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;
  }
  function createCommentNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateComment++;
    return renderer.createComment(escapeCommentText(value));
  }
  function createElementNode(renderer, name, namespace) {
    ngDevMode && ngDevMode.rendererCreateElement++;
    if (isProceduralRenderer(renderer)) {
      return renderer.createElement(name, namespace);
    } else {
      const namespaceUri = namespace !== null ? getNamespaceUri(namespace) : null;
      return namespaceUri === null ? renderer.createElement(name) : renderer.createElementNS(namespaceUri, name);
    }
  }
  function removeViewFromContainer(tView, lView) {
    const renderer = lView[RENDERER];
    applyView(tView, lView, renderer, 2, null, null);
    lView[HOST] = null;
    lView[T_HOST] = null;
  }
  function addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
    lView[HOST] = parentNativeNode;
    lView[T_HOST] = parentTNode;
    applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
  }
  function renderDetachView(tView, lView) {
    applyView(tView, lView, lView[RENDERER], 2, null, null);
  }
  function destroyViewTree(rootView) {
    let lViewOrLContainer = rootView[CHILD_HEAD];
    if (!lViewOrLContainer) {
      return cleanUpView(rootView[TVIEW], rootView);
    }
    while (lViewOrLContainer) {
      let next = null;
      if (isLView(lViewOrLContainer)) {
        next = lViewOrLContainer[CHILD_HEAD];
      } else {
        ngDevMode && assertLContainer(lViewOrLContainer);
        const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
        if (firstView)
          next = firstView;
      }
      if (!next) {
        while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
          if (isLView(lViewOrLContainer)) {
            cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
          }
          lViewOrLContainer = lViewOrLContainer[PARENT];
        }
        if (lViewOrLContainer === null)
          lViewOrLContainer = rootView;
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        next = lViewOrLContainer && lViewOrLContainer[NEXT];
      }
      lViewOrLContainer = next;
    }
  }
  function insertView(tView, lView, lContainer, index) {
    ngDevMode && assertLView(lView);
    ngDevMode && assertLContainer(lContainer);
    const indexInContainer = CONTAINER_HEADER_OFFSET + index;
    const containerLength = lContainer.length;
    if (index > 0) {
      lContainer[indexInContainer - 1][NEXT] = lView;
    }
    if (index < containerLength - CONTAINER_HEADER_OFFSET) {
      lView[NEXT] = lContainer[indexInContainer];
      addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
    } else {
      lContainer.push(lView);
      lView[NEXT] = null;
    }
    lView[PARENT] = lContainer;
    const declarationLContainer = lView[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && lContainer !== declarationLContainer) {
      trackMovedView(declarationLContainer, lView);
    }
    const lQueries = lView[QUERIES];
    if (lQueries !== null) {
      lQueries.insertView(tView);
    }
    lView[FLAGS] |= 128;
  }
  function trackMovedView(declarationContainer, lView) {
    ngDevMode && assertDefined(lView, "LView required");
    ngDevMode && assertLContainer(declarationContainer);
    const movedViews = declarationContainer[MOVED_VIEWS];
    const insertedLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertedLContainer);
    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;
    }
    if (movedViews === null) {
      declarationContainer[MOVED_VIEWS] = [lView];
    } else {
      movedViews.push(lView);
    }
  }
  function detachMovedView(declarationContainer, lView) {
    ngDevMode && assertLContainer(declarationContainer);
    ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
    const movedViews = declarationContainer[MOVED_VIEWS];
    const declarationViewIndex = movedViews.indexOf(lView);
    const insertionLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertionLContainer);
    if (lView[FLAGS] & 1024) {
      lView[FLAGS] &= ~1024;
      updateTransplantedViewCount(insertionLContainer, -1);
    }
    movedViews.splice(declarationViewIndex, 1);
  }
  function detachView(lContainer, removeIndex) {
    if (lContainer.length <= CONTAINER_HEADER_OFFSET)
      return;
    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
    const viewToDetach = lContainer[indexInContainer];
    if (viewToDetach) {
      const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
      if (declarationLContainer !== null && declarationLContainer !== lContainer) {
        detachMovedView(declarationLContainer, viewToDetach);
      }
      if (removeIndex > 0) {
        lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
      }
      const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
      removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
      const lQueries = removedLView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(removedLView[TVIEW]);
      }
      viewToDetach[PARENT] = null;
      viewToDetach[NEXT] = null;
      viewToDetach[FLAGS] &= ~128;
    }
    return viewToDetach;
  }
  function destroyLView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
      const renderer = lView[RENDERER];
      if (isProceduralRenderer(renderer) && renderer.destroyNode) {
        applyView(tView, lView, renderer, 3, null, null);
      }
      destroyViewTree(lView);
    }
  }
  function cleanUpView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
      lView[FLAGS] &= ~128;
      lView[FLAGS] |= 256;
      executeOnDestroys(tView, lView);
      processCleanups(tView, lView);
      if (lView[TVIEW].type === 1 && isProceduralRenderer(lView[RENDERER])) {
        ngDevMode && ngDevMode.rendererDestroy++;
        lView[RENDERER].destroy();
      }
      const declarationContainer = lView[DECLARATION_LCONTAINER];
      if (declarationContainer !== null && isLContainer(lView[PARENT])) {
        if (declarationContainer !== lView[PARENT]) {
          detachMovedView(declarationContainer, lView);
        }
        const lQueries = lView[QUERIES];
        if (lQueries !== null) {
          lQueries.detachView(tView);
        }
      }
    }
  }
  function processCleanups(tView, lView) {
    const tCleanup = tView.cleanup;
    const lCleanup = lView[CLEANUP];
    let lastLCleanupIndex = -1;
    if (tCleanup !== null) {
      for (let i = 0; i < tCleanup.length - 1; i += 2) {
        if (typeof tCleanup[i] === "string") {
          const idxOrTargetGetter = tCleanup[i + 1];
          const target = typeof idxOrTargetGetter === "function" ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]);
          const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];
          const useCaptureOrSubIdx = tCleanup[i + 3];
          if (typeof useCaptureOrSubIdx === "boolean") {
            target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
          } else {
            if (useCaptureOrSubIdx >= 0) {
              lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();
            } else {
              lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();
            }
          }
          i += 2;
        } else {
          const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
          tCleanup[i].call(context);
        }
      }
    }
    if (lCleanup !== null) {
      for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
        const instanceCleanupFn = lCleanup[i];
        ngDevMode && assertFunction(instanceCleanupFn, "Expecting instance cleanup function.");
        instanceCleanupFn();
      }
      lView[CLEANUP] = null;
    }
  }
  function executeOnDestroys(tView, lView) {
    let destroyHooks;
    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
      for (let i = 0; i < destroyHooks.length; i += 2) {
        const context = lView[destroyHooks[i]];
        if (!(context instanceof NodeInjectorFactory)) {
          const toCall = destroyHooks[i + 1];
          if (Array.isArray(toCall)) {
            for (let j = 0; j < toCall.length; j += 2) {
              const callContext = context[toCall[j]];
              const hook = toCall[j + 1];
              profiler(4, callContext, hook);
              try {
                hook.call(callContext);
              } finally {
                profiler(5, callContext, hook);
              }
            }
          } else {
            profiler(4, context, toCall);
            try {
              toCall.call(context);
            } finally {
              profiler(5, context, toCall);
            }
          }
        }
      }
    }
  }
  function getParentRElement(tView, tNode, lView) {
    return getClosestRElement(tView, tNode.parent, lView);
  }
  function getClosestRElement(tView, tNode, lView) {
    let parentTNode = tNode;
    while (parentTNode !== null && parentTNode.type & (8 | 32)) {
      tNode = parentTNode;
      parentTNode = tNode.parent;
    }
    if (parentTNode === null) {
      return lView[HOST];
    } else {
      ngDevMode && assertTNodeType(parentTNode, 3 | 4);
      if (parentTNode.flags & 2) {
        ngDevMode && assertTNodeForLView(parentTNode, lView);
        const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;
        if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
          return null;
        }
      }
      return getNativeByTNode(parentTNode, lView);
    }
  }
  function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
    ngDevMode && ngDevMode.rendererInsertBefore++;
    if (isProceduralRenderer(renderer)) {
      renderer.insertBefore(parent, child, beforeNode, isMove);
    } else {
      parent.insertBefore(child, beforeNode, isMove);
    }
  }
  function nativeAppendChild(renderer, parent, child) {
    ngDevMode && ngDevMode.rendererAppendChild++;
    ngDevMode && assertDefined(parent, "parent node must be defined");
    if (isProceduralRenderer(renderer)) {
      renderer.appendChild(parent, child);
    } else {
      parent.appendChild(child);
    }
  }
  function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
    if (beforeNode !== null) {
      nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
    } else {
      nativeAppendChild(renderer, parent, child);
    }
  }
  function nativeRemoveChild(renderer, parent, child, isHostElement) {
    if (isProceduralRenderer(renderer)) {
      renderer.removeChild(parent, child, isHostElement);
    } else {
      parent.removeChild(child);
    }
  }
  function nativeParentNode(renderer, node) {
    return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;
  }
  function nativeNextSibling(renderer, node) {
    return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
  }
  function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
  }
  function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
    if (parentTNode.type & (8 | 32)) {
      return getNativeByTNode(parentTNode, lView);
    }
    return null;
  }
  var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
  var _processI18nInsertBefore;
  function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
    _processI18nInsertBefore = processI18nInsertBefore2;
  }
  function appendChild(tView, lView, childRNode, childTNode) {
    const parentRNode = getParentRElement(tView, childTNode, lView);
    const renderer = lView[RENDERER];
    const parentTNode = childTNode.parent || lView[T_HOST];
    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
    if (parentRNode != null) {
      if (Array.isArray(childRNode)) {
        for (let i = 0; i < childRNode.length; i++) {
          nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
        }
      } else {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
      }
    }
    _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
  }
  function getFirstNativeNode(lView, tNode) {
    if (tNode !== null) {
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 32 | 16);
      const tNodeType = tNode.type;
      if (tNodeType & 3) {
        return getNativeByTNode(tNode, lView);
      } else if (tNodeType & 4) {
        return getBeforeNodeForView(-1, lView[tNode.index]);
      } else if (tNodeType & 8) {
        const elIcuContainerChild = tNode.child;
        if (elIcuContainerChild !== null) {
          return getFirstNativeNode(lView, elIcuContainerChild);
        } else {
          const rNodeOrLContainer = lView[tNode.index];
          if (isLContainer(rNodeOrLContainer)) {
            return getBeforeNodeForView(-1, rNodeOrLContainer);
          } else {
            return unwrapRNode(rNodeOrLContainer);
          }
        }
      } else if (tNodeType & 32) {
        let nextRNode = icuContainerIterate(tNode, lView);
        let rNode = nextRNode();
        return rNode || unwrapRNode(lView[tNode.index]);
      } else {
        const projectionNodes = getProjectionNodes(lView, tNode);
        if (projectionNodes !== null) {
          if (Array.isArray(projectionNodes)) {
            return projectionNodes[0];
          }
          const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
          ngDevMode && assertParentView(parentView);
          return getFirstNativeNode(parentView, projectionNodes);
        } else {
          return getFirstNativeNode(lView, tNode.next);
        }
      }
    }
    return null;
  }
  function getProjectionNodes(lView, tNode) {
    if (tNode !== null) {
      const componentView = lView[DECLARATION_COMPONENT_VIEW];
      const componentHost = componentView[T_HOST];
      const slotIdx = tNode.projection;
      ngDevMode && assertProjectionSlots(lView);
      return componentHost.projection[slotIdx];
    }
    return null;
  }
  function getBeforeNodeForView(viewIndexInContainer, lContainer) {
    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
    if (nextViewIndex < lContainer.length) {
      const lView = lContainer[nextViewIndex];
      const firstTNodeOfView = lView[TVIEW].firstChild;
      if (firstTNodeOfView !== null) {
        return getFirstNativeNode(lView, firstTNodeOfView);
      }
    }
    return lContainer[NATIVE];
  }
  function nativeRemoveNode(renderer, rNode, isHostElement) {
    ngDevMode && ngDevMode.rendererRemoveNode++;
    const nativeParent = nativeParentNode(renderer, rNode);
    if (nativeParent) {
      nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
    }
  }
  function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
    while (tNode != null) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
      const rawSlotValue = lView[tNode.index];
      const tNodeType = tNode.type;
      if (isProjection) {
        if (action === 0) {
          rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
          tNode.flags |= 4;
        }
      }
      if ((tNode.flags & 64) !== 64) {
        if (tNodeType & 8) {
          applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        } else if (tNodeType & 32) {
          const nextRNode = icuContainerIterate(tNode, lView);
          let rNode;
          while (rNode = nextRNode()) {
            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
          }
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        } else if (tNodeType & 16) {
          applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
        } else {
          ngDevMode && assertTNodeType(tNode, 3 | 4);
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        }
      }
      tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
  }
  function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
  }
  function applyProjection(tView, lView, tProjectionNode) {
    const renderer = lView[RENDERER];
    const parentRNode = getParentRElement(tView, tProjectionNode, lView);
    const parentTNode = tProjectionNode.parent || lView[T_HOST];
    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
    applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
  }
  function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    const componentNode = componentLView[T_HOST];
    ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
    if (Array.isArray(nodeToProjectOrRNodes)) {
      for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
        const rNode = nodeToProjectOrRNodes[i];
        applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
      }
    } else {
      let nodeToProject = nodeToProjectOrRNodes;
      const projectedComponentLView = componentLView[PARENT];
      applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
    }
  }
  function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
    ngDevMode && assertLContainer(lContainer);
    const anchor = lContainer[NATIVE];
    const native = unwrapRNode(lContainer);
    if (anchor !== native) {
      applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
    }
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const lView = lContainer[i];
      applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
    }
  }
  function applyStyling(renderer, isClassBased, rNode, prop, value) {
    const isProcedural = isProceduralRenderer(renderer);
    if (isClassBased) {
      if (!value) {
        ngDevMode && ngDevMode.rendererRemoveClass++;
        if (isProcedural) {
          renderer.removeClass(rNode, prop);
        } else {
          rNode.classList.remove(prop);
        }
      } else {
        ngDevMode && ngDevMode.rendererAddClass++;
        if (isProcedural) {
          renderer.addClass(rNode, prop);
        } else {
          ngDevMode && assertDefined(rNode.classList, "HTMLElement expected");
          rNode.classList.add(prop);
        }
      }
    } else {
      let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
      if (value == null) {
        ngDevMode && ngDevMode.rendererRemoveStyle++;
        if (isProcedural) {
          renderer.removeStyle(rNode, prop, flags);
        } else {
          rNode.style.removeProperty(prop);
        }
      } else {
        const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
        if (isImportant) {
          value = value.slice(0, -10);
          flags |= RendererStyleFlags2.Important;
        }
        ngDevMode && ngDevMode.rendererSetStyle++;
        if (isProcedural) {
          renderer.setStyle(rNode, prop, value, flags);
        } else {
          ngDevMode && assertDefined(rNode.style, "HTMLElement expected");
          rNode.style.setProperty(prop, value, isImportant ? "important" : "");
        }
      }
    }
  }
  function writeDirectStyle(renderer, element2, newValue) {
    ngDevMode && assertString(newValue, "'newValue' should be a string");
    if (isProceduralRenderer(renderer)) {
      renderer.setAttribute(element2, "style", newValue);
    } else {
      element2.style.cssText = newValue;
    }
    ngDevMode && ngDevMode.rendererSetStyle++;
  }
  function writeDirectClass(renderer, element2, newValue) {
    ngDevMode && assertString(newValue, "'newValue' should be a string");
    if (isProceduralRenderer(renderer)) {
      if (newValue === "") {
        renderer.removeAttribute(element2, "class");
      } else {
        renderer.setAttribute(element2, "class", newValue);
      }
    } else {
      element2.className = newValue;
    }
    ngDevMode && ngDevMode.rendererSetClassName++;
  }
  function classIndexOf(className, classToSearch, startingIndex) {
    ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
    let end = className.length;
    while (true) {
      const foundIndex = className.indexOf(classToSearch, startingIndex);
      if (foundIndex === -1)
        return foundIndex;
      if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
        const length = classToSearch.length;
        if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
          return foundIndex;
        }
      }
      startingIndex = foundIndex + 1;
    }
  }
  var unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3;
  var NG_TEMPLATE_SELECTOR = "ng-template";
  function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
    ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
    let i = 0;
    while (i < attrs.length) {
      let item = attrs[i++];
      if (isProjectionMode && item === "class") {
        item = attrs[i];
        if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {
          return true;
        }
      } else if (item === 1) {
        while (i < attrs.length && typeof (item = attrs[i++]) == "string") {
          if (item.toLowerCase() === cssClassToMatch)
            return true;
        }
        return false;
      }
    }
    return false;
  }
  function isInlineTemplate(tNode) {
    return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
  }
  function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
    const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
    return currentSelector === tagNameToCompare;
  }
  function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
    ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
    let mode = 4;
    const nodeAttrs = tNode.attrs || [];
    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);
    let skipToNextSelector = false;
    for (let i = 0; i < selector.length; i++) {
      const current = selector[i];
      if (typeof current === "number") {
        if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
          return false;
        }
        if (skipToNextSelector && isPositive(current))
          continue;
        skipToNextSelector = false;
        mode = current | mode & 1;
        continue;
      }
      if (skipToNextSelector)
        continue;
      if (mode & 4) {
        mode = 2 | mode & 1;
        if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      } else {
        const selectorAttrValue = mode & 8 ? current : selector[++i];
        if (mode & 8 && tNode.attrs !== null) {
          if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {
            if (isPositive(mode))
              return false;
            skipToNextSelector = true;
          }
          continue;
        }
        const attrName = mode & 8 ? "class" : current;
        const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
        if (attrIndexInNode === -1) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
          continue;
        }
        if (selectorAttrValue !== "") {
          let nodeAttrValue;
          if (attrIndexInNode > nameOnlyMarkerIdx) {
            nodeAttrValue = "";
          } else {
            ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
            nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
          }
          const compareAgainstClassName = mode & 8 ? nodeAttrValue : null;
          if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 && selectorAttrValue !== nodeAttrValue) {
            if (isPositive(mode))
              return false;
            skipToNextSelector = true;
          }
        }
      }
    }
    return isPositive(mode) || skipToNextSelector;
  }
  function isPositive(mode) {
    return (mode & 1) === 0;
  }
  function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
    if (attrs === null)
      return -1;
    let i = 0;
    if (isProjectionMode || !isInlineTemplate2) {
      let bindingsMode = false;
      while (i < attrs.length) {
        const maybeAttrName = attrs[i];
        if (maybeAttrName === name) {
          return i;
        } else if (maybeAttrName === 3 || maybeAttrName === 6) {
          bindingsMode = true;
        } else if (maybeAttrName === 1 || maybeAttrName === 2) {
          let value = attrs[++i];
          while (typeof value === "string") {
            value = attrs[++i];
          }
          continue;
        } else if (maybeAttrName === 4) {
          break;
        } else if (maybeAttrName === 0) {
          i += 4;
          continue;
        }
        i += bindingsMode ? 1 : 2;
      }
      return -1;
    } else {
      return matchTemplateAttribute(attrs, name);
    }
  }
  function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
    for (let i = 0; i < selector.length; i++) {
      if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
        return true;
      }
    }
    return false;
  }
  function getProjectAsAttrValue(tNode) {
    const nodeAttrs = tNode.attrs;
    if (nodeAttrs != null) {
      const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
      if ((ngProjectAsAttrIdx & 1) === 0) {
        return nodeAttrs[ngProjectAsAttrIdx + 1];
      }
    }
    return null;
  }
  function getNameOnlyMarkerIndex(nodeAttrs) {
    for (let i = 0; i < nodeAttrs.length; i++) {
      const nodeAttr = nodeAttrs[i];
      if (isNameOnlyAttributeMarker(nodeAttr)) {
        return i;
      }
    }
    return nodeAttrs.length;
  }
  function matchTemplateAttribute(attrs, name) {
    let i = attrs.indexOf(4);
    if (i > -1) {
      i++;
      while (i < attrs.length) {
        const attr = attrs[i];
        if (typeof attr === "number")
          return -1;
        if (attr === name)
          return i;
        i++;
      }
    }
    return -1;
  }
  function isSelectorInSelectorList(selector, list) {
    selectorListLoop:
      for (let i = 0; i < list.length; i++) {
        const currentSelectorInList = list[i];
        if (selector.length !== currentSelectorInList.length) {
          continue;
        }
        for (let j = 0; j < selector.length; j++) {
          if (selector[j] !== currentSelectorInList[j]) {
            continue selectorListLoop;
          }
        }
        return true;
      }
    return false;
  }
  function maybeWrapInNotSelector(isNegativeMode, chunk) {
    return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
  }
  function stringifyCSSSelector(selector) {
    let result = selector[0];
    let i = 1;
    let mode = 2;
    let currentChunk = "";
    let isNegativeMode = false;
    while (i < selector.length) {
      let valueOrMarker = selector[i];
      if (typeof valueOrMarker === "string") {
        if (mode & 2) {
          const attrValue = selector[++i];
          currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
        } else if (mode & 8) {
          currentChunk += "." + valueOrMarker;
        } else if (mode & 4) {
          currentChunk += " " + valueOrMarker;
        }
      } else {
        if (currentChunk !== "" && !isPositive(valueOrMarker)) {
          result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
          currentChunk = "";
        }
        mode = valueOrMarker;
        isNegativeMode = isNegativeMode || !isPositive(mode);
      }
      i++;
    }
    if (currentChunk !== "") {
      result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
    }
    return result;
  }
  function stringifyCSSSelectorList(selectorList) {
    return selectorList.map(stringifyCSSSelector).join(",");
  }
  function extractAttrsAndClassesFromSelector(selector) {
    const attrs = [];
    const classes = [];
    let i = 1;
    let mode = 2;
    while (i < selector.length) {
      let valueOrMarker = selector[i];
      if (typeof valueOrMarker === "string") {
        if (mode === 2) {
          if (valueOrMarker !== "") {
            attrs.push(valueOrMarker, selector[++i]);
          }
        } else if (mode === 8) {
          classes.push(valueOrMarker);
        }
      } else {
        if (!isPositive(mode))
          break;
        mode = valueOrMarker;
      }
      i++;
    }
    return { attrs, classes };
  }
  var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
  function \u0275\u0275advance(delta) {
    ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
    selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, isInCheckNoChangesMode());
  }
  function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
    ngDevMode && assertIndexInDeclRange(lView, index);
    if (!checkNoChangesMode) {
      const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, index);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
        }
      }
    }
    setSelectedIndex(index);
  }
  function createNamedArrayType(name) {
    if (ngDevMode) {
      try {
        return newTrustedFunctionForDev("Array", `return class ${name} extends Array{}`)(Array);
      } catch (e) {
        return Array;
      }
    } else {
      throw new Error("Looks like we are in 'prod mode', but we are creating a named Array type, which is wrong! Check your code");
    }
  }
  function toTStylingRange(prev, next) {
    ngDevMode && assertNumberInRange(prev, 0, 32767);
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return prev << 17 | next << 2;
  }
  function getTStylingRangePrev(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return tStylingRange >> 17 & 32767;
  }
  function getTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return (tStylingRange & 2) == 2;
  }
  function setTStylingRangePrev(tStylingRange, previous) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    ngDevMode && assertNumberInRange(previous, 0, 32767);
    return tStylingRange & ~4294836224 | previous << 17;
  }
  function setTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return tStylingRange | 2;
  }
  function getTStylingRangeNext(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return (tStylingRange & 131068) >> 2;
  }
  function setTStylingRangeNext(tStylingRange, next) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return tStylingRange & ~131068 | next << 2;
  }
  function getTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return (tStylingRange & 1) === 1;
  }
  function setTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return tStylingRange | 1;
  }
  function attachDebugObject(obj, debug) {
    if (ngDevMode) {
      Object.defineProperty(obj, "debug", { value: debug, enumerable: false });
    } else {
      throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
    }
  }
  function attachDebugGetter(obj, debugGetter) {
    if (ngDevMode) {
      Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
    } else {
      throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
    }
  }
  var LVIEW_COMPONENT_CACHE;
  var LVIEW_EMBEDDED_CACHE;
  var LVIEW_ROOT;
  var LVIEW_COMPONENT;
  var LVIEW_EMBEDDED;
  function cloneToLViewFromTViewBlueprint(tView) {
    const debugTView = tView;
    const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);
    return lView.concat(tView.blueprint);
  }
  var LRootView = class extends Array {
  };
  var LComponentView = class extends Array {
  };
  var LEmbeddedView = class extends Array {
  };
  function getLViewToClone(type, name) {
    switch (type) {
      case 0:
        if (LVIEW_ROOT === void 0)
          LVIEW_ROOT = new LRootView();
        return LVIEW_ROOT;
      case 1:
        if (!ngDevMode || !ngDevMode.namedConstructors) {
          if (LVIEW_COMPONENT === void 0)
            LVIEW_COMPONENT = new LComponentView();
          return LVIEW_COMPONENT;
        }
        if (LVIEW_COMPONENT_CACHE === void 0)
          LVIEW_COMPONENT_CACHE = /* @__PURE__ */ new Map();
        let componentArray = LVIEW_COMPONENT_CACHE.get(name);
        if (componentArray === void 0) {
          componentArray = new (createNamedArrayType("LComponentView" + nameSuffix(name)))();
          LVIEW_COMPONENT_CACHE.set(name, componentArray);
        }
        return componentArray;
      case 2:
        if (!ngDevMode || !ngDevMode.namedConstructors) {
          if (LVIEW_EMBEDDED === void 0)
            LVIEW_EMBEDDED = new LEmbeddedView();
          return LVIEW_EMBEDDED;
        }
        if (LVIEW_EMBEDDED_CACHE === void 0)
          LVIEW_EMBEDDED_CACHE = /* @__PURE__ */ new Map();
        let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
        if (embeddedArray === void 0) {
          embeddedArray = new (createNamedArrayType("LEmbeddedView" + nameSuffix(name)))();
          LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);
        }
        return embeddedArray;
    }
  }
  function nameSuffix(text) {
    if (text == null)
      return "";
    const index = text.lastIndexOf("_Template");
    return "_" + (index === -1 ? text : text.substr(0, index));
  }
  var TViewConstructor = class TView {
    constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {
      this.type = type;
      this.blueprint = blueprint;
      this.template = template;
      this.queries = queries;
      this.viewQuery = viewQuery;
      this.declTNode = declTNode;
      this.data = data;
      this.bindingStartIndex = bindingStartIndex;
      this.expandoStartIndex = expandoStartIndex;
      this.hostBindingOpCodes = hostBindingOpCodes;
      this.firstCreatePass = firstCreatePass;
      this.firstUpdatePass = firstUpdatePass;
      this.staticViewQueries = staticViewQueries;
      this.staticContentQueries = staticContentQueries;
      this.preOrderHooks = preOrderHooks;
      this.preOrderCheckHooks = preOrderCheckHooks;
      this.contentHooks = contentHooks;
      this.contentCheckHooks = contentCheckHooks;
      this.viewHooks = viewHooks;
      this.viewCheckHooks = viewCheckHooks;
      this.destroyHooks = destroyHooks;
      this.cleanup = cleanup;
      this.contentQueries = contentQueries;
      this.components = components;
      this.directiveRegistry = directiveRegistry;
      this.pipeRegistry = pipeRegistry;
      this.firstChild = firstChild;
      this.schemas = schemas;
      this.consts = consts;
      this.incompleteFirstPass = incompleteFirstPass;
      this._decls = _decls;
      this._vars = _vars;
    }
    get template_() {
      const buf = [];
      processTNodeChildren(this.firstChild, buf);
      return buf.join("");
    }
    get type_() {
      return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;
    }
  };
  var TNode = class {
    constructor(tView_, type, index, insertBeforeIndex, injectorIndex, directiveStart, directiveEnd, directiveStylingLast, propertyBindings, flags, providerIndexes, value, attrs, mergedAttrs, localNames, initialInputs, inputs, outputs, tViews, next, projectionNext, child, parent, projection, styles, stylesWithoutHost, residualStyles, classes, classesWithoutHost, residualClasses, classBindings, styleBindings) {
      this.tView_ = tView_;
      this.type = type;
      this.index = index;
      this.insertBeforeIndex = insertBeforeIndex;
      this.injectorIndex = injectorIndex;
      this.directiveStart = directiveStart;
      this.directiveEnd = directiveEnd;
      this.directiveStylingLast = directiveStylingLast;
      this.propertyBindings = propertyBindings;
      this.flags = flags;
      this.providerIndexes = providerIndexes;
      this.value = value;
      this.attrs = attrs;
      this.mergedAttrs = mergedAttrs;
      this.localNames = localNames;
      this.initialInputs = initialInputs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.tViews = tViews;
      this.next = next;
      this.projectionNext = projectionNext;
      this.child = child;
      this.parent = parent;
      this.projection = projection;
      this.styles = styles;
      this.stylesWithoutHost = stylesWithoutHost;
      this.residualStyles = residualStyles;
      this.classes = classes;
      this.classesWithoutHost = classesWithoutHost;
      this.residualClasses = residualClasses;
      this.classBindings = classBindings;
      this.styleBindings = styleBindings;
    }
    debugNodeInjectorPath(lView) {
      const path = [];
      let injectorIndex = getInjectorIndex(this, lView);
      if (injectorIndex === -1) {
        const parentLocation = getParentInjectorLocation(this, lView);
        if (parentLocation !== NO_PARENT_INJECTOR) {
          injectorIndex = getParentInjectorIndex(parentLocation);
          lView = getParentInjectorView(parentLocation, lView);
        } else {
        }
      }
      while (injectorIndex !== -1) {
        ngDevMode && assertNodeInjector(lView, injectorIndex);
        const tNode = lView[TVIEW].data[injectorIndex + 8];
        path.push(buildDebugNode(tNode, lView));
        const parentLocation = lView[injectorIndex + 8];
        if (parentLocation === NO_PARENT_INJECTOR) {
          injectorIndex = -1;
        } else {
          injectorIndex = getParentInjectorIndex(parentLocation);
          lView = getParentInjectorView(parentLocation, lView);
        }
      }
      return path;
    }
    get type_() {
      return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;
    }
    get flags_() {
      const flags = [];
      if (this.flags & 16)
        flags.push("TNodeFlags.hasClassInput");
      if (this.flags & 8)
        flags.push("TNodeFlags.hasContentQuery");
      if (this.flags & 32)
        flags.push("TNodeFlags.hasStyleInput");
      if (this.flags & 128)
        flags.push("TNodeFlags.hasHostBindings");
      if (this.flags & 2)
        flags.push("TNodeFlags.isComponentHost");
      if (this.flags & 1)
        flags.push("TNodeFlags.isDirectiveHost");
      if (this.flags & 64)
        flags.push("TNodeFlags.isDetached");
      if (this.flags & 4)
        flags.push("TNodeFlags.isProjected");
      return flags.join("|");
    }
    get template_() {
      if (this.type & 1)
        return this.value;
      const buf = [];
      const tagName = typeof this.value === "string" && this.value || this.type_;
      buf.push("<", tagName);
      if (this.flags) {
        buf.push(" ", this.flags_);
      }
      if (this.attrs) {
        for (let i = 0; i < this.attrs.length; ) {
          const attrName = this.attrs[i++];
          if (typeof attrName == "number") {
            break;
          }
          const attrValue = this.attrs[i++];
          buf.push(" ", attrName, '="', attrValue, '"');
        }
      }
      buf.push(">");
      processTNodeChildren(this.child, buf);
      buf.push("</", tagName, ">");
      return buf.join("");
    }
    get styleBindings_() {
      return toDebugStyleBinding(this, false);
    }
    get classBindings_() {
      return toDebugStyleBinding(this, true);
    }
    get providerIndexStart_() {
      return this.providerIndexes & 1048575;
    }
    get providerIndexEnd_() {
      return this.providerIndexStart_ + (this.providerIndexes >>> 20);
    }
  };
  var TNodeDebug = TNode;
  function toDebugStyleBinding(tNode, isClassBased) {
    const tData = tNode.tView_.data;
    const bindings = [];
    const range = isClassBased ? tNode.classBindings : tNode.styleBindings;
    const prev = getTStylingRangePrev(range);
    const next = getTStylingRangeNext(range);
    let isTemplate = next !== 0;
    let cursor = isTemplate ? next : prev;
    while (cursor !== 0) {
      const itemKey = tData[cursor];
      const itemRange = tData[cursor + 1];
      bindings.unshift({
        key: itemKey,
        index: cursor,
        isTemplate,
        prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
        nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
        nextIndex: getTStylingRangeNext(itemRange),
        prevIndex: getTStylingRangePrev(itemRange)
      });
      if (cursor === prev)
        isTemplate = false;
      cursor = getTStylingRangePrev(itemRange);
    }
    bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);
    return bindings;
  }
  function processTNodeChildren(tNode, buf) {
    while (tNode) {
      buf.push(tNode.template_);
      tNode = tNode.next;
    }
  }
  var TViewData = class extends Array {
  };
  var TVIEWDATA_EMPTY;
  function cloneToTViewData(list) {
    if (TVIEWDATA_EMPTY === void 0)
      TVIEWDATA_EMPTY = new TViewData();
    return TVIEWDATA_EMPTY.concat(list);
  }
  var LViewBlueprint = class extends Array {
  };
  var MatchesArray = class extends Array {
  };
  var TViewComponents = class extends Array {
  };
  var TNodeLocalNames = class extends Array {
  };
  var TNodeInitialInputs = class extends Array {
  };
  var LCleanup = class extends Array {
  };
  var TCleanup = class extends Array {
  };
  function attachLViewDebug(lView) {
    attachDebugObject(lView, new LViewDebug(lView));
  }
  function attachLContainerDebug(lContainer) {
    attachDebugObject(lContainer, new LContainerDebug(lContainer));
  }
  function toDebug(obj) {
    if (obj) {
      const debug = obj.debug;
      assertDefined(debug, "Object does not have a debug representation.");
      return debug;
    } else {
      return obj;
    }
  }
  function toHtml(value, includeChildren = false) {
    const node = unwrapRNode(value);
    if (node) {
      switch (node.nodeType) {
        case Node.TEXT_NODE:
          return node.textContent;
        case Node.COMMENT_NODE:
          return `<!--${node.textContent}-->`;
        case Node.ELEMENT_NODE:
          const outerHTML = node.outerHTML;
          if (includeChildren) {
            return outerHTML;
          } else {
            const innerHTML = ">" + node.innerHTML + "<";
            return outerHTML.split(innerHTML)[0] + ">";
          }
      }
    }
    return null;
  }
  var LViewDebug = class {
    constructor(_raw_lView) {
      this._raw_lView = _raw_lView;
    }
    get flags() {
      const flags = this._raw_lView[FLAGS];
      return {
        __raw__flags__: flags,
        initPhaseState: flags & 3,
        creationMode: !!(flags & 4),
        firstViewPass: !!(flags & 8),
        checkAlways: !!(flags & 16),
        dirty: !!(flags & 64),
        attached: !!(flags & 128),
        destroyed: !!(flags & 256),
        isRoot: !!(flags & 512),
        indexWithinInitPhase: flags >> 11
      };
    }
    get parent() {
      return toDebug(this._raw_lView[PARENT]);
    }
    get hostHTML() {
      return toHtml(this._raw_lView[HOST], true);
    }
    get html() {
      return (this.nodes || []).map(mapToHTML).join("");
    }
    get context() {
      return this._raw_lView[CONTEXT];
    }
    get nodes() {
      const lView = this._raw_lView;
      const tNode = lView[TVIEW].firstChild;
      return toDebugNodes(tNode, lView);
    }
    get template() {
      return this.tView.template_;
    }
    get tView() {
      return this._raw_lView[TVIEW];
    }
    get cleanup() {
      return this._raw_lView[CLEANUP];
    }
    get injector() {
      return this._raw_lView[INJECTOR$1];
    }
    get rendererFactory() {
      return this._raw_lView[RENDERER_FACTORY];
    }
    get renderer() {
      return this._raw_lView[RENDERER];
    }
    get sanitizer() {
      return this._raw_lView[SANITIZER];
    }
    get childHead() {
      return toDebug(this._raw_lView[CHILD_HEAD]);
    }
    get next() {
      return toDebug(this._raw_lView[NEXT]);
    }
    get childTail() {
      return toDebug(this._raw_lView[CHILD_TAIL]);
    }
    get declarationView() {
      return toDebug(this._raw_lView[DECLARATION_VIEW]);
    }
    get queries() {
      return this._raw_lView[QUERIES];
    }
    get tHost() {
      return this._raw_lView[T_HOST];
    }
    get decls() {
      return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);
    }
    get vars() {
      return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);
    }
    get expando() {
      return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);
    }
    get childViews() {
      const childViews = [];
      let child = this.childHead;
      while (child) {
        childViews.push(child);
        child = child.next;
      }
      return childViews;
    }
  };
  function mapToHTML(node) {
    if (node.type === "ElementContainer") {
      return (node.children || []).map(mapToHTML).join("");
    } else if (node.type === "IcuContainer") {
      throw new Error("Not implemented");
    } else {
      return toHtml(node.native, true) || "";
    }
  }
  function toLViewRange(tView, lView, start, end) {
    let content = [];
    for (let index = start; index < end; index++) {
      content.push({ index, t: tView.data[index], l: lView[index] });
    }
    return { start, end, length: end - start, content };
  }
  function toDebugNodes(tNode, lView) {
    if (tNode) {
      const debugNodes = [];
      let tNodeCursor = tNode;
      while (tNodeCursor) {
        debugNodes.push(buildDebugNode(tNodeCursor, lView));
        tNodeCursor = tNodeCursor.next;
      }
      return debugNodes;
    } else {
      return [];
    }
  }
  function buildDebugNode(tNode, lView) {
    const rawValue = lView[tNode.index];
    const native = unwrapRNode(rawValue);
    const factories = [];
    const instances = [];
    const tView = lView[TVIEW];
    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
      const def = tView.data[i];
      factories.push(def.type);
      instances.push(lView[i]);
    }
    return {
      html: toHtml(native),
      type: toTNodeTypeAsString(tNode.type),
      tNode,
      native,
      children: toDebugNodes(tNode.child, lView),
      factories,
      instances,
      injector: buildNodeInjectorDebug(tNode, tView, lView),
      get injectorResolutionPath() {
        return tNode.debugNodeInjectorPath(lView);
      }
    };
  }
  function buildNodeInjectorDebug(tNode, tView, lView) {
    const viewProviders = [];
    for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {
      viewProviders.push(tView.data[i]);
    }
    const providers = [];
    for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {
      providers.push(tView.data[i]);
    }
    const nodeInjectorDebug = {
      bloom: toBloom(lView, tNode.injectorIndex),
      cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
      providers,
      viewProviders,
      parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]
    };
    return nodeInjectorDebug;
  }
  function binary(array, idx) {
    const value = array[idx];
    if (typeof value !== "number")
      return "????????";
    const text = "00000000" + value.toString(2);
    return text.substring(text.length - 8);
  }
  function toBloom(array, idx) {
    if (idx < 0) {
      return "NO_NODE_INJECTOR";
    }
    return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;
  }
  var LContainerDebug = class {
    constructor(_raw_lContainer) {
      this._raw_lContainer = _raw_lContainer;
    }
    get hasTransplantedViews() {
      return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];
    }
    get views() {
      return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);
    }
    get parent() {
      return toDebug(this._raw_lContainer[PARENT]);
    }
    get movedViews() {
      return this._raw_lContainer[MOVED_VIEWS];
    }
    get host() {
      return this._raw_lContainer[HOST];
    }
    get native() {
      return this._raw_lContainer[NATIVE];
    }
    get next() {
      return toDebug(this._raw_lContainer[NEXT]);
    }
  };
  var _CLEAN_PROMISE = (() => Promise.resolve(null))();
  function processHostBindingOpCodes(tView, lView) {
    const hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null)
      return;
    try {
      for (let i = 0; i < hostBindingOpCodes.length; i++) {
        const opCode = hostBindingOpCodes[i];
        if (opCode < 0) {
          setSelectedIndex(~opCode);
        } else {
          const directiveIdx = opCode;
          const bindingRootIndx = hostBindingOpCodes[++i];
          const hostBindingFn = hostBindingOpCodes[++i];
          setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
          const context = lView[directiveIdx];
          hostBindingFn(2, context);
        }
      }
    } finally {
      setSelectedIndex(-1);
    }
  }
  function refreshContentQueries(tView, lView) {
    const contentQueries = tView.contentQueries;
    if (contentQueries !== null) {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    }
  }
  function refreshChildComponents(hostLView, components) {
    for (let i = 0; i < components.length; i++) {
      refreshComponent(hostLView, components[i]);
    }
  }
  function renderChildComponents(hostLView, components) {
    for (let i = 0; i < components.length; i++) {
      renderComponent$1(hostLView, components[i]);
    }
  }
  function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector2) {
    const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
    lView[HOST] = host;
    lView[FLAGS] = flags | 4 | 128 | 8;
    resetPreOrderHookFlags(lView);
    ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
    lView[CONTEXT] = context;
    lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY];
    ngDevMode && assertDefined(lView[RENDERER_FACTORY], "RendererFactory is required");
    lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
    ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
    lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;
    lView[INJECTOR$1] = injector2 || parentLView && parentLView[INJECTOR$1] || null;
    lView[T_HOST] = tHostNode;
    ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
    lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
    ngDevMode && attachLViewDebug(lView);
    return lView;
  }
  function getOrCreateTNode(tView, index, type, name, attrs) {
    ngDevMode && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
    ngDevMode && assertPureTNodeType(type);
    let tNode = tView.data[index];
    if (tNode === null) {
      tNode = createTNodeAtIndex(tView, index, type, name, attrs);
      if (isInI18nBlock()) {
        tNode.flags |= 64;
      }
    } else if (tNode.type & 64) {
      tNode.type = type;
      tNode.value = name;
      tNode.attrs = attrs;
      const parent = getCurrentParentTNode();
      tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
      ngDevMode && assertTNodeForTView(tNode, tView);
      ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
    }
    setCurrentTNode(tNode, true);
    return tNode;
  }
  function createTNodeAtIndex(tView, index, type, name, attrs) {
    const currentTNode = getCurrentTNodePlaceholderOk();
    const isParent = isCurrentTNodeParent();
    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
    const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
    if (tView.firstChild === null) {
      tView.firstChild = tNode;
    }
    if (currentTNode !== null) {
      if (isParent) {
        if (currentTNode.child == null && tNode.parent !== null) {
          currentTNode.child = tNode;
        }
      } else {
        if (currentTNode.next === null) {
          currentTNode.next = tNode;
        }
      }
    }
    return tNode;
  }
  function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
    if (numSlotsToAlloc === 0)
      return -1;
    if (ngDevMode) {
      assertFirstCreatePass(tView);
      assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
      assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
      assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
      assertFirstUpdatePass(tView);
    }
    const allocIdx = lView.length;
    for (let i = 0; i < numSlotsToAlloc; i++) {
      lView.push(initialValue);
      tView.blueprint.push(initialValue);
      tView.data.push(null);
    }
    return allocIdx;
  }
  function renderView(tView, lView, context) {
    ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
    enterView(lView);
    try {
      const viewQuery = tView.viewQuery;
      if (viewQuery !== null) {
        executeViewQueryFn(1, viewQuery, context);
      }
      const templateFn = tView.template;
      if (templateFn !== null) {
        executeTemplate(tView, lView, templateFn, 1, context);
      }
      if (tView.firstCreatePass) {
        tView.firstCreatePass = false;
      }
      if (tView.staticContentQueries) {
        refreshContentQueries(tView, lView);
      }
      if (tView.staticViewQueries) {
        executeViewQueryFn(2, tView.viewQuery, context);
      }
      const components = tView.components;
      if (components !== null) {
        renderChildComponents(lView, components);
      }
    } catch (error3) {
      if (tView.firstCreatePass) {
        tView.incompleteFirstPass = true;
        tView.firstCreatePass = false;
      }
      throw error3;
    } finally {
      lView[FLAGS] &= ~4;
      leaveView();
    }
  }
  function refreshView(tView, lView, templateFn, context) {
    ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
    const flags = lView[FLAGS];
    if ((flags & 256) === 256)
      return;
    enterView(lView);
    const isInCheckNoChangesPass = isInCheckNoChangesMode();
    try {
      resetPreOrderHookFlags(lView);
      setBindingIndex(tView.bindingStartIndex);
      if (templateFn !== null) {
        executeTemplate(tView, lView, templateFn, 2, context);
      }
      const hooksInitPhaseCompleted = (flags & 3) === 3;
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const preOrderCheckHooks = tView.preOrderCheckHooks;
          if (preOrderCheckHooks !== null) {
            executeCheckHooks(lView, preOrderCheckHooks, null);
          }
        } else {
          const preOrderHooks = tView.preOrderHooks;
          if (preOrderHooks !== null) {
            executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
          }
          incrementInitPhaseFlags(lView, 0);
        }
      }
      markTransplantedViewsForRefresh(lView);
      refreshEmbeddedViews(lView);
      if (tView.contentQueries !== null) {
        refreshContentQueries(tView, lView);
      }
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const contentCheckHooks = tView.contentCheckHooks;
          if (contentCheckHooks !== null) {
            executeCheckHooks(lView, contentCheckHooks);
          }
        } else {
          const contentHooks = tView.contentHooks;
          if (contentHooks !== null) {
            executeInitAndCheckHooks(lView, contentHooks, 1);
          }
          incrementInitPhaseFlags(lView, 1);
        }
      }
      processHostBindingOpCodes(tView, lView);
      const components = tView.components;
      if (components !== null) {
        refreshChildComponents(lView, components);
      }
      const viewQuery = tView.viewQuery;
      if (viewQuery !== null) {
        executeViewQueryFn(2, viewQuery, context);
      }
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const viewCheckHooks = tView.viewCheckHooks;
          if (viewCheckHooks !== null) {
            executeCheckHooks(lView, viewCheckHooks);
          }
        } else {
          const viewHooks = tView.viewHooks;
          if (viewHooks !== null) {
            executeInitAndCheckHooks(lView, viewHooks, 2);
          }
          incrementInitPhaseFlags(lView, 2);
        }
      }
      if (tView.firstUpdatePass === true) {
        tView.firstUpdatePass = false;
      }
      if (!isInCheckNoChangesPass) {
        lView[FLAGS] &= ~(64 | 8);
      }
      if (lView[FLAGS] & 1024) {
        lView[FLAGS] &= ~1024;
        updateTransplantedViewCount(lView[PARENT], -1);
      }
    } finally {
      leaveView();
    }
  }
  function renderComponentOrTemplate(tView, lView, templateFn, context) {
    const rendererFactory = lView[RENDERER_FACTORY];
    const normalExecutionPath = !isInCheckNoChangesMode();
    const creationModeIsActive = isCreationMode(lView);
    try {
      if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {
        rendererFactory.begin();
      }
      if (creationModeIsActive) {
        renderView(tView, lView, context);
      }
      refreshView(tView, lView, templateFn, context);
    } finally {
      if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {
        rendererFactory.end();
      }
    }
  }
  function executeTemplate(tView, lView, templateFn, rf, context) {
    const prevSelectedIndex = getSelectedIndex();
    const isUpdatePhase = rf & 2;
    try {
      setSelectedIndex(-1);
      if (isUpdatePhase && lView.length > HEADER_OFFSET) {
        selectIndexInternal(tView, lView, HEADER_OFFSET, isInCheckNoChangesMode());
      }
      const preHookType = isUpdatePhase ? 2 : 0;
      profiler(preHookType, context);
      templateFn(rf, context);
    } finally {
      setSelectedIndex(prevSelectedIndex);
      const postHookType = isUpdatePhase ? 3 : 1;
      profiler(postHookType, context);
    }
  }
  function executeContentQueries(tView, tNode, lView) {
    if (isContentQueryHost(tNode)) {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          def.contentQueries(1, lView[directiveIndex], directiveIndex);
        }
      }
    }
  }
  function createDirectivesInstances(tView, lView, tNode) {
    if (!getBindingsEnabled())
      return;
    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
    if ((tNode.flags & 128) === 128) {
      invokeDirectivesHostBindings(tView, lView, tNode);
    }
  }
  function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
      let localIndex = tNode.index + 1;
      for (let i = 0; i < localNames.length; i += 2) {
        const index = localNames[i + 1];
        const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
        viewData[localIndex++] = value;
      }
    }
  }
  function getOrCreateTComponentView(def) {
    const tView = def.tView;
    if (tView === null || tView.incompleteFirstPass) {
      const declTNode = null;
      return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);
    }
    return tView;
  }
  function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {
    ngDevMode && ngDevMode.tView++;
    const bindingStartIndex = HEADER_OFFSET + decls;
    const initialViewLength = bindingStartIndex + vars;
    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
    const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
    const tView = blueprint[TVIEW] = ngDevMode ? new TViewConstructor(type, blueprint, templateFn, null, viewQuery, declTNode, cloneToTViewData(blueprint).fill(null, bindingStartIndex), bindingStartIndex, initialViewLength, null, true, true, false, false, null, null, null, null, null, null, null, null, null, null, typeof directives === "function" ? directives() : directives, typeof pipes === "function" ? pipes() : pipes, null, schemas, consts, false, decls, vars) : {
      type,
      blueprint,
      template: templateFn,
      queries: null,
      viewQuery,
      declTNode,
      data: blueprint.slice().fill(null, bindingStartIndex),
      bindingStartIndex,
      expandoStartIndex: initialViewLength,
      hostBindingOpCodes: null,
      firstCreatePass: true,
      firstUpdatePass: true,
      staticViewQueries: false,
      staticContentQueries: false,
      preOrderHooks: null,
      preOrderCheckHooks: null,
      contentHooks: null,
      contentCheckHooks: null,
      viewHooks: null,
      viewCheckHooks: null,
      destroyHooks: null,
      cleanup: null,
      contentQueries: null,
      components: null,
      directiveRegistry: typeof directives === "function" ? directives() : directives,
      pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
      firstChild: null,
      schemas,
      consts,
      incompleteFirstPass: false
    };
    if (ngDevMode) {
      Object.seal(tView);
    }
    return tView;
  }
  function createViewBlueprint(bindingStartIndex, initialViewLength) {
    const blueprint = ngDevMode ? new LViewBlueprint() : [];
    for (let i = 0; i < initialViewLength; i++) {
      blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
    }
    return blueprint;
  }
  function createError(text, token) {
    return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);
  }
  function assertHostNodeExists(rElement, elementOrSelector) {
    if (!rElement) {
      if (typeof elementOrSelector === "string") {
        throw createError("Host node with selector not found:", elementOrSelector);
      } else {
        throw createError("Host node is required:", elementOrSelector);
      }
    }
  }
  function locateHostElement(renderer, elementOrSelector, encapsulation) {
    if (isProceduralRenderer(renderer)) {
      const preserveContent = encapsulation === ViewEncapsulation$1.ShadowDom;
      return renderer.selectRootElement(elementOrSelector, preserveContent);
    }
    let rElement = typeof elementOrSelector === "string" ? renderer.querySelector(elementOrSelector) : elementOrSelector;
    ngDevMode && assertHostNodeExists(rElement, elementOrSelector);
    rElement.textContent = "";
    return rElement;
  }
  function storeCleanupWithContext(tView, lView, context, cleanupFn) {
    const lCleanup = getOrCreateLViewCleanup(lView);
    if (context === null) {
      if (ngDevMode) {
        Object.freeze(getOrCreateTViewCleanup(tView));
      }
      lCleanup.push(cleanupFn);
    } else {
      lCleanup.push(context);
      if (tView.firstCreatePass) {
        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
      }
    }
  }
  function createTNode(tView, tParent, type, index, value, attrs) {
    ngDevMode && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
    ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
    ngDevMode && ngDevMode.tNode++;
    ngDevMode && tParent && assertTNodeForTView(tParent, tView);
    let injectorIndex = tParent ? tParent.injectorIndex : -1;
    const tNode = ngDevMode ? new TNodeDebug(tView, type, index, null, injectorIndex, -1, -1, -1, null, 0, 0, value, attrs, null, null, void 0, null, null, null, null, null, null, tParent, null, null, null, void 0, null, null, void 0, 0, 0) : {
      type,
      index,
      insertBeforeIndex: null,
      injectorIndex,
      directiveStart: -1,
      directiveEnd: -1,
      directiveStylingLast: -1,
      propertyBindings: null,
      flags: 0,
      providerIndexes: 0,
      value,
      attrs,
      mergedAttrs: null,
      localNames: null,
      initialInputs: void 0,
      inputs: null,
      outputs: null,
      tViews: null,
      next: null,
      projectionNext: null,
      child: null,
      parent: tParent,
      projection: null,
      styles: null,
      stylesWithoutHost: null,
      residualStyles: void 0,
      classes: null,
      classesWithoutHost: null,
      residualClasses: void 0,
      classBindings: 0,
      styleBindings: 0
    };
    if (ngDevMode) {
      Object.seal(tNode);
    }
    return tNode;
  }
  function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
    for (let publicName in inputAliasMap) {
      if (inputAliasMap.hasOwnProperty(publicName)) {
        propStore = propStore === null ? {} : propStore;
        const internalName = inputAliasMap[publicName];
        if (propStore.hasOwnProperty(publicName)) {
          propStore[publicName].push(directiveDefIdx, internalName);
        } else {
          propStore[publicName] = [directiveDefIdx, internalName];
        }
      }
    }
    return propStore;
  }
  function initializeInputAndOutputAliases(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const tViewData = tView.data;
    const tNodeAttrs = tNode.attrs;
    const inputsFromAttrs = ngDevMode ? new TNodeInitialInputs() : [];
    let inputsStore = null;
    let outputsStore = null;
    for (let i = start; i < end; i++) {
      const directiveDef = tViewData[i];
      const directiveInputs = directiveDef.inputs;
      const initialInputs = tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(directiveInputs, tNodeAttrs) : null;
      inputsFromAttrs.push(initialInputs);
      inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);
      outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
    }
    if (inputsStore !== null) {
      if (inputsStore.hasOwnProperty("class")) {
        tNode.flags |= 16;
      }
      if (inputsStore.hasOwnProperty("style")) {
        tNode.flags |= 32;
      }
    }
    tNode.initialInputs = inputsFromAttrs;
    tNode.inputs = inputsStore;
    tNode.outputs = outputsStore;
  }
  function mapPropName(name) {
    if (name === "class")
      return "className";
    if (name === "for")
      return "htmlFor";
    if (name === "formaction")
      return "formAction";
    if (name === "innerHtml")
      return "innerHTML";
    if (name === "readonly")
      return "readOnly";
    if (name === "tabindex")
      return "tabIndex";
    return name;
  }
  function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
    ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    const element2 = getNativeByTNode(tNode, lView);
    let inputData = tNode.inputs;
    let dataValue;
    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
      setInputsForProperty(tView, lView, dataValue, propName, value);
      if (isComponentHost(tNode))
        markDirtyIfOnPush(lView, tNode.index);
      if (ngDevMode) {
        setNgReflectProperties(lView, element2, tNode.type, dataValue, value);
      }
    } else if (tNode.type & 3) {
      propName = mapPropName(propName);
      if (ngDevMode) {
        validateAgainstEventProperties(propName);
        if (!validateProperty(element2, tNode.value, propName, tView.schemas)) {
          logUnknownPropertyError(propName, tNode.value);
          return;
        }
        ngDevMode.rendererSetProperty++;
      }
      value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
      if (isProceduralRenderer(renderer)) {
        renderer.setProperty(element2, propName, value);
      } else if (!isAnimationProp(propName)) {
        element2.setProperty ? element2.setProperty(propName, value) : element2[propName] = value;
      }
    } else if (tNode.type & 12) {
      if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {
        logUnknownPropertyError(propName, tNode.value);
      }
    }
  }
  function markDirtyIfOnPush(lView, viewIndex) {
    ngDevMode && assertLView(lView);
    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
    if (!(childComponentLView[FLAGS] & 16)) {
      childComponentLView[FLAGS] |= 64;
    }
  }
  function setNgReflectProperty(lView, element2, type, attrName, value) {
    const renderer = lView[RENDERER];
    attrName = normalizeDebugBindingName(attrName);
    const debugValue = normalizeDebugBindingValue(value);
    if (type & 3) {
      if (value == null) {
        isProceduralRenderer(renderer) ? renderer.removeAttribute(element2, attrName) : element2.removeAttribute(attrName);
      } else {
        isProceduralRenderer(renderer) ? renderer.setAttribute(element2, attrName, debugValue) : element2.setAttribute(attrName, debugValue);
      }
    } else {
      const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
      if (isProceduralRenderer(renderer)) {
        renderer.setValue(element2, textContent);
      } else {
        element2.textContent = textContent;
      }
    }
  }
  function setNgReflectProperties(lView, element2, type, dataValue, value) {
    if (type & (3 | 4)) {
      for (let i = 0; i < dataValue.length; i += 2) {
        setNgReflectProperty(lView, element2, type, dataValue[i + 1], value);
      }
    }
  }
  function validateProperty(element2, tagName, propName, schemas) {
    if (schemas === null)
      return true;
    if (matchingSchemas(schemas, tagName) || propName in element2 || isAnimationProp(propName)) {
      return true;
    }
    return typeof Node === "undefined" || Node === null || !(element2 instanceof Node);
  }
  function matchingSchemas(schemas, tagName) {
    if (schemas !== null) {
      for (let i = 0; i < schemas.length; i++) {
        const schema = schemas[i];
        if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
          return true;
        }
      }
    }
    return false;
  }
  function logUnknownPropertyError(propName, tagName) {
    const message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'.`;
    console.error(formatRuntimeError(303, message));
  }
  function instantiateRootComponent(tView, lView, def) {
    const rootTNode = getCurrentTNode();
    if (tView.firstCreatePass) {
      if (def.providersResolver)
        def.providersResolver(def);
      const directiveIndex = allocExpando(tView, lView, 1, null);
      ngDevMode && assertEqual(directiveIndex, rootTNode.directiveStart, "Because this is a root component the allocated expando should match the TNode component.");
      configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);
    }
    const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
    attachPatchData(directive, lView);
    const native = getNativeByTNode(rootTNode, lView);
    if (native) {
      attachPatchData(native, lView);
    }
    return directive;
  }
  function resolveDirectives(tView, lView, tNode, localRefs) {
    ngDevMode && assertFirstCreatePass(tView);
    let hasDirectives = false;
    if (getBindingsEnabled()) {
      const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);
      const exportsMap = localRefs === null ? null : { "": -1 };
      if (directiveDefs !== null) {
        hasDirectives = true;
        initTNodeFlags(tNode, tView.data.length, directiveDefs.length);
        for (let i = 0; i < directiveDefs.length; i++) {
          const def = directiveDefs[i];
          if (def.providersResolver)
            def.providersResolver(def);
        }
        let preOrderHooksFound = false;
        let preOrderCheckHooksFound = false;
        let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);
        ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
        for (let i = 0; i < directiveDefs.length; i++) {
          const def = directiveDefs[i];
          tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
          configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
          saveNameToExportMap(directiveIdx, def, exportsMap);
          if (def.contentQueries !== null)
            tNode.flags |= 8;
          if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
            tNode.flags |= 128;
          const lifeCycleHooks = def.type.prototype;
          if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);
            preOrderHooksFound = true;
          }
          if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);
            preOrderCheckHooksFound = true;
          }
          directiveIdx++;
        }
        initializeInputAndOutputAliases(tView, tNode);
      }
      if (exportsMap)
        cacheMatchingLocalNames(tNode, localRefs, exportsMap);
    }
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    return hasDirectives;
  }
  function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
    ngDevMode && assertFirstCreatePass(tView);
    const hostBindings = def.hostBindings;
    if (hostBindings) {
      let hostBindingOpCodes = tView.hostBindingOpCodes;
      if (hostBindingOpCodes === null) {
        hostBindingOpCodes = tView.hostBindingOpCodes = [];
      }
      const elementIndx = ~tNode.index;
      if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
        hostBindingOpCodes.push(elementIndx);
      }
      hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
    }
  }
  function lastSelectedElementIdx(hostBindingOpCodes) {
    let i = hostBindingOpCodes.length;
    while (i > 0) {
      const value = hostBindingOpCodes[--i];
      if (typeof value === "number" && value < 0) {
        return value;
      }
    }
    return 0;
  }
  function instantiateAllDirectives(tView, lView, tNode, native) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    if (!tView.firstCreatePass) {
      getOrCreateNodeInjectorForNode(tNode, lView);
    }
    attachPatchData(native, lView);
    const initialInputs = tNode.initialInputs;
    for (let i = start; i < end; i++) {
      const def = tView.data[i];
      const isComponent = isComponentDef(def);
      if (isComponent) {
        ngDevMode && assertTNodeType(tNode, 3);
        addComponentLogic(lView, tNode, def);
      }
      const directive = getNodeInjectable(lView, tView, i, tNode);
      attachPatchData(directive, lView);
      if (initialInputs !== null) {
        setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
      }
      if (isComponent) {
        const componentView = getComponentLViewByIndex(tNode.index, lView);
        componentView[CONTEXT] = directive;
      }
    }
  }
  function invokeDirectivesHostBindings(tView, lView, tNode) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const firstCreatePass = tView.firstCreatePass;
    const elementIndex = tNode.index;
    const currentDirectiveIndex = getCurrentDirectiveIndex();
    try {
      setSelectedIndex(elementIndex);
      for (let dirIndex = start; dirIndex < end; dirIndex++) {
        const def = tView.data[dirIndex];
        const directive = lView[dirIndex];
        setCurrentDirectiveIndex(dirIndex);
        if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
          invokeHostBindingsInCreationMode(def, directive);
        }
      }
    } finally {
      setSelectedIndex(-1);
      setCurrentDirectiveIndex(currentDirectiveIndex);
    }
  }
  function invokeHostBindingsInCreationMode(def, directive) {
    if (def.hostBindings !== null) {
      def.hostBindings(1, directive);
    }
  }
  function findDirectiveDefMatches(tView, viewData, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    const registry = tView.directiveRegistry;
    let matches = null;
    if (registry) {
      for (let i = 0; i < registry.length; i++) {
        const def = registry[i];
        if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
          matches || (matches = ngDevMode ? new MatchesArray() : []);
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);
          if (isComponentDef(def)) {
            if (ngDevMode) {
              assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
              if (tNode.flags & 2)
                throwMultipleComponentError(tNode);
            }
            markAsComponentHost(tView, tNode);
            matches.unshift(def);
          } else {
            matches.push(def);
          }
        }
      }
    }
    return matches;
  }
  function markAsComponentHost(tView, hostTNode) {
    ngDevMode && assertFirstCreatePass(tView);
    hostTNode.flags |= 2;
    (tView.components || (tView.components = ngDevMode ? new TViewComponents() : [])).push(hostTNode.index);
  }
  function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
    if (localRefs) {
      const localNames = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];
      for (let i = 0; i < localRefs.length; i += 2) {
        const index = exportsMap[localRefs[i + 1]];
        if (index == null)
          throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
        localNames.push(localRefs[i], index);
      }
    }
  }
  function saveNameToExportMap(directiveIdx, def, exportsMap) {
    if (exportsMap) {
      if (def.exportAs) {
        for (let i = 0; i < def.exportAs.length; i++) {
          exportsMap[def.exportAs[i]] = directiveIdx;
        }
      }
      if (isComponentDef(def))
        exportsMap[""] = directiveIdx;
    }
  }
  function initTNodeFlags(tNode, index, numberOfDirectives) {
    ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
    tNode.flags |= 1;
    tNode.directiveStart = index;
    tNode.directiveEnd = index + numberOfDirectives;
    tNode.providerIndexes = index;
  }
  function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
    ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
    tView.data[directiveIndex] = def;
    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
    const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
    tView.blueprint[directiveIndex] = nodeInjectorFactory;
    lView[directiveIndex] = nodeInjectorFactory;
    registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
  }
  function addComponentLogic(lView, hostTNode, def) {
    const native = getNativeByTNode(hostTNode, lView);
    const tView = getOrCreateTComponentView(def);
    const rendererFactory = lView[RENDERER_FACTORY];
    const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64 : 16, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def), null, null));
    lView[hostTNode.index] = componentView;
  }
  function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
    if (ngDevMode) {
      assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
      validateAgainstEventAttributes(name);
      assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
    }
    const element2 = getNativeByTNode(tNode, lView);
    setElementAttribute(lView[RENDERER], element2, namespace, tNode.value, name, value, sanitizer);
  }
  function setElementAttribute(renderer, element2, namespace, tagName, name, value, sanitizer) {
    if (value == null) {
      ngDevMode && ngDevMode.rendererRemoveAttribute++;
      isProceduralRenderer(renderer) ? renderer.removeAttribute(element2, name, namespace) : element2.removeAttribute(name);
    } else {
      ngDevMode && ngDevMode.rendererSetAttribute++;
      const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
      if (isProceduralRenderer(renderer)) {
        renderer.setAttribute(element2, name, strValue, namespace);
      } else {
        namespace ? element2.setAttributeNS(namespace, name, strValue) : element2.setAttribute(name, strValue);
      }
    }
  }
  function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
    const initialInputs = initialInputData[directiveIndex];
    if (initialInputs !== null) {
      const setInput = def.setInput;
      for (let i = 0; i < initialInputs.length; ) {
        const publicName = initialInputs[i++];
        const privateName = initialInputs[i++];
        const value = initialInputs[i++];
        if (setInput !== null) {
          def.setInput(instance, value, publicName, privateName);
        } else {
          instance[privateName] = value;
        }
        if (ngDevMode) {
          const nativeElement = getNativeByTNode(tNode, lView);
          setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
        }
      }
    }
  }
  function generateInitialInputs(inputs, attrs) {
    let inputsToStore = null;
    let i = 0;
    while (i < attrs.length) {
      const attrName = attrs[i];
      if (attrName === 0) {
        i += 4;
        continue;
      } else if (attrName === 5) {
        i += 2;
        continue;
      }
      if (typeof attrName === "number")
        break;
      if (inputs.hasOwnProperty(attrName)) {
        if (inputsToStore === null)
          inputsToStore = [];
        inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);
      }
      i += 2;
    }
    return inputsToStore;
  }
  var LContainerArray = class LContainer extends Array {
  };
  function createLContainer(hostNative, currentView, native, tNode) {
    ngDevMode && assertLView(currentView);
    ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);
    const lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, true, false, currentView, null, 0, tNode, native, null, null);
    ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
    ngDevMode && attachLContainerDebug(lContainer);
    return lContainer;
  }
  function refreshEmbeddedViews(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        const embeddedLView = lContainer[i];
        const embeddedTView = embeddedLView[TVIEW];
        ngDevMode && assertDefined(embeddedTView, "TView must be allocated");
        if (viewAttachedToChangeDetector(embeddedLView)) {
          refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
        }
      }
    }
  }
  function markTransplantedViewsForRefresh(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
      if (!lContainer[HAS_TRANSPLANTED_VIEWS])
        continue;
      const movedViews = lContainer[MOVED_VIEWS];
      ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
      for (let i = 0; i < movedViews.length; i++) {
        const movedLView = movedViews[i];
        const insertionLContainer = movedLView[PARENT];
        ngDevMode && assertLContainer(insertionLContainer);
        if ((movedLView[FLAGS] & 1024) === 0) {
          updateTransplantedViewCount(insertionLContainer, 1);
        }
        movedLView[FLAGS] |= 1024;
      }
    }
  }
  function refreshComponent(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    if (viewAttachedToChangeDetector(componentView)) {
      const tView = componentView[TVIEW];
      if (componentView[FLAGS] & (16 | 64)) {
        refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
      } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
        refreshContainsDirtyView(componentView);
      }
    }
  }
  function refreshContainsDirtyView(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        const embeddedLView = lContainer[i];
        if (embeddedLView[FLAGS] & 1024) {
          const embeddedTView = embeddedLView[TVIEW];
          ngDevMode && assertDefined(embeddedTView, "TView must be allocated");
          refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
        } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
          refreshContainsDirtyView(embeddedLView);
        }
      }
    }
    const tView = lView[TVIEW];
    const components = tView.components;
    if (components !== null) {
      for (let i = 0; i < components.length; i++) {
        const componentView = getComponentLViewByIndex(components[i], lView);
        if (viewAttachedToChangeDetector(componentView) && componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
          refreshContainsDirtyView(componentView);
        }
      }
    }
  }
  function renderComponent$1(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    const componentTView = componentView[TVIEW];
    syncViewWithBlueprint(componentTView, componentView);
    renderView(componentTView, componentView, componentView[CONTEXT]);
  }
  function syncViewWithBlueprint(tView, lView) {
    for (let i = lView.length; i < tView.blueprint.length; i++) {
      lView.push(tView.blueprint[i]);
    }
  }
  function addToViewTree(lView, lViewOrLContainer) {
    if (lView[CHILD_HEAD]) {
      lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
    } else {
      lView[CHILD_HEAD] = lViewOrLContainer;
    }
    lView[CHILD_TAIL] = lViewOrLContainer;
    return lViewOrLContainer;
  }
  function markViewDirty(lView) {
    while (lView) {
      lView[FLAGS] |= 64;
      const parent = getLViewParent(lView);
      if (isRootView(lView) && !parent) {
        return lView;
      }
      lView = parent;
    }
    return null;
  }
  function scheduleTick(rootContext, flags) {
    const nothingScheduled = rootContext.flags === 0;
    if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {
      rootContext.flags |= flags;
      let res;
      rootContext.clean = new Promise((r) => res = r);
      rootContext.scheduler(() => {
        if (rootContext.flags & 1) {
          rootContext.flags &= ~1;
          tickRootContext(rootContext);
        }
        if (rootContext.flags & 2) {
          rootContext.flags &= ~2;
          const playerHandler = rootContext.playerHandler;
          if (playerHandler) {
            playerHandler.flushPlayers();
          }
        }
        rootContext.clean = _CLEAN_PROMISE;
        res(null);
      });
    }
  }
  function tickRootContext(rootContext) {
    for (let i = 0; i < rootContext.components.length; i++) {
      const rootComponent = rootContext.components[i];
      const lView = readPatchedLView(rootComponent);
      const tView = lView[TVIEW];
      renderComponentOrTemplate(tView, lView, tView.template, rootComponent);
    }
  }
  function detectChangesInternal(tView, lView, context) {
    const rendererFactory = lView[RENDERER_FACTORY];
    if (rendererFactory.begin)
      rendererFactory.begin();
    try {
      refreshView(tView, lView, tView.template, context);
    } catch (error3) {
      handleError(lView, error3);
      throw error3;
    } finally {
      if (rendererFactory.end)
        rendererFactory.end();
    }
  }
  function detectChangesInRootView(lView) {
    tickRootContext(lView[CONTEXT]);
  }
  function checkNoChangesInternal(tView, view, context) {
    setIsInCheckNoChangesMode(true);
    try {
      detectChangesInternal(tView, view, context);
    } finally {
      setIsInCheckNoChangesMode(false);
    }
  }
  function checkNoChangesInRootView(lView) {
    setIsInCheckNoChangesMode(true);
    try {
      detectChangesInRootView(lView);
    } finally {
      setIsInCheckNoChangesMode(false);
    }
  }
  function executeViewQueryFn(flags, viewQueryFn, component) {
    ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
    setCurrentQueryIndex(0);
    viewQueryFn(flags, component);
  }
  function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
    if (tData[bindingIndex] === null) {
      if (tNode.inputs == null || !tNode.inputs[propertyName]) {
        const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
        propBindingIdxs.push(bindingIndex);
        let bindingMetadata = propertyName;
        if (interpolationParts.length > 0) {
          bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
        }
        tData[bindingIndex] = bindingMetadata;
      }
    }
  }
  var CLEAN_PROMISE = _CLEAN_PROMISE;
  function getOrCreateLViewCleanup(view) {
    return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);
  }
  function getOrCreateTViewCleanup(tView) {
    return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);
  }
  function loadComponentRenderer(currentDef, tNode, lView) {
    if (currentDef === null || isComponentDef(currentDef)) {
      lView = unwrapLView(lView[tNode.index]);
    }
    return lView[RENDERER];
  }
  function handleError(lView, error3) {
    const injector2 = lView[INJECTOR$1];
    const errorHandler = injector2 ? injector2.get(ErrorHandler, null) : null;
    errorHandler && errorHandler.handleError(error3);
  }
  function setInputsForProperty(tView, lView, inputs, publicName, value) {
    for (let i = 0; i < inputs.length; ) {
      const index = inputs[i++];
      const privateName = inputs[i++];
      const instance = lView[index];
      ngDevMode && assertIndexInRange(lView, index);
      const def = tView.data[index];
      if (def.setInput !== null) {
        def.setInput(instance, value, publicName, privateName);
      } else {
        instance[privateName] = value;
      }
    }
  }
  function textBindingInternal(lView, index, value) {
    ngDevMode && assertString(value, "Value should be a string");
    ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
    ngDevMode && assertIndexInRange(lView, index);
    const element2 = getNativeByIndex(index, lView);
    ngDevMode && assertDefined(element2, "native element should exist");
    updateTextNode(lView[RENDERER], element2, value);
  }
  function computeStaticStyling(tNode, attrs, writeToHost) {
    ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
    let styles = writeToHost ? tNode.styles : null;
    let classes = writeToHost ? tNode.classes : null;
    let mode = 0;
    if (attrs !== null) {
      for (let i = 0; i < attrs.length; i++) {
        const value = attrs[i];
        if (typeof value === "number") {
          mode = value;
        } else if (mode == 1) {
          classes = concatStringsWithSpace(classes, value);
        } else if (mode == 2) {
          const style = value;
          const styleValue = attrs[++i];
          styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
        }
      }
    }
    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
  }
  function detectChanges(component) {
    const view = getComponentViewByInstance(component);
    detectChangesInternal(view[TVIEW], view, component);
  }
  function markDirty(component) {
    ngDevMode && assertDefined(component, "component");
    const rootView = markViewDirty(getComponentViewByInstance(component));
    ngDevMode && assertDefined(rootView[CONTEXT], "rootContext should be defined");
    scheduleTick(rootView[CONTEXT], 1);
  }
  var INJECTOR = new InjectionToken("INJECTOR", -1);
  var NullInjector = class {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
      if (notFoundValue === THROW_IF_NOT_FOUND) {
        const error3 = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
        error3.name = "NullInjectorError";
        throw error3;
      }
      return notFoundValue;
    }
  };
  var INJECTOR_SCOPE = new InjectionToken("Set Injector scope.");
  var NOT_YET = {};
  var CIRCULAR = {};
  var NULL_INJECTOR$1 = void 0;
  function getNullInjector() {
    if (NULL_INJECTOR$1 === void 0) {
      NULL_INJECTOR$1 = new NullInjector();
    }
    return NULL_INJECTOR$1;
  }
  function createInjector(defType, parent = null, additionalProviders = null, name) {
    const injector2 = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
    injector2._resolveInjectorDefTypes();
    return injector2;
  }
  function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name) {
    return new R3Injector(defType, additionalProviders, parent || getNullInjector(), name);
  }
  var R3Injector = class {
    constructor(def, additionalProviders, parent, source = null) {
      this.parent = parent;
      this.records = /* @__PURE__ */ new Map();
      this.injectorDefTypes = /* @__PURE__ */ new Set();
      this.onDestroy = /* @__PURE__ */ new Set();
      this._destroyed = false;
      const dedupStack = [];
      additionalProviders && deepForEach(additionalProviders, (provider) => this.processProvider(provider, def, additionalProviders));
      deepForEach([def], (injectorDef) => this.processInjectorType(injectorDef, [], dedupStack));
      this.records.set(INJECTOR, makeRecord(void 0, this));
      const record = this.records.get(INJECTOR_SCOPE);
      this.scope = record != null ? record.value : null;
      this.source = source || (typeof def === "object" ? null : stringify(def));
    }
    get destroyed() {
      return this._destroyed;
    }
    destroy() {
      this.assertNotDestroyed();
      this._destroyed = true;
      try {
        this.onDestroy.forEach((service) => service.ngOnDestroy());
      } finally {
        this.records.clear();
        this.onDestroy.clear();
        this.injectorDefTypes.clear();
      }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      this.assertNotDestroyed();
      const previousInjector = setCurrentInjector(this);
      const previousInjectImplementation = setInjectImplementation(void 0);
      try {
        if (!(flags & InjectFlags.SkipSelf)) {
          let record = this.records.get(token);
          if (record === void 0) {
            const def = couldBeInjectableType(token) && getInjectableDef(token);
            if (def && this.injectableDefInScope(def)) {
              record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
            } else {
              record = null;
            }
            this.records.set(token, record);
          }
          if (record != null) {
            return this.hydrate(token, record);
          }
        }
        const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
        notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
        return nextInjector.get(token, notFoundValue);
      } catch (e) {
        if (e.name === "NullInjectorError") {
          const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
          path.unshift(stringify(token));
          if (previousInjector) {
            throw e;
          } else {
            return catchInjectorError(e, token, "R3InjectorError", this.source);
          }
        } else {
          throw e;
        }
      } finally {
        setInjectImplementation(previousInjectImplementation);
        setCurrentInjector(previousInjector);
      }
    }
    _resolveInjectorDefTypes() {
      this.injectorDefTypes.forEach((defType) => this.get(defType));
    }
    toString() {
      const tokens = [], records = this.records;
      records.forEach((v, token) => tokens.push(stringify(token)));
      return `R3Injector[${tokens.join(", ")}]`;
    }
    assertNotDestroyed() {
      if (this._destroyed) {
        throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
      }
    }
    processInjectorType(defOrWrappedDef, parents, dedupStack) {
      defOrWrappedDef = resolveForwardRef(defOrWrappedDef);
      if (!defOrWrappedDef)
        return false;
      let def = getInjectorDef(defOrWrappedDef);
      const ngModule = def == null && defOrWrappedDef.ngModule || void 0;
      const defType = ngModule === void 0 ? defOrWrappedDef : ngModule;
      if (ngDevMode && parents.indexOf(defType) !== -1) {
        const defName = stringify(defType);
        const path = parents.map(stringify);
        throwCyclicDependencyError(defName, path);
      }
      const isDuplicate = dedupStack.indexOf(defType) !== -1;
      if (ngModule !== void 0) {
        def = getInjectorDef(ngModule);
      }
      if (def == null) {
        return false;
      }
      if (def.imports != null && !isDuplicate) {
        ngDevMode && parents.push(defType);
        dedupStack.push(defType);
        let importTypesWithProviders;
        try {
          deepForEach(def.imports, (imported) => {
            if (this.processInjectorType(imported, parents, dedupStack)) {
              if (importTypesWithProviders === void 0)
                importTypesWithProviders = [];
              importTypesWithProviders.push(imported);
            }
          });
        } finally {
          ngDevMode && parents.pop();
        }
        if (importTypesWithProviders !== void 0) {
          for (let i = 0; i < importTypesWithProviders.length; i++) {
            const { ngModule: ngModule2, providers } = importTypesWithProviders[i];
            deepForEach(providers, (provider) => this.processProvider(provider, ngModule2, providers || EMPTY_ARRAY));
          }
        }
      }
      this.injectorDefTypes.add(defType);
      const factory = getFactoryDef(defType) || (() => new defType());
      this.records.set(defType, makeRecord(factory, NOT_YET));
      const defProviders = def.providers;
      if (defProviders != null && !isDuplicate) {
        const injectorType = defOrWrappedDef;
        deepForEach(defProviders, (provider) => this.processProvider(provider, injectorType, defProviders));
      }
      return ngModule !== void 0 && defOrWrappedDef.providers !== void 0;
    }
    processProvider(provider, ngModuleType, providers) {
      provider = resolveForwardRef(provider);
      let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
      const record = providerToRecord(provider, ngModuleType, providers);
      if (!isTypeProvider(provider) && provider.multi === true) {
        let multiRecord = this.records.get(token);
        if (multiRecord) {
          if (ngDevMode && multiRecord.multi === void 0) {
            throwMixedMultiProviderError();
          }
        } else {
          multiRecord = makeRecord(void 0, NOT_YET, true);
          multiRecord.factory = () => injectArgs(multiRecord.multi);
          this.records.set(token, multiRecord);
        }
        token = provider;
        multiRecord.multi.push(provider);
      } else {
        const existing = this.records.get(token);
        if (ngDevMode && existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
      this.records.set(token, record);
    }
    hydrate(token, record) {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        record.value = record.factory();
      }
      if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
        this.onDestroy.add(record.value);
      }
      return record.value;
    }
    injectableDefInScope(def) {
      if (!def.providedIn) {
        return false;
      }
      const providedIn = resolveForwardRef(def.providedIn);
      if (typeof providedIn === "string") {
        return providedIn === "any" || providedIn === this.scope;
      } else {
        return this.injectorDefTypes.has(providedIn);
      }
    }
  };
  function injectableDefOrInjectorDefFactory(token) {
    const injectableDef = getInjectableDef(token);
    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
    if (factory !== null) {
      return factory;
    }
    if (token instanceof InjectionToken) {
      throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);
    }
    if (token instanceof Function) {
      return getUndecoratedInjectableFactory(token);
    }
    throw new RuntimeError(204, ngDevMode && "unreachable");
  }
  function getUndecoratedInjectableFactory(token) {
    const paramLength = token.length;
    if (paramLength > 0) {
      const args = newArray(paramLength, "?");
      throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`);
    }
    const inheritedInjectableDef = getInheritedInjectableDef(token);
    if (inheritedInjectableDef !== null) {
      return () => inheritedInjectableDef.factory(token);
    } else {
      return () => new token();
    }
  }
  function providerToRecord(provider, ngModuleType, providers) {
    if (isValueProvider(provider)) {
      return makeRecord(void 0, provider.useValue);
    } else {
      const factory = providerToFactory(provider, ngModuleType, providers);
      return makeRecord(factory, NOT_YET);
    }
  }
  function providerToFactory(provider, ngModuleType, providers) {
    let factory = void 0;
    if (isTypeProvider(provider)) {
      const unwrappedProvider = resolveForwardRef(provider);
      return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
    } else {
      if (isValueProvider(provider)) {
        factory = () => resolveForwardRef(provider.useValue);
      } else if (isFactoryProvider(provider)) {
        factory = () => provider.useFactory(...injectArgs(provider.deps || []));
      } else if (isExistingProvider(provider)) {
        factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
      } else {
        const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
        if (ngDevMode && !classRef) {
          throwInvalidProviderError(ngModuleType, providers, provider);
        }
        if (hasDeps(provider)) {
          factory = () => new classRef(...injectArgs(provider.deps));
        } else {
          return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
        }
      }
    }
    return factory;
  }
  function makeRecord(factory, value, multi = false) {
    return {
      factory,
      value,
      multi: multi ? [] : void 0
    };
  }
  function isValueProvider(value) {
    return value !== null && typeof value == "object" && USE_VALUE$1 in value;
  }
  function isExistingProvider(value) {
    return !!(value && value.useExisting);
  }
  function isFactoryProvider(value) {
    return !!(value && value.useFactory);
  }
  function isTypeProvider(value) {
    return typeof value === "function";
  }
  function isClassProvider(value) {
    return !!value.useClass;
  }
  function hasDeps(value) {
    return !!value.deps;
  }
  function hasOnDestroy(value) {
    return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
  }
  function couldBeInjectableType(value) {
    return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
  }
  var Injector = class {
    static create(options, parent) {
      if (Array.isArray(options)) {
        return createInjector({ name: "" }, parent, options, "");
      } else {
        const name = options.name ?? "";
        return createInjector({ name }, options.parent, options.providers, name);
      }
    }
  };
  Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  Injector.NULL = /* @__PURE__ */ new NullInjector();
  Injector.\u0275prov = \u0275\u0275defineInjectable({
    token: Injector,
    providedIn: "any",
    factory: () => \u0275\u0275inject(INJECTOR)
  });
  Injector.__NG_ELEMENT_ID__ = -1;
  function getComponent$1(element2) {
    assertDomElement(element2);
    const context = getLContext(element2);
    if (context === null)
      return null;
    if (context.component === void 0) {
      context.component = getComponentAtNodeIndex(context.nodeIndex, context.lView);
    }
    return context.component;
  }
  function getContext(element2) {
    assertDomElement(element2);
    const context = getLContext(element2);
    return context === null ? null : context.lView[CONTEXT];
  }
  function getOwningComponent(elementOrDir) {
    const context = getLContext(elementOrDir);
    if (context === null)
      return null;
    let lView = context.lView;
    let parent;
    ngDevMode && assertLView(lView);
    while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
      lView = parent;
    }
    return lView[FLAGS] & 512 ? null : lView[CONTEXT];
  }
  function getRootComponents(elementOrDir) {
    return [...getRootContext(elementOrDir).components];
  }
  function getInjector(elementOrDir) {
    const context = getLContext(elementOrDir);
    if (context === null)
      return Injector.NULL;
    const tNode = context.lView[TVIEW].data[context.nodeIndex];
    return new NodeInjector(tNode, context.lView);
  }
  function getInjectionTokens(element2) {
    const context = getLContext(element2);
    if (context === null)
      return [];
    const lView = context.lView;
    const tView = lView[TVIEW];
    const tNode = tView.data[context.nodeIndex];
    const providerTokens = [];
    const startIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveEnd;
    for (let i = startIndex; i < endIndex; i++) {
      let value = tView.data[i];
      if (isDirectiveDefHack(value)) {
        value = value.type;
      }
      providerTokens.push(value);
    }
    return providerTokens;
  }
  function getDirectives(node) {
    if (node instanceof Text) {
      return [];
    }
    const context = getLContext(node);
    if (context === null) {
      return [];
    }
    const lView = context.lView;
    const tView = lView[TVIEW];
    const nodeIndex = context.nodeIndex;
    if (!tView?.data[nodeIndex]) {
      return [];
    }
    if (context.directives === void 0) {
      context.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
    }
    return context.directives === null ? [] : [...context.directives];
  }
  function getDirectiveMetadata$1(directiveOrComponentInstance) {
    const { constructor } = directiveOrComponentInstance;
    if (!constructor) {
      throw new Error("Unable to find the instance constructor");
    }
    const componentDef = getComponentDef(constructor);
    if (componentDef) {
      return {
        inputs: componentDef.inputs,
        outputs: componentDef.outputs,
        encapsulation: componentDef.encapsulation,
        changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
      };
    }
    const directiveDef = getDirectiveDef(constructor);
    if (directiveDef) {
      return { inputs: directiveDef.inputs, outputs: directiveDef.outputs };
    }
    return null;
  }
  function getLocalRefs(target) {
    const context = getLContext(target);
    if (context === null)
      return {};
    if (context.localRefs === void 0) {
      context.localRefs = discoverLocalRefs(context.lView, context.nodeIndex);
    }
    return context.localRefs || {};
  }
  function getHostElement(componentOrDirective) {
    return getLContext(componentOrDirective).native;
  }
  function getListeners(element2) {
    assertDomElement(element2);
    const lContext = getLContext(element2);
    if (lContext === null)
      return [];
    const lView = lContext.lView;
    const tView = lView[TVIEW];
    const lCleanup = lView[CLEANUP];
    const tCleanup = tView.cleanup;
    const listeners = [];
    if (tCleanup && lCleanup) {
      for (let i = 0; i < tCleanup.length; ) {
        const firstParam = tCleanup[i++];
        const secondParam = tCleanup[i++];
        if (typeof firstParam === "string") {
          const name = firstParam;
          const listenerElement = unwrapRNode(lView[secondParam]);
          const callback = lCleanup[tCleanup[i++]];
          const useCaptureOrIndx = tCleanup[i++];
          const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
          const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
          if (element2 == listenerElement) {
            listeners.push({ element: element2, name, callback, useCapture, type });
          }
        }
      }
    }
    listeners.sort(sortListeners);
    return listeners;
  }
  function sortListeners(a, b) {
    if (a.name == b.name)
      return 0;
    return a.name < b.name ? -1 : 1;
  }
  function isDirectiveDefHack(obj) {
    return obj.type !== void 0 && obj.template !== void 0 && obj.declaredInputs !== void 0;
  }
  function assertDomElement(value) {
    if (typeof Element !== "undefined" && !(value instanceof Element)) {
      throw new Error("Expecting instance of DOM Element");
    }
  }
  function applyChanges(component) {
    markDirty(component);
    getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
  }
  var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
  var _published = false;
  function publishDefaultGlobalUtils$1() {
    if (!_published) {
      _published = true;
      publishGlobalUtil("\u0275setProfiler", setProfiler);
      publishGlobalUtil("getDirectiveMetadata", getDirectiveMetadata$1);
      publishGlobalUtil("getComponent", getComponent$1);
      publishGlobalUtil("getContext", getContext);
      publishGlobalUtil("getListeners", getListeners);
      publishGlobalUtil("getOwningComponent", getOwningComponent);
      publishGlobalUtil("getHostElement", getHostElement);
      publishGlobalUtil("getInjector", getInjector);
      publishGlobalUtil("getRootComponents", getRootComponents);
      publishGlobalUtil("getDirectives", getDirectives);
      publishGlobalUtil("applyChanges", applyChanges);
    }
  }
  function publishGlobalUtil(name, fn2) {
    if (typeof COMPILED === "undefined" || !COMPILED) {
      const w = _global2;
      ngDevMode && assertDefined(fn2, "function not defined");
      if (w) {
        let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];
        if (!container) {
          container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
        }
        container[name] = fn2;
      }
    }
  }
  function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
    const tView = rootView[TVIEW];
    const index = HEADER_OFFSET;
    ngDevMode && assertIndexInRange(rootView, index);
    rootView[index] = rNode;
    const tNode = getOrCreateTNode(tView, index, 2, "#host", null);
    const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
    if (mergedAttrs !== null) {
      computeStaticStyling(tNode, mergedAttrs, true);
      if (rNode !== null) {
        setUpAttributes(hostRenderer, rNode, mergedAttrs);
        if (tNode.classes !== null) {
          writeDirectClass(hostRenderer, rNode, tNode.classes);
        }
        if (tNode.styles !== null) {
          writeDirectStyle(hostRenderer, rNode, tNode.styles);
        }
      }
    }
    const viewRenderer = rendererFactory.createRenderer(rNode, def);
    const componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 : 16, rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null);
    if (tView.firstCreatePass) {
      diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
      markAsComponentHost(tView, tNode);
      initTNodeFlags(tNode, rootView.length, 1);
    }
    addToViewTree(rootView, componentView);
    return rootView[index] = componentView;
  }
  function createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {
    const tView = rootLView[TVIEW];
    const component = instantiateRootComponent(tView, rootLView, componentDef);
    rootContext.components.push(component);
    componentView[CONTEXT] = component;
    hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));
    if (componentDef.contentQueries) {
      const tNode = getCurrentTNode();
      ngDevMode && assertDefined(tNode, "TNode expected");
      componentDef.contentQueries(1, component, tNode.directiveStart);
    }
    const rootTNode = getCurrentTNode();
    ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
    if (tView.firstCreatePass && (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {
      setSelectedIndex(rootTNode.index);
      const rootTView = rootLView[TVIEW];
      registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);
      invokeHostBindingsInCreationMode(componentDef, component);
    }
    return component;
  }
  function createRootContext(scheduler, playerHandler) {
    return {
      components: [],
      scheduler: scheduler || defaultScheduler,
      clean: CLEAN_PROMISE,
      playerHandler: playerHandler || null,
      flags: 0
    };
  }
  function LifecycleHooksFeature(component, def) {
    const lView = readPatchedLView(component);
    ngDevMode && assertDefined(lView, "LView is required");
    const tView = lView[TVIEW];
    const tNode = getCurrentTNode();
    ngDevMode && assertDefined(tNode, "TNode is required");
    registerPostOrderHooks(tView, tNode);
  }
  function getSuperType(type) {
    return Object.getPrototypeOf(type.prototype).constructor;
  }
  function \u0275\u0275InheritDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let shouldInheritFields = true;
    const inheritanceChain = [definition];
    while (superType) {
      let superDef = void 0;
      if (isComponentDef(definition)) {
        superDef = superType.\u0275cmp || superType.\u0275dir;
      } else {
        if (superType.\u0275cmp) {
          const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "Directives cannot inherit Components" : "";
          throw new RuntimeError(903, errorMessage);
        }
        superDef = superType.\u0275dir;
      }
      if (superDef) {
        if (shouldInheritFields) {
          inheritanceChain.push(superDef);
          const writeableDef = definition;
          writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
          writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
          writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
          const superHostBindings = superDef.hostBindings;
          superHostBindings && inheritHostBindings(definition, superHostBindings);
          const superViewQuery = superDef.viewQuery;
          const superContentQueries = superDef.contentQueries;
          superViewQuery && inheritViewQuery(definition, superViewQuery);
          superContentQueries && inheritContentQueries(definition, superContentQueries);
          fillProperties(definition.inputs, superDef.inputs);
          fillProperties(definition.declaredInputs, superDef.declaredInputs);
          fillProperties(definition.outputs, superDef.outputs);
          if (isComponentDef(superDef) && superDef.data.animation) {
            const defData = definition.data;
            defData.animation = (defData.animation || []).concat(superDef.data.animation);
          }
        }
        const features = superDef.features;
        if (features) {
          for (let i = 0; i < features.length; i++) {
            const feature = features[i];
            if (feature && feature.ngInherit) {
              feature(definition);
            }
            if (feature === \u0275\u0275InheritDefinitionFeature) {
              shouldInheritFields = false;
            }
          }
        }
      }
      superType = Object.getPrototypeOf(superType);
    }
    mergeHostAttrsAcrossInheritance(inheritanceChain);
  }
  function mergeHostAttrsAcrossInheritance(inheritanceChain) {
    let hostVars = 0;
    let hostAttrs = null;
    for (let i = inheritanceChain.length - 1; i >= 0; i--) {
      const def = inheritanceChain[i];
      def.hostVars = hostVars += def.hostVars;
      def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
    }
  }
  function maybeUnwrapEmpty(value) {
    if (value === EMPTY_OBJ) {
      return {};
    } else if (value === EMPTY_ARRAY) {
      return [];
    } else {
      return value;
    }
  }
  function inheritViewQuery(definition, superViewQuery) {
    const prevViewQuery = definition.viewQuery;
    if (prevViewQuery) {
      definition.viewQuery = (rf, ctx) => {
        superViewQuery(rf, ctx);
        prevViewQuery(rf, ctx);
      };
    } else {
      definition.viewQuery = superViewQuery;
    }
  }
  function inheritContentQueries(definition, superContentQueries) {
    const prevContentQueries = definition.contentQueries;
    if (prevContentQueries) {
      definition.contentQueries = (rf, ctx, directiveIndex) => {
        superContentQueries(rf, ctx, directiveIndex);
        prevContentQueries(rf, ctx, directiveIndex);
      };
    } else {
      definition.contentQueries = superContentQueries;
    }
  }
  function inheritHostBindings(definition, superHostBindings) {
    const prevHostBindings = definition.hostBindings;
    if (prevHostBindings) {
      definition.hostBindings = (rf, ctx) => {
        superHostBindings(rf, ctx);
        prevHostBindings(rf, ctx);
      };
    } else {
      definition.hostBindings = superHostBindings;
    }
  }
  var COPY_DIRECTIVE_FIELDS = [
    "providersResolver"
  ];
  var COPY_COMPONENT_FIELDS = [
    "template",
    "decls",
    "consts",
    "vars",
    "onPush",
    "ngContentSelectors",
    "styles",
    "encapsulation",
    "schemas"
  ];
  function \u0275\u0275CopyDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp;
    } else {
      superDef = superType.\u0275dir;
    }
    const defAny = definition;
    for (const field of COPY_DIRECTIVE_FIELDS) {
      defAny[field] = superDef[field];
    }
    if (isComponentDef(superDef)) {
      for (const field of COPY_COMPONENT_FIELDS) {
        defAny[field] = superDef[field];
      }
    }
  }
  var _symbolIterator = null;
  function getSymbolIterator2() {
    if (!_symbolIterator) {
      const Symbol2 = _global2["Symbol"];
      if (Symbol2 && Symbol2.iterator) {
        _symbolIterator = Symbol2.iterator;
      } else {
        const keys = Object.getOwnPropertyNames(Map.prototype);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          if (key !== "entries" && key !== "size" && Map.prototype[key] === Map.prototype["entries"]) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  function devModeEqual(a, b) {
    const isListLikeIterableA = isListLikeIterable(a);
    const isListLikeIterableB = isListLikeIterable(b);
    if (isListLikeIterableA && isListLikeIterableB) {
      return areIterablesEqual(a, b, devModeEqual);
    } else {
      const isAObject = a && (typeof a === "object" || typeof a === "function");
      const isBObject = b && (typeof b === "object" || typeof b === "function");
      if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
        return true;
      } else {
        return Object.is(a, b);
      }
    }
  }
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator2() in obj;
  }
  function areIterablesEqual(a, b, comparator) {
    const iterator1 = a[getSymbolIterator2()]();
    const iterator2 = b[getSymbolIterator2()]();
    while (true) {
      const item1 = iterator1.next();
      const item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  function iterateListLike(obj, fn2) {
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn2(obj[i]);
      }
    } else {
      const iterator2 = obj[getSymbolIterator2()]();
      let item;
      while (!(item = iterator2.next()).done) {
        fn2(item.value);
      }
    }
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function updateBinding(lView, bindingIndex, value) {
    return lView[bindingIndex] = value;
  }
  function getBinding(lView, bindingIndex) {
    ngDevMode && assertIndexInRange(lView, bindingIndex);
    ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
    return lView[bindingIndex];
  }
  function bindingUpdated(lView, bindingIndex, value) {
    ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
    const oldValue = lView[bindingIndex];
    if (Object.is(oldValue, value)) {
      return false;
    } else {
      if (ngDevMode && isInCheckNoChangesMode()) {
        const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
        if (!devModeEqual(oldValueToCompare, value)) {
          const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
          throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);
        }
        return false;
      }
      lView[bindingIndex] = value;
      return true;
    }
  }
  function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
    const different = bindingUpdated(lView, bindingIndex, exp1);
    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
  }
  function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
  }
  function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
  }
  function \u0275\u0275attribute(name, value, sanitizer, namespace) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
    }
    return \u0275\u0275attribute;
  }
  function interpolationV(lView, values) {
    ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
    ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
    let isBindingUpdated = false;
    let bindingIndex = getBindingIndex();
    for (let i = 1; i < values.length; i += 2) {
      isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
    }
    setBindingIndex(bindingIndex);
    if (!isBindingUpdated) {
      return NO_CHANGE;
    }
    let content = values[0];
    for (let i = 1; i < values.length; i += 2) {
      content += renderStringify(values[i]) + values[i + 1];
    }
    return content;
  }
  function interpolation1(lView, prefix, v0, suffix) {
    const different = bindingUpdated(lView, nextBindingIndex(), v0);
    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
  }
  function interpolation2(lView, prefix, v0, i0, v1, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated2(lView, bindingIndex, v0, v1);
    incrementBindingIndex(2);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
  }
  function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
    incrementBindingIndex(3);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
  }
  function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    incrementBindingIndex(4);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
  }
  function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
    incrementBindingIndex(5);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
  }
  function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
    incrementBindingIndex(6);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
  }
  function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
    incrementBindingIndex(7);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
  }
  function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
    incrementBindingIndex(8);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
  }
  function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
    }
    return \u0275\u0275attributeInterpolate1;
  }
  function \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
    }
    return \u0275\u0275attributeInterpolate2;
  }
  function \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
    }
    return \u0275\u0275attributeInterpolate3;
  }
  function \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
    }
    return \u0275\u0275attributeInterpolate4;
  }
  function \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
    }
    return \u0275\u0275attributeInterpolate5;
  }
  function \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
    }
    return \u0275\u0275attributeInterpolate6;
  }
  function \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
    }
    return \u0275\u0275attributeInterpolate7;
  }
  function \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
    }
    return \u0275\u0275attributeInterpolate8;
  }
  function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
      if (ngDevMode) {
        const interpolationInBetween = [values[0]];
        for (let i = 2; i < values.length; i += 2) {
          interpolationInBetween.push(values[i]);
        }
        storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
      }
    }
    return \u0275\u0275attributeInterpolateV;
  }
  function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const tNode = getOrCreateTNode(tView, index, 4, tagName || null, getConstant(tViewConsts, attrsIndex));
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    registerPostOrderHooks(tView, tNode);
    const embeddedTView = tNode.tViews = createTView(2, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);
    if (tView.queries !== null) {
      tView.queries.template(tView, tNode);
      embeddedTView.queries = tView.queries.embeddedTView(tNode);
    }
    return tNode;
  }
  function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, false);
    const comment = lView[RENDERER].createComment(ngDevMode ? "container" : "");
    appendChild(tView, lView, comment, tNode);
    attachPatchData(comment, lView);
    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
    }
    if (localRefsIndex != null) {
      saveResolvedLocalsInData(lView, tNode, localRefExtractor);
    }
  }
  function store(tView, lView, index, value) {
    if (index >= tView.data.length) {
      tView.data[index] = null;
      tView.blueprint[index] = null;
    }
    lView[index] = value;
  }
  function \u0275\u0275reference(index) {
    const contextLView = getContextLView();
    return load(contextLView, HEADER_OFFSET + index);
  }
  var angularCoreDiEnv = {
    "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
    "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
    "\u0275\u0275inject": \u0275\u0275inject,
    "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
    "resolveForwardRef": resolveForwardRef
  };
  function compileInjectable(type, meta) {
    let ngInjectableDef = null;
    let ngFactoryDef = null;
    if (!type.hasOwnProperty(NG_PROV_DEF)) {
      Object.defineProperty(type, NG_PROV_DEF, {
        get: () => {
          if (ngInjectableDef === null) {
            const compiler = getCompilerFacade({ usage: 0, kind: "injectable", type });
            ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));
          }
          return ngInjectableDef;
        }
      });
    }
    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
      Object.defineProperty(type, NG_FACTORY_DEF, {
        get: () => {
          if (ngFactoryDef === null) {
            const compiler = getCompilerFacade({ usage: 0, kind: "injectable", type });
            ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
              name: type.name,
              type,
              typeArgumentCount: 0,
              deps: reflectDependencies(type),
              target: compiler.FactoryTarget.Injectable
            });
          }
          return ngFactoryDef;
        },
        configurable: true
      });
    }
  }
  var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
  function isUseClassProvider(meta) {
    return meta.useClass !== void 0;
  }
  function isUseValueProvider(meta) {
    return USE_VALUE in meta;
  }
  function isUseFactoryProvider(meta) {
    return meta.useFactory !== void 0;
  }
  function isUseExistingProvider(meta) {
    return meta.useExisting !== void 0;
  }
  function getInjectableMetadata(type, srcMeta) {
    const meta = srcMeta || { providedIn: null };
    const compilerMeta = {
      name: type.name,
      type,
      typeArgumentCount: 0,
      providedIn: meta.providedIn
    };
    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
      compilerMeta.deps = convertDependencies(meta.deps);
    }
    if (isUseClassProvider(meta)) {
      compilerMeta.useClass = meta.useClass;
    } else if (isUseValueProvider(meta)) {
      compilerMeta.useValue = meta.useValue;
    } else if (isUseFactoryProvider(meta)) {
      compilerMeta.useFactory = meta.useFactory;
    } else if (isUseExistingProvider(meta)) {
      compilerMeta.useExisting = meta.useExisting;
    }
    return compilerMeta;
  }
  var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
  function findFirstClosedCycle(keys) {
    const res = [];
    for (let i = 0; i < keys.length; ++i) {
      if (res.indexOf(keys[i]) > -1) {
        res.push(keys[i]);
        return res;
      }
      res.push(keys[i]);
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      const reversed = findFirstClosedCycle(keys.slice().reverse());
      const tokenStrs = reversed.map((k) => stringify(k.token));
      return " (" + tokenStrs.join(" -> ") + ")";
    }
    return "";
  }
  function injectionError(injector2, key, constructResolvingMessage, originalError) {
    const keys = [key];
    const errMsg = constructResolvingMessage(keys);
    const error3 = originalError ? wrappedError(errMsg, originalError) : Error(errMsg);
    error3.addKey = addKey;
    error3.keys = keys;
    error3.injectors = [injector2];
    error3.constructResolvingMessage = constructResolvingMessage;
    error3[ERROR_ORIGINAL_ERROR] = originalError;
    return error3;
  }
  function addKey(injector2, key) {
    this.injectors.push(injector2);
    this.keys.push(key);
    this.message = this.constructResolvingMessage(this.keys);
  }
  function noProviderError(injector2, key) {
    return injectionError(injector2, key, function(keys) {
      const first = stringify(keys[0].token);
      return `No provider for ${first}!${constructResolvingPath(keys)}`;
    });
  }
  function cyclicDependencyError(injector2, key) {
    return injectionError(injector2, key, function(keys) {
      return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;
    });
  }
  function instantiationError(injector2, originalException, originalStack, key) {
    return injectionError(injector2, key, function(keys) {
      const first = stringify(keys[0].token);
      return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;
    }, originalException);
  }
  function invalidProviderError(provider) {
    return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);
  }
  function noAnnotationError(typeOrFunc, params) {
    const signature = [];
    for (let i = 0, ii = params.length; i < ii; i++) {
      const parameter = params[i];
      if (!parameter || parameter.length == 0) {
        signature.push("?");
      } else {
        signature.push(parameter.map(stringify).join(" "));
      }
    }
    return Error("Cannot resolve all parameters for '" + stringify(typeOrFunc) + "'(" + signature.join(", ") + "). Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + stringify(typeOrFunc) + "' is decorated with Injectable.");
  }
  function outOfBoundsError(index) {
    return Error(`Index ${index} is out-of-bounds.`);
  }
  function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
    return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);
  }
  var ReflectiveKey = class {
    constructor(token, id) {
      this.token = token;
      this.id = id;
      if (!token) {
        throw new Error("Token must be defined!");
      }
      this.displayName = stringify(this.token);
    }
    static get(token) {
      return _globalKeyRegistry.get(resolveForwardRef(token));
    }
    static get numberOfKeys() {
      return _globalKeyRegistry.numberOfKeys;
    }
  };
  var KeyRegistry = class {
    constructor() {
      this._allKeys = /* @__PURE__ */ new Map();
    }
    get(token) {
      if (token instanceof ReflectiveKey)
        return token;
      if (this._allKeys.has(token)) {
        return this._allKeys.get(token);
      }
      const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
      this._allKeys.set(token, newKey);
      return newKey;
    }
    get numberOfKeys() {
      return this._allKeys.size;
    }
  };
  var _globalKeyRegistry = new KeyRegistry();
  var Reflector = class {
    constructor(reflectionCapabilities) {
      this.reflectionCapabilities = reflectionCapabilities;
    }
    updateCapabilities(caps) {
      this.reflectionCapabilities = caps;
    }
    factory(type) {
      return this.reflectionCapabilities.factory(type);
    }
    parameters(typeOrFunc) {
      return this.reflectionCapabilities.parameters(typeOrFunc);
    }
    annotations(typeOrFunc) {
      return this.reflectionCapabilities.annotations(typeOrFunc);
    }
    propMetadata(typeOrFunc) {
      return this.reflectionCapabilities.propMetadata(typeOrFunc);
    }
    hasLifecycleHook(type, lcProperty) {
      return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
    }
    getter(name) {
      return this.reflectionCapabilities.getter(name);
    }
    setter(name) {
      return this.reflectionCapabilities.setter(name);
    }
    method(name) {
      return this.reflectionCapabilities.method(name);
    }
    importUri(type) {
      return this.reflectionCapabilities.importUri(type);
    }
    resourceUri(type) {
      return this.reflectionCapabilities.resourceUri(type);
    }
    resolveIdentifier(name, moduleUrl, members, runtime) {
      return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
    }
    resolveEnum(identifier, name) {
      return this.reflectionCapabilities.resolveEnum(identifier, name);
    }
  };
  var reflector = new Reflector(new ReflectionCapabilities());
  var ReflectiveDependency = class {
    constructor(key, optional, visibility) {
      this.key = key;
      this.optional = optional;
      this.visibility = visibility;
    }
    static fromKey(key) {
      return new ReflectiveDependency(key, false, null);
    }
  };
  var _EMPTY_LIST = [];
  var ResolvedReflectiveProvider_ = class {
    constructor(key, resolvedFactories, multiProvider) {
      this.key = key;
      this.resolvedFactories = resolvedFactories;
      this.multiProvider = multiProvider;
      this.resolvedFactory = this.resolvedFactories[0];
    }
  };
  var ResolvedReflectiveFactory = class {
    constructor(factory, dependencies) {
      this.factory = factory;
      this.dependencies = dependencies;
    }
  };
  function resolveReflectiveFactory(provider) {
    let factoryFn;
    let resolvedDeps;
    if (provider.useClass) {
      const useClass = resolveForwardRef(provider.useClass);
      factoryFn = reflector.factory(useClass);
      resolvedDeps = _dependenciesFor(useClass);
    } else if (provider.useExisting) {
      factoryFn = (aliasInstance) => aliasInstance;
      resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
    } else if (provider.useFactory) {
      factoryFn = provider.useFactory;
      resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
    } else {
      factoryFn = () => provider.useValue;
      resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
  }
  function resolveReflectiveProviders(providers) {
    const normalized = _normalizeProviders(providers, []);
    const resolved = normalized.map(resolveReflectiveProvider);
    const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, /* @__PURE__ */ new Map());
    return Array.from(resolvedProviderMap.values());
  }
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (let i = 0; i < providers.length; i++) {
      const provider = providers[i];
      const existing = normalizedProvidersMap.get(provider.key.id);
      if (existing) {
        if (provider.multiProvider !== existing.multiProvider) {
          throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
        }
        if (provider.multiProvider) {
          for (let j = 0; j < provider.resolvedFactories.length; j++) {
            existing.resolvedFactories.push(provider.resolvedFactories[j]);
          }
        } else {
          normalizedProvidersMap.set(provider.key.id, provider);
        }
      } else {
        let resolvedProvider;
        if (provider.multiProvider) {
          resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
        } else {
          resolvedProvider = provider;
        }
        normalizedProvidersMap.set(provider.key.id, resolvedProvider);
      }
    }
    return normalizedProvidersMap;
  }
  function _normalizeProviders(providers, res) {
    providers.forEach((b) => {
      if (b instanceof Type) {
        res.push({ provide: b, useClass: b });
      } else if (b && typeof b == "object" && b.provide !== void 0) {
        res.push(b);
      } else if (Array.isArray(b)) {
        _normalizeProviders(b, res);
      } else {
        throw invalidProviderError(b);
      }
    });
    return res;
  }
  function constructDependencies(typeOrFunc, dependencies) {
    if (!dependencies) {
      return _dependenciesFor(typeOrFunc);
    } else {
      const params = dependencies.map((t) => [t]);
      return dependencies.map((t) => _extractToken(typeOrFunc, t, params));
    }
  }
  function _dependenciesFor(typeOrFunc) {
    const params = reflector.parameters(typeOrFunc);
    if (!params)
      return [];
    if (params.some((p) => p == null)) {
      throw noAnnotationError(typeOrFunc, params);
    }
    return params.map((p) => _extractToken(typeOrFunc, p, params));
  }
  function _extractToken(typeOrFunc, metadata, params) {
    let token = null;
    let optional = false;
    if (!Array.isArray(metadata)) {
      if (metadata instanceof Inject) {
        return _createDependency(metadata.token, optional, null);
      } else {
        return _createDependency(metadata, optional, null);
      }
    }
    let visibility = null;
    for (let i = 0; i < metadata.length; ++i) {
      const paramMetadata = metadata[i];
      if (paramMetadata instanceof Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof Inject) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof Optional) {
        optional = true;
      } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
        visibility = paramMetadata;
      } else if (paramMetadata instanceof InjectionToken) {
        token = paramMetadata;
      }
    }
    token = resolveForwardRef(token);
    if (token != null) {
      return _createDependency(token, optional, visibility);
    } else {
      throw noAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, visibility) {
    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
  }
  var UNDEFINED = {};
  var ReflectiveInjector = class {
    static resolve(providers) {
      return resolveReflectiveProviders(providers);
    }
    static resolveAndCreate(providers, parent) {
      const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    }
    static fromResolvedProviders(providers, parent) {
      return new ReflectiveInjector_(providers, parent);
    }
  };
  var ReflectiveInjector_ = class {
    constructor(_providers, _parent) {
      this._constructionCounter = 0;
      this._providers = _providers;
      this.parent = _parent || null;
      const len = _providers.length;
      this.keyIds = [];
      this.objs = [];
      for (let i = 0; i < len; i++) {
        this.keyIds[i] = _providers[i].key.id;
        this.objs[i] = UNDEFINED;
      }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
      return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
    }
    resolveAndCreateChild(providers) {
      const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return this.createChildFromResolved(ResolvedReflectiveProviders);
    }
    createChildFromResolved(providers) {
      const inj = new ReflectiveInjector_(providers);
      inj.parent = this;
      return inj;
    }
    resolveAndInstantiate(provider) {
      return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    }
    instantiateResolved(provider) {
      return this._instantiateProvider(provider);
    }
    getProviderAtIndex(index) {
      if (index < 0 || index >= this._providers.length) {
        throw outOfBoundsError(index);
      }
      return this._providers[index];
    }
    _new(provider) {
      if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
        throw cyclicDependencyError(this, provider.key);
      }
      return this._instantiateProvider(provider);
    }
    _getMaxNumberOfObjects() {
      return this.objs.length;
    }
    _instantiateProvider(provider) {
      if (provider.multiProvider) {
        const res = [];
        for (let i = 0; i < provider.resolvedFactories.length; ++i) {
          res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
        }
        return res;
      } else {
        return this._instantiate(provider, provider.resolvedFactories[0]);
      }
    }
    _instantiate(provider, ResolvedReflectiveFactory2) {
      const factory = ResolvedReflectiveFactory2.factory;
      let deps;
      try {
        deps = ResolvedReflectiveFactory2.dependencies.map((dep) => this._getByReflectiveDependency(dep));
      } catch (e) {
        if (e.addKey) {
          e.addKey(this, provider.key);
        }
        throw e;
      }
      let obj;
      try {
        obj = factory(...deps);
      } catch (e) {
        throw instantiationError(this, e, e.stack, provider.key);
      }
      return obj;
    }
    _getByReflectiveDependency(dep) {
      return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
    }
    _getByKey(key, visibility, notFoundValue) {
      if (key === ReflectiveInjector_.INJECTOR_KEY) {
        return this;
      }
      if (visibility instanceof Self) {
        return this._getByKeySelf(key, notFoundValue);
      } else {
        return this._getByKeyDefault(key, notFoundValue, visibility);
      }
    }
    _getObjByKeyId(keyId) {
      for (let i = 0; i < this.keyIds.length; i++) {
        if (this.keyIds[i] === keyId) {
          if (this.objs[i] === UNDEFINED) {
            this.objs[i] = this._new(this._providers[i]);
          }
          return this.objs[i];
        }
      }
      return UNDEFINED;
    }
    _throwOrNull(key, notFoundValue) {
      if (notFoundValue !== THROW_IF_NOT_FOUND) {
        return notFoundValue;
      } else {
        throw noProviderError(this, key);
      }
    }
    _getByKeySelf(key, notFoundValue) {
      const obj = this._getObjByKeyId(key.id);
      return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);
    }
    _getByKeyDefault(key, notFoundValue, visibility) {
      let inj;
      if (visibility instanceof SkipSelf) {
        inj = this.parent;
      } else {
        inj = this;
      }
      while (inj instanceof ReflectiveInjector_) {
        const inj_ = inj;
        const obj = inj_._getObjByKeyId(key.id);
        if (obj !== UNDEFINED)
          return obj;
        inj = inj_.parent;
      }
      if (inj !== null) {
        return inj.get(key.token, notFoundValue);
      } else {
        return this._throwOrNull(key, notFoundValue);
      }
    }
    get displayName() {
      const providers = _mapProviders(this, (b) => ' "' + b.key.displayName + '" ').join(", ");
      return `ReflectiveInjector(providers: [${providers}])`;
    }
    toString() {
      return this.displayName;
    }
  };
  ReflectiveInjector_.INJECTOR_KEY = /* @__PURE__ */ ReflectiveKey.get(Injector);
  function _mapProviders(injector2, fn2) {
    const res = [];
    for (let i = 0; i < injector2._providers.length; ++i) {
      res[i] = fn2(injector2.getProviderAtIndex(i));
    }
    return res;
  }
  function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
    const lView = getLView();
    if (lView === null) {
      ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
      return \u0275\u0275inject(token, flags);
    }
    const tNode = getCurrentTNode();
    return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  }
  function \u0275\u0275invalidFactory() {
    const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
    throw new Error(msg);
  }
  function \u0275\u0275property(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275property;
  }
  function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
    const inputs = tNode.inputs;
    const property = isClassBased ? "class" : "style";
    setInputsForProperty(tView, lView, inputs[property], property, value);
  }
  function elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
    const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    ngDevMode && validateElementIsKnown(native, tNode.value, tView.schemas, hasDirectives);
    if (tNode.attrs !== null) {
      computeStaticStyling(tNode, tNode.attrs, false);
    }
    if (tNode.mergedAttrs !== null) {
      computeStaticStyling(tNode, tNode.mergedAttrs, true);
    }
    if (tView.queries !== null) {
      tView.queries.elementStart(tView, tNode);
    }
    return tNode;
  }
  function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const renderer = lView[RENDERER];
    const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());
    const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    const mergedAttrs = tNode.mergedAttrs;
    if (mergedAttrs !== null) {
      setUpAttributes(renderer, native, mergedAttrs);
    }
    const classes = tNode.classes;
    if (classes !== null) {
      writeDirectClass(renderer, native, classes);
    }
    const styles = tNode.styles;
    if (styles !== null) {
      writeDirectStyle(renderer, native, styles);
    }
    if ((tNode.flags & 64) !== 64) {
      appendChild(tView, lView, native, tNode);
    }
    if (getElementDepthCount() === 0) {
      attachPatchData(native, lView);
    }
    increaseElementDepthCount();
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex !== null) {
      saveResolvedLocalsInData(lView, tNode);
    }
    return \u0275\u0275elementStart;
  }
  function \u0275\u0275elementEnd() {
    let currentTNode = getCurrentTNode();
    ngDevMode && assertDefined(currentTNode, "No parent node to close.");
    if (isCurrentTNodeParent()) {
      setCurrentTNodeAsNotParent();
    } else {
      ngDevMode && assertHasParent(getCurrentTNode());
      currentTNode = currentTNode.parent;
      setCurrentTNode(currentTNode, false);
    }
    const tNode = currentTNode;
    ngDevMode && assertTNodeType(tNode, 3);
    decreaseElementDepthCount();
    const tView = getTView();
    if (tView.firstCreatePass) {
      registerPostOrderHooks(tView, currentTNode);
      if (isContentQueryHost(currentTNode)) {
        tView.queries.elementEnd(currentTNode);
      }
    }
    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
      setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
    }
    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
      setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
    }
    return \u0275\u0275elementEnd;
  }
  function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
    \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
    \u0275\u0275elementEnd();
    return \u0275\u0275element;
  }
  function validateElementIsKnown(element2, tagName, schemas, hasDirectives) {
    if (schemas === null)
      return;
    if (!hasDirectives && tagName !== null) {
      const isUnknown = typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element2 instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName);
      if (isUnknown && !matchingSchemas(schemas, tagName)) {
        let message = `'${tagName}' is not a known element:
`;
        message += `1. If '${tagName}' is an Angular component, then verify that it is part of this module.
`;
        if (tagName && tagName.indexOf("-") > -1) {
          message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
        } else {
          message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
        }
        console.error(formatRuntimeError(304, message));
      }
    }
  }
  function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
    if (attrs !== null) {
      computeStaticStyling(tNode, attrs, true);
    }
    const localRefs = getConstant(tViewConsts, localRefsIndex);
    resolveDirectives(tView, lView, tNode, localRefs);
    if (tView.queries !== null) {
      tView.queries.elementStart(tView, tNode);
    }
    return tNode;
  }
  function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
    const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    ngDevMode && ngDevMode.rendererCreateComment++;
    const native = lView[adjustedIndex] = lView[RENDERER].createComment(ngDevMode ? "ng-container" : "");
    appendChild(tView, lView, native, tNode);
    attachPatchData(native, lView);
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex != null) {
      saveResolvedLocalsInData(lView, tNode);
    }
    return \u0275\u0275elementContainerStart;
  }
  function \u0275\u0275elementContainerEnd() {
    let currentTNode = getCurrentTNode();
    const tView = getTView();
    if (isCurrentTNodeParent()) {
      setCurrentTNodeAsNotParent();
    } else {
      ngDevMode && assertHasParent(currentTNode);
      currentTNode = currentTNode.parent;
      setCurrentTNode(currentTNode, false);
    }
    ngDevMode && assertTNodeType(currentTNode, 8);
    if (tView.firstCreatePass) {
      registerPostOrderHooks(tView, currentTNode);
      if (isContentQueryHost(currentTNode)) {
        tView.queries.elementEnd(currentTNode);
      }
    }
    return \u0275\u0275elementContainerEnd;
  }
  function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
    \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
    \u0275\u0275elementContainerEnd();
    return \u0275\u0275elementContainer;
  }
  function \u0275\u0275getCurrentView() {
    return getLView();
  }
  function isPromise2(obj) {
    return !!obj && typeof obj.then === "function";
  }
  function isSubscribable(obj) {
    return !!obj && typeof obj.subscribe === "function";
  }
  var isObservable = isSubscribable;
  function \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {
    const lView = getLView();
    const tView = getTView();
    const tNode = getCurrentTNode();
    listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);
    return \u0275\u0275listener;
  }
  function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
    const tNode = getCurrentTNode();
    const lView = getLView();
    const tView = getTView();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);
    return \u0275\u0275syntheticHostListener;
  }
  function findExistingListener(tView, lView, eventName, tNodeIdx) {
    const tCleanup = tView.cleanup;
    if (tCleanup != null) {
      for (let i = 0; i < tCleanup.length - 1; i += 2) {
        const cleanupEventName = tCleanup[i];
        if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
          const lCleanup = lView[CLEANUP];
          const listenerIdxInLCleanup = tCleanup[i + 2];
          return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
        }
        if (typeof cleanupEventName === "string") {
          i += 2;
        }
      }
    }
    return null;
  }
  function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {
    const isTNodeDirectiveHost = isDirectiveHost(tNode);
    const firstCreatePass = tView.firstCreatePass;
    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
    const context = lView[CONTEXT];
    const lCleanup = getOrCreateLViewCleanup(lView);
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    let processOutputs = true;
    if (tNode.type & 3 || eventTargetResolver) {
      const native = getNativeByTNode(tNode, lView);
      const target = eventTargetResolver ? eventTargetResolver(native) : native;
      const lCleanupIndex = lCleanup.length;
      const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
      if (isProceduralRenderer(renderer)) {
        let existingListener = null;
        if (!eventTargetResolver && isTNodeDirectiveHost) {
          existingListener = findExistingListener(tView, lView, eventName, tNode.index);
        }
        if (existingListener !== null) {
          const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
          lastListenerFn.__ngNextListenerFn__ = listenerFn;
          existingListener.__ngLastListenerFn__ = listenerFn;
          processOutputs = false;
        } else {
          listenerFn = wrapListener(tNode, lView, context, listenerFn, false);
          const cleanupFn = renderer.listen(target, eventName, listenerFn);
          ngDevMode && ngDevMode.rendererAddEventListener++;
          lCleanup.push(listenerFn, cleanupFn);
          tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
        }
      } else {
        listenerFn = wrapListener(tNode, lView, context, listenerFn, true);
        target.addEventListener(eventName, listenerFn, useCapture);
        ngDevMode && ngDevMode.rendererAddEventListener++;
        lCleanup.push(listenerFn);
        tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);
      }
    } else {
      listenerFn = wrapListener(tNode, lView, context, listenerFn, false);
    }
    const outputs = tNode.outputs;
    let props;
    if (processOutputs && outputs !== null && (props = outputs[eventName])) {
      const propsLength = props.length;
      if (propsLength) {
        for (let i = 0; i < propsLength; i += 2) {
          const index = props[i];
          ngDevMode && assertIndexInRange(lView, index);
          const minifiedName = props[i + 1];
          const directiveInstance = lView[index];
          const output = directiveInstance[minifiedName];
          if (ngDevMode && !isObservable(output)) {
            throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
          }
          const subscription = output.subscribe(listenerFn);
          const idx = lCleanup.length;
          lCleanup.push(listenerFn, subscription);
          tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
        }
      }
    }
  }
  function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
    try {
      profiler(6, context, listenerFn);
      return listenerFn(e) !== false;
    } catch (error3) {
      handleError(lView, error3);
      return false;
    } finally {
      profiler(7, context, listenerFn);
    }
  }
  function wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {
    return function wrapListenerIn_markDirtyAndPreventDefault(e) {
      if (e === Function) {
        return listenerFn;
      }
      const startView = tNode.flags & 2 ? getComponentLViewByIndex(tNode.index, lView) : lView;
      if ((lView[FLAGS] & 32) === 0) {
        markViewDirty(startView);
      }
      let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);
      let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
      while (nextListenerFn) {
        result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;
        nextListenerFn = nextListenerFn.__ngNextListenerFn__;
      }
      if (wrapWithPreventDefault && result === false) {
        e.preventDefault();
        e.returnValue = false;
      }
      return result;
    };
  }
  function \u0275\u0275nextContext(level = 1) {
    return nextContextImpl(level);
  }
  function matchingProjectionSlotIndex(tNode, projectionSlots) {
    let wildcardNgContentIndex = null;
    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
    for (let i = 0; i < projectionSlots.length; i++) {
      const slotValue = projectionSlots[i];
      if (slotValue === "*") {
        wildcardNgContentIndex = i;
        continue;
      }
      if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
        return i;
      }
    }
    return wildcardNgContentIndex;
  }
  function \u0275\u0275projectionDef(projectionSlots) {
    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
    if (!componentNode.projection) {
      const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
      const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
      const tails = projectionHeads.slice();
      let componentChild = componentNode.child;
      while (componentChild !== null) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
        componentChild = componentChild.next;
      }
    }
  }
  function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs) {
    const lView = getLView();
    const tView = getTView();
    const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
    if (tProjectionNode.projection === null)
      tProjectionNode.projection = selectorIndex;
    setCurrentTNodeAsNotParent();
    if ((tProjectionNode.flags & 64) !== 64) {
      applyProjection(tView, lView, tProjectionNode);
    }
  }
  function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
    \u0275\u0275propertyInterpolate1(propName, "", v0, "", sanitizer);
    return \u0275\u0275propertyInterpolate;
  }
  function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
    }
    return \u0275\u0275propertyInterpolate1;
  }
  function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
    }
    return \u0275\u0275propertyInterpolate2;
  }
  function \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
    }
    return \u0275\u0275propertyInterpolate3;
  }
  function \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
    }
    return \u0275\u0275propertyInterpolate4;
  }
  function \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
    }
    return \u0275\u0275propertyInterpolate5;
  }
  function \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
    }
    return \u0275\u0275propertyInterpolate6;
  }
  function \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
    }
    return \u0275\u0275propertyInterpolate7;
  }
  function \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
    }
    return \u0275\u0275propertyInterpolate8;
  }
  function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      if (ngDevMode) {
        const interpolationInBetween = [values[0]];
        for (let i = 2; i < values.length; i += 2) {
          interpolationInBetween.push(values[i]);
        }
        storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
      }
    }
    return \u0275\u0275propertyInterpolateV;
  }
  function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding2, isClassBinding) {
    ngDevMode && assertFirstUpdatePass(getTView());
    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
    let tmplHead = getTStylingRangePrev(tBindings);
    let tmplTail = getTStylingRangeNext(tBindings);
    tData[index] = tStylingKeyWithStatic;
    let isKeyDuplicateOfStatic = false;
    let tStylingKey;
    if (Array.isArray(tStylingKeyWithStatic)) {
      const staticKeyValueArray = tStylingKeyWithStatic;
      tStylingKey = staticKeyValueArray[1];
      if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
        isKeyDuplicateOfStatic = true;
      }
    } else {
      tStylingKey = tStylingKeyWithStatic;
    }
    if (isHostBinding2) {
      const hasTemplateBindings = tmplTail !== 0;
      if (hasTemplateBindings) {
        const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
        tData[index + 1] = toTStylingRange(previousNode, tmplHead);
        if (previousNode !== 0) {
          tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
        }
        tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
      } else {
        tData[index + 1] = toTStylingRange(tmplHead, 0);
        if (tmplHead !== 0) {
          tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
        }
        tmplHead = index;
      }
    } else {
      tData[index + 1] = toTStylingRange(tmplTail, 0);
      ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
      if (tmplHead === 0) {
        tmplHead = index;
      } else {
        tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
      }
      tmplTail = index;
    }
    if (isKeyDuplicateOfStatic) {
      tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
    }
    markDuplicates(tData, tStylingKey, index, true, isClassBinding);
    markDuplicates(tData, tStylingKey, index, false, isClassBinding);
    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
    tBindings = toTStylingRange(tmplHead, tmplTail);
    if (isClassBinding) {
      tNode.classBindings = tBindings;
    } else {
      tNode.styleBindings = tBindings;
    }
  }
  function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
      tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
    }
  }
  function markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {
    const tStylingAtIndex = tData[index + 1];
    const isMap = tStylingKey === null;
    let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
    let foundDuplicate = false;
    while (cursor !== 0 && (foundDuplicate === false || isMap)) {
      ngDevMode && assertIndexInRange(tData, cursor);
      const tStylingValueAtCursor = tData[cursor];
      const tStyleRangeAtCursor = tData[cursor + 1];
      if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
        foundDuplicate = true;
        tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
      }
      cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
    }
    if (foundDuplicate) {
      tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
    }
  }
  function isStylingMatch(tStylingKeyCursor, tStylingKey) {
    ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
    if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
      return true;
    } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
      return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
    }
    return false;
  }
  var parserState = {
    textEnd: 0,
    key: 0,
    keyEnd: 0,
    value: 0,
    valueEnd: 0
  };
  function getLastParsedKey(text) {
    return text.substring(parserState.key, parserState.keyEnd);
  }
  function getLastParsedValue(text) {
    return text.substring(parserState.value, parserState.valueEnd);
  }
  function parseClassName(text) {
    resetParserState(text);
    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
  }
  function parseClassNameNext(text, index) {
    const end = parserState.textEnd;
    if (end === index) {
      return -1;
    }
    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
    return consumeWhitespace(text, index, end);
  }
  function parseStyle(text) {
    resetParserState(text);
    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
  }
  function parseStyleNext(text, startIndex) {
    const end = parserState.textEnd;
    let index = parserState.key = consumeWhitespace(text, startIndex, end);
    if (end === index) {
      return -1;
    }
    index = parserState.keyEnd = consumeStyleKey(text, index, end);
    index = consumeSeparator(text, index, end, 58);
    index = parserState.value = consumeWhitespace(text, index, end);
    index = parserState.valueEnd = consumeStyleValue(text, index, end);
    return consumeSeparator(text, index, end, 59);
  }
  function resetParserState(text) {
    parserState.key = 0;
    parserState.keyEnd = 0;
    parserState.value = 0;
    parserState.valueEnd = 0;
    parserState.textEnd = text.length;
  }
  function consumeWhitespace(text, startIndex, endIndex) {
    while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeClassToken(text, startIndex, endIndex) {
    while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeStyleKey(text, startIndex, endIndex) {
    let ch;
    while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeSeparator(text, startIndex, endIndex, separator) {
    startIndex = consumeWhitespace(text, startIndex, endIndex);
    if (startIndex < endIndex) {
      if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
        malformedStyleError(text, String.fromCharCode(separator), startIndex);
      }
      startIndex++;
    }
    return startIndex;
  }
  function consumeStyleValue(text, startIndex, endIndex) {
    let ch1 = -1;
    let ch2 = -1;
    let ch3 = -1;
    let i = startIndex;
    let lastChIndex = i;
    while (i < endIndex) {
      const ch = text.charCodeAt(i++);
      if (ch === 59) {
        return lastChIndex;
      } else if (ch === 34 || ch === 39) {
        lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
      } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
        lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
      } else if (ch > 32) {
        lastChIndex = i;
      }
      ch3 = ch2;
      ch2 = ch1;
      ch1 = ch & -33;
    }
    return lastChIndex;
  }
  function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
    let ch1 = -1;
    let index = startIndex;
    while (index < endIndex) {
      const ch = text.charCodeAt(index++);
      if (ch == quoteCharCode && ch1 !== 92) {
        return index;
      }
      if (ch == 92 && ch1 === 92) {
        ch1 = 0;
      } else {
        ch1 = ch;
      }
    }
    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
  }
  function malformedStyleError(text, expecting, index) {
    ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
    throw throwError2(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.substr(index + 1) + `'. Expecting '${expecting}'.`);
  }
  function \u0275\u0275styleProp(prop, value, suffix) {
    checkStylingProperty(prop, value, suffix, false);
    return \u0275\u0275styleProp;
  }
  function \u0275\u0275classProp(className, value) {
    checkStylingProperty(className, value, null, true);
    return \u0275\u0275classProp;
  }
  function \u0275\u0275styleMap(styles) {
    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
  }
  function styleStringParser(keyValueArray, text) {
    for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
      styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
    }
  }
  function \u0275\u0275classMap(classes) {
    checkStylingMap(keyValueArraySet, classStringParser, classes, true);
  }
  function classStringParser(keyValueArray, text) {
    for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
      keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
    }
  }
  function checkStylingProperty(prop, value, suffix, isClassBased) {
    const lView = getLView();
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) {
      stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
    }
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
      const tNode = tView.data[getSelectedIndex()];
      updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
    }
  }
  function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) {
      stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
    }
    const lView = getLView();
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
      const tNode = tView.data[getSelectedIndex()];
      if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
        if (ngDevMode) {
          const tStylingKey = tView.data[bindingIndex];
          assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
        }
        let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
        ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
        if (staticPrefix !== null) {
          value = concatStringsWithSpace(staticPrefix, value ? value : "");
        }
        setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
      } else {
        updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
      }
    }
  }
  function isInHostBindings(tView, bindingIndex) {
    return bindingIndex >= tView.expandoStartIndex;
  }
  function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
    ngDevMode && assertFirstUpdatePass(tView);
    const tData = tView.data;
    if (tData[bindingIndex + 1] === null) {
      const tNode = tData[getSelectedIndex()];
      ngDevMode && assertDefined(tNode, "TNode expected");
      const isHostBindings = isInHostBindings(tView, bindingIndex);
      if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
        tStylingKey = false;
      }
      tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
      insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
    }
  }
  function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
    const hostDirectiveDef = getCurrentDirectiveDef(tData);
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (hostDirectiveDef === null) {
      const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
      if (isFirstStylingInstructionInTemplate) {
        stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
        stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
        residual = null;
      }
    } else {
      const directiveStylingLast = tNode.directiveStylingLast;
      const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
      if (isFirstStylingInstructionInHostBinding) {
        stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
        if (residual === null) {
          let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
          if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
            templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
            templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
            setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
          }
        } else {
          residual = collectResidual(tData, tNode, isClassBased);
        }
      }
    }
    if (residual !== void 0) {
      isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
    }
    return stylingKey;
  }
  function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    if (getTStylingRangeNext(bindings) === 0) {
      return void 0;
    }
    return tData[getTStylingRangePrev(bindings)];
  }
  function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
    tData[getTStylingRangePrev(bindings)] = tStylingKey;
  }
  function collectResidual(tData, tNode, isClassBased) {
    let residual = void 0;
    const directiveEnd = tNode.directiveEnd;
    ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
    for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
      const attrs = tData[i].hostAttrs;
      residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
    }
    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
  }
  function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
    let currentDirective = null;
    const directiveEnd = tNode.directiveEnd;
    let directiveStylingLast = tNode.directiveStylingLast;
    if (directiveStylingLast === -1) {
      directiveStylingLast = tNode.directiveStart;
    } else {
      directiveStylingLast++;
    }
    while (directiveStylingLast < directiveEnd) {
      currentDirective = tData[directiveStylingLast];
      ngDevMode && assertDefined(currentDirective, "expected to be defined");
      stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
      if (currentDirective === hostDirectiveDef)
        break;
      directiveStylingLast++;
    }
    if (hostDirectiveDef !== null) {
      tNode.directiveStylingLast = directiveStylingLast;
    }
    return stylingKey;
  }
  function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
    const desiredMarker = isClassBased ? 1 : 2;
    let currentMarker = -1;
    if (attrs !== null) {
      for (let i = 0; i < attrs.length; i++) {
        const item = attrs[i];
        if (typeof item === "number") {
          currentMarker = item;
        } else {
          if (currentMarker === desiredMarker) {
            if (!Array.isArray(stylingKey)) {
              stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
            }
            keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
          }
        }
      }
    }
    return stylingKey === void 0 ? null : stylingKey;
  }
  function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
    if (value == null || value === "")
      return EMPTY_ARRAY;
    const styleKeyValueArray = [];
    const unwrappedValue = unwrapSafeValue(value);
    if (Array.isArray(unwrappedValue)) {
      for (let i = 0; i < unwrappedValue.length; i++) {
        keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
      }
    } else if (typeof unwrappedValue === "object") {
      for (const key in unwrappedValue) {
        if (unwrappedValue.hasOwnProperty(key)) {
          keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
        }
      }
    } else if (typeof unwrappedValue === "string") {
      stringParser(styleKeyValueArray, unwrappedValue);
    } else {
      ngDevMode && throwError2("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
    }
    return styleKeyValueArray;
  }
  function styleKeyValueArraySet(keyValueArray, key, value) {
    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
  }
  function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
    if (oldKeyValueArray === NO_CHANGE) {
      oldKeyValueArray = EMPTY_ARRAY;
    }
    let oldIndex = 0;
    let newIndex = 0;
    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
    while (oldKey !== null || newKey !== null) {
      ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
      ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
      const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
      const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
      let setKey = null;
      let setValue = void 0;
      if (oldKey === newKey) {
        oldIndex += 2;
        newIndex += 2;
        if (oldValue !== newValue) {
          setKey = newKey;
          setValue = newValue;
        }
      } else if (newKey === null || oldKey !== null && oldKey < newKey) {
        oldIndex += 2;
        setKey = oldKey;
      } else {
        ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
        newIndex += 2;
        setKey = newKey;
        setValue = newValue;
      }
      if (setKey !== null) {
        updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
      }
      oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
      newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
    }
  }
  function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
    if (!(tNode.type & 3)) {
      return;
    }
    const tData = tView.data;
    const tRange = tData[bindingIndex + 1];
    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
    if (!isStylingValuePresent(higherPriorityValue)) {
      if (!isStylingValuePresent(value)) {
        if (getTStylingRangePrevDuplicate(tRange)) {
          value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
        }
      }
      const rNode = getNativeByIndex(getSelectedIndex(), lView);
      applyStyling(renderer, isClassBased, rNode, prop, value);
    }
  }
  function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
    const isPrevDirection = tNode === null;
    let value = void 0;
    while (index > 0) {
      const rawKey = tData[index];
      const containsStatics = Array.isArray(rawKey);
      const key = containsStatics ? rawKey[1] : rawKey;
      const isStylingMap = key === null;
      let valueAtLViewIndex = lView[index + 1];
      if (valueAtLViewIndex === NO_CHANGE) {
        valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
      }
      let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
      if (containsStatics && !isStylingValuePresent(currentValue)) {
        currentValue = keyValueArrayGet(rawKey, prop);
      }
      if (isStylingValuePresent(currentValue)) {
        value = currentValue;
        if (isPrevDirection) {
          return value;
        }
      }
      const tRange = tData[index + 1];
      index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
    }
    if (tNode !== null) {
      let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
      if (residual != null) {
        value = keyValueArrayGet(residual, prop);
      }
    }
    return value;
  }
  function isStylingValuePresent(value) {
    return value !== void 0;
  }
  function normalizeSuffix(value, suffix) {
    if (value == null) {
    } else if (typeof suffix === "string") {
      value = value + suffix;
    } else if (typeof value === "object") {
      value = stringify(unwrapSafeValue(value));
    }
    return value;
  }
  function hasStylingInputShadow(tNode, isClassBased) {
    return (tNode.flags & (isClassBased ? 16 : 32)) !== 0;
  }
  function \u0275\u0275text(index, value = "") {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
    const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);
    appendChild(tView, lView, textNative, tNode);
    setCurrentTNode(tNode, false);
  }
  function \u0275\u0275textInterpolate(v0) {
    \u0275\u0275textInterpolate1("", v0, "");
    return \u0275\u0275textInterpolate;
  }
  function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolated = interpolation1(lView, prefix, v0, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate1;
  }
  function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate2;
  }
  function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate3;
  }
  function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate4;
  }
  function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate5;
  }
  function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate6;
  }
  function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate7;
  }
  function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate8;
  }
  function \u0275\u0275textInterpolateV(values) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolateV;
  }
  function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate1;
  }
  function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate2;
  }
  function \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate3;
  }
  function \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate4;
  }
  function \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate5;
  }
  function \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate6;
  }
  function \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate7;
  }
  function \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate8;
  }
  function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolateV;
  }
  function \u0275\u0275hostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275hostProperty;
  }
  function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      const currentDef = getCurrentDirectiveDef(tView.data);
      const renderer = loadComponentRenderer(currentDef, tNode, lView);
      elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275syntheticHostProperty;
  }
  if (typeof ngI18nClosureMode === "undefined") {
    (function() {
      _global2["ngI18nClosureMode"] = typeof goog !== "undefined" && typeof goog.getMsg === "function";
    })();
  }
  var u = void 0;
  function plural(val) {
    const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
    if (i === 1 && v === 0)
      return 1;
    return 5;
  }
  var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
  var LOCALE_DATA = {};
  function findLocaleData(locale) {
    const normalizedLocale = normalizeLocale(locale);
    let match = getLocaleData(normalizedLocale);
    if (match) {
      return match;
    }
    const parentLocale = normalizedLocale.split("-")[0];
    match = getLocaleData(parentLocale);
    if (match) {
      return match;
    }
    if (parentLocale === "en") {
      return localeEn;
    }
    throw new Error(`Missing locale data for the locale "${locale}".`);
  }
  function getLocalePluralCase(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.PluralCase];
  }
  function getLocaleData(normalizedLocale) {
    if (!(normalizedLocale in LOCALE_DATA)) {
      LOCALE_DATA[normalizedLocale] = _global2.ng && _global2.ng.common && _global2.ng.common.locales && _global2.ng.common.locales[normalizedLocale];
    }
    return LOCALE_DATA[normalizedLocale];
  }
  var LocaleDataIndex;
  (function(LocaleDataIndex2) {
    LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
    LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
    LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
    LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
    LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
    LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
    LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
    LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
    LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
    LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
    LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
    LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
    LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
    LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
    LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
    LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
    LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
    LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
    LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
    LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
    LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
    LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
  })(LocaleDataIndex || (LocaleDataIndex = {}));
  function normalizeLocale(locale) {
    return locale.toLowerCase().replace(/_/g, "-");
  }
  var pluralMapping = ["zero", "one", "two", "few", "many"];
  function getPluralCase(value, locale) {
    const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
    const result = pluralMapping[plural2];
    return result !== void 0 ? result : "other";
  }
  var DEFAULT_LOCALE_ID = "en-US";
  var USD_CURRENCY_CODE = "USD";
  var ELEMENT_MARKER = {
    marker: "element"
  };
  var ICU_MARKER = {
    marker: "ICU"
  };
  var I18nCreateOpCode;
  (function(I18nCreateOpCode2) {
    I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
    I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
    I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
  })(I18nCreateOpCode || (I18nCreateOpCode = {}));
  var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
  function setLocaleId(localeId) {
    assertDefined(localeId, `Expected localeId to be defined`);
    if (typeof localeId === "string") {
      LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
    }
  }
  function getLocaleId() {
    return LOCALE_ID$1;
  }
  function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
    const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
    if (insertBeforeIndex === null) {
      return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
    } else {
      ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
      return unwrapRNode(lView[insertBeforeIndex]);
    }
  }
  function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
    if (Array.isArray(tNodeInsertBeforeIndex)) {
      ngDevMode && assertDomNode(childRNode);
      let i18nParent = childRNode;
      let anchorRNode = null;
      if (!(childTNode.type & 3)) {
        anchorRNode = i18nParent;
        i18nParent = parentRElement;
      }
      if (i18nParent !== null && (childTNode.flags & 2) === 0) {
        for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
          const i18nChild = lView[tNodeInsertBeforeIndex[i]];
          nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
        }
      }
    }
  }
  function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
    ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
    previousTNodes.push(newTNode);
    if (previousTNodes.length > 1) {
      for (let i = previousTNodes.length - 2; i >= 0; i--) {
        const existingTNode = previousTNodes[i];
        if (!isI18nText(existingTNode)) {
          if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
            setInsertBeforeIndex(existingTNode, newTNode.index);
          }
        }
      }
    }
  }
  function isI18nText(tNode) {
    return !(tNode.type & 64);
  }
  function isNewTNodeCreatedBefore(existingTNode, newTNode) {
    return isI18nText(newTNode) || existingTNode.index > newTNode.index;
  }
  function getInsertBeforeIndex(tNode) {
    const index = tNode.insertBeforeIndex;
    return Array.isArray(index) ? index[0] : index;
  }
  function setInsertBeforeIndex(tNode, value) {
    const index = tNode.insertBeforeIndex;
    if (Array.isArray(index)) {
      index[0] = value;
    } else {
      setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
      tNode.insertBeforeIndex = value;
    }
  }
  function getTIcu(tView, index) {
    const value = tView.data[index];
    if (value === null || typeof value === "string")
      return null;
    if (ngDevMode && !(value.hasOwnProperty("tViews") || value.hasOwnProperty("currentCaseLViewIndex"))) {
      throwError2("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
    }
    const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
    ngDevMode && assertTIcu(tIcu);
    return tIcu;
  }
  function setTIcu(tView, index, tIcu) {
    const tNode = tView.data[index];
    ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tViews"), true, "We expect to get 'null'|'TIcuContainer'");
    if (tNode === null) {
      tView.data[index] = tIcu;
    } else {
      ngDevMode && assertTNodeType(tNode, 32);
      tNode.value = tIcu;
    }
  }
  function setTNodeInsertBeforeIndex(tNode, index) {
    ngDevMode && assertTNode(tNode);
    let insertBeforeIndex = tNode.insertBeforeIndex;
    if (insertBeforeIndex === null) {
      setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
      insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
    } else {
      assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
      insertBeforeIndex.push(index);
    }
  }
  function createTNodePlaceholder(tView, previousTNodes, index) {
    const tNode = createTNodeAtIndex(tView, index, 64, null, null);
    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
    return tNode;
  }
  function getCurrentICUCaseIndex(tIcu, lView) {
    const currentCase = lView[tIcu.currentCaseLViewIndex];
    return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
  }
  function getParentFromIcuCreateOpCode(mergedCode) {
    return mergedCode >>> 17;
  }
  function getRefFromIcuCreateOpCode(mergedCode) {
    return (mergedCode & 131070) >>> 1;
  }
  function getInstructionFromIcuCreateOpCode(mergedCode) {
    return mergedCode & 1;
  }
  function icuCreateOpCode(opCode, parentIdx, refIdx) {
    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
    ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
    return opCode | parentIdx << 17 | refIdx << 1;
  }
  var changeMask = 0;
  var changeMaskCounter = 0;
  function setMaskBit(hasChange) {
    if (hasChange) {
      changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
    }
    changeMaskCounter++;
  }
  function applyI18n(tView, lView, index) {
    if (changeMaskCounter > 0) {
      ngDevMode && assertDefined(tView, `tView should be defined`);
      const tI18n = tView.data[index];
      const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
      const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
      applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
    }
    changeMask = 0;
    changeMaskCounter = 0;
  }
  function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
    const renderer = lView[RENDERER];
    for (let i = 0; i < createOpCodes.length; i++) {
      const opCode = createOpCodes[i++];
      const text = createOpCodes[i];
      const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
      const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
      const index = opCode >>> I18nCreateOpCode.SHIFT;
      let rNode = lView[index];
      if (rNode === null) {
        rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);
      }
      if (appendNow && parentRNode !== null) {
        nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
      }
    }
  }
  function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
    ngDevMode && assertDomNode(anchorRNode);
    const renderer = lView[RENDERER];
    let rootIdx = null;
    let rootRNode;
    for (let i = 0; i < mutableOpCodes.length; i++) {
      const opCode = mutableOpCodes[i];
      if (typeof opCode == "string") {
        const textNodeIndex = mutableOpCodes[++i];
        if (lView[textNodeIndex] === null) {
          ngDevMode && ngDevMode.rendererCreateTextNode++;
          ngDevMode && assertIndexInRange(lView, textNodeIndex);
          lView[textNodeIndex] = createTextNode(renderer, opCode);
        }
      } else if (typeof opCode == "number") {
        switch (opCode & 1) {
          case 0:
            const parentIdx = getParentFromIcuCreateOpCode(opCode);
            if (rootIdx === null) {
              rootIdx = parentIdx;
              rootRNode = nativeParentNode(renderer, anchorRNode);
            }
            let insertInFrontOf;
            let parentRNode;
            if (parentIdx === rootIdx) {
              insertInFrontOf = anchorRNode;
              parentRNode = rootRNode;
            } else {
              insertInFrontOf = null;
              parentRNode = unwrapRNode(lView[parentIdx]);
            }
            if (parentRNode !== null) {
              ngDevMode && assertDomNode(parentRNode);
              const refIdx = getRefFromIcuCreateOpCode(opCode);
              ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
              const child = lView[refIdx];
              ngDevMode && assertDomNode(child);
              nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
              const tIcu = getTIcu(tView, refIdx);
              if (tIcu !== null && typeof tIcu === "object") {
                ngDevMode && assertTIcu(tIcu);
                const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
                if (caseIndex !== null) {
                  applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
                }
              }
            }
            break;
          case 1:
            const elementNodeIndex = opCode >>> 1;
            const attrName = mutableOpCodes[++i];
            const attrValue = mutableOpCodes[++i];
            setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
            break;
          default:
            if (ngDevMode) {
              throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
            }
        }
      } else {
        switch (opCode) {
          case ICU_MARKER:
            const commentValue = mutableOpCodes[++i];
            const commentNodeIndex = mutableOpCodes[++i];
            if (lView[commentNodeIndex] === null) {
              ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
              ngDevMode && ngDevMode.rendererCreateComment++;
              ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
              const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue);
              attachPatchData(commentRNode, lView);
            }
            break;
          case ELEMENT_MARKER:
            const tagName = mutableOpCodes[++i];
            const elementNodeIndex = mutableOpCodes[++i];
            if (lView[elementNodeIndex] === null) {
              ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
              ngDevMode && ngDevMode.rendererCreateElement++;
              ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
              const elementRNode = lView[elementNodeIndex] = createElementNode(renderer, tagName, null);
              attachPatchData(elementRNode, lView);
            }
            break;
          default:
            ngDevMode && throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
        }
      }
    }
  }
  function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
    for (let i = 0; i < updateOpCodes.length; i++) {
      const checkBit = updateOpCodes[i];
      const skipCodes = updateOpCodes[++i];
      if (checkBit & changeMask2) {
        let value = "";
        for (let j = i + 1; j <= i + skipCodes; j++) {
          const opCode = updateOpCodes[j];
          if (typeof opCode == "string") {
            value += opCode;
          } else if (typeof opCode == "number") {
            if (opCode < 0) {
              value += renderStringify(lView[bindingsStartIndex - opCode]);
            } else {
              const nodeIndex = opCode >>> 2;
              switch (opCode & 3) {
                case 1:
                  const propName = updateOpCodes[++j];
                  const sanitizeFn = updateOpCodes[++j];
                  const tNodeOrTagName = tView.data[nodeIndex];
                  ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                  if (typeof tNodeOrTagName === "string") {
                    setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                  } else {
                    elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                  }
                  break;
                case 0:
                  const rText = lView[nodeIndex];
                  rText !== null && updateTextNode(lView[RENDERER], rText, value);
                  break;
                case 2:
                  applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                  break;
                case 3:
                  applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                  break;
              }
            }
          }
        }
      } else {
        const opCode = updateOpCodes[i + 1];
        if (opCode > 0 && (opCode & 3) === 3) {
          const nodeIndex = opCode >>> 2;
          const tIcu = getTIcu(tView, nodeIndex);
          const currentIndex = lView[tIcu.currentCaseLViewIndex];
          if (currentIndex < 0) {
            applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
          }
        }
      }
      i += skipCodes;
    }
  }
  function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
    if (activeCaseIndex !== null) {
      let mask = changeMask;
      if (activeCaseIndex < 0) {
        activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
        mask = -1;
      }
      applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
    }
  }
  function applyIcuSwitchCase(tView, tIcu, lView, value) {
    const caseIndex = getCaseIndex(tIcu, value);
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== caseIndex) {
      applyIcuSwitchCaseRemove(tView, tIcu, lView);
      lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
      if (caseIndex !== null) {
        const anchorRNode = lView[tIcu.anchorIdx];
        if (anchorRNode) {
          ngDevMode && assertDomNode(anchorRNode);
          applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
        }
      }
    }
  }
  function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== null) {
      const removeCodes = tIcu.remove[activeCaseIndex];
      for (let i = 0; i < removeCodes.length; i++) {
        const nodeOrIcuIndex = removeCodes[i];
        if (nodeOrIcuIndex > 0) {
          const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
          rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
        } else {
          applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
        }
      }
    }
  }
  function getCaseIndex(icuExpression, bindingValue) {
    let index = icuExpression.cases.indexOf(bindingValue);
    if (index === -1) {
      switch (icuExpression.type) {
        case 1: {
          const resolvedCase = getPluralCase(bindingValue, getLocaleId());
          index = icuExpression.cases.indexOf(resolvedCase);
          if (index === -1 && resolvedCase !== "other") {
            index = icuExpression.cases.indexOf("other");
          }
          break;
        }
        case 0: {
          index = icuExpression.cases.indexOf("other");
          break;
        }
      }
    }
    return index === -1 ? null : index;
  }
  function loadIcuContainerVisitor() {
    const _stack = [];
    let _index = -1;
    let _lView;
    let _removes;
    function icuContainerIteratorStart(tIcuContainerNode, lView) {
      _lView = lView;
      while (_stack.length)
        _stack.pop();
      ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
      enterIcu(tIcuContainerNode.value, lView);
      return icuContainerIteratorNext;
    }
    function enterIcu(tIcu, lView) {
      _index = 0;
      const currentCase = getCurrentICUCaseIndex(tIcu, lView);
      if (currentCase !== null) {
        ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
        _removes = tIcu.remove[currentCase];
      } else {
        _removes = EMPTY_ARRAY;
      }
    }
    function icuContainerIteratorNext() {
      if (_index < _removes.length) {
        const removeOpCode = _removes[_index++];
        ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
        if (removeOpCode > 0) {
          const rNode = _lView[removeOpCode];
          ngDevMode && assertDomNode(rNode);
          return rNode;
        } else {
          _stack.push(_index, _removes);
          const tIcuIndex = ~removeOpCode;
          const tIcu = _lView[TVIEW].data[tIcuIndex];
          ngDevMode && assertTIcu(tIcu);
          enterIcu(tIcu, _lView);
          return icuContainerIteratorNext();
        }
      } else {
        if (_stack.length === 0) {
          return null;
        } else {
          _removes = _stack.pop();
          _index = _stack.pop();
          return icuContainerIteratorNext();
        }
      }
    }
    return icuContainerIteratorStart;
  }
  function i18nCreateOpCodesToString(opcodes) {
    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for (let i = 0; i < createOpCodes.length; i++) {
      const opCode = createOpCodes[i++];
      const text = createOpCodes[i];
      const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
      const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
      const index = opCode >>> I18nCreateOpCode.SHIFT;
      lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
      if (appendNow) {
        lines.push(`parent.appendChild(lView[${index}]);`);
      }
    }
    return lines;
  }
  function i18nUpdateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(value) {
      const ref = value >>> 2;
      const opCode = value & 3;
      switch (opCode) {
        case 0:
          return `(lView[${ref}] as Text).textContent = $$$`;
        case 1:
          const attrName = parser.consumeString();
          const sanitizationFn = parser.consumeFunction();
          const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
          return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
        case 2:
          return `icuSwitchCase(${ref}, $$$)`;
        case 3:
          return `icuUpdateCase(${ref})`;
      }
      throw new Error("unexpected OpCode");
    }
    while (parser.hasMore()) {
      let mask = parser.consumeNumber();
      let size = parser.consumeNumber();
      const end = parser.i + size;
      const statements = [];
      let statement = "";
      while (parser.i < end) {
        let value = parser.consumeNumberOrString();
        if (typeof value === "string") {
          statement += value;
        } else if (value < 0) {
          statement += "${lView[i" + value + "]}";
        } else {
          const opCodeText = consumeOpCode(value);
          statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
          statement = "";
        }
      }
      lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
    }
    return lines;
  }
  function icuCreateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(opCode) {
      const parent = getParentFromIcuCreateOpCode(opCode);
      const ref = getRefFromIcuCreateOpCode(opCode);
      switch (getInstructionFromIcuCreateOpCode(opCode)) {
        case 0:
          return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
        case 1:
          return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
      }
      throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
    }
    let lastRef = -1;
    while (parser.hasMore()) {
      let value = parser.consumeNumberStringOrMarker();
      if (value === ICU_MARKER) {
        const text = parser.consumeString();
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
      } else if (value === ELEMENT_MARKER) {
        const text = parser.consumeString();
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
      } else if (typeof value === "string") {
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
      } else if (typeof value === "number") {
        const line = consumeOpCode(value);
        line && lines.push(line);
      } else {
        throw new Error("Unexpected value");
      }
    }
    return lines;
  }
  function i18nRemoveOpCodesToString(opcodes) {
    const removeCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        lines.push(`remove(lView[${nodeOrIcuIndex}])`);
      } else {
        lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
      }
    }
    return lines;
  }
  var OpCodeParser = class {
    constructor(codes) {
      this.i = 0;
      this.codes = codes;
    }
    hasMore() {
      return this.i < this.codes.length;
    }
    consumeNumber() {
      let value = this.codes[this.i++];
      assertNumber(value, "expecting number in OpCode");
      return value;
    }
    consumeString() {
      let value = this.codes[this.i++];
      assertString(value, "expecting string in OpCode");
      return value;
    }
    consumeFunction() {
      let value = this.codes[this.i++];
      if (value === null || typeof value === "function") {
        return value;
      }
      throw new Error("expecting function in OpCode");
    }
    consumeNumberOrString() {
      let value = this.codes[this.i++];
      if (typeof value === "string") {
        return value;
      }
      assertNumber(value, "expecting number or string in OpCode");
      return value;
    }
    consumeNumberStringOrMarker() {
      let value = this.codes[this.i++];
      if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
        return value;
      }
      assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
      return value;
    }
  };
  var BINDING_REGEXP = /�(\d+):?\d*�/gi;
  var ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
  var NESTED_ICU = /�(\d+)�/;
  var ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
  var MARKER = `\uFFFD`;
  var SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
  var PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
  var NGSP_UNICODE_REGEXP = /\uE500/g;
  function replaceNgsp(value) {
    return value.replace(NGSP_UNICODE_REGEXP, " ");
  }
  function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
    const rootTNode = getCurrentParentTNode();
    const createOpCodes = [];
    const updateOpCodes = [];
    const existingTNodeStack = [[]];
    if (ngDevMode) {
      attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    message = getTranslationForTemplate(message, subTemplateIndex);
    const msgParts = replaceNgsp(message).split(PH_REGEXP);
    for (let i = 0; i < msgParts.length; i++) {
      let value = msgParts[i];
      if ((i & 1) === 0) {
        const parts = i18nParseTextIntoPartsAndICU(value);
        for (let j = 0; j < parts.length; j++) {
          let part = parts[j];
          if ((j & 1) === 0) {
            const text = part;
            ngDevMode && assertString(text, "Parsed ICU part should be string");
            if (text !== "") {
              i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
            }
          } else {
            const icuExpression = part;
            if (typeof icuExpression !== "object") {
              throw new Error(`Unable to parse ICU expression in "${message}" message.`);
            }
            const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
            const icuNodeIndex = icuContainerTNode.index;
            ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
            icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
          }
        }
      } else {
        const isClosing = value.charCodeAt(0) === 47;
        const type = value.charCodeAt(isClosing ? 1 : 0);
        ngDevMode && assertOneOf(type, 42, 35);
        const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
        if (isClosing) {
          existingTNodeStack.shift();
          setCurrentTNode(getCurrentParentTNode(), false);
        } else {
          const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
          existingTNodeStack.unshift([]);
          setCurrentTNode(tNode, true);
        }
      }
    }
    tView.data[index] = {
      create: createOpCodes,
      update: updateOpCodes
    };
  }
  function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
    const i18nNodeIdx = allocExpando(tView, lView, 1, null);
    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
    let parentTNode = getCurrentParentTNode();
    if (rootTNode === parentTNode) {
      parentTNode = null;
    }
    if (parentTNode === null) {
      opCode |= I18nCreateOpCode.APPEND_EAGERLY;
    }
    if (isICU) {
      opCode |= I18nCreateOpCode.COMMENT;
      ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
    }
    createOpCodes.push(opCode, text === null ? "" : text);
    const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
    const tNodeIdx = tNode.index;
    setCurrentTNode(tNode, false);
    if (parentTNode !== null && rootTNode !== parentTNode) {
      setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
    }
    return tNode;
  }
  function i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
    const hasBinding = text.match(BINDING_REGEXP);
    const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
    if (hasBinding) {
      generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);
    }
  }
  function i18nAttributesFirstPass(tView, index, values) {
    const previousElement = getCurrentTNode();
    const previousElementIndex = previousElement.index;
    const updateOpCodes = [];
    if (ngDevMode) {
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    if (tView.firstCreatePass && tView.data[index] === null) {
      for (let i = 0; i < values.length; i += 2) {
        const attrName = values[i];
        const message = values[i + 1];
        if (message !== "") {
          if (ICU_REGEXP.test(message)) {
            throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
          }
          generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
        }
      }
      tView.data[index] = updateOpCodes;
    }
  }
  function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
    ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
    const maskIndex = updateOpCodes.length;
    const sizeIndex = maskIndex + 1;
    updateOpCodes.push(null, null);
    const startIndex = maskIndex + 2;
    if (ngDevMode) {
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    const textParts = str.split(BINDING_REGEXP);
    let mask = 0;
    for (let j = 0; j < textParts.length; j++) {
      const textValue = textParts[j];
      if (j & 1) {
        const bindingIndex = bindingStart + parseInt(textValue, 10);
        updateOpCodes.push(-1 - bindingIndex);
        mask = mask | toMaskBit(bindingIndex);
      } else if (textValue !== "") {
        updateOpCodes.push(textValue);
      }
    }
    updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
    if (attrName) {
      updateOpCodes.push(attrName, sanitizeFn);
    }
    updateOpCodes[maskIndex] = mask;
    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
    return mask;
  }
  function countBindings(opCodes) {
    let count = 0;
    for (let i = 0; i < opCodes.length; i++) {
      const opCode = opCodes[i];
      if (typeof opCode === "number" && opCode < 0) {
        count++;
      }
    }
    return count;
  }
  function toMaskBit(bindingIndex) {
    return 1 << Math.min(bindingIndex, 31);
  }
  function isRootTemplateMessage(subTemplateIndex) {
    return subTemplateIndex === -1;
  }
  function removeInnerTemplateTranslation(message) {
    let match;
    let res = "";
    let index = 0;
    let inTemplate = false;
    let tagMatched;
    while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
      if (!inTemplate) {
        res += message.substring(index, match.index + match[0].length);
        tagMatched = match[1];
        inTemplate = true;
      } else {
        if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
          index = match.index;
          inTemplate = false;
        }
      }
    }
    ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
    res += message.substr(index);
    return res;
  }
  function getTranslationForTemplate(message, subTemplateIndex) {
    if (isRootTemplateMessage(subTemplateIndex)) {
      return removeInnerTemplateTranslation(message);
    } else {
      const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
      const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
      return removeInnerTemplateTranslation(message.substring(start, end));
    }
  }
  function icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
    ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
    let bindingMask = 0;
    const tIcu = {
      type: icuExpression.type,
      currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
      anchorIdx,
      cases: [],
      create: [],
      remove: [],
      update: []
    };
    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
    setTIcu(tView, anchorIdx, tIcu);
    const values = icuExpression.values;
    for (let i = 0; i < values.length; i++) {
      const valueArr = values[i];
      const nestedIcus = [];
      for (let j = 0; j < valueArr.length; j++) {
        const value = valueArr[j];
        if (typeof value !== "string") {
          const icuIndex = nestedIcus.push(value) - 1;
          valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
        }
      }
      bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
    }
    if (bindingMask) {
      addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
    }
  }
  function parseICUBlock(pattern) {
    const cases = [];
    const values = [];
    let icuType = 1;
    let mainBinding = 0;
    pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
      if (type === "select") {
        icuType = 0;
      } else {
        icuType = 1;
      }
      mainBinding = parseInt(binding.substr(1), 10);
      return "";
    });
    const parts = i18nParseTextIntoPartsAndICU(pattern);
    for (let pos = 0; pos < parts.length; ) {
      let key = parts[pos++].trim();
      if (icuType === 1) {
        key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
      }
      if (key.length) {
        cases.push(key);
      }
      const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
      if (cases.length > values.length) {
        values.push(blocks);
      }
    }
    return { type: icuType, mainBinding, cases, values };
  }
  function i18nParseTextIntoPartsAndICU(pattern) {
    if (!pattern) {
      return [];
    }
    let prevPos = 0;
    const braceStack = [];
    const results = [];
    const braces = /[{}]/g;
    braces.lastIndex = 0;
    let match;
    while (match = braces.exec(pattern)) {
      const pos = match.index;
      if (match[0] == "}") {
        braceStack.pop();
        if (braceStack.length == 0) {
          const block = pattern.substring(prevPos, pos);
          if (ICU_BLOCK_REGEXP.test(block)) {
            results.push(parseICUBlock(block));
          } else {
            results.push(block);
          }
          prevPos = pos + 1;
        }
      } else {
        if (braceStack.length == 0) {
          const substring2 = pattern.substring(prevPos, pos);
          results.push(substring2);
          prevPos = pos + 1;
        }
        braceStack.push("{");
      }
    }
    const substring = pattern.substring(prevPos);
    results.push(substring);
    return results;
  }
  function parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
    const create = [];
    const remove2 = [];
    const update = [];
    if (ngDevMode) {
      attachDebugGetter(create, icuCreateOpCodesToString);
      attachDebugGetter(remove2, i18nRemoveOpCodesToString);
      attachDebugGetter(update, i18nUpdateOpCodesToString);
    }
    tIcu.cases.push(caseName);
    tIcu.create.push(create);
    tIcu.remove.push(remove2);
    tIcu.update.push(update);
    const inertBodyHelper2 = getInertBodyHelper(getDocument());
    const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
    ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
    if (inertRootNode) {
      return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
    } else {
      return 0;
    }
  }
  function walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
    let bindingMask = 0;
    let currentNode = parentNode.firstChild;
    while (currentNode) {
      const newIndex = allocExpando(tView, lView, 1, null);
      switch (currentNode.nodeType) {
        case Node.ELEMENT_NODE:
          const element2 = currentNode;
          const tagName = element2.tagName.toLowerCase();
          if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
            addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
            tView.data[newIndex] = tagName;
            const elAttrs = element2.attributes;
            for (let i = 0; i < elAttrs.length; i++) {
              const attr = elAttrs.item(i);
              const lowerAttrName = attr.name.toLowerCase();
              const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
              if (hasBinding2) {
                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                  if (URI_ATTRS[lowerAttrName]) {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                  } else if (SRCSET_ATTRS[lowerAttrName]) {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, sanitizeSrcset);
                  } else {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                  }
                } else {
                  ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see https://g.co/ng/security#xss)`);
                }
              } else {
                addCreateAttribute(create, newIndex, attr);
              }
            }
            bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
            addRemoveNode(remove2, newIndex, depth);
          }
          break;
        case Node.TEXT_NODE:
          const value = currentNode.textContent || "";
          const hasBinding = value.match(BINDING_REGEXP);
          addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
          addRemoveNode(remove2, newIndex, depth);
          if (hasBinding) {
            bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
          }
          break;
        case Node.COMMENT_NODE:
          const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
          if (isNestedIcu) {
            const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
            const icuExpression = nestedIcus[nestedIcuIndex];
            addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
            icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
            addRemoveNestedIcu(remove2, newIndex, depth);
          }
          break;
      }
      currentNode = currentNode.nextSibling;
    }
    return bindingMask;
  }
  function addRemoveNode(remove2, index, depth) {
    if (depth === 0) {
      remove2.push(index);
    }
  }
  function addRemoveNestedIcu(remove2, index, depth) {
    if (depth === 0) {
      remove2.push(~index);
      remove2.push(index);
    }
  }
  function addUpdateIcuSwitch(update, icuExpression, index) {
    update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
  }
  function addUpdateIcuUpdate(update, bindingMask, index) {
    update.push(bindingMask, 1, index << 2 | 3);
  }
  function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
    if (marker !== null) {
      create.push(marker);
    }
    create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
  }
  function addCreateAttribute(create, newIndex, attr) {
    create.push(newIndex << 1 | 1, attr.name, attr.value);
  }
  var ROOT_TEMPLATE_ID = 0;
  var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
  var PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
  var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
  var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
  var PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
  var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
  var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
  function i18nPostprocess(message, replacements = {}) {
    let result = message;
    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
      const matches = {};
      const templateIdsStack = [ROOT_TEMPLATE_ID];
      result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
        const content = phs || tmpl;
        const placeholders = matches[content] || [];
        if (!placeholders.length) {
          content.split("|").forEach((placeholder2) => {
            const match = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
            const templateId2 = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
            const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
            placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
          });
          matches[content] = placeholders;
        }
        if (!placeholders.length) {
          throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
        }
        const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
        let idx = 0;
        for (let i = 0; i < placeholders.length; i++) {
          if (placeholders[i][0] === currentTemplateId) {
            idx = i;
            break;
          }
        }
        const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
        if (isCloseTemplateTag) {
          templateIdsStack.pop();
        } else if (currentTemplateId !== templateId) {
          templateIdsStack.push(templateId);
        }
        placeholders.splice(idx, 1);
        return placeholder;
      });
    }
    if (!Object.keys(replacements).length) {
      return result;
    }
    result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
      return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
    });
    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
      return replacements.hasOwnProperty(key) ? replacements[key] : match;
    });
    result = result.replace(PP_ICUS_REGEXP, (match, key) => {
      if (replacements.hasOwnProperty(key)) {
        const list = replacements[key];
        if (!list.length) {
          throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
        }
        return list.shift();
      }
      return match;
    });
    return result;
  }
  function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
    const tView = getTView();
    const lView = getLView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const message = getConstant(tView.consts, messageIndex);
    const parentTNode = getCurrentParentTNode();
    if (tView.firstCreatePass) {
      i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
    }
    const tI18n = tView.data[adjustedIndex];
    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
    const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
    setInI18nBlock(true);
  }
  function \u0275\u0275i18nEnd() {
    setInI18nBlock(false);
  }
  function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
    \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
    \u0275\u0275i18nEnd();
  }
  function \u0275\u0275i18nAttributes(index, attrsIndex) {
    const tView = getTView();
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const attrs = getConstant(tView.consts, attrsIndex);
    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
  }
  function \u0275\u0275i18nExp(value) {
    const lView = getLView();
    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
    return \u0275\u0275i18nExp;
  }
  function \u0275\u0275i18nApply(index) {
    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
  }
  function \u0275\u0275i18nPostprocess(message, replacements = {}) {
    return i18nPostprocess(message, replacements);
  }
  function providersResolver(def, providers, viewProviders) {
    const tView = getTView();
    if (tView.firstCreatePass) {
      const isComponent = isComponentDef(def);
      resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);
      resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);
    }
  }
  function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
    provider = resolveForwardRef(provider);
    if (Array.isArray(provider)) {
      for (let i = 0; i < provider.length; i++) {
        resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
      }
    } else {
      const tView = getTView();
      const lView = getLView();
      let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
      let providerFactory = providerToFactory(provider);
      const tNode = getCurrentTNode();
      const beginIndex = tNode.providerIndexes & 1048575;
      const endIndex = tNode.directiveStart;
      const cptViewProvidersCount = tNode.providerIndexes >> 20;
      if (isTypeProvider(provider) || !provider.multi) {
        const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
        const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
        if (existingFactoryIndex === -1) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
          registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
          tInjectables.push(token);
          tNode.directiveStart++;
          tNode.directiveEnd++;
          if (isViewProvider) {
            tNode.providerIndexes += 1048576;
          }
          lInjectablesBlueprint.push(factory);
          lView.push(factory);
        } else {
          lInjectablesBlueprint[existingFactoryIndex] = factory;
          lView[existingFactoryIndex] = factory;
        }
      } else {
        const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
        const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
        const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
        const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
        if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
          const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
          if (!isViewProvider && doesViewProvidersFactoryExist) {
            lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
          }
          registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
          tInjectables.push(token);
          tNode.directiveStart++;
          tNode.directiveEnd++;
          if (isViewProvider) {
            tNode.providerIndexes += 1048576;
          }
          lInjectablesBlueprint.push(factory);
          lView.push(factory);
        } else {
          const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
          registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
        }
        if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
        }
      }
    }
  }
  function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
    const providerIsTypeProvider = isTypeProvider(provider);
    const providerIsClassProvider = isClassProvider(provider);
    if (providerIsTypeProvider || providerIsClassProvider) {
      const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
      const prototype = classToken.prototype;
      const ngOnDestroy = prototype.ngOnDestroy;
      if (ngOnDestroy) {
        const hooks = tView.destroyHooks || (tView.destroyHooks = []);
        if (!providerIsTypeProvider && provider.multi) {
          ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
          const existingCallbacksIndex = hooks.indexOf(contextIndex);
          if (existingCallbacksIndex === -1) {
            hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
          } else {
            hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
          }
        } else {
          hooks.push(contextIndex, ngOnDestroy);
        }
      }
    }
  }
  function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
    if (isComponentProvider) {
      multiFactory2.componentProviders++;
    }
    return multiFactory2.multi.push(factory) - 1;
  }
  function indexOf(item, arr, begin, end) {
    for (let i = begin; i < end; i++) {
      if (arr[i] === item)
        return i;
    }
    return -1;
  }
  function multiProvidersFactoryResolver(_, tData, lData, tNode) {
    return multiResolve(this.multi, []);
  }
  function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
    const factories = this.multi;
    let result;
    if (this.providerFactory) {
      const componentCount = this.providerFactory.componentProviders;
      const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
      result = multiProviders.slice(0, componentCount);
      multiResolve(factories, result);
      for (let i = componentCount; i < multiProviders.length; i++) {
        result.push(multiProviders[i]);
      }
    } else {
      result = [];
      multiResolve(factories, result);
    }
    return result;
  }
  function multiResolve(factories, result) {
    for (let i = 0; i < factories.length; i++) {
      const factory = factories[i];
      result.push(factory());
    }
    return result;
  }
  function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
    factory.multi = [];
    factory.index = index;
    factory.componentProviders = 0;
    multiFactoryAdd(factory, f, isComponent && !isViewProvider);
    return factory;
  }
  function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
    return (definition) => {
      definition.providersResolver = (def, processProvidersFn) => {
        return providersResolver(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
      };
    };
  }
  var ComponentRef$1 = class {
  };
  var ComponentFactory$1 = class {
  };
  function noComponentFactoryError(component) {
    const error3 = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
    error3[ERROR_COMPONENT] = component;
    return error3;
  }
  var ERROR_COMPONENT = "ngComponent";
  var _NullComponentFactoryResolver = class {
    resolveComponentFactory(component) {
      throw noComponentFactoryError(component);
    }
  };
  var ComponentFactoryResolver$1 = class {
  };
  ComponentFactoryResolver$1.NULL = /* @__PURE__ */ new _NullComponentFactoryResolver();
  function injectElementRef() {
    return createElementRef(getCurrentTNode(), getLView());
  }
  function createElementRef(tNode, lView) {
    return new ElementRef(getNativeByTNode(tNode, lView));
  }
  var ElementRef = class {
    constructor(nativeElement) {
      this.nativeElement = nativeElement;
    }
  };
  ElementRef.__NG_ELEMENT_ID__ = injectElementRef;
  function unwrapElementRef(value) {
    return value instanceof ElementRef ? value.nativeElement : value;
  }
  var Renderer2Interceptor = new InjectionToken("Renderer2Interceptor");
  var RendererFactory2 = class {
  };
  var Renderer2 = class {
  };
  Renderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();
  function getOrCreateRenderer2(lView) {
    const renderer = lView[RENDERER];
    if (ngDevMode && !isProceduralRenderer(renderer)) {
      throw new Error("Cannot inject Renderer2 when the application uses Renderer3!");
    }
    return renderer;
  }
  function injectRenderer2() {
    const lView = getLView();
    const tNode = getCurrentTNode();
    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
    return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);
  }
  var Sanitizer = class {
  };
  Sanitizer.\u0275prov = \u0275\u0275defineInjectable({
    token: Sanitizer,
    providedIn: "root",
    factory: () => null
  });
  var Version = class {
    constructor(full) {
      this.full = full;
      this.major = full.split(".")[0];
      this.minor = full.split(".")[1];
      this.patch = full.split(".").slice(2).join(".");
    }
  };
  var VERSION = new Version("13.3.3");
  var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
  function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
    while (tNode !== null) {
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
      const lNode = lView[tNode.index];
      if (lNode !== null) {
        result.push(unwrapRNode(lNode));
      }
      if (isLContainer(lNode)) {
        for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
          const lViewInAContainer = lNode[i];
          const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
          if (lViewFirstChildTNode !== null) {
            collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
          }
        }
      }
      const tNodeType = tNode.type;
      if (tNodeType & 8) {
        collectNativeNodes(tView, lView, tNode.child, result);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          result.push(rNode);
        }
      } else if (tNodeType & 16) {
        const nodesInSlot = getProjectionNodes(lView, tNode);
        if (Array.isArray(nodesInSlot)) {
          result.push(...nodesInSlot);
        } else {
          const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
          ngDevMode && assertParentView(parentView);
          collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
        }
      }
      tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
    return result;
  }
  var ViewRef$1 = class {
    constructor(_lView, _cdRefInjectingView) {
      this._lView = _lView;
      this._cdRefInjectingView = _cdRefInjectingView;
      this._appRef = null;
      this._attachedToViewContainer = false;
    }
    get rootNodes() {
      const lView = this._lView;
      const tView = lView[TVIEW];
      return collectNativeNodes(tView, lView, tView.firstChild, []);
    }
    get context() {
      return this._lView[CONTEXT];
    }
    set context(value) {
      this._lView[CONTEXT] = value;
    }
    get destroyed() {
      return (this._lView[FLAGS] & 256) === 256;
    }
    destroy() {
      if (this._appRef) {
        this._appRef.detachView(this);
      } else if (this._attachedToViewContainer) {
        const parent = this._lView[PARENT];
        if (isLContainer(parent)) {
          const viewRefs = parent[VIEW_REFS];
          const index = viewRefs ? viewRefs.indexOf(this) : -1;
          if (index > -1) {
            ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
            detachView(parent, index);
            removeFromArray(viewRefs, index);
          }
        }
        this._attachedToViewContainer = false;
      }
      destroyLView(this._lView[TVIEW], this._lView);
    }
    onDestroy(callback) {
      storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);
    }
    markForCheck() {
      markViewDirty(this._cdRefInjectingView || this._lView);
    }
    detach() {
      this._lView[FLAGS] &= ~128;
    }
    reattach() {
      this._lView[FLAGS] |= 128;
    }
    detectChanges() {
      detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    checkNoChanges() {
      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    attachToViewContainerRef() {
      if (this._appRef) {
        const errorMessage = ngDevMode ? "This view is already attached directly to the ApplicationRef!" : "";
        throw new RuntimeError(902, errorMessage);
      }
      this._attachedToViewContainer = true;
    }
    detachFromAppRef() {
      this._appRef = null;
      renderDetachView(this._lView[TVIEW], this._lView);
    }
    attachToAppRef(appRef) {
      if (this._attachedToViewContainer) {
        const errorMessage = ngDevMode ? "This view is already attached to a ViewContainer!" : "";
        throw new RuntimeError(902, errorMessage);
      }
      this._appRef = appRef;
    }
  };
  var RootViewRef = class extends ViewRef$1 {
    constructor(_view) {
      super(_view);
      this._view = _view;
    }
    detectChanges() {
      detectChangesInRootView(this._view);
    }
    checkNoChanges() {
      checkNoChangesInRootView(this._view);
    }
    get context() {
      return null;
    }
  };
  var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
    constructor(ngModule) {
      super();
      this.ngModule = ngModule;
    }
    resolveComponentFactory(component) {
      ngDevMode && assertComponentType(component);
      const componentDef = getComponentDef(component);
      return new ComponentFactory(componentDef, this.ngModule);
    }
  };
  function toRefArray(map2) {
    const array = [];
    for (let nonMinified in map2) {
      if (map2.hasOwnProperty(nonMinified)) {
        const minified = map2[nonMinified];
        array.push({ propName: minified, templateName: nonMinified });
      }
    }
    return array;
  }
  function getNamespace(elementName) {
    const name = elementName.toLowerCase();
    return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
  }
  function createChainedInjector(rootViewInjector, moduleInjector) {
    return {
      get: (token, notFoundValue, flags) => {
        const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
          return value;
        }
        return moduleInjector.get(token, notFoundValue, flags);
      }
    };
  }
  var ComponentFactory = class extends ComponentFactory$1 {
    constructor(componentDef, ngModule) {
      super();
      this.componentDef = componentDef;
      this.ngModule = ngModule;
      this.componentType = componentDef.type;
      this.selector = stringifyCSSSelectorList(componentDef.selectors);
      this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
      this.isBoundToModule = !!ngModule;
    }
    get inputs() {
      return toRefArray(this.componentDef.inputs);
    }
    get outputs() {
      return toRefArray(this.componentDef.outputs);
    }
    create(injector2, projectableNodes, rootSelectorOrNode, ngModule) {
      ngModule = ngModule || this.ngModule;
      const rootViewInjector = ngModule ? createChainedInjector(injector2, ngModule.injector) : injector2;
      const rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || "div";
      const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) : createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, getNamespace(elementName));
      const rootFlags = this.componentDef.onPush ? 64 | 512 : 16 | 512;
      const rootContext = createRootContext();
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null);
      const rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector);
      enterView(rootLView);
      let component;
      let tElementNode;
      try {
        const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
        if (hostRNode) {
          if (rootSelectorOrNode) {
            setUpAttributes(hostRenderer, hostRNode, ["ng-version", VERSION.full]);
          } else {
            const { attrs, classes } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);
            if (attrs) {
              setUpAttributes(hostRenderer, hostRNode, attrs);
            }
            if (classes && classes.length > 0) {
              writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
            }
          }
        }
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (projectableNodes !== void 0) {
          const projection = tElementNode.projection = [];
          for (let i = 0; i < this.ngContentSelectors.length; i++) {
            const nodesforSlot = projectableNodes[i];
            projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
          }
        }
        component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } finally {
        leaveView();
      }
      return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    }
  };
  var componentFactoryResolver = new ComponentFactoryResolver();
  var ComponentRef = class extends ComponentRef$1 {
    constructor(componentType, instance, location2, _rootLView, _tNode) {
      super();
      this.location = location2;
      this._rootLView = _rootLView;
      this._tNode = _tNode;
      this.instance = instance;
      this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
      this.componentType = componentType;
    }
    get injector() {
      return new NodeInjector(this._tNode, this._rootLView);
    }
    destroy() {
      this.hostView.destroy();
    }
    onDestroy(callback) {
      this.hostView.onDestroy(callback);
    }
  };
  function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
    return noSideEffects(() => {
      const clazz = type;
      if (decorators !== null) {
        if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
          clazz.decorators.push(...decorators);
        } else {
          clazz.decorators = decorators;
        }
      }
      if (ctorParameters !== null) {
        clazz.ctorParameters = ctorParameters;
      }
      if (propDecorators !== null) {
        if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
          clazz.propDecorators = { ...clazz.propDecorators, ...propDecorators };
        } else {
          clazz.propDecorators = propDecorators;
        }
      }
    });
  }
  var NgModuleRef$1 = class {
  };
  var NgModuleFactory$1 = class {
  };
  var modules = /* @__PURE__ */ new Map();
  function assertSameOrNotExisting(id, type, incoming) {
    if (type && type !== incoming) {
      throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
    }
  }
  function registerNgModuleType(ngModuleType) {
    const visited = /* @__PURE__ */ new Set();
    recurse(ngModuleType);
    function recurse(ngModuleType2) {
      const def = getNgModuleDef(ngModuleType2, true);
      const id = def.id;
      if (id !== null) {
        const existing = modules.get(id);
        assertSameOrNotExisting(id, existing, ngModuleType2);
        modules.set(id, ngModuleType2);
      }
      const imports = maybeUnwrapFn(def.imports);
      for (const i of imports) {
        if (!visited.has(i)) {
          visited.add(i);
          recurse(i);
        }
      }
    }
  }
  var NgModuleRef = class extends NgModuleRef$1 {
    constructor(ngModuleType, _parent) {
      super();
      this._parent = _parent;
      this._bootstrapComponents = [];
      this.injector = this;
      this.destroyCbs = [];
      this.componentFactoryResolver = new ComponentFactoryResolver(this);
      const ngModuleDef = getNgModuleDef(ngModuleType);
      ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
      this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
      this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
        { provide: NgModuleRef$1, useValue: this },
        {
          provide: ComponentFactoryResolver$1,
          useValue: this.componentFactoryResolver
        }
      ], stringify(ngModuleType));
      this._r3Injector._resolveInjectorDefTypes();
      this.instance = this.get(ngModuleType);
    }
    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
      if (token === Injector || token === NgModuleRef$1 || token === INJECTOR) {
        return this;
      }
      return this._r3Injector.get(token, notFoundValue, injectFlags);
    }
    destroy() {
      ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
      const injector2 = this._r3Injector;
      !injector2.destroyed && injector2.destroy();
      this.destroyCbs.forEach((fn2) => fn2());
      this.destroyCbs = null;
    }
    onDestroy(callback) {
      ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
      this.destroyCbs.push(callback);
    }
  };
  var NgModuleFactory = class extends NgModuleFactory$1 {
    constructor(moduleType) {
      super();
      this.moduleType = moduleType;
      const ngModuleDef = getNgModuleDef(moduleType);
      if (ngModuleDef !== null) {
        registerNgModuleType(moduleType);
      }
    }
    create(parentInjector) {
      return new NgModuleRef(this.moduleType, parentInjector);
    }
  };
  function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
  }
  function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
  }
  function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
    return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
  }
  function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
  }
  function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
  }
  function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
  }
  function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
  }
  function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
  }
  function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
  }
  function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
  }
  function getPureFunctionReturnValue(lView, returnValueIndex) {
    ngDevMode && assertIndexInRange(lView, returnValueIndex);
    const lastReturnValue = lView[returnValueIndex];
    return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
  }
  function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
  }
  function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
  }
  function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
  }
  function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
  }
  function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
    let bindingIndex = bindingRoot + slotOffset;
    let different = false;
    for (let i = 0; i < exps.length; i++) {
      bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
    }
    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
  }
  function \u0275\u0275pipe(index, pipeName) {
    const tView = getTView();
    let pipeDef;
    const adjustedIndex = index + HEADER_OFFSET;
    if (tView.firstCreatePass) {
      pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
      tView.data[adjustedIndex] = pipeDef;
      if (pipeDef.onDestroy) {
        (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);
      }
    } else {
      pipeDef = tView.data[adjustedIndex];
    }
    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
    const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
    try {
      const previousIncludeViewProviders = setIncludeViewProviders(false);
      const pipeInstance = pipeFactory();
      setIncludeViewProviders(previousIncludeViewProviders);
      store(tView, getLView(), adjustedIndex, pipeInstance);
      return pipeInstance;
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  function getPipeDef(name, registry) {
    if (registry) {
      for (let i = registry.length - 1; i >= 0; i--) {
        const pipeDef = registry[i];
        if (name === pipeDef.name) {
          return pipeDef;
        }
      }
    }
    if (ngDevMode) {
      const lView = getLView();
      const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
      const context = declarationLView[CONTEXT];
      const component = context ? ` in the '${context.constructor.name}' component` : "";
      throw new RuntimeError(-302, `The pipe '${name}' could not be found${component}!`);
    }
  }
  function \u0275\u0275pipeBind1(index, slotOffset, v1) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
  }
  function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
  }
  function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
  }
  function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
  }
  function \u0275\u0275pipeBindV(index, slotOffset, values) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
  }
  function isPure(lView, index) {
    return lView[TVIEW].data[index].pure;
  }
  var EventEmitter_ = class extends Subject {
    constructor(isAsync = false) {
      super();
      this.__isAsync = isAsync;
    }
    emit(value) {
      super.next(value);
    }
    subscribe(observerOrNext, error3, complete) {
      let nextFn = observerOrNext;
      let errorFn = error3 || (() => null);
      let completeFn = complete;
      if (observerOrNext && typeof observerOrNext === "object") {
        const observer = observerOrNext;
        nextFn = observer.next?.bind(observer);
        errorFn = observer.error?.bind(observer);
        completeFn = observer.complete?.bind(observer);
      }
      if (this.__isAsync) {
        errorFn = _wrapInTimeout(errorFn);
        if (nextFn) {
          nextFn = _wrapInTimeout(nextFn);
        }
        if (completeFn) {
          completeFn = _wrapInTimeout(completeFn);
        }
      }
      const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
      if (observerOrNext instanceof Subscription) {
        observerOrNext.add(sink);
      }
      return sink;
    }
  };
  function _wrapInTimeout(fn2) {
    return (value) => {
      setTimeout(fn2, void 0, value);
    };
  }
  var EventEmitter = EventEmitter_;
  function symbolIterator() {
    return this._results[getSymbolIterator2()]();
  }
  var QueryList = class {
    constructor(_emitDistinctChangesOnly = false) {
      this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
      this.dirty = true;
      this._results = [];
      this._changesDetected = false;
      this._changes = null;
      this.length = 0;
      this.first = void 0;
      this.last = void 0;
      const symbol = getSymbolIterator2();
      const proto = QueryList.prototype;
      if (!proto[symbol])
        proto[symbol] = symbolIterator;
    }
    get changes() {
      return this._changes || (this._changes = new EventEmitter());
    }
    get(index) {
      return this._results[index];
    }
    map(fn2) {
      return this._results.map(fn2);
    }
    filter(fn2) {
      return this._results.filter(fn2);
    }
    find(fn2) {
      return this._results.find(fn2);
    }
    reduce(fn2, init) {
      return this._results.reduce(fn2, init);
    }
    forEach(fn2) {
      this._results.forEach(fn2);
    }
    some(fn2) {
      return this._results.some(fn2);
    }
    toArray() {
      return this._results.slice();
    }
    toString() {
      return this._results.toString();
    }
    reset(resultsTree, identityAccessor) {
      const self2 = this;
      self2.dirty = false;
      const newResultFlat = flatten(resultsTree);
      if (this._changesDetected = !arrayEquals(self2._results, newResultFlat, identityAccessor)) {
        self2._results = newResultFlat;
        self2.length = newResultFlat.length;
        self2.last = newResultFlat[this.length - 1];
        self2.first = newResultFlat[0];
      }
    }
    notifyOnChanges() {
      if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))
        this._changes.emit(this);
    }
    setDirty() {
      this.dirty = true;
    }
    destroy() {
      this.changes.complete();
      this.changes.unsubscribe();
    }
  };
  var TemplateRef = class {
  };
  TemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;
  var ViewEngineTemplateRef = TemplateRef;
  var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
    constructor(_declarationLView, _declarationTContainer, elementRef) {
      super();
      this._declarationLView = _declarationLView;
      this._declarationTContainer = _declarationTContainer;
      this.elementRef = elementRef;
    }
    createEmbeddedView(context) {
      const embeddedTView = this._declarationTContainer.tViews;
      const embeddedLView = createLView(this._declarationLView, embeddedTView, context, 16, null, embeddedTView.declTNode, null, null, null, null);
      const declarationLContainer = this._declarationLView[this._declarationTContainer.index];
      ngDevMode && assertLContainer(declarationLContainer);
      embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
      const declarationViewLQueries = this._declarationLView[QUERIES];
      if (declarationViewLQueries !== null) {
        embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
      }
      renderView(embeddedTView, embeddedLView, context);
      return new ViewRef$1(embeddedLView);
    }
  };
  function injectTemplateRef() {
    return createTemplateRef(getCurrentTNode(), getLView());
  }
  function createTemplateRef(hostTNode, hostLView) {
    if (hostTNode.type & 4) {
      ngDevMode && assertDefined(hostTNode.tViews, "TView must be allocated");
      return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
    }
    return null;
  }
  var ViewContainerRef = class {
  };
  ViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;
  function injectViewContainerRef() {
    const previousTNode = getCurrentTNode();
    return createContainerRef(previousTNode, getLView());
  }
  var VE_ViewContainerRef = ViewContainerRef;
  var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
    constructor(_lContainer, _hostTNode, _hostLView) {
      super();
      this._lContainer = _lContainer;
      this._hostTNode = _hostTNode;
      this._hostLView = _hostLView;
    }
    get element() {
      return createElementRef(this._hostTNode, this._hostLView);
    }
    get injector() {
      return new NodeInjector(this._hostTNode, this._hostLView);
    }
    get parentInjector() {
      const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
      if (hasParentInjector(parentLocation)) {
        const parentView = getParentInjectorView(parentLocation, this._hostLView);
        const injectorIndex = getParentInjectorIndex(parentLocation);
        ngDevMode && assertNodeInjector(parentView, injectorIndex);
        const parentTNode = parentView[TVIEW].data[injectorIndex + 8];
        return new NodeInjector(parentTNode, parentView);
      } else {
        return new NodeInjector(null, this._hostLView);
      }
    }
    clear() {
      while (this.length > 0) {
        this.remove(this.length - 1);
      }
    }
    get(index) {
      const viewRefs = getViewRefs(this._lContainer);
      return viewRefs !== null && viewRefs[index] || null;
    }
    get length() {
      return this._lContainer.length - CONTAINER_HEADER_OFFSET;
    }
    createEmbeddedView(templateRef, context, index) {
      const viewRef = templateRef.createEmbeddedView(context || {});
      this.insert(viewRef, index);
      return viewRef;
    }
    createComponent(componentFactoryOrType, indexOrOptions, injector2, projectableNodes, ngModuleRef) {
      const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
      let index;
      if (isComponentFactory) {
        if (ngDevMode) {
          assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
        }
        index = indexOrOptions;
      } else {
        if (ngDevMode) {
          assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
          assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
        }
        const options = indexOrOptions || {};
        index = options.index;
        injector2 = options.injector;
        projectableNodes = options.projectableNodes;
        ngModuleRef = options.ngModuleRef;
      }
      const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
      const contextInjector = injector2 || this.parentInjector;
      if (!ngModuleRef && componentFactory.ngModule == null) {
        const _injector = isComponentFactory ? contextInjector : this.parentInjector;
        const result = _injector.get(NgModuleRef$1, null);
        if (result) {
          ngModuleRef = result;
        }
      }
      const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
      this.insert(componentRef.hostView, index);
      return componentRef;
    }
    insert(viewRef, index) {
      const lView = viewRef._lView;
      const tView = lView[TVIEW];
      if (ngDevMode && viewRef.destroyed) {
        throw new Error("Cannot insert a destroyed View in a ViewContainer!");
      }
      if (viewAttachedToContainer(lView)) {
        const prevIdx = this.indexOf(viewRef);
        if (prevIdx !== -1) {
          this.detach(prevIdx);
        } else {
          const prevLContainer = lView[PARENT];
          ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
          const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
          prevVCRef.detach(prevVCRef.indexOf(viewRef));
        }
      }
      const adjustedIdx = this._adjustIndex(index);
      const lContainer = this._lContainer;
      insertView(tView, lView, lContainer, adjustedIdx);
      const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);
      const renderer = lView[RENDERER];
      const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
      if (parentRNode !== null) {
        addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
      }
      viewRef.attachToViewContainerRef();
      addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
      return viewRef;
    }
    move(viewRef, newIndex) {
      if (ngDevMode && viewRef.destroyed) {
        throw new Error("Cannot move a destroyed View in a ViewContainer!");
      }
      return this.insert(viewRef, newIndex);
    }
    indexOf(viewRef) {
      const viewRefsArr = getViewRefs(this._lContainer);
      return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
    }
    remove(index) {
      const adjustedIdx = this._adjustIndex(index, -1);
      const detachedView = detachView(this._lContainer, adjustedIdx);
      if (detachedView) {
        removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
        destroyLView(detachedView[TVIEW], detachedView);
      }
    }
    detach(index) {
      const adjustedIdx = this._adjustIndex(index, -1);
      const view = detachView(this._lContainer, adjustedIdx);
      const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
      return wasDetached ? new ViewRef$1(view) : null;
    }
    _adjustIndex(index, shift = 0) {
      if (index == null) {
        return this.length + shift;
      }
      if (ngDevMode) {
        assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
        assertLessThan(index, this.length + 1 + shift, "index");
      }
      return index;
    }
  };
  function getViewRefs(lContainer) {
    return lContainer[VIEW_REFS];
  }
  function getOrCreateViewRefs(lContainer) {
    return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
  }
  function createContainerRef(hostTNode, hostLView) {
    ngDevMode && assertTNodeType(hostTNode, 12 | 3);
    let lContainer;
    const slotValue = hostLView[hostTNode.index];
    if (isLContainer(slotValue)) {
      lContainer = slotValue;
    } else {
      let commentNode;
      if (hostTNode.type & 8) {
        commentNode = unwrapRNode(slotValue);
      } else {
        const renderer = hostLView[RENDERER];
        ngDevMode && ngDevMode.rendererCreateComment++;
        commentNode = renderer.createComment(ngDevMode ? "container" : "");
        const hostNative = getNativeByTNode(hostTNode, hostLView);
        const parentOfHostNative = nativeParentNode(renderer, hostNative);
        nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
      }
      hostLView[hostTNode.index] = lContainer = createLContainer(slotValue, hostLView, commentNode, hostTNode);
      addToViewTree(hostLView, lContainer);
    }
    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
  }
  var unusedValueExportToPlacateAjd$1 = 1;
  var unusedValueExportToPlacateAjd = 1;
  var unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd;
  var LQuery_ = class {
    constructor(queryList) {
      this.queryList = queryList;
      this.matches = null;
    }
    clone() {
      return new LQuery_(this.queryList);
    }
    setDirty() {
      this.queryList.setDirty();
    }
  };
  var LQueries_ = class {
    constructor(queries = []) {
      this.queries = queries;
    }
    createEmbeddedView(tView) {
      const tQueries = tView.queries;
      if (tQueries !== null) {
        const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
        const viewLQueries = [];
        for (let i = 0; i < noOfInheritedQueries; i++) {
          const tQuery = tQueries.getByIndex(i);
          const parentLQuery = this.queries[tQuery.indexInDeclarationView];
          viewLQueries.push(parentLQuery.clone());
        }
        return new LQueries_(viewLQueries);
      }
      return null;
    }
    insertView(tView) {
      this.dirtyQueriesWithMatches(tView);
    }
    detachView(tView) {
      this.dirtyQueriesWithMatches(tView);
    }
    dirtyQueriesWithMatches(tView) {
      for (let i = 0; i < this.queries.length; i++) {
        if (getTQuery(tView, i).matches !== null) {
          this.queries[i].setDirty();
        }
      }
    }
  };
  var TQueryMetadata_ = class {
    constructor(predicate, flags, read = null) {
      this.predicate = predicate;
      this.flags = flags;
      this.read = read;
    }
  };
  var TQueries_ = class {
    constructor(queries = []) {
      this.queries = queries;
    }
    elementStart(tView, tNode) {
      ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].elementStart(tView, tNode);
      }
    }
    elementEnd(tNode) {
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].elementEnd(tNode);
      }
    }
    embeddedTView(tNode) {
      let queriesForTemplateRef = null;
      for (let i = 0; i < this.length; i++) {
        const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
        const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
        if (tqueryClone) {
          tqueryClone.indexInDeclarationView = i;
          if (queriesForTemplateRef !== null) {
            queriesForTemplateRef.push(tqueryClone);
          } else {
            queriesForTemplateRef = [tqueryClone];
          }
        }
      }
      return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
    }
    template(tView, tNode) {
      ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].template(tView, tNode);
      }
    }
    getByIndex(index) {
      ngDevMode && assertIndexInRange(this.queries, index);
      return this.queries[index];
    }
    get length() {
      return this.queries.length;
    }
    track(tquery) {
      this.queries.push(tquery);
    }
  };
  var TQuery_ = class {
    constructor(metadata, nodeIndex = -1) {
      this.metadata = metadata;
      this.matches = null;
      this.indexInDeclarationView = -1;
      this.crossesNgTemplate = false;
      this._appliesToNextNode = true;
      this._declarationNodeIndex = nodeIndex;
    }
    elementStart(tView, tNode) {
      if (this.isApplyingToNode(tNode)) {
        this.matchTNode(tView, tNode);
      }
    }
    elementEnd(tNode) {
      if (this._declarationNodeIndex === tNode.index) {
        this._appliesToNextNode = false;
      }
    }
    template(tView, tNode) {
      this.elementStart(tView, tNode);
    }
    embeddedTView(tNode, childQueryIndex) {
      if (this.isApplyingToNode(tNode)) {
        this.crossesNgTemplate = true;
        this.addMatch(-tNode.index, childQueryIndex);
        return new TQuery_(this.metadata);
      }
      return null;
    }
    isApplyingToNode(tNode) {
      if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
        const declarationNodeIdx = this._declarationNodeIndex;
        let parent = tNode.parent;
        while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
          parent = parent.parent;
        }
        return declarationNodeIdx === (parent !== null ? parent.index : -1);
      }
      return this._appliesToNextNode;
    }
    matchTNode(tView, tNode) {
      const predicate = this.metadata.predicate;
      if (Array.isArray(predicate)) {
        for (let i = 0; i < predicate.length; i++) {
          const name = predicate[i];
          this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
          this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
        }
      } else {
        if (predicate === TemplateRef) {
          if (tNode.type & 4) {
            this.matchTNodeWithReadOption(tView, tNode, -1);
          }
        } else {
          this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
        }
      }
    }
    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
      if (nodeMatchIdx !== null) {
        const read = this.metadata.read;
        if (read !== null) {
          if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
            this.addMatch(tNode.index, -2);
          } else {
            const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
            if (directiveOrProviderIdx !== null) {
              this.addMatch(tNode.index, directiveOrProviderIdx);
            }
          }
        } else {
          this.addMatch(tNode.index, nodeMatchIdx);
        }
      }
    }
    addMatch(tNodeIdx, matchIdx) {
      if (this.matches === null) {
        this.matches = [tNodeIdx, matchIdx];
      } else {
        this.matches.push(tNodeIdx, matchIdx);
      }
    }
  };
  function getIdxOfMatchingSelector(tNode, selector) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
      for (let i = 0; i < localNames.length; i += 2) {
        if (localNames[i] === selector) {
          return localNames[i + 1];
        }
      }
    }
    return null;
  }
  function createResultByTNodeType(tNode, currentView) {
    if (tNode.type & (3 | 8)) {
      return createElementRef(tNode, currentView);
    } else if (tNode.type & 4) {
      return createTemplateRef(tNode, currentView);
    }
    return null;
  }
  function createResultForNode(lView, tNode, matchingIdx, read) {
    if (matchingIdx === -1) {
      return createResultByTNodeType(tNode, lView);
    } else if (matchingIdx === -2) {
      return createSpecialToken(lView, tNode, read);
    } else {
      return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
    }
  }
  function createSpecialToken(lView, tNode, read) {
    if (read === ElementRef) {
      return createElementRef(tNode, lView);
    } else if (read === TemplateRef) {
      return createTemplateRef(tNode, lView);
    } else if (read === ViewContainerRef) {
      ngDevMode && assertTNodeType(tNode, 3 | 12);
      return createContainerRef(tNode, lView);
    } else {
      ngDevMode && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
    }
  }
  function materializeViewResults(tView, lView, tQuery, queryIndex) {
    const lQuery = lView[QUERIES].queries[queryIndex];
    if (lQuery.matches === null) {
      const tViewData = tView.data;
      const tQueryMatches = tQuery.matches;
      const result = [];
      for (let i = 0; i < tQueryMatches.length; i += 2) {
        const matchedNodeIdx = tQueryMatches[i];
        if (matchedNodeIdx < 0) {
          result.push(null);
        } else {
          ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
          const tNode = tViewData[matchedNodeIdx];
          result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
        }
      }
      lQuery.matches = result;
    }
    return lQuery.matches;
  }
  function collectQueryResults(tView, lView, queryIndex, result) {
    const tQuery = tView.queries.getByIndex(queryIndex);
    const tQueryMatches = tQuery.matches;
    if (tQueryMatches !== null) {
      const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
      for (let i = 0; i < tQueryMatches.length; i += 2) {
        const tNodeIdx = tQueryMatches[i];
        if (tNodeIdx > 0) {
          result.push(lViewResults[i / 2]);
        } else {
          const childQueryIndex = tQueryMatches[i + 1];
          const declarationLContainer = lView[-tNodeIdx];
          ngDevMode && assertLContainer(declarationLContainer);
          for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
            const embeddedLView = declarationLContainer[i2];
            if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
              collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
            }
          }
          if (declarationLContainer[MOVED_VIEWS] !== null) {
            const embeddedLViews = declarationLContainer[MOVED_VIEWS];
            for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
              const embeddedLView = embeddedLViews[i2];
              collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
            }
          }
        }
      }
    }
    return result;
  }
  function \u0275\u0275queryRefresh(queryList) {
    const lView = getLView();
    const tView = getTView();
    const queryIndex = getCurrentQueryIndex();
    setCurrentQueryIndex(queryIndex + 1);
    const tQuery = getTQuery(tView, queryIndex);
    if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
      if (tQuery.matches === null) {
        queryList.reset([]);
      } else {
        const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
        queryList.reset(result, unwrapElementRef);
        queryList.notifyOnChanges();
      }
      return true;
    }
    return false;
  }
  function \u0275\u0275viewQuery(predicate, flags, read) {
    ngDevMode && assertNumber(flags, "Expecting flags");
    const tView = getTView();
    if (tView.firstCreatePass) {
      createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
      if ((flags & 2) === 2) {
        tView.staticViewQueries = true;
      }
    }
    createLQuery(tView, getLView(), flags);
  }
  function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
    ngDevMode && assertNumber(flags, "Expecting flags");
    const tView = getTView();
    if (tView.firstCreatePass) {
      const tNode = getCurrentTNode();
      createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
      saveContentQueryAndDirectiveIndex(tView, directiveIndex);
      if ((flags & 2) === 2) {
        tView.staticContentQueries = true;
      }
    }
    createLQuery(tView, getLView(), flags);
  }
  function \u0275\u0275loadQuery() {
    return loadQueryInternal(getLView(), getCurrentQueryIndex());
  }
  function loadQueryInternal(lView, queryIndex) {
    ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
    return lView[QUERIES].queries[queryIndex].queryList;
  }
  function createLQuery(tView, lView, flags) {
    const queryList = new QueryList((flags & 4) === 4);
    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
    if (lView[QUERIES] === null)
      lView[QUERIES] = new LQueries_();
    lView[QUERIES].queries.push(new LQuery_(queryList));
  }
  function createTQuery(tView, metadata, nodeIndex) {
    if (tView.queries === null)
      tView.queries = new TQueries_();
    tView.queries.track(new TQuery_(metadata, nodeIndex));
  }
  function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
    const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
    if (directiveIndex !== lastSavedDirectiveIndex) {
      tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
    }
  }
  function getTQuery(tView, index) {
    ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
    return tView.queries.getByIndex(index);
  }
  function \u0275\u0275templateRefExtractor(tNode, lView) {
    return createTemplateRef(tNode, lView);
  }
  var angularCoreEnv = (() => ({
    "\u0275\u0275attribute": \u0275\u0275attribute,
    "\u0275\u0275attributeInterpolate1": \u0275\u0275attributeInterpolate1,
    "\u0275\u0275attributeInterpolate2": \u0275\u0275attributeInterpolate2,
    "\u0275\u0275attributeInterpolate3": \u0275\u0275attributeInterpolate3,
    "\u0275\u0275attributeInterpolate4": \u0275\u0275attributeInterpolate4,
    "\u0275\u0275attributeInterpolate5": \u0275\u0275attributeInterpolate5,
    "\u0275\u0275attributeInterpolate6": \u0275\u0275attributeInterpolate6,
    "\u0275\u0275attributeInterpolate7": \u0275\u0275attributeInterpolate7,
    "\u0275\u0275attributeInterpolate8": \u0275\u0275attributeInterpolate8,
    "\u0275\u0275attributeInterpolateV": \u0275\u0275attributeInterpolateV,
    "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
    "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
    "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
    "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
    "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
    "\u0275\u0275definePipe": \u0275\u0275definePipe,
    "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
    "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
    "\u0275\u0275inject": \u0275\u0275inject,
    "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
    "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
    "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
    "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
    "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
    "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
    "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
    "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
    "\u0275\u0275nextContext": \u0275\u0275nextContext,
    "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
    "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
    "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
    "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
    "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
    "\u0275\u0275elementStart": \u0275\u0275elementStart,
    "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
    "\u0275\u0275element": \u0275\u0275element,
    "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
    "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
    "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
    "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
    "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
    "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
    "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
    "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
    "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
    "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
    "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
    "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
    "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
    "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
    "\u0275\u0275restoreView": \u0275\u0275restoreView,
    "\u0275\u0275listener": \u0275\u0275listener,
    "\u0275\u0275projection": \u0275\u0275projection,
    "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
    "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
    "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
    "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
    "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
    "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
    "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
    "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
    "\u0275\u0275hostProperty": \u0275\u0275hostProperty,
    "\u0275\u0275property": \u0275\u0275property,
    "\u0275\u0275propertyInterpolate": \u0275\u0275propertyInterpolate,
    "\u0275\u0275propertyInterpolate1": \u0275\u0275propertyInterpolate1,
    "\u0275\u0275propertyInterpolate2": \u0275\u0275propertyInterpolate2,
    "\u0275\u0275propertyInterpolate3": \u0275\u0275propertyInterpolate3,
    "\u0275\u0275propertyInterpolate4": \u0275\u0275propertyInterpolate4,
    "\u0275\u0275propertyInterpolate5": \u0275\u0275propertyInterpolate5,
    "\u0275\u0275propertyInterpolate6": \u0275\u0275propertyInterpolate6,
    "\u0275\u0275propertyInterpolate7": \u0275\u0275propertyInterpolate7,
    "\u0275\u0275propertyInterpolate8": \u0275\u0275propertyInterpolate8,
    "\u0275\u0275propertyInterpolateV": \u0275\u0275propertyInterpolateV,
    "\u0275\u0275pipe": \u0275\u0275pipe,
    "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
    "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
    "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
    "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
    "\u0275\u0275reference": \u0275\u0275reference,
    "\u0275\u0275classMap": \u0275\u0275classMap,
    "\u0275\u0275classMapInterpolate1": \u0275\u0275classMapInterpolate1,
    "\u0275\u0275classMapInterpolate2": \u0275\u0275classMapInterpolate2,
    "\u0275\u0275classMapInterpolate3": \u0275\u0275classMapInterpolate3,
    "\u0275\u0275classMapInterpolate4": \u0275\u0275classMapInterpolate4,
    "\u0275\u0275classMapInterpolate5": \u0275\u0275classMapInterpolate5,
    "\u0275\u0275classMapInterpolate6": \u0275\u0275classMapInterpolate6,
    "\u0275\u0275classMapInterpolate7": \u0275\u0275classMapInterpolate7,
    "\u0275\u0275classMapInterpolate8": \u0275\u0275classMapInterpolate8,
    "\u0275\u0275classMapInterpolateV": \u0275\u0275classMapInterpolateV,
    "\u0275\u0275styleMap": \u0275\u0275styleMap,
    "\u0275\u0275styleMapInterpolate1": \u0275\u0275styleMapInterpolate1,
    "\u0275\u0275styleMapInterpolate2": \u0275\u0275styleMapInterpolate2,
    "\u0275\u0275styleMapInterpolate3": \u0275\u0275styleMapInterpolate3,
    "\u0275\u0275styleMapInterpolate4": \u0275\u0275styleMapInterpolate4,
    "\u0275\u0275styleMapInterpolate5": \u0275\u0275styleMapInterpolate5,
    "\u0275\u0275styleMapInterpolate6": \u0275\u0275styleMapInterpolate6,
    "\u0275\u0275styleMapInterpolate7": \u0275\u0275styleMapInterpolate7,
    "\u0275\u0275styleMapInterpolate8": \u0275\u0275styleMapInterpolate8,
    "\u0275\u0275styleMapInterpolateV": \u0275\u0275styleMapInterpolateV,
    "\u0275\u0275styleProp": \u0275\u0275styleProp,
    "\u0275\u0275stylePropInterpolate1": \u0275\u0275stylePropInterpolate1,
    "\u0275\u0275stylePropInterpolate2": \u0275\u0275stylePropInterpolate2,
    "\u0275\u0275stylePropInterpolate3": \u0275\u0275stylePropInterpolate3,
    "\u0275\u0275stylePropInterpolate4": \u0275\u0275stylePropInterpolate4,
    "\u0275\u0275stylePropInterpolate5": \u0275\u0275stylePropInterpolate5,
    "\u0275\u0275stylePropInterpolate6": \u0275\u0275stylePropInterpolate6,
    "\u0275\u0275stylePropInterpolate7": \u0275\u0275stylePropInterpolate7,
    "\u0275\u0275stylePropInterpolate8": \u0275\u0275stylePropInterpolate8,
    "\u0275\u0275stylePropInterpolateV": \u0275\u0275stylePropInterpolateV,
    "\u0275\u0275classProp": \u0275\u0275classProp,
    "\u0275\u0275advance": \u0275\u0275advance,
    "\u0275\u0275template": \u0275\u0275template,
    "\u0275\u0275text": \u0275\u0275text,
    "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
    "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
    "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
    "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
    "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
    "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
    "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
    "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
    "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
    "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
    "\u0275\u0275i18n": \u0275\u0275i18n,
    "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
    "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
    "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
    "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
    "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
    "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
    "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
    "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
    "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
    "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
    "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
    "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
    "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
    "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
    "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
    "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
    "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
    "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
    "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
    "forwardRef": forwardRef,
    "resolveForwardRef": resolveForwardRef
  }))();
  var jitOptions = null;
  function setJitOptions(options) {
    if (jitOptions !== null) {
      if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
        ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
        return;
      }
      if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
        ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
        return;
      }
    }
    jitOptions = options;
  }
  function getJitOptions() {
    return jitOptions;
  }
  var moduleQueue = [];
  function enqueueModuleForDelayedScoping(moduleType, ngModule) {
    moduleQueue.push({ moduleType, ngModule });
  }
  var flushingModuleQueue = false;
  function flushModuleScopingQueueAsMuchAsPossible() {
    if (!flushingModuleQueue) {
      flushingModuleQueue = true;
      try {
        for (let i = moduleQueue.length - 1; i >= 0; i--) {
          const { moduleType, ngModule } = moduleQueue[i];
          if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
            moduleQueue.splice(i, 1);
            setScopeOnDeclaredComponents(moduleType, ngModule);
          }
        }
      } finally {
        flushingModuleQueue = false;
      }
    }
  }
  function isResolvedDeclaration(declaration) {
    if (Array.isArray(declaration)) {
      return declaration.every(isResolvedDeclaration);
    }
    return !!resolveForwardRef(declaration);
  }
  function compileNgModule(moduleType, ngModule = {}) {
    compileNgModuleDefs(moduleType, ngModule);
    enqueueModuleForDelayedScoping(moduleType, ngModule);
  }
  function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
    ngDevMode && assertDefined(moduleType, "Required value moduleType");
    ngDevMode && assertDefined(ngModule, "Required value ngModule");
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
    let ngModuleDef = null;
    Object.defineProperty(moduleType, NG_MOD_DEF, {
      configurable: true,
      get: () => {
        if (ngModuleDef === null) {
          if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
            throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
          }
          const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
          ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
            type: moduleType,
            bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
            declarations: declarations.map(resolveForwardRef),
            imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
            exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
            schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
            id: ngModule.id || null
          });
          if (!ngModuleDef.schemas) {
            ngModuleDef.schemas = [];
          }
        }
        return ngModuleDef;
      }
    });
    let ngFactoryDef = null;
    Object.defineProperty(moduleType, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
          ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
            name: moduleType.name,
            type: moduleType,
            deps: reflectDependencies(moduleType),
            target: compiler.FactoryTarget.NgModule,
            typeArgumentCount: 0
          });
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
    let ngInjectorDef = null;
    Object.defineProperty(moduleType, NG_INJ_DEF, {
      get: () => {
        if (ngInjectorDef === null) {
          ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
          const meta = {
            name: moduleType.name,
            type: moduleType,
            providers: ngModule.providers || EMPTY_ARRAY,
            imports: [
              (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
              (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
            ]
          };
          const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
          ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
        }
        return ngInjectorDef;
      },
      configurable: !!ngDevMode
    });
  }
  function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
    if (verifiedNgModule.get(moduleType))
      return;
    verifiedNgModule.set(moduleType, true);
    moduleType = resolveForwardRef(moduleType);
    let ngModuleDef;
    if (importingModule) {
      ngModuleDef = getNgModuleDef(moduleType);
      if (!ngModuleDef) {
        throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
      }
    } else {
      ngModuleDef = getNgModuleDef(moduleType, true);
    }
    const errors = [];
    const declarations = maybeUnwrapFn(ngModuleDef.declarations);
    const imports = maybeUnwrapFn(ngModuleDef.imports);
    flatten(imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    const exports = maybeUnwrapFn(ngModuleDef.exports);
    declarations.forEach(verifyDeclarationsHaveDefinitions);
    declarations.forEach(verifyDirectivesHaveSelector);
    const combinedDeclarations = [
      ...declarations.map(resolveForwardRef),
      ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
    ];
    exports.forEach(verifyExportsAreDeclaredOrReExported);
    declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
    declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);
    const ngModule = getAnnotation(moduleType, "NgModule");
    if (ngModule) {
      ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
        verifySemanticsOfNgModuleImport(mod, moduleType);
        verifySemanticsOfNgModuleDef(mod, false, moduleType);
      });
      ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
      ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
      ngModule.entryComponents && deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);
    }
    if (errors.length) {
      throw new Error(errors.join("\n"));
    }
    function verifyDeclarationsHaveDefinitions(type) {
      type = resolveForwardRef(type);
      const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
      if (!def) {
        errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
      }
    }
    function verifyDirectivesHaveSelector(type) {
      type = resolveForwardRef(type);
      const def = getDirectiveDef(type);
      if (!getComponentDef(type) && def && def.selectors.length == 0) {
        errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
      }
    }
    function verifyExportsAreDeclaredOrReExported(type) {
      type = resolveForwardRef(type);
      const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
      if (kind) {
        if (combinedDeclarations.lastIndexOf(type) === -1) {
          errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
        }
      }
    }
    function verifyDeclarationIsUnique(type, suppressErrors) {
      type = resolveForwardRef(type);
      const existingModule = ownerNgModule.get(type);
      if (existingModule && existingModule !== moduleType) {
        if (!suppressErrors) {
          const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
          errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
        }
      } else {
        ownerNgModule.set(type, moduleType);
      }
    }
    function verifyComponentIsPartOfNgModule(type) {
      type = resolveForwardRef(type);
      const existingModule = ownerNgModule.get(type);
      if (!existingModule) {
        errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
      }
    }
    function verifyCorrectBootstrapType(type) {
      type = resolveForwardRef(type);
      if (!getComponentDef(type)) {
        errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
      }
    }
    function verifyComponentEntryComponentsIsPartOfNgModule(type) {
      type = resolveForwardRef(type);
      if (getComponentDef(type)) {
        const component = getAnnotation(type, "Component");
        if (component && component.entryComponents) {
          deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);
        }
      }
    }
    function verifySemanticsOfNgModuleImport(type, importingModule2) {
      type = resolveForwardRef(type);
      if (getComponentDef(type) || getDirectiveDef(type)) {
        throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
      }
      if (getPipeDef$1(type)) {
        throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
      }
    }
  }
  function unwrapModuleWithProvidersImports(typeOrWithProviders) {
    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
    return typeOrWithProviders.ngModule || typeOrWithProviders;
  }
  function getAnnotation(type, name) {
    let annotation = null;
    collect(type.__annotations__);
    collect(type.decorators);
    return annotation;
    function collect(annotations) {
      if (annotations) {
        annotations.forEach(readAnnotation);
      }
    }
    function readAnnotation(decorator) {
      if (!annotation) {
        const proto = Object.getPrototypeOf(decorator);
        if (proto.ngMetadataName == name) {
          annotation = decorator;
        } else if (decorator.type) {
          const proto2 = Object.getPrototypeOf(decorator.type);
          if (proto2.ngMetadataName == name) {
            annotation = decorator.args[0];
          }
        }
      }
    }
  }
  var ownerNgModule = /* @__PURE__ */ new WeakMap();
  var verifiedNgModule = /* @__PURE__ */ new WeakMap();
  function resetCompiledComponents() {
    ownerNgModule = /* @__PURE__ */ new WeakMap();
    verifiedNgModule = /* @__PURE__ */ new WeakMap();
    moduleQueue.length = 0;
  }
  function computeCombinedExports(type) {
    type = resolveForwardRef(type);
    const ngModuleDef = getNgModuleDef(type, true);
    return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
      const ngModuleDef2 = getNgModuleDef(type2);
      if (ngModuleDef2) {
        verifySemanticsOfNgModuleDef(type2, false);
        return computeCombinedExports(type2);
      } else {
        return type2;
      }
    }))];
  }
  function setScopeOnDeclaredComponents(moduleType, ngModule) {
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
    const transitiveScopes = transitiveScopesFor(moduleType);
    declarations.forEach((declaration) => {
      if (declaration.hasOwnProperty(NG_COMP_DEF)) {
        const component = declaration;
        const componentDef = getComponentDef(component);
        patchComponentDefWithScope(componentDef, transitiveScopes);
      } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
        declaration.ngSelectorScope = moduleType;
      }
    });
  }
  function patchComponentDefWithScope(componentDef, transitiveScopes) {
    componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
    componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe) => getPipeDef$1(pipe));
    componentDef.schemas = transitiveScopes.schemas;
    componentDef.tView = null;
  }
  function transitiveScopesFor(moduleType) {
    if (!isNgModule(moduleType)) {
      throw new Error(`${moduleType.name} does not have a module def (\u0275mod property)`);
    }
    const def = getNgModuleDef(moduleType);
    if (def.transitiveCompileScopes !== null) {
      return def.transitiveCompileScopes;
    }
    const scopes = {
      schemas: def.schemas || null,
      compilation: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      },
      exported: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      }
    };
    maybeUnwrapFn(def.imports).forEach((imported) => {
      const importedType = imported;
      if (!isNgModule(importedType)) {
        throw new Error(`Importing ${importedType.name} which does not have a \u0275mod property`);
      }
      const importedScope = transitiveScopesFor(importedType);
      importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
      importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
    });
    maybeUnwrapFn(def.declarations).forEach((declared) => {
      const declaredWithDefs = declared;
      if (getPipeDef$1(declaredWithDefs)) {
        scopes.compilation.pipes.add(declared);
      } else {
        scopes.compilation.directives.add(declared);
      }
    });
    maybeUnwrapFn(def.exports).forEach((exported) => {
      const exportedType = exported;
      if (isNgModule(exportedType)) {
        const exportedScope = transitiveScopesFor(exportedType);
        exportedScope.exported.directives.forEach((entry) => {
          scopes.compilation.directives.add(entry);
          scopes.exported.directives.add(entry);
        });
        exportedScope.exported.pipes.forEach((entry) => {
          scopes.compilation.pipes.add(entry);
          scopes.exported.pipes.add(entry);
        });
      } else if (getPipeDef$1(exportedType)) {
        scopes.exported.pipes.add(exportedType);
      } else {
        scopes.exported.directives.add(exportedType);
      }
    });
    def.transitiveCompileScopes = scopes;
    return scopes;
  }
  function expandModuleWithProviders(value) {
    if (isModuleWithProviders(value)) {
      return value.ngModule;
    }
    return value;
  }
  function isModuleWithProviders(value) {
    return value.ngModule !== void 0;
  }
  function isNgModule(value) {
    return !!getNgModuleDef(value);
  }
  var compilationDepth = 0;
  function compileComponent(type, metadata) {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    let ngComponentDef = null;
    maybeQueueResolutionOfComponentResources(type, metadata);
    addDirectiveFactoryDef(type, metadata);
    Object.defineProperty(type, NG_COMP_DEF, {
      get: () => {
        if (ngComponentDef === null) {
          const compiler = getCompilerFacade({ usage: 0, kind: "component", type });
          if (componentNeedsResolution(metadata)) {
            const error3 = [`Component '${type.name}' is not resolved:`];
            if (metadata.templateUrl) {
              error3.push(` - templateUrl: ${metadata.templateUrl}`);
            }
            if (metadata.styleUrls && metadata.styleUrls.length) {
              error3.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
            }
            error3.push(`Did you run and wait for 'resolveComponentResources()'?`);
            throw new Error(error3.join("\n"));
          }
          const options = getJitOptions();
          let preserveWhitespaces = metadata.preserveWhitespaces;
          if (preserveWhitespaces === void 0) {
            if (options !== null && options.preserveWhitespaces !== void 0) {
              preserveWhitespaces = options.preserveWhitespaces;
            } else {
              preserveWhitespaces = false;
            }
          }
          let encapsulation = metadata.encapsulation;
          if (encapsulation === void 0) {
            if (options !== null && options.defaultEncapsulation !== void 0) {
              encapsulation = options.defaultEncapsulation;
            } else {
              encapsulation = ViewEncapsulation$1.Emulated;
            }
          }
          const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
          const meta = {
            ...directiveMetadata(type, metadata),
            typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
            template: metadata.template || "",
            preserveWhitespaces,
            styles: metadata.styles || EMPTY_ARRAY,
            animations: metadata.animations,
            directives: [],
            changeDetection: metadata.changeDetection,
            pipes: /* @__PURE__ */ new Map(),
            encapsulation,
            interpolation: metadata.interpolation,
            viewProviders: metadata.viewProviders || null
          };
          compilationDepth++;
          try {
            if (meta.usesInheritance) {
              addDirectiveDefToUndecoratedParents(type);
            }
            ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          } finally {
            compilationDepth--;
          }
          if (compilationDepth === 0) {
            flushModuleScopingQueueAsMuchAsPossible();
          }
          if (hasSelectorScope(type)) {
            const scopes = transitiveScopesFor(type.ngSelectorScope);
            patchComponentDefWithScope(ngComponentDef, scopes);
          }
        }
        return ngComponentDef;
      },
      configurable: !!ngDevMode
    });
  }
  function hasSelectorScope(component) {
    return component.ngSelectorScope !== void 0;
  }
  function compileDirective(type, directive) {
    let ngDirectiveDef = null;
    addDirectiveFactoryDef(type, directive || {});
    Object.defineProperty(type, NG_DIR_DEF, {
      get: () => {
        if (ngDirectiveDef === null) {
          const meta = getDirectiveMetadata(type, directive || {});
          const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
          ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
        }
        return ngDirectiveDef;
      },
      configurable: !!ngDevMode
    });
  }
  function getDirectiveMetadata(type, metadata) {
    const name = type && type.name;
    const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
    const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
    const facade = directiveMetadata(type, metadata);
    facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
    if (facade.usesInheritance) {
      addDirectiveDefToUndecoratedParents(type);
    }
    return { metadata: facade, sourceMapUrl };
  }
  function addDirectiveFactoryDef(type, metadata) {
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const meta = getDirectiveMetadata(type, metadata);
          const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
          ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: meta.metadata.name,
            type: meta.metadata.type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Directive
          });
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
  }
  function extendsDirectlyFromObject(type) {
    return Object.getPrototypeOf(type.prototype) === Object.prototype;
  }
  function directiveMetadata(type, metadata) {
    const reflect = getReflect();
    const propMetadata = reflect.ownPropMetadata(type);
    return {
      name: type.name,
      type,
      selector: metadata.selector !== void 0 ? metadata.selector : null,
      host: metadata.host || EMPTY_OBJ,
      propMetadata,
      inputs: metadata.inputs || EMPTY_ARRAY,
      outputs: metadata.outputs || EMPTY_ARRAY,
      queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
      lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges") },
      typeSourceSpan: null,
      usesInheritance: !extendsDirectlyFromObject(type),
      exportAs: extractExportAs(metadata.exportAs),
      providers: metadata.providers || null,
      viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery)
    };
  }
  function addDirectiveDefToUndecoratedParents(type) {
    const objPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objPrototype) {
      if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
        compileDirective(parent, null);
      }
      parent = Object.getPrototypeOf(parent);
    }
  }
  function convertToR3QueryPredicate(selector) {
    return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
  }
  function convertToR3QueryMetadata(propertyName, ann) {
    return {
      propertyName,
      predicate: convertToR3QueryPredicate(ann.selector),
      descendants: ann.descendants,
      first: ann.first,
      read: ann.read ? ann.read : null,
      static: !!ann.static,
      emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly
    };
  }
  function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
    const queriesMeta = [];
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        const annotations = propMetadata[field];
        annotations.forEach((ann) => {
          if (isQueryAnn(ann)) {
            if (!ann.selector) {
              throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
            }
            if (annotations.some(isInputAnnotation)) {
              throw new Error(`Cannot combine @Input decorators with query decorators`);
            }
            queriesMeta.push(convertToR3QueryMetadata(field, ann));
          }
        });
      }
    }
    return queriesMeta;
  }
  function extractExportAs(exportAs) {
    return exportAs === void 0 ? null : splitByComma(exportAs);
  }
  function isContentQuery(value) {
    const name = value.ngMetadataName;
    return name === "ContentChild" || name === "ContentChildren";
  }
  function isViewQuery(value) {
    const name = value.ngMetadataName;
    return name === "ViewChild" || name === "ViewChildren";
  }
  function isInputAnnotation(value) {
    return value.ngMetadataName === "Input";
  }
  function splitByComma(value) {
    return value.split(",").map((piece) => piece.trim());
  }
  var LIFECYCLE_HOOKS = [
    "ngOnChanges",
    "ngOnInit",
    "ngOnDestroy",
    "ngDoCheck",
    "ngAfterViewInit",
    "ngAfterViewChecked",
    "ngAfterContentInit",
    "ngAfterContentChecked"
  ];
  function shouldAddAbstractDirective(type) {
    const reflect = getReflect();
    if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
      return true;
    }
    const propMetadata = reflect.propMetadata(type);
    for (const field in propMetadata) {
      const annotations = propMetadata[field];
      for (let i = 0; i < annotations.length; i++) {
        const current = annotations[i];
        const metadataName = current.ngMetadataName;
        if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
          return true;
        }
      }
    }
    return false;
  }
  function compilePipe(type, meta) {
    let ngPipeDef = null;
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const metadata = getPipeMetadata(type, meta);
          const compiler = getCompilerFacade({ usage: 0, kind: "pipe", type: metadata.type });
          ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
            name: metadata.name,
            type: metadata.type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Pipe
          });
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
    Object.defineProperty(type, NG_PIPE_DEF, {
      get: () => {
        if (ngPipeDef === null) {
          const metadata = getPipeMetadata(type, meta);
          const compiler = getCompilerFacade({ usage: 0, kind: "pipe", type: metadata.type });
          ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
        }
        return ngPipeDef;
      },
      configurable: !!ngDevMode
    });
  }
  function getPipeMetadata(type, meta) {
    return {
      type,
      name: type.name,
      pipeName: meta.name,
      pure: meta.pure !== void 0 ? meta.pure : true
    };
  }
  var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
  var Component = makeDecorator("Component", (c = {}) => ({ changeDetection: ChangeDetectionStrategy.Default, ...c }), Directive, void 0, (type, meta) => compileComponent(type, meta));
  var Pipe = makeDecorator("Pipe", (p) => ({ pure: true, ...p }), void 0, void 0, (type, meta) => compilePipe(type, meta));
  var Input = makePropDecorator("Input", (bindingPropertyName) => ({ bindingPropertyName }));
  var Output = makePropDecorator("Output", (bindingPropertyName) => ({ bindingPropertyName }));
  var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
  var HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
  var NgModule = makeDecorator("NgModule", (ngModule) => ngModule, void 0, void 0, (type, meta) => compileNgModule(type, meta));
  function noop2(...args) {
  }
  var APP_INITIALIZER = new InjectionToken("Application Initializer");
  var ApplicationInitStatus = class {
    constructor(appInits) {
      this.appInits = appInits;
      this.resolve = noop2;
      this.reject = noop2;
      this.initialized = false;
      this.done = false;
      this.donePromise = new Promise((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
    runInitializers() {
      if (this.initialized) {
        return;
      }
      const asyncInitPromises = [];
      const complete = () => {
        this.done = true;
        this.resolve();
      };
      if (this.appInits) {
        for (let i = 0; i < this.appInits.length; i++) {
          const initResult = this.appInits[i]();
          if (isPromise2(initResult)) {
            asyncInitPromises.push(initResult);
          } else if (isObservable(initResult)) {
            const observableAsPromise = new Promise((resolve, reject) => {
              initResult.subscribe({ complete: resolve, error: reject });
            });
            asyncInitPromises.push(observableAsPromise);
          }
        }
      }
      Promise.all(asyncInitPromises).then(() => {
        complete();
      }).catch((e) => {
        this.reject(e);
      });
      if (asyncInitPromises.length === 0) {
        complete();
      }
      this.initialized = true;
    }
  };
  ApplicationInitStatus.\u0275fac = function ApplicationInitStatus_Factory(t) {
    return new (t || ApplicationInitStatus)(\u0275\u0275inject(APP_INITIALIZER, 8));
  };
  ApplicationInitStatus.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: ApplicationInitStatus, factory: ApplicationInitStatus.\u0275fac, providedIn: "root" });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], function() {
      return [{ type: void 0, decorators: [{
        type: Inject,
        args: [APP_INITIALIZER]
      }, {
        type: Optional
      }] }];
    }, null);
  })();
  var APP_ID = new InjectionToken("AppId", {
    providedIn: "root",
    factory: _appIdRandomProviderFactory
  });
  function _appIdRandomProviderFactory() {
    return `${_randomChar()}${_randomChar()}${_randomChar()}`;
  }
  function _randomChar() {
    return String.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  var PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer");
  var PLATFORM_ID = new InjectionToken("Platform ID", {
    providedIn: "platform",
    factory: () => "unknown"
  });
  var APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
  var PACKAGE_ROOT_URL = new InjectionToken("Application Packages Root URL");
  var Console = class {
    log(message) {
      console.log(message);
    }
    warn(message) {
      console.warn(message);
    }
  };
  Console.\u0275fac = function Console_Factory(t) {
    return new (t || Console)();
  };
  Console.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: Console, factory: Console.\u0275fac, providedIn: "platform" });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
      type: Injectable,
      args: [{ providedIn: "platform" }]
    }], null, null);
  })();
  function getGlobalLocale() {
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode && typeof goog !== "undefined" && goog.LOCALE !== "en") {
      return goog.LOCALE;
    } else {
      return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
    }
  }
  var LOCALE_ID = new InjectionToken("LocaleId", {
    providedIn: "root",
    factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
  });
  var DEFAULT_CURRENCY_CODE = new InjectionToken("DefaultCurrencyCode", {
    providedIn: "root",
    factory: () => USD_CURRENCY_CODE
  });
  var TRANSLATIONS = new InjectionToken("Translations");
  var TRANSLATIONS_FORMAT = new InjectionToken("TranslationsFormat");
  var MissingTranslationStrategy;
  (function(MissingTranslationStrategy3) {
    MissingTranslationStrategy3[MissingTranslationStrategy3["Error"] = 0] = "Error";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Warning"] = 1] = "Warning";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Ignore"] = 2] = "Ignore";
  })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
  var ModuleWithComponentFactories = class {
    constructor(ngModuleFactory, componentFactories) {
      this.ngModuleFactory = ngModuleFactory;
      this.componentFactories = componentFactories;
    }
  };
  var Compiler = class {
    compileModuleSync(moduleType) {
      return new NgModuleFactory(moduleType);
    }
    compileModuleAsync(moduleType) {
      return Promise.resolve(this.compileModuleSync(moduleType));
    }
    compileModuleAndAllComponentsSync(moduleType) {
      const ngModuleFactory = this.compileModuleSync(moduleType);
      const moduleDef = getNgModuleDef(moduleType);
      const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
        const componentDef = getComponentDef(declaration);
        componentDef && factories.push(new ComponentFactory(componentDef));
        return factories;
      }, []);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    compileModuleAndAllComponentsAsync(moduleType) {
      return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
    }
    clearCache() {
    }
    clearCacheFor(type) {
    }
    getModuleId(moduleType) {
      return void 0;
    }
  };
  Compiler.\u0275fac = function Compiler_Factory(t) {
    return new (t || Compiler)();
  };
  Compiler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: Compiler, factory: Compiler.\u0275fac, providedIn: "root" });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], null, null);
  })();
  var COMPILER_OPTIONS = new InjectionToken("compilerOptions");
  var promise = (() => Promise.resolve(0))();
  function scheduleMicroTask(fn2) {
    if (typeof Zone === "undefined") {
      promise.then(() => {
        fn2 && fn2.apply(null, null);
      });
    } else {
      Zone.current.scheduleMicroTask("scheduleMicrotask", fn2);
    }
  }
  function getNativeRequestAnimationFrame() {
    let nativeRequestAnimationFrame = _global2["requestAnimationFrame"];
    let nativeCancelAnimationFrame = _global2["cancelAnimationFrame"];
    if (typeof Zone !== "undefined" && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
      const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
      if (unpatchedRequestAnimationFrame) {
        nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
      }
      const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
      if (unpatchedCancelAnimationFrame) {
        nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
      }
    }
    return { nativeRequestAnimationFrame, nativeCancelAnimationFrame };
  }
  var NgZone = class {
    constructor({ enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false }) {
      this.hasPendingMacrotasks = false;
      this.hasPendingMicrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter(false);
      this.onMicrotaskEmpty = new EventEmitter(false);
      this.onStable = new EventEmitter(false);
      this.onError = new EventEmitter(false);
      if (typeof Zone == "undefined") {
        throw new Error(`In this configuration Angular requires Zone.js`);
      }
      Zone.assertZonePatched();
      const self2 = this;
      self2._nesting = 0;
      self2._outer = self2._inner = Zone.current;
      if (Zone["TaskTrackingZoneSpec"]) {
        self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
      }
      if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
        self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
      }
      self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
      self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
      self2.lastRequestAnimationFrameId = -1;
      self2.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
      forkInnerZoneWithAngularBehavior(self2);
    }
    static isInAngularZone() {
      return typeof Zone !== "undefined" && Zone.current.get("isAngularZone") === true;
    }
    static assertInAngularZone() {
      if (!NgZone.isInAngularZone()) {
        throw new Error("Expected to be in Angular Zone, but it is not!");
      }
    }
    static assertNotInAngularZone() {
      if (NgZone.isInAngularZone()) {
        throw new Error("Expected to not be in Angular Zone, but it is!");
      }
    }
    run(fn2, applyThis, applyArgs) {
      return this._inner.run(fn2, applyThis, applyArgs);
    }
    runTask(fn2, applyThis, applyArgs, name) {
      const zone = this._inner;
      const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn2, EMPTY_PAYLOAD, noop2, noop2);
      try {
        return zone.runTask(task, applyThis, applyArgs);
      } finally {
        zone.cancelTask(task);
      }
    }
    runGuarded(fn2, applyThis, applyArgs) {
      return this._inner.runGuarded(fn2, applyThis, applyArgs);
    }
    runOutsideAngular(fn2) {
      return this._outer.run(fn2);
    }
  };
  var EMPTY_PAYLOAD = {};
  function checkStable(zone) {
    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
      try {
        zone._nesting++;
        zone.onMicrotaskEmpty.emit(null);
      } finally {
        zone._nesting--;
        if (!zone.hasPendingMicrotasks) {
          try {
            zone.runOutsideAngular(() => zone.onStable.emit(null));
          } finally {
            zone.isStable = true;
          }
        }
      }
    }
  }
  function delayChangeDetectionForEvents(zone) {
    if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
      return;
    }
    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global2, () => {
      if (!zone.fakeTopEventTask) {
        zone.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
          zone.lastRequestAnimationFrameId = -1;
          updateMicroTaskStatus(zone);
          zone.isCheckStableRunning = true;
          checkStable(zone);
          zone.isCheckStableRunning = false;
        }, void 0, () => {
        }, () => {
        });
      }
      zone.fakeTopEventTask.invoke();
    });
    updateMicroTaskStatus(zone);
  }
  function forkInnerZoneWithAngularBehavior(zone) {
    const delayChangeDetectionForEventsDelegate = () => {
      delayChangeDetectionForEvents(zone);
    };
    zone._inner = zone._inner.fork({
      name: "angular",
      properties: { "isAngularZone": true },
      onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
        try {
          onEnter(zone);
          return delegate.invokeTask(target, task, applyThis, applyArgs);
        } finally {
          if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
            delayChangeDetectionForEventsDelegate();
          }
          onLeave(zone);
        }
      },
      onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
        try {
          onEnter(zone);
          return delegate.invoke(target, callback, applyThis, applyArgs, source);
        } finally {
          if (zone.shouldCoalesceRunChangeDetection) {
            delayChangeDetectionForEventsDelegate();
          }
          onLeave(zone);
        }
      },
      onHasTask: (delegate, current, target, hasTaskState) => {
        delegate.hasTask(target, hasTaskState);
        if (current === target) {
          if (hasTaskState.change == "microTask") {
            zone._hasPendingMicrotasks = hasTaskState.microTask;
            updateMicroTaskStatus(zone);
            checkStable(zone);
          } else if (hasTaskState.change == "macroTask") {
            zone.hasPendingMacrotasks = hasTaskState.macroTask;
          }
        }
      },
      onHandleError: (delegate, current, target, error3) => {
        delegate.handleError(target, error3);
        zone.runOutsideAngular(() => zone.onError.emit(error3));
        return false;
      }
    });
  }
  function updateMicroTaskStatus(zone) {
    if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) {
      zone.hasPendingMicrotasks = true;
    } else {
      zone.hasPendingMicrotasks = false;
    }
  }
  function onEnter(zone) {
    zone._nesting++;
    if (zone.isStable) {
      zone.isStable = false;
      zone.onUnstable.emit(null);
    }
  }
  function onLeave(zone) {
    zone._nesting--;
    checkStable(zone);
  }
  var NoopNgZone = class {
    constructor() {
      this.hasPendingMicrotasks = false;
      this.hasPendingMacrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter();
      this.onMicrotaskEmpty = new EventEmitter();
      this.onStable = new EventEmitter();
      this.onError = new EventEmitter();
    }
    run(fn2, applyThis, applyArgs) {
      return fn2.apply(applyThis, applyArgs);
    }
    runGuarded(fn2, applyThis, applyArgs) {
      return fn2.apply(applyThis, applyArgs);
    }
    runOutsideAngular(fn2) {
      return fn2();
    }
    runTask(fn2, applyThis, applyArgs, name) {
      return fn2.apply(applyThis, applyArgs);
    }
  };
  var Testability = class {
    constructor(_ngZone) {
      this._ngZone = _ngZone;
      this._pendingCount = 0;
      this._isZoneStable = true;
      this._didWork = false;
      this._callbacks = [];
      this.taskTrackingZone = null;
      this._watchAngularEvents();
      _ngZone.run(() => {
        this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
      });
    }
    _watchAngularEvents() {
      this._ngZone.onUnstable.subscribe({
        next: () => {
          this._didWork = true;
          this._isZoneStable = false;
        }
      });
      this._ngZone.runOutsideAngular(() => {
        this._ngZone.onStable.subscribe({
          next: () => {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(() => {
              this._isZoneStable = true;
              this._runCallbacksIfReady();
            });
          }
        });
      });
    }
    increasePendingRequestCount() {
      this._pendingCount += 1;
      this._didWork = true;
      return this._pendingCount;
    }
    decreasePendingRequestCount() {
      this._pendingCount -= 1;
      if (this._pendingCount < 0) {
        throw new Error("pending async requests below zero");
      }
      this._runCallbacksIfReady();
      return this._pendingCount;
    }
    isStable() {
      return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
    }
    _runCallbacksIfReady() {
      if (this.isStable()) {
        scheduleMicroTask(() => {
          while (this._callbacks.length !== 0) {
            let cb = this._callbacks.pop();
            clearTimeout(cb.timeoutId);
            cb.doneCb(this._didWork);
          }
          this._didWork = false;
        });
      } else {
        let pending = this.getPendingTasks();
        this._callbacks = this._callbacks.filter((cb) => {
          if (cb.updateCb && cb.updateCb(pending)) {
            clearTimeout(cb.timeoutId);
            return false;
          }
          return true;
        });
        this._didWork = true;
      }
    }
    getPendingTasks() {
      if (!this.taskTrackingZone) {
        return [];
      }
      return this.taskTrackingZone.macroTasks.map((t) => {
        return {
          source: t.source,
          creationLocation: t.creationLocation,
          data: t.data
        };
      });
    }
    addCallback(cb, timeout, updateCb) {
      let timeoutId = -1;
      if (timeout && timeout > 0) {
        timeoutId = setTimeout(() => {
          this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
          cb(this._didWork, this.getPendingTasks());
        }, timeout);
      }
      this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
    }
    whenStable(doneCb, timeout, updateCb) {
      if (updateCb && !this.taskTrackingZone) {
        throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
      }
      this.addCallback(doneCb, timeout, updateCb);
      this._runCallbacksIfReady();
    }
    getPendingRequestCount() {
      return this._pendingCount;
    }
    findProviders(using, provider, exactMatch) {
      return [];
    }
  };
  Testability.\u0275fac = function Testability_Factory(t) {
    return new (t || Testability)(\u0275\u0275inject(NgZone));
  };
  Testability.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: Testability, factory: Testability.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
      type: Injectable
    }], function() {
      return [{ type: NgZone }];
    }, null);
  })();
  var TestabilityRegistry = class {
    constructor() {
      this._applications = /* @__PURE__ */ new Map();
      _testabilityGetter.addToWindow(this);
    }
    registerApplication(token, testability) {
      this._applications.set(token, testability);
    }
    unregisterApplication(token) {
      this._applications.delete(token);
    }
    unregisterAllApplications() {
      this._applications.clear();
    }
    getTestability(elem) {
      return this._applications.get(elem) || null;
    }
    getAllTestabilities() {
      return Array.from(this._applications.values());
    }
    getAllRootElements() {
      return Array.from(this._applications.keys());
    }
    findTestabilityInTree(elem, findInAncestors = true) {
      return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    }
  };
  TestabilityRegistry.\u0275fac = function TestabilityRegistry_Factory(t) {
    return new (t || TestabilityRegistry)();
  };
  TestabilityRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: TestabilityRegistry, factory: TestabilityRegistry.\u0275fac, providedIn: "platform" });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
      type: Injectable,
      args: [{ providedIn: "platform" }]
    }], function() {
      return [];
    }, null);
  })();
  var _NoopGetTestability = class {
    addToWindow(registry) {
    }
    findTestabilityInTree(registry, elem, findInAncestors) {
      return null;
    }
  };
  var _testabilityGetter = new _NoopGetTestability();
  var _platform;
  function compileNgModuleFactory(injector2, options, moduleType) {
    ngDevMode && assertNgModuleType(moduleType);
    const moduleFactory = new NgModuleFactory(moduleType);
    if (typeof ngJitMode !== "undefined" && !ngJitMode) {
      return Promise.resolve(moduleFactory);
    }
    const compilerOptions = injector2.get(COMPILER_OPTIONS, []).concat(options);
    setJitOptions({
      defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
      preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
    });
    if (isComponentResourceResolutionQueueEmpty()) {
      return Promise.resolve(moduleFactory);
    }
    const compilerProviders = _mergeArrays(compilerOptions.map((o) => o.providers));
    if (compilerProviders.length === 0) {
      return Promise.resolve(moduleFactory);
    }
    const compiler = getCompilerFacade({
      usage: 0,
      kind: "NgModule",
      type: moduleType
    });
    const compilerInjector = Injector.create({ providers: compilerProviders });
    const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
    return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
  }
  function publishDefaultGlobalUtils() {
    ngDevMode && publishDefaultGlobalUtils$1();
  }
  function isBoundToModule(cf) {
    return cf.isBoundToModule;
  }
  var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
  function createPlatform(injector2) {
    if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "There can be only one platform. Destroy the previous one to create a new one." : "";
      throw new RuntimeError(400, errorMessage);
    }
    publishDefaultGlobalUtils();
    _platform = injector2.get(PlatformRef);
    const inits = injector2.get(PLATFORM_INITIALIZER, null);
    if (inits)
      inits.forEach((init) => init());
    return _platform;
  }
  function createPlatformFactory(parentPlatformFactory, name, providers = []) {
    const desc = `Platform: ${name}`;
    const marker = new InjectionToken(desc);
    return (extraProviders = []) => {
      let platform = getPlatform();
      if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
        if (parentPlatformFactory) {
          parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
        } else {
          const injectedProviders = providers.concat(extraProviders).concat({ provide: marker, useValue: true }, {
            provide: INJECTOR_SCOPE,
            useValue: "platform"
          });
          createPlatform(Injector.create({ providers: injectedProviders, name: desc }));
        }
      }
      return assertPlatform(marker);
    };
  }
  function assertPlatform(requiredToken) {
    const platform = getPlatform();
    if (!platform) {
      const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "No platform exists!" : "";
      throw new RuntimeError(401, errorMessage);
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
      throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
    }
    return platform;
  }
  function destroyPlatform() {
    if (_platform && !_platform.destroyed) {
      _platform.destroy();
    }
  }
  function getPlatform() {
    return _platform && !_platform.destroyed ? _platform : null;
  }
  var PlatformRef = class {
    constructor(_injector) {
      this._injector = _injector;
      this._modules = [];
      this._destroyListeners = [];
      this._destroyed = false;
    }
    bootstrapModuleFactory(moduleFactory, options) {
      const ngZoneOption = options ? options.ngZone : void 0;
      const ngZoneEventCoalescing = options && options.ngZoneEventCoalescing || false;
      const ngZoneRunCoalescing = options && options.ngZoneRunCoalescing || false;
      const ngZone = getNgZone(ngZoneOption, { ngZoneEventCoalescing, ngZoneRunCoalescing });
      const providers = [{ provide: NgZone, useValue: ngZone }];
      return ngZone.run(() => {
        const ngZoneInjector = Injector.create({ providers, parent: this.injector, name: moduleFactory.moduleType.name });
        const moduleRef = moduleFactory.create(ngZoneInjector);
        const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
        if (!exceptionHandler) {
          const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "No ErrorHandler. Is platform module (BrowserModule) included?" : "";
          throw new RuntimeError(402, errorMessage);
        }
        ngZone.runOutsideAngular(() => {
          const subscription = ngZone.onError.subscribe({
            next: (error3) => {
              exceptionHandler.handleError(error3);
            }
          });
          moduleRef.onDestroy(() => {
            remove(this._modules, moduleRef);
            subscription.unsubscribe();
          });
        });
        return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
          const initStatus = moduleRef.injector.get(ApplicationInitStatus);
          initStatus.runInitializers();
          return initStatus.donePromise.then(() => {
            const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
            setLocaleId(localeId || DEFAULT_LOCALE_ID);
            this._moduleDoBootstrap(moduleRef);
            return moduleRef;
          });
        });
      });
    }
    bootstrapModule(moduleType, compilerOptions = []) {
      const options = optionsReducer({}, compilerOptions);
      return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
    }
    _moduleDoBootstrap(moduleRef) {
      const appRef = moduleRef.injector.get(ApplicationRef);
      if (moduleRef._bootstrapComponents.length > 0) {
        moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
      } else if (moduleRef.instance.ngDoBootstrap) {
        moduleRef.instance.ngDoBootstrap(appRef);
      } else {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.` : "";
        throw new RuntimeError(403, errorMessage);
      }
      this._modules.push(moduleRef);
    }
    onDestroy(callback) {
      this._destroyListeners.push(callback);
    }
    get injector() {
      return this._injector;
    }
    destroy() {
      if (this._destroyed) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "The platform has already been destroyed!" : "";
        throw new RuntimeError(404, errorMessage);
      }
      this._modules.slice().forEach((module) => module.destroy());
      this._destroyListeners.forEach((listener) => listener());
      this._destroyed = true;
    }
    get destroyed() {
      return this._destroyed;
    }
  };
  PlatformRef.\u0275fac = function PlatformRef_Factory(t) {
    return new (t || PlatformRef)(\u0275\u0275inject(Injector));
  };
  PlatformRef.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: PlatformRef, factory: PlatformRef.\u0275fac, providedIn: "platform" });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
      type: Injectable,
      args: [{ providedIn: "platform" }]
    }], function() {
      return [{ type: Injector }];
    }, null);
  })();
  function getNgZone(ngZoneOption, extra) {
    let ngZone;
    if (ngZoneOption === "noop") {
      ngZone = new NoopNgZone();
    } else {
      ngZone = (ngZoneOption === "zone.js" ? void 0 : ngZoneOption) || new NgZone({
        enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
        shouldCoalesceEventChangeDetection: !!extra?.ngZoneEventCoalescing,
        shouldCoalesceRunChangeDetection: !!extra?.ngZoneRunCoalescing
      });
    }
    return ngZone;
  }
  function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
    try {
      const result = callback();
      if (isPromise2(result)) {
        return result.catch((e) => {
          ngZone.runOutsideAngular(() => errorHandler.handleError(e));
          throw e;
        });
      }
      return result;
    } catch (e) {
      ngZone.runOutsideAngular(() => errorHandler.handleError(e));
      throw e;
    }
  }
  function optionsReducer(dst, objs) {
    if (Array.isArray(objs)) {
      dst = objs.reduce(optionsReducer, dst);
    } else {
      dst = { ...dst, ...objs };
    }
    return dst;
  }
  var ApplicationRef = class {
    constructor(_zone, _injector, _exceptionHandler, _initStatus) {
      this._zone = _zone;
      this._injector = _injector;
      this._exceptionHandler = _exceptionHandler;
      this._initStatus = _initStatus;
      this._bootstrapListeners = [];
      this._views = [];
      this._runningTick = false;
      this._stable = true;
      this.componentTypes = [];
      this.components = [];
      this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
        next: () => {
          this._zone.run(() => {
            this.tick();
          });
        }
      });
      const isCurrentlyStable = new Observable((observer) => {
        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks;
        this._zone.runOutsideAngular(() => {
          observer.next(this._stable);
          observer.complete();
        });
      });
      const isStable = new Observable((observer) => {
        let stableSub;
        this._zone.runOutsideAngular(() => {
          stableSub = this._zone.onStable.subscribe(() => {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(() => {
              if (!this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks) {
                this._stable = true;
                observer.next(true);
              }
            });
          });
        });
        const unstableSub = this._zone.onUnstable.subscribe(() => {
          NgZone.assertInAngularZone();
          if (this._stable) {
            this._stable = false;
            this._zone.runOutsideAngular(() => {
              observer.next(false);
            });
          }
        });
        return () => {
          stableSub.unsubscribe();
          unstableSub.unsubscribe();
        };
      });
      this.isStable = merge(isCurrentlyStable, isStable.pipe(share()));
    }
    bootstrap(componentOrFactory, rootSelectorOrNode) {
      if (!this._initStatus.done) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module." : "";
        throw new RuntimeError(405, errorMessage);
      }
      let componentFactory;
      if (componentOrFactory instanceof ComponentFactory$1) {
        componentFactory = componentOrFactory;
      } else {
        const resolver = this._injector.get(ComponentFactoryResolver$1);
        componentFactory = resolver.resolveComponentFactory(componentOrFactory);
      }
      this.componentTypes.push(componentFactory.componentType);
      const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
      const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
      const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
      const nativeElement = compRef.location.nativeElement;
      const testability = compRef.injector.get(Testability, null);
      const testabilityRegistry = testability && compRef.injector.get(TestabilityRegistry);
      if (testability && testabilityRegistry) {
        testabilityRegistry.registerApplication(nativeElement, testability);
      }
      compRef.onDestroy(() => {
        this.detachView(compRef.hostView);
        remove(this.components, compRef);
        if (testabilityRegistry) {
          testabilityRegistry.unregisterApplication(nativeElement);
        }
      });
      this._loadComponent(compRef);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        const _console = this._injector.get(Console);
        _console.log(`Angular is running in development mode. Call enableProdMode() to enable production mode.`);
      }
      return compRef;
    }
    tick() {
      if (this._runningTick) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "ApplicationRef.tick is called recursively" : "";
        throw new RuntimeError(101, errorMessage);
      }
      try {
        this._runningTick = true;
        for (let view of this._views) {
          view.detectChanges();
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          for (let view of this._views) {
            view.checkNoChanges();
          }
        }
      } catch (e) {
        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
      } finally {
        this._runningTick = false;
      }
    }
    attachView(viewRef) {
      const view = viewRef;
      this._views.push(view);
      view.attachToAppRef(this);
    }
    detachView(viewRef) {
      const view = viewRef;
      remove(this._views, view);
      view.detachFromAppRef();
    }
    _loadComponent(componentRef) {
      this.attachView(componentRef.hostView);
      this.tick();
      this.components.push(componentRef);
      const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
      listeners.forEach((listener) => listener(componentRef));
    }
    ngOnDestroy() {
      this._views.slice().forEach((view) => view.destroy());
      this._onMicrotaskEmptySubscription.unsubscribe();
    }
    get viewCount() {
      return this._views.length;
    }
  };
  ApplicationRef.\u0275fac = function ApplicationRef_Factory(t) {
    return new (t || ApplicationRef)(\u0275\u0275inject(NgZone), \u0275\u0275inject(Injector), \u0275\u0275inject(ErrorHandler), \u0275\u0275inject(ApplicationInitStatus));
  };
  ApplicationRef.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: ApplicationRef, factory: ApplicationRef.\u0275fac, providedIn: "root" });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], function() {
      return [{ type: NgZone }, { type: Injector }, { type: ErrorHandler }, { type: ApplicationInitStatus }];
    }, null);
  })();
  function remove(list, el) {
    const index = list.indexOf(el);
    if (index > -1) {
      list.splice(index, 1);
    }
  }
  function _lastDefined(args) {
    for (let i = args.length - 1; i >= 0; i--) {
      if (args[i] !== void 0) {
        return args[i];
      }
    }
    return void 0;
  }
  function _mergeArrays(parts) {
    const result = [];
    parts.forEach((part) => part && result.push(...part));
    return result;
  }
  var ChangeDetectorRef = class {
  };
  ChangeDetectorRef.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
  function injectChangeDetectorRef(flags) {
    return createViewRef(getCurrentTNode(), getLView(), (flags & 16) === 16);
  }
  function createViewRef(tNode, lView, isPipe) {
    if (isComponentHost(tNode) && !isPipe) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      return new ViewRef$1(componentView, componentView);
    } else if (tNode.type & (3 | 12 | 32)) {
      const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
      return new ViewRef$1(hostComponentView, lView);
    }
    return null;
  }
  var DebugNode = class {
    constructor(nativeNode) {
      this.nativeNode = nativeNode;
    }
    get parent() {
      const parent = this.nativeNode.parentNode;
      return parent ? new DebugElement(parent) : null;
    }
    get injector() {
      return getInjector(this.nativeNode);
    }
    get componentInstance() {
      const nativeElement = this.nativeNode;
      return nativeElement && (getComponent$1(nativeElement) || getOwningComponent(nativeElement));
    }
    get context() {
      return getComponent$1(this.nativeNode) || getContext(this.nativeNode);
    }
    get listeners() {
      return getListeners(this.nativeNode).filter((listener) => listener.type === "dom");
    }
    get references() {
      return getLocalRefs(this.nativeNode);
    }
    get providerTokens() {
      return getInjectionTokens(this.nativeNode);
    }
  };
  var DebugElement = class extends DebugNode {
    constructor(nativeNode) {
      ngDevMode && assertDomNode(nativeNode);
      super(nativeNode);
    }
    get nativeElement() {
      return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
    }
    get name() {
      const context = getLContext(this.nativeNode);
      if (context !== null) {
        const lView = context.lView;
        const tData = lView[TVIEW].data;
        const tNode = tData[context.nodeIndex];
        return tNode.value;
      } else {
        return this.nativeNode.nodeName;
      }
    }
    get properties() {
      const context = getLContext(this.nativeNode);
      if (context === null) {
        return {};
      }
      const lView = context.lView;
      const tData = lView[TVIEW].data;
      const tNode = tData[context.nodeIndex];
      const properties = {};
      copyDomProperties(this.nativeElement, properties);
      collectPropertyBindings(properties, tNode, lView, tData);
      return properties;
    }
    get attributes() {
      const attributes = {};
      const element2 = this.nativeElement;
      if (!element2) {
        return attributes;
      }
      const context = getLContext(element2);
      if (context === null) {
        return {};
      }
      const lView = context.lView;
      const tNodeAttrs = lView[TVIEW].data[context.nodeIndex].attrs;
      const lowercaseTNodeAttrs = [];
      if (tNodeAttrs) {
        let i = 0;
        while (i < tNodeAttrs.length) {
          const attrName = tNodeAttrs[i];
          if (typeof attrName !== "string")
            break;
          const attrValue = tNodeAttrs[i + 1];
          attributes[attrName] = attrValue;
          lowercaseTNodeAttrs.push(attrName.toLowerCase());
          i += 2;
        }
      }
      const eAttrs = element2.attributes;
      for (let i = 0; i < eAttrs.length; i++) {
        const attr = eAttrs[i];
        const lowercaseName = attr.name.toLowerCase();
        if (lowercaseTNodeAttrs.indexOf(lowercaseName) === -1) {
          attributes[lowercaseName] = attr.value;
        }
      }
      return attributes;
    }
    get styles() {
      if (this.nativeElement && this.nativeElement.style) {
        return this.nativeElement.style;
      }
      return {};
    }
    get classes() {
      const result = {};
      const element2 = this.nativeElement;
      const className = element2.className;
      const classes = typeof className !== "string" ? className.baseVal.split(" ") : className.split(" ");
      classes.forEach((value) => result[value] = true);
      return result;
    }
    get childNodes() {
      const childNodes = this.nativeNode.childNodes;
      const children = [];
      for (let i = 0; i < childNodes.length; i++) {
        const element2 = childNodes[i];
        children.push(getDebugNode(element2));
      }
      return children;
    }
    get children() {
      const nativeElement = this.nativeElement;
      if (!nativeElement)
        return [];
      const childNodes = nativeElement.children;
      const children = [];
      for (let i = 0; i < childNodes.length; i++) {
        const element2 = childNodes[i];
        children.push(getDebugNode(element2));
      }
      return children;
    }
    query(predicate) {
      const results = this.queryAll(predicate);
      return results[0] || null;
    }
    queryAll(predicate) {
      const matches = [];
      _queryAll(this, predicate, matches, true);
      return matches;
    }
    queryAllNodes(predicate) {
      const matches = [];
      _queryAll(this, predicate, matches, false);
      return matches;
    }
    triggerEventHandler(eventName, eventObj) {
      const node = this.nativeNode;
      const invokedListeners = [];
      this.listeners.forEach((listener) => {
        if (listener.name === eventName) {
          const callback = listener.callback;
          callback.call(node, eventObj);
          invokedListeners.push(callback);
        }
      });
      if (typeof node.eventListeners === "function") {
        node.eventListeners(eventName).forEach((listener) => {
          if (listener.toString().indexOf("__ngUnwrap__") !== -1) {
            const unwrappedListener = listener("__ngUnwrap__");
            return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
          }
        });
      }
    }
  };
  function copyDomProperties(element2, properties) {
    if (element2) {
      let obj = Object.getPrototypeOf(element2);
      const NodePrototype = Node.prototype;
      while (obj !== null && obj !== NodePrototype) {
        const descriptors = Object.getOwnPropertyDescriptors(obj);
        for (let key in descriptors) {
          if (!key.startsWith("__") && !key.startsWith("on")) {
            const value = element2[key];
            if (isPrimitiveValue(value)) {
              properties[key] = value;
            }
          }
        }
        obj = Object.getPrototypeOf(obj);
      }
    }
  }
  function isPrimitiveValue(value) {
    return typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === null;
  }
  function _queryAll(parentElement, predicate, matches, elementsOnly) {
    const context = getLContext(parentElement.nativeNode);
    if (context !== null) {
      const parentTNode = context.lView[TVIEW].data[context.nodeIndex];
      _queryNodeChildren(parentTNode, context.lView, predicate, matches, elementsOnly, parentElement.nativeNode);
    } else {
      _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
    }
  }
  function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    const nativeNode = getNativeByTNodeOrNull(tNode, lView);
    if (tNode.type & (3 | 8)) {
      _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
      if (isComponentHost(tNode)) {
        const componentView = getComponentLViewByIndex(tNode.index, lView);
        if (componentView && componentView[TVIEW].firstChild) {
          _queryNodeChildren(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
        }
      } else {
        if (tNode.child) {
          _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
        }
        nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
      }
      const nodeOrContainer = lView[tNode.index];
      if (isLContainer(nodeOrContainer)) {
        _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (tNode.type & 4) {
      const lContainer = lView[tNode.index];
      _addQueryMatch(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);
      _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
    } else if (tNode.type & 16) {
      const componentView = lView[DECLARATION_COMPONENT_VIEW];
      const componentHost = componentView[T_HOST];
      const head = componentHost.projection[tNode.projection];
      if (Array.isArray(head)) {
        for (let nativeNode2 of head) {
          _addQueryMatch(nativeNode2, predicate, matches, elementsOnly, rootNativeNode);
        }
      } else if (head) {
        const nextLView = componentView[PARENT];
        const nextTNode = nextLView[TVIEW].data[head.index];
        _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (tNode.child) {
      _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
    if (rootNativeNode !== nativeNode) {
      const nextTNode = tNode.flags & 4 ? tNode.projectionNext : tNode.next;
      if (nextTNode) {
        _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
    }
  }
  function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const childView = lContainer[i];
      const firstChild = childView[TVIEW].firstChild;
      if (firstChild) {
        _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
      }
    }
  }
  function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
    if (rootNativeNode !== nativeNode) {
      const debugNode = getDebugNode(nativeNode);
      if (!debugNode) {
        return;
      }
      if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
    }
  }
  function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
    const nodes = parentNode.childNodes;
    const length = nodes.length;
    for (let i = 0; i < length; i++) {
      const node = nodes[i];
      const debugNode = getDebugNode(node);
      if (debugNode) {
        if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
          matches.push(debugNode);
        } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
          matches.push(debugNode);
        }
        _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
      }
    }
  }
  function collectPropertyBindings(properties, tNode, lView, tData) {
    let bindingIndexes = tNode.propertyBindings;
    if (bindingIndexes !== null) {
      for (let i = 0; i < bindingIndexes.length; i++) {
        const bindingIndex = bindingIndexes[i];
        const propMetadata = tData[bindingIndex];
        const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
        const propertyName = metadataParts[0];
        if (metadataParts.length > 1) {
          let value = metadataParts[1];
          for (let j = 1; j < metadataParts.length - 1; j++) {
            value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
          }
          properties[propertyName] = value;
        } else {
          properties[propertyName] = lView[bindingIndex];
        }
      }
    }
  }
  var NG_DEBUG_PROPERTY = "__ng_debug__";
  function getDebugNode(nativeNode) {
    if (nativeNode instanceof Node) {
      if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
        nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
      }
      return nativeNode[NG_DEBUG_PROPERTY];
    }
    return null;
  }
  var DefaultIterableDifferFactory = class {
    constructor() {
    }
    supports(obj) {
      return isListLikeIterable(obj);
    }
    create(trackByFn) {
      return new DefaultIterableDiffer(trackByFn);
    }
  };
  var trackByIdentity = (index, item) => item;
  var DefaultIterableDiffer = class {
    constructor(trackByFn) {
      this.length = 0;
      this._linkedRecords = null;
      this._unlinkedRecords = null;
      this._previousItHead = null;
      this._itHead = null;
      this._itTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._movesHead = null;
      this._movesTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
      this._identityChangesHead = null;
      this._identityChangesTail = null;
      this._trackByFn = trackByFn || trackByIdentity;
    }
    forEachItem(fn2) {
      let record;
      for (record = this._itHead; record !== null; record = record._next) {
        fn2(record);
      }
    }
    forEachOperation(fn2) {
      let nextIt = this._itHead;
      let nextRemove = this._removalsHead;
      let addRemoveOffset = 0;
      let moveOffsets = null;
      while (nextIt || nextRemove) {
        const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
        const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
        const currentIndex = record.currentIndex;
        if (record === nextRemove) {
          addRemoveOffset--;
          nextRemove = nextRemove._nextRemoved;
        } else {
          nextIt = nextIt._next;
          if (record.previousIndex == null) {
            addRemoveOffset++;
          } else {
            if (!moveOffsets)
              moveOffsets = [];
            const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
            const localCurrentIndex = currentIndex - addRemoveOffset;
            if (localMovePreviousIndex != localCurrentIndex) {
              for (let i = 0; i < localMovePreviousIndex; i++) {
                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                const index = offset + i;
                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                  moveOffsets[i] = offset + 1;
                }
              }
              const previousIndex = record.previousIndex;
              moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
            }
          }
        }
        if (adjPreviousIndex !== currentIndex) {
          fn2(record, adjPreviousIndex, currentIndex);
        }
      }
    }
    forEachPreviousItem(fn2) {
      let record;
      for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
        fn2(record);
      }
    }
    forEachAddedItem(fn2) {
      let record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn2(record);
      }
    }
    forEachMovedItem(fn2) {
      let record;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        fn2(record);
      }
    }
    forEachRemovedItem(fn2) {
      let record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn2(record);
      }
    }
    forEachIdentityChange(fn2) {
      let record;
      for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
        fn2(record);
      }
    }
    diff(collection) {
      if (collection == null)
        collection = [];
      if (!isListLikeIterable(collection)) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed` : "";
        throw new RuntimeError(900, errorMessage);
      }
      if (this.check(collection)) {
        return this;
      } else {
        return null;
      }
    }
    onDestroy() {
    }
    check(collection) {
      this._reset();
      let record = this._itHead;
      let mayBeDirty = false;
      let index;
      let item;
      let itemTrackBy;
      if (Array.isArray(collection)) {
        this.length = collection.length;
        for (let index2 = 0; index2 < this.length; index2++) {
          item = collection[index2];
          itemTrackBy = this._trackByFn(index2, item);
          if (record === null || !Object.is(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item, itemTrackBy, index2);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item, itemTrackBy, index2);
            }
            if (!Object.is(record.item, item))
              this._addIdentityChange(record, item);
          }
          record = record._next;
        }
      } else {
        index = 0;
        iterateListLike(collection, (item2) => {
          itemTrackBy = this._trackByFn(index, item2);
          if (record === null || !Object.is(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item2, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item2, itemTrackBy, index);
            }
            if (!Object.is(record.item, item2))
              this._addIdentityChange(record, item2);
          }
          record = record._next;
          index++;
        });
        this.length = index;
      }
      this._truncate(record);
      this.collection = collection;
      return this.isDirty;
    }
    get isDirty() {
      return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
    }
    _reset() {
      if (this.isDirty) {
        let record;
        for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          record.previousIndex = record.currentIndex;
        }
        this._additionsHead = this._additionsTail = null;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          record.previousIndex = record.currentIndex;
        }
        this._movesHead = this._movesTail = null;
        this._removalsHead = this._removalsTail = null;
        this._identityChangesHead = this._identityChangesTail = null;
      }
    }
    _mismatch(record, item, itemTrackBy, index) {
      let previousRecord;
      if (record === null) {
        previousRecord = this._itTail;
      } else {
        previousRecord = record._prev;
        this._remove(record);
      }
      record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
      if (record !== null) {
        if (!Object.is(record.item, item))
          this._addIdentityChange(record, item);
        this._reinsertAfter(record, previousRecord, index);
      } else {
        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
        if (record !== null) {
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
          this._moveAfter(record, previousRecord, index);
        } else {
          record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
        }
      }
      return record;
    }
    _verifyReinsertion(record, item, itemTrackBy, index) {
      let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
      if (reinsertRecord !== null) {
        record = this._reinsertAfter(reinsertRecord, record._prev, index);
      } else if (record.currentIndex != index) {
        record.currentIndex = index;
        this._addToMoves(record, index);
      }
      return record;
    }
    _truncate(record) {
      while (record !== null) {
        const nextRecord = record._next;
        this._addToRemovals(this._unlink(record));
        record = nextRecord;
      }
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.clear();
      }
      if (this._additionsTail !== null) {
        this._additionsTail._nextAdded = null;
      }
      if (this._movesTail !== null) {
        this._movesTail._nextMoved = null;
      }
      if (this._itTail !== null) {
        this._itTail._next = null;
      }
      if (this._removalsTail !== null) {
        this._removalsTail._nextRemoved = null;
      }
      if (this._identityChangesTail !== null) {
        this._identityChangesTail._nextIdentityChange = null;
      }
    }
    _reinsertAfter(record, prevRecord, index) {
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.remove(record);
      }
      const prev = record._prevRemoved;
      const next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    }
    _moveAfter(record, prevRecord, index) {
      this._unlink(record);
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    }
    _addAfter(record, prevRecord, index) {
      this._insertAfter(record, prevRecord, index);
      if (this._additionsTail === null) {
        this._additionsTail = this._additionsHead = record;
      } else {
        this._additionsTail = this._additionsTail._nextAdded = record;
      }
      return record;
    }
    _insertAfter(record, prevRecord, index) {
      const next = prevRecord === null ? this._itHead : prevRecord._next;
      record._next = next;
      record._prev = prevRecord;
      if (next === null) {
        this._itTail = record;
      } else {
        next._prev = record;
      }
      if (prevRecord === null) {
        this._itHead = record;
      } else {
        prevRecord._next = record;
      }
      if (this._linkedRecords === null) {
        this._linkedRecords = new _DuplicateMap();
      }
      this._linkedRecords.put(record);
      record.currentIndex = index;
      return record;
    }
    _remove(record) {
      return this._addToRemovals(this._unlink(record));
    }
    _unlink(record) {
      if (this._linkedRecords !== null) {
        this._linkedRecords.remove(record);
      }
      const prev = record._prev;
      const next = record._next;
      if (prev === null) {
        this._itHead = next;
      } else {
        prev._next = next;
      }
      if (next === null) {
        this._itTail = prev;
      } else {
        next._prev = prev;
      }
      return record;
    }
    _addToMoves(record, toIndex) {
      if (record.previousIndex === toIndex) {
        return record;
      }
      if (this._movesTail === null) {
        this._movesTail = this._movesHead = record;
      } else {
        this._movesTail = this._movesTail._nextMoved = record;
      }
      return record;
    }
    _addToRemovals(record) {
      if (this._unlinkedRecords === null) {
        this._unlinkedRecords = new _DuplicateMap();
      }
      this._unlinkedRecords.put(record);
      record.currentIndex = null;
      record._nextRemoved = null;
      if (this._removalsTail === null) {
        this._removalsTail = this._removalsHead = record;
        record._prevRemoved = null;
      } else {
        record._prevRemoved = this._removalsTail;
        this._removalsTail = this._removalsTail._nextRemoved = record;
      }
      return record;
    }
    _addIdentityChange(record, item) {
      record.item = item;
      if (this._identityChangesTail === null) {
        this._identityChangesTail = this._identityChangesHead = record;
      } else {
        this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
      }
      return record;
    }
  };
  var IterableChangeRecord_ = class {
    constructor(item, trackById) {
      this.item = item;
      this.trackById = trackById;
      this.currentIndex = null;
      this.previousIndex = null;
      this._nextPrevious = null;
      this._prev = null;
      this._next = null;
      this._prevDup = null;
      this._nextDup = null;
      this._prevRemoved = null;
      this._nextRemoved = null;
      this._nextAdded = null;
      this._nextMoved = null;
      this._nextIdentityChange = null;
    }
  };
  var _DuplicateItemRecordList = class {
    constructor() {
      this._head = null;
      this._tail = null;
    }
    add(record) {
      if (this._head === null) {
        this._head = this._tail = record;
        record._nextDup = null;
        record._prevDup = null;
      } else {
        this._tail._nextDup = record;
        record._prevDup = this._tail;
        record._nextDup = null;
        this._tail = record;
      }
    }
    get(trackById, atOrAfterIndex) {
      let record;
      for (record = this._head; record !== null; record = record._nextDup) {
        if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
          return record;
        }
      }
      return null;
    }
    remove(record) {
      const prev = record._prevDup;
      const next = record._nextDup;
      if (prev === null) {
        this._head = next;
      } else {
        prev._nextDup = next;
      }
      if (next === null) {
        this._tail = prev;
      } else {
        next._prevDup = prev;
      }
      return this._head === null;
    }
  };
  var _DuplicateMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    put(record) {
      const key = record.trackById;
      let duplicates = this.map.get(key);
      if (!duplicates) {
        duplicates = new _DuplicateItemRecordList();
        this.map.set(key, duplicates);
      }
      duplicates.add(record);
    }
    get(trackById, atOrAfterIndex) {
      const key = trackById;
      const recordList = this.map.get(key);
      return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
    }
    remove(record) {
      const key = record.trackById;
      const recordList = this.map.get(key);
      if (recordList.remove(record)) {
        this.map.delete(key);
      }
      return record;
    }
    get isEmpty() {
      return this.map.size === 0;
    }
    clear() {
      this.map.clear();
    }
  };
  function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    const previousIndex = item.previousIndex;
    if (previousIndex === null)
      return previousIndex;
    let moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) {
      moveOffset = moveOffsets[previousIndex];
    }
    return previousIndex + addRemoveOffset + moveOffset;
  }
  var DefaultKeyValueDifferFactory = class {
    constructor() {
    }
    supports(obj) {
      return obj instanceof Map || isJsObject(obj);
    }
    create() {
      return new DefaultKeyValueDiffer();
    }
  };
  var DefaultKeyValueDiffer = class {
    constructor() {
      this._records = /* @__PURE__ */ new Map();
      this._mapHead = null;
      this._appendAfter = null;
      this._previousMapHead = null;
      this._changesHead = null;
      this._changesTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
    }
    get isDirty() {
      return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
    }
    forEachItem(fn2) {
      let record;
      for (record = this._mapHead; record !== null; record = record._next) {
        fn2(record);
      }
    }
    forEachPreviousItem(fn2) {
      let record;
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        fn2(record);
      }
    }
    forEachChangedItem(fn2) {
      let record;
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        fn2(record);
      }
    }
    forEachAddedItem(fn2) {
      let record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn2(record);
      }
    }
    forEachRemovedItem(fn2) {
      let record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn2(record);
      }
    }
    diff(map2) {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
      } else if (!(map2 instanceof Map || isJsObject(map2))) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed` : "";
        throw new RuntimeError(900, errorMessage);
      }
      return this.check(map2) ? this : null;
    }
    onDestroy() {
    }
    check(map2) {
      this._reset();
      let insertBefore = this._mapHead;
      this._appendAfter = null;
      this._forEach(map2, (value, key) => {
        if (insertBefore && insertBefore.key === key) {
          this._maybeAddToChanges(insertBefore, value);
          this._appendAfter = insertBefore;
          insertBefore = insertBefore._next;
        } else {
          const record = this._getOrCreateRecordForKey(key, value);
          insertBefore = this._insertBeforeOrAppend(insertBefore, record);
        }
      });
      if (insertBefore) {
        if (insertBefore._prev) {
          insertBefore._prev._next = null;
        }
        this._removalsHead = insertBefore;
        for (let record = insertBefore; record !== null; record = record._nextRemoved) {
          if (record === this._mapHead) {
            this._mapHead = null;
          }
          this._records.delete(record.key);
          record._nextRemoved = record._next;
          record.previousValue = record.currentValue;
          record.currentValue = null;
          record._prev = null;
          record._next = null;
        }
      }
      if (this._changesTail)
        this._changesTail._nextChanged = null;
      if (this._additionsTail)
        this._additionsTail._nextAdded = null;
      return this.isDirty;
    }
    _insertBeforeOrAppend(before, record) {
      if (before) {
        const prev = before._prev;
        record._next = before;
        record._prev = prev;
        before._prev = record;
        if (prev) {
          prev._next = record;
        }
        if (before === this._mapHead) {
          this._mapHead = record;
        }
        this._appendAfter = before;
        return before;
      }
      if (this._appendAfter) {
        this._appendAfter._next = record;
        record._prev = this._appendAfter;
      } else {
        this._mapHead = record;
      }
      this._appendAfter = record;
      return null;
    }
    _getOrCreateRecordForKey(key, value) {
      if (this._records.has(key)) {
        const record2 = this._records.get(key);
        this._maybeAddToChanges(record2, value);
        const prev = record2._prev;
        const next = record2._next;
        if (prev) {
          prev._next = next;
        }
        if (next) {
          next._prev = prev;
        }
        record2._next = null;
        record2._prev = null;
        return record2;
      }
      const record = new KeyValueChangeRecord_(key);
      this._records.set(key, record);
      record.currentValue = value;
      this._addToAdditions(record);
      return record;
    }
    _reset() {
      if (this.isDirty) {
        let record;
        this._previousMapHead = this._mapHead;
        for (record = this._previousMapHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          record.previousValue = record.currentValue;
        }
        for (record = this._additionsHead; record != null; record = record._nextAdded) {
          record.previousValue = record.currentValue;
        }
        this._changesHead = this._changesTail = null;
        this._additionsHead = this._additionsTail = null;
        this._removalsHead = null;
      }
    }
    _maybeAddToChanges(record, newValue) {
      if (!Object.is(newValue, record.currentValue)) {
        record.previousValue = record.currentValue;
        record.currentValue = newValue;
        this._addToChanges(record);
      }
    }
    _addToAdditions(record) {
      if (this._additionsHead === null) {
        this._additionsHead = this._additionsTail = record;
      } else {
        this._additionsTail._nextAdded = record;
        this._additionsTail = record;
      }
    }
    _addToChanges(record) {
      if (this._changesHead === null) {
        this._changesHead = this._changesTail = record;
      } else {
        this._changesTail._nextChanged = record;
        this._changesTail = record;
      }
    }
    _forEach(obj, fn2) {
      if (obj instanceof Map) {
        obj.forEach(fn2);
      } else {
        Object.keys(obj).forEach((k) => fn2(obj[k], k));
      }
    }
  };
  var KeyValueChangeRecord_ = class {
    constructor(key) {
      this.key = key;
      this.previousValue = null;
      this.currentValue = null;
      this._nextPrevious = null;
      this._next = null;
      this._prev = null;
      this._nextAdded = null;
      this._nextRemoved = null;
      this._nextChanged = null;
    }
  };
  function defaultIterableDiffersFactory() {
    return new IterableDiffers([new DefaultIterableDifferFactory()]);
  }
  var IterableDiffers = class {
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent != null) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new IterableDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: IterableDiffers,
        useFactory: (parent) => {
          return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
        },
        deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
      };
    }
    find(iterable) {
      const factory = this.factories.find((f) => f.supports(iterable));
      if (factory != null) {
        return factory;
      } else {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'` : "";
        throw new RuntimeError(901, errorMessage);
      }
    }
  };
  IterableDiffers.\u0275prov = \u0275\u0275defineInjectable({ token: IterableDiffers, providedIn: "root", factory: defaultIterableDiffersFactory });
  function getTypeNameForDebugging(type) {
    return type["name"] || typeof type;
  }
  function defaultKeyValueDiffersFactory() {
    return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
  }
  var KeyValueDiffers = class {
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new KeyValueDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: KeyValueDiffers,
        useFactory: (parent) => {
          return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
        },
        deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
      };
    }
    find(kv) {
      const factory = this.factories.find((f) => f.supports(kv));
      if (factory) {
        return factory;
      }
      const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `Cannot find a differ supporting object '${kv}'` : "";
      throw new RuntimeError(901, errorMessage);
    }
  };
  KeyValueDiffers.\u0275prov = \u0275\u0275defineInjectable({ token: KeyValueDiffers, providedIn: "root", factory: defaultKeyValueDiffersFactory });
  var keyValDiff = [new DefaultKeyValueDifferFactory()];
  var iterableDiff = [new DefaultIterableDifferFactory()];
  var defaultIterableDiffers = new IterableDiffers(iterableDiff);
  var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
  var platformCore = createPlatformFactory(null, "core", []);
  var ApplicationModule = class {
    constructor(appRef) {
    }
  };
  ApplicationModule.\u0275fac = function ApplicationModule_Factory(t) {
    return new (t || ApplicationModule)(\u0275\u0275inject(ApplicationRef));
  };
  ApplicationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: ApplicationModule });
  ApplicationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
      type: NgModule
    }], function() {
      return [{ type: ApplicationRef }];
    }, null);
  })();
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    _global2.$localize = _global2.$localize || function() {
      throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
    };
  }

  // node_modules/@angular/compiler/fesm2020/compiler.mjs
  var TagContentType;
  (function(TagContentType2) {
    TagContentType2[TagContentType2["RAW_TEXT"] = 0] = "RAW_TEXT";
    TagContentType2[TagContentType2["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
    TagContentType2[TagContentType2["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(TagContentType || (TagContentType = {}));
  function splitNsName(elementName) {
    if (elementName[0] != ":") {
      return [null, elementName];
    }
    const colonIndex = elementName.indexOf(":", 1);
    if (colonIndex === -1) {
      throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
    }
    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  function isNgContainer(tagName) {
    return splitNsName(tagName)[1] === "ng-container";
  }
  function isNgContent(tagName) {
    return splitNsName(tagName)[1] === "ng-content";
  }
  function isNgTemplate(tagName) {
    return splitNsName(tagName)[1] === "ng-template";
  }
  function getNsPrefix(fullName) {
    return fullName === null ? null : splitNsName(fullName)[0];
  }
  function mergeNsAndName(prefix, localName) {
    return prefix ? `:${prefix}:${localName}` : localName;
  }
  var HtmlTagDefinition = class {
    constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {
      this.closedByChildren = {};
      this.closedByParent = false;
      this.canSelfClose = false;
      if (closedByChildren && closedByChildren.length > 0) {
        closedByChildren.forEach((tagName) => this.closedByChildren[tagName] = true);
      }
      this.isVoid = isVoid;
      this.closedByParent = closedByParent || isVoid;
      this.implicitNamespacePrefix = implicitNamespacePrefix || null;
      this.contentType = contentType;
      this.ignoreFirstLf = ignoreFirstLf;
      this.preventNamespaceInheritance = preventNamespaceInheritance;
    }
    isClosedByChild(name) {
      return this.isVoid || name.toLowerCase() in this.closedByChildren;
    }
    getContentType(prefix) {
      if (typeof this.contentType === "object") {
        const overrideType = prefix === void 0 ? void 0 : this.contentType[prefix];
        return overrideType ?? this.contentType.default;
      }
      return this.contentType;
    }
  };
  var _DEFAULT_TAG_DEFINITION;
  var TAG_DEFINITIONS;
  function getHtmlTagDefinition(tagName) {
    if (!TAG_DEFINITIONS) {
      _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
      TAG_DEFINITIONS = {
        "base": new HtmlTagDefinition({ isVoid: true }),
        "meta": new HtmlTagDefinition({ isVoid: true }),
        "area": new HtmlTagDefinition({ isVoid: true }),
        "embed": new HtmlTagDefinition({ isVoid: true }),
        "link": new HtmlTagDefinition({ isVoid: true }),
        "img": new HtmlTagDefinition({ isVoid: true }),
        "input": new HtmlTagDefinition({ isVoid: true }),
        "param": new HtmlTagDefinition({ isVoid: true }),
        "hr": new HtmlTagDefinition({ isVoid: true }),
        "br": new HtmlTagDefinition({ isVoid: true }),
        "source": new HtmlTagDefinition({ isVoid: true }),
        "track": new HtmlTagDefinition({ isVoid: true }),
        "wbr": new HtmlTagDefinition({ isVoid: true }),
        "p": new HtmlTagDefinition({
          closedByChildren: [
            "address",
            "article",
            "aside",
            "blockquote",
            "div",
            "dl",
            "fieldset",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "hr",
            "main",
            "nav",
            "ol",
            "p",
            "pre",
            "section",
            "table",
            "ul"
          ],
          closedByParent: true
        }),
        "thead": new HtmlTagDefinition({ closedByChildren: ["tbody", "tfoot"] }),
        "tbody": new HtmlTagDefinition({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }),
        "tfoot": new HtmlTagDefinition({ closedByChildren: ["tbody"], closedByParent: true }),
        "tr": new HtmlTagDefinition({ closedByChildren: ["tr"], closedByParent: true }),
        "td": new HtmlTagDefinition({ closedByChildren: ["td", "th"], closedByParent: true }),
        "th": new HtmlTagDefinition({ closedByChildren: ["td", "th"], closedByParent: true }),
        "col": new HtmlTagDefinition({ isVoid: true }),
        "svg": new HtmlTagDefinition({ implicitNamespacePrefix: "svg" }),
        "foreignObject": new HtmlTagDefinition({
          implicitNamespacePrefix: "svg",
          preventNamespaceInheritance: true
        }),
        "math": new HtmlTagDefinition({ implicitNamespacePrefix: "math" }),
        "li": new HtmlTagDefinition({ closedByChildren: ["li"], closedByParent: true }),
        "dt": new HtmlTagDefinition({ closedByChildren: ["dt", "dd"] }),
        "dd": new HtmlTagDefinition({ closedByChildren: ["dt", "dd"], closedByParent: true }),
        "rb": new HtmlTagDefinition({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }),
        "rt": new HtmlTagDefinition({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }),
        "rtc": new HtmlTagDefinition({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }),
        "rp": new HtmlTagDefinition({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }),
        "optgroup": new HtmlTagDefinition({ closedByChildren: ["optgroup"], closedByParent: true }),
        "option": new HtmlTagDefinition({ closedByChildren: ["option", "optgroup"], closedByParent: true }),
        "pre": new HtmlTagDefinition({ ignoreFirstLf: true }),
        "listing": new HtmlTagDefinition({ ignoreFirstLf: true }),
        "style": new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
        "script": new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
        "title": new HtmlTagDefinition({
          contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }
        }),
        "textarea": new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true })
      };
    }
    return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ?? _DEFAULT_TAG_DEFINITION;
  }
  var _SELECTOR_REGEXP = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
  var CssSelector = class {
    constructor() {
      this.element = null;
      this.classNames = [];
      this.attrs = [];
      this.notSelectors = [];
    }
    static parse(selector) {
      const results = [];
      const _addResult = (res, cssSel) => {
        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {
          cssSel.element = "*";
        }
        res.push(cssSel);
      };
      let cssSelector = new CssSelector();
      let match;
      let current = cssSelector;
      let inNot = false;
      _SELECTOR_REGEXP.lastIndex = 0;
      while (match = _SELECTOR_REGEXP.exec(selector)) {
        if (match[1]) {
          if (inNot) {
            throw new Error("Nesting :not in a selector is not allowed");
          }
          inNot = true;
          current = new CssSelector();
          cssSelector.notSelectors.push(current);
        }
        const tag = match[2];
        if (tag) {
          const prefix = match[3];
          if (prefix === "#") {
            current.addAttribute("id", tag.substr(1));
          } else if (prefix === ".") {
            current.addClassName(tag.substr(1));
          } else {
            current.setElement(tag);
          }
        }
        const attribute = match[4];
        if (attribute) {
          current.addAttribute(current.unescapeAttribute(attribute), match[6]);
        }
        if (match[7]) {
          inNot = false;
          current = cssSelector;
        }
        if (match[8]) {
          if (inNot) {
            throw new Error("Multiple selectors in :not are not supported");
          }
          _addResult(results, cssSelector);
          cssSelector = current = new CssSelector();
        }
      }
      _addResult(results, cssSelector);
      return results;
    }
    unescapeAttribute(attr) {
      let result = "";
      let escaping = false;
      for (let i = 0; i < attr.length; i++) {
        const char = attr.charAt(i);
        if (char === "\\") {
          escaping = true;
          continue;
        }
        if (char === "$" && !escaping) {
          throw new Error(`Error in attribute selector "${attr}". Unescaped "$" is not supported. Please escape with "\\$".`);
        }
        escaping = false;
        result += char;
      }
      return result;
    }
    escapeAttribute(attr) {
      return attr.replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
    }
    isElementSelector() {
      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;
    }
    hasElementSelector() {
      return !!this.element;
    }
    setElement(element2 = null) {
      this.element = element2;
    }
    getMatchingElementTemplate() {
      const tagName = this.element || "div";
      const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(" ")}"` : "";
      let attrs = "";
      for (let i = 0; i < this.attrs.length; i += 2) {
        const attrName = this.attrs[i];
        const attrValue = this.attrs[i + 1] !== "" ? `="${this.attrs[i + 1]}"` : "";
        attrs += ` ${attrName}${attrValue}`;
      }
      return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` : `<${tagName}${classAttr}${attrs}></${tagName}>`;
    }
    getAttrs() {
      const result = [];
      if (this.classNames.length > 0) {
        result.push("class", this.classNames.join(" "));
      }
      return result.concat(this.attrs);
    }
    addAttribute(name, value = "") {
      this.attrs.push(name, value && value.toLowerCase() || "");
    }
    addClassName(name) {
      this.classNames.push(name.toLowerCase());
    }
    toString() {
      let res = this.element || "";
      if (this.classNames) {
        this.classNames.forEach((klass) => res += `.${klass}`);
      }
      if (this.attrs) {
        for (let i = 0; i < this.attrs.length; i += 2) {
          const name = this.escapeAttribute(this.attrs[i]);
          const value = this.attrs[i + 1];
          res += `[${name}${value ? "=" + value : ""}]`;
        }
      }
      this.notSelectors.forEach((notSelector) => res += `:not(${notSelector})`);
      return res;
    }
  };
  var ViewEncapsulation2;
  (function(ViewEncapsulation3) {
    ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
    ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
    ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation2 || (ViewEncapsulation2 = {}));
  var ChangeDetectionStrategy2;
  (function(ChangeDetectionStrategy3) {
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["OnPush"] = 0] = "OnPush";
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["Default"] = 1] = "Default";
  })(ChangeDetectionStrategy2 || (ChangeDetectionStrategy2 = {}));
  var CUSTOM_ELEMENTS_SCHEMA2 = {
    name: "custom-elements"
  };
  var NO_ERRORS_SCHEMA2 = {
    name: "no-errors-schema"
  };
  var SecurityContext2;
  (function(SecurityContext3) {
    SecurityContext3[SecurityContext3["NONE"] = 0] = "NONE";
    SecurityContext3[SecurityContext3["HTML"] = 1] = "HTML";
    SecurityContext3[SecurityContext3["STYLE"] = 2] = "STYLE";
    SecurityContext3[SecurityContext3["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext3[SecurityContext3["URL"] = 4] = "URL";
    SecurityContext3[SecurityContext3["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(SecurityContext2 || (SecurityContext2 = {}));
  var MissingTranslationStrategy2;
  (function(MissingTranslationStrategy3) {
    MissingTranslationStrategy3[MissingTranslationStrategy3["Error"] = 0] = "Error";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Warning"] = 1] = "Warning";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Ignore"] = 2] = "Ignore";
  })(MissingTranslationStrategy2 || (MissingTranslationStrategy2 = {}));
  function parserSelectorToSimpleSelector(selector) {
    const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];
    const elementName = selector.element && selector.element !== "*" ? selector.element : "";
    return [elementName, ...selector.attrs, ...classes];
  }
  function parserSelectorToNegativeSelector(selector) {
    const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];
    if (selector.element) {
      return [
        1 | 4,
        selector.element,
        ...selector.attrs,
        ...classes
      ];
    } else if (selector.attrs.length) {
      return [1 | 2, ...selector.attrs, ...classes];
    } else {
      return selector.classNames && selector.classNames.length ? [1 | 8, ...selector.classNames] : [];
    }
  }
  function parserSelectorToR3Selector(selector) {
    const positive = parserSelectorToSimpleSelector(selector);
    const negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map((notSelector) => parserSelectorToNegativeSelector(notSelector)) : [];
    return positive.concat(...negative);
  }
  function parseSelectorToR3Selector(selector) {
    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
  }
  var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
  function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
  }
  function splitAtColon(input, defaultValues) {
    return _splitAt(input, ":", defaultValues);
  }
  function splitAtPeriod(input, defaultValues) {
    return _splitAt(input, ".", defaultValues);
  }
  function _splitAt(input, character, defaultValues) {
    const characterIndex = input.indexOf(character);
    if (characterIndex == -1)
      return defaultValues;
    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
  }
  function error2(msg) {
    throw new Error(`Internal Error: ${msg}`);
  }
  function utf8Encode(str) {
    let encoded = [];
    for (let index = 0; index < str.length; index++) {
      let codePoint = str.charCodeAt(index);
      if (codePoint >= 55296 && codePoint <= 56319 && str.length > index + 1) {
        const low = str.charCodeAt(index + 1);
        if (low >= 56320 && low <= 57343) {
          index++;
          codePoint = (codePoint - 55296 << 10) + low - 56320 + 65536;
        }
      }
      if (codePoint <= 127) {
        encoded.push(codePoint);
      } else if (codePoint <= 2047) {
        encoded.push(codePoint >> 6 & 31 | 192, codePoint & 63 | 128);
      } else if (codePoint <= 65535) {
        encoded.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint <= 2097151) {
        encoded.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      }
    }
    return encoded;
  }
  function stringify2(token) {
    if (typeof token === "string") {
      return token;
    }
    if (Array.isArray(token)) {
      return "[" + token.map(stringify2).join(", ") + "]";
    }
    if (token == null) {
      return "" + token;
    }
    if (token.overriddenName) {
      return `${token.overriddenName}`;
    }
    if (token.name) {
      return `${token.name}`;
    }
    if (!token.toString) {
      return "object";
    }
    const res = token.toString();
    if (res == null) {
      return "" + res;
    }
    const newLineIndex = res.indexOf("\n");
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  var Version2 = class {
    constructor(full) {
      this.full = full;
      const splits = full.split(".");
      this.major = splits[0];
      this.minor = splits[1];
      this.patch = splits.slice(2).join(".");
    }
  };
  var __window2 = typeof window !== "undefined" && window;
  var __self2 = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
  var __global2 = typeof global !== "undefined" && global;
  var _global3 = __global2 || __window2 || __self2;
  function newArray2(size, value) {
    const list = [];
    for (let i = 0; i < size; i++) {
      list.push(value);
    }
    return list;
  }
  function partitionArray(arr, conditionFn) {
    const truthy = [];
    const falsy = [];
    for (const item of arr) {
      (conditionFn(item) ? truthy : falsy).push(item);
    }
    return [truthy, falsy];
  }
  var BigInteger = class {
    constructor(digits) {
      this.digits = digits;
    }
    static zero() {
      return new BigInteger([0]);
    }
    static one() {
      return new BigInteger([1]);
    }
    clone() {
      return new BigInteger(this.digits.slice());
    }
    add(other) {
      const result = this.clone();
      result.addToSelf(other);
      return result;
    }
    addToSelf(other) {
      const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);
      let carry = 0;
      for (let i = 0; i < maxNrOfDigits; i++) {
        let digitSum = carry;
        if (i < this.digits.length) {
          digitSum += this.digits[i];
        }
        if (i < other.digits.length) {
          digitSum += other.digits[i];
        }
        if (digitSum >= 10) {
          this.digits[i] = digitSum - 10;
          carry = 1;
        } else {
          this.digits[i] = digitSum;
          carry = 0;
        }
      }
      if (carry > 0) {
        this.digits[maxNrOfDigits] = 1;
      }
    }
    toString() {
      let res = "";
      for (let i = this.digits.length - 1; i >= 0; i--) {
        res += this.digits[i];
      }
      return res;
    }
  };
  var BigIntForMultiplication = class {
    constructor(value) {
      this.powerOfTwos = [value];
    }
    getValue() {
      return this.powerOfTwos[0];
    }
    multiplyBy(num) {
      const product = BigInteger.zero();
      this.multiplyByAndAddTo(num, product);
      return product;
    }
    multiplyByAndAddTo(num, result) {
      for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {
        if (num & 1) {
          const value = this.getMultipliedByPowerOfTwo(exponent);
          result.addToSelf(value);
        }
      }
    }
    getMultipliedByPowerOfTwo(exponent) {
      for (let i = this.powerOfTwos.length; i <= exponent; i++) {
        const previousPower = this.powerOfTwos[i - 1];
        this.powerOfTwos[i] = previousPower.add(previousPower);
      }
      return this.powerOfTwos[exponent];
    }
  };
  var BigIntExponentiation = class {
    constructor(base) {
      this.base = base;
      this.exponents = [new BigIntForMultiplication(BigInteger.one())];
    }
    toThePowerOf(exponent) {
      for (let i = this.exponents.length; i <= exponent; i++) {
        const value = this.exponents[i - 1].multiplyBy(this.base);
        this.exponents[i] = new BigIntForMultiplication(value);
      }
      return this.exponents[exponent];
    }
  };
  function computeDigest(message) {
    return sha1(serializeNodes(message.nodes).join("") + `[${message.meaning}]`);
  }
  function decimalDigest(message) {
    return message.id || computeDecimalDigest(message);
  }
  function computeDecimalDigest(message) {
    const visitor = new _SerializerIgnoreIcuExpVisitor();
    const parts = message.nodes.map((a) => a.visit(visitor, null));
    return computeMsgId(parts.join(""), message.meaning);
  }
  var _SerializerVisitor = class {
    visitText(text, context) {
      return text.value;
    }
    visitContainer(container, context) {
      return `[${container.children.map((child) => child.visit(this)).join(", ")}]`;
    }
    visitIcu(icu, context) {
      const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      return `{${icu.expression}, ${icu.type}, ${strCases.join(", ")}}`;
    }
    visitTagPlaceholder(ph, context) {
      return ph.isVoid ? `<ph tag name="${ph.startName}"/>` : `<ph tag name="${ph.startName}">${ph.children.map((child) => child.visit(this)).join(", ")}</ph name="${ph.closeName}">`;
    }
    visitPlaceholder(ph, context) {
      return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
    }
    visitIcuPlaceholder(ph, context) {
      return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
    }
  };
  var serializerVisitor$1 = new _SerializerVisitor();
  function serializeNodes(nodes) {
    return nodes.map((a) => a.visit(serializerVisitor$1, null));
  }
  var _SerializerIgnoreIcuExpVisitor = class extends _SerializerVisitor {
    visitIcu(icu, context) {
      let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      return `{${icu.type}, ${strCases.join(", ")}}`;
    }
  };
  function sha1(str) {
    const utf8 = utf8Encode(str);
    const words32 = bytesToWords32(utf8, Endian.Big);
    const len = utf8.length * 8;
    const w = newArray2(80);
    let a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, e = 3285377520;
    words32[len >> 5] |= 128 << 24 - len % 32;
    words32[(len + 64 >> 9 << 4) + 15] = len;
    for (let i = 0; i < words32.length; i += 16) {
      const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
      for (let j = 0; j < 80; j++) {
        if (j < 16) {
          w[j] = words32[i + j];
        } else {
          w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }
        const fkVal = fk(j, b, c, d);
        const f = fkVal[0];
        const k = fkVal[1];
        const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
        e = d;
        d = c;
        c = rol32(b, 30);
        b = a;
        a = temp;
      }
      a = add32(a, h0);
      b = add32(b, h1);
      c = add32(c, h2);
      d = add32(d, h3);
      e = add32(e, h4);
    }
    return bytesToHexString(words32ToByteString([a, b, c, d, e]));
  }
  function fk(index, b, c, d) {
    if (index < 20) {
      return [b & c | ~b & d, 1518500249];
    }
    if (index < 40) {
      return [b ^ c ^ d, 1859775393];
    }
    if (index < 60) {
      return [b & c | b & d | c & d, 2400959708];
    }
    return [b ^ c ^ d, 3395469782];
  }
  function fingerprint(str) {
    const utf8 = utf8Encode(str);
    let hi = hash32(utf8, 0);
    let lo = hash32(utf8, 102072);
    if (hi == 0 && (lo == 0 || lo == 1)) {
      hi = hi ^ 319790063;
      lo = lo ^ -1801410264;
    }
    return [hi, lo];
  }
  function computeMsgId(msg, meaning = "") {
    let msgFingerprint = fingerprint(msg);
    if (meaning) {
      const meaningFingerprint = fingerprint(meaning);
      msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
    }
    const hi = msgFingerprint[0];
    const lo = msgFingerprint[1];
    return wordsToDecimalString(hi & 2147483647, lo);
  }
  function hash32(bytes, c) {
    let a = 2654435769, b = 2654435769;
    let i;
    const len = bytes.length;
    for (i = 0; i + 12 <= len; i += 12) {
      a = add32(a, wordAt(bytes, i, Endian.Little));
      b = add32(b, wordAt(bytes, i + 4, Endian.Little));
      c = add32(c, wordAt(bytes, i + 8, Endian.Little));
      const res = mix(a, b, c);
      a = res[0], b = res[1], c = res[2];
    }
    a = add32(a, wordAt(bytes, i, Endian.Little));
    b = add32(b, wordAt(bytes, i + 4, Endian.Little));
    c = add32(c, len);
    c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);
    return mix(a, b, c)[2];
  }
  function mix(a, b, c) {
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 13;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 8;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 13;
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 12;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 16;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 5;
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 3;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 10;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 15;
    return [a, b, c];
  }
  var Endian;
  (function(Endian2) {
    Endian2[Endian2["Little"] = 0] = "Little";
    Endian2[Endian2["Big"] = 1] = "Big";
  })(Endian || (Endian = {}));
  function add32(a, b) {
    return add32to64(a, b)[1];
  }
  function add32to64(a, b) {
    const low = (a & 65535) + (b & 65535);
    const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
    return [high >>> 16, high << 16 | low & 65535];
  }
  function add64(a, b) {
    const ah = a[0], al = a[1];
    const bh = b[0], bl = b[1];
    const result = add32to64(al, bl);
    const carry = result[0];
    const l = result[1];
    const h = add32(add32(ah, bh), carry);
    return [h, l];
  }
  function sub32(a, b) {
    const low = (a & 65535) - (b & 65535);
    const high = (a >> 16) - (b >> 16) + (low >> 16);
    return high << 16 | low & 65535;
  }
  function rol32(a, count) {
    return a << count | a >>> 32 - count;
  }
  function rol64(num, count) {
    const hi = num[0], lo = num[1];
    const h = hi << count | lo >>> 32 - count;
    const l = lo << count | hi >>> 32 - count;
    return [h, l];
  }
  function bytesToWords32(bytes, endian) {
    const size = bytes.length + 3 >>> 2;
    const words32 = [];
    for (let i = 0; i < size; i++) {
      words32[i] = wordAt(bytes, i * 4, endian);
    }
    return words32;
  }
  function byteAt(bytes, index) {
    return index >= bytes.length ? 0 : bytes[index];
  }
  function wordAt(bytes, index, endian) {
    let word = 0;
    if (endian === Endian.Big) {
      for (let i = 0; i < 4; i++) {
        word += byteAt(bytes, index + i) << 24 - 8 * i;
      }
    } else {
      for (let i = 0; i < 4; i++) {
        word += byteAt(bytes, index + i) << 8 * i;
      }
    }
    return word;
  }
  function words32ToByteString(words32) {
    return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);
  }
  function word32ToByteString(word) {
    let bytes = [];
    for (let i = 0; i < 4; i++) {
      bytes.push(word >>> 8 * (3 - i) & 255);
    }
    return bytes;
  }
  function bytesToHexString(bytes) {
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      const b = byteAt(bytes, i);
      hex += (b >>> 4).toString(16) + (b & 15).toString(16);
    }
    return hex.toLowerCase();
  }
  var base256 = new BigIntExponentiation(256);
  function wordsToDecimalString(hi, lo) {
    const decimal = base256.toThePowerOf(0).multiplyBy(lo);
    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
    return decimal.toString();
  }
  var TypeModifier;
  (function(TypeModifier2) {
    TypeModifier2[TypeModifier2["None"] = 0] = "None";
    TypeModifier2[TypeModifier2["Const"] = 1] = "Const";
  })(TypeModifier || (TypeModifier = {}));
  var Type2 = class {
    constructor(modifiers = TypeModifier.None) {
      this.modifiers = modifiers;
    }
    hasModifier(modifier) {
      return (this.modifiers & modifier) !== 0;
    }
  };
  var BuiltinTypeName;
  (function(BuiltinTypeName2) {
    BuiltinTypeName2[BuiltinTypeName2["Dynamic"] = 0] = "Dynamic";
    BuiltinTypeName2[BuiltinTypeName2["Bool"] = 1] = "Bool";
    BuiltinTypeName2[BuiltinTypeName2["String"] = 2] = "String";
    BuiltinTypeName2[BuiltinTypeName2["Int"] = 3] = "Int";
    BuiltinTypeName2[BuiltinTypeName2["Number"] = 4] = "Number";
    BuiltinTypeName2[BuiltinTypeName2["Function"] = 5] = "Function";
    BuiltinTypeName2[BuiltinTypeName2["Inferred"] = 6] = "Inferred";
    BuiltinTypeName2[BuiltinTypeName2["None"] = 7] = "None";
  })(BuiltinTypeName || (BuiltinTypeName = {}));
  var BuiltinType = class extends Type2 {
    constructor(name, modifiers) {
      super(modifiers);
      this.name = name;
    }
    visitType(visitor, context) {
      return visitor.visitBuiltinType(this, context);
    }
  };
  var ExpressionType = class extends Type2 {
    constructor(value, modifiers, typeParams = null) {
      super(modifiers);
      this.value = value;
      this.typeParams = typeParams;
    }
    visitType(visitor, context) {
      return visitor.visitExpressionType(this, context);
    }
  };
  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  var INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  var NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
  var UnaryOperator;
  (function(UnaryOperator2) {
    UnaryOperator2[UnaryOperator2["Minus"] = 0] = "Minus";
    UnaryOperator2[UnaryOperator2["Plus"] = 1] = "Plus";
  })(UnaryOperator || (UnaryOperator = {}));
  var BinaryOperator;
  (function(BinaryOperator2) {
    BinaryOperator2[BinaryOperator2["Equals"] = 0] = "Equals";
    BinaryOperator2[BinaryOperator2["NotEquals"] = 1] = "NotEquals";
    BinaryOperator2[BinaryOperator2["Identical"] = 2] = "Identical";
    BinaryOperator2[BinaryOperator2["NotIdentical"] = 3] = "NotIdentical";
    BinaryOperator2[BinaryOperator2["Minus"] = 4] = "Minus";
    BinaryOperator2[BinaryOperator2["Plus"] = 5] = "Plus";
    BinaryOperator2[BinaryOperator2["Divide"] = 6] = "Divide";
    BinaryOperator2[BinaryOperator2["Multiply"] = 7] = "Multiply";
    BinaryOperator2[BinaryOperator2["Modulo"] = 8] = "Modulo";
    BinaryOperator2[BinaryOperator2["And"] = 9] = "And";
    BinaryOperator2[BinaryOperator2["Or"] = 10] = "Or";
    BinaryOperator2[BinaryOperator2["BitwiseAnd"] = 11] = "BitwiseAnd";
    BinaryOperator2[BinaryOperator2["Lower"] = 12] = "Lower";
    BinaryOperator2[BinaryOperator2["LowerEquals"] = 13] = "LowerEquals";
    BinaryOperator2[BinaryOperator2["Bigger"] = 14] = "Bigger";
    BinaryOperator2[BinaryOperator2["BiggerEquals"] = 15] = "BiggerEquals";
    BinaryOperator2[BinaryOperator2["NullishCoalesce"] = 16] = "NullishCoalesce";
  })(BinaryOperator || (BinaryOperator = {}));
  function nullSafeIsEquivalent(base, other) {
    if (base == null || other == null) {
      return base == other;
    }
    return base.isEquivalent(other);
  }
  function areAllEquivalentPredicate(base, other, equivalentPredicate) {
    const len = base.length;
    if (len !== other.length) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (!equivalentPredicate(base[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function areAllEquivalent(base, other) {
    return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));
  }
  var Expression = class {
    constructor(type, sourceSpan) {
      this.type = type || null;
      this.sourceSpan = sourceSpan || null;
    }
    prop(name, sourceSpan) {
      return new ReadPropExpr(this, name, null, sourceSpan);
    }
    key(index, type, sourceSpan) {
      return new ReadKeyExpr(this, index, type, sourceSpan);
    }
    callFn(params, sourceSpan, pure) {
      return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
    }
    instantiate(params, type, sourceSpan) {
      return new InstantiateExpr(this, params, type, sourceSpan);
    }
    conditional(trueCase, falseCase = null, sourceSpan) {
      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
    }
    equals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
    }
    notEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
    }
    identical(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
    }
    notIdentical(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
    }
    minus(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
    }
    plus(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
    }
    divide(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
    }
    multiply(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
    }
    modulo(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
    }
    and(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
    }
    bitwiseAnd(rhs, sourceSpan, parens = true) {
      return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
    }
    or(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
    }
    lower(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
    }
    lowerEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
    }
    bigger(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
    }
    biggerEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
    }
    isBlank(sourceSpan) {
      return this.equals(TYPED_NULL_EXPR, sourceSpan);
    }
    nullishCoalesce(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);
    }
    toStmt() {
      return new ExpressionStatement(this, null);
    }
  };
  var ReadVarExpr = class extends Expression {
    constructor(name, type, sourceSpan) {
      super(type, sourceSpan);
      this.name = name;
    }
    isEquivalent(e) {
      return e instanceof ReadVarExpr && this.name === e.name;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitReadVarExpr(this, context);
    }
    set(value) {
      return new WriteVarExpr(this.name, value, null, this.sourceSpan);
    }
  };
  var TypeofExpr = class extends Expression {
    constructor(expr, type, sourceSpan) {
      super(type, sourceSpan);
      this.expr = expr;
    }
    visitExpression(visitor, context) {
      return visitor.visitTypeofExpr(this, context);
    }
    isEquivalent(e) {
      return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
    }
    isConstant() {
      return this.expr.isConstant();
    }
  };
  var WrappedNodeExpr = class extends Expression {
    constructor(node, type, sourceSpan) {
      super(type, sourceSpan);
      this.node = node;
    }
    isEquivalent(e) {
      return e instanceof WrappedNodeExpr && this.node === e.node;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitWrappedNodeExpr(this, context);
    }
  };
  var WriteVarExpr = class extends Expression {
    constructor(name, value, type, sourceSpan) {
      super(type || value.type, sourceSpan);
      this.name = name;
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitWriteVarExpr(this, context);
    }
    toDeclStmt(type, modifiers) {
      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
    }
    toConstDecl() {
      return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);
    }
  };
  var WriteKeyExpr = class extends Expression {
    constructor(receiver, index, value, type, sourceSpan) {
      super(type || value.type, sourceSpan);
      this.receiver = receiver;
      this.index = index;
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitWriteKeyExpr(this, context);
    }
  };
  var WritePropExpr = class extends Expression {
    constructor(receiver, name, value, type, sourceSpan) {
      super(type || value.type, sourceSpan);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitWritePropExpr(this, context);
    }
  };
  var InvokeFunctionExpr = class extends Expression {
    constructor(fn2, args, type, sourceSpan, pure = false) {
      super(type, sourceSpan);
      this.fn = fn2;
      this.args = args;
      this.pure = pure;
    }
    isEquivalent(e) {
      return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitInvokeFunctionExpr(this, context);
    }
  };
  var TaggedTemplateExpr = class extends Expression {
    constructor(tag, template, type, sourceSpan) {
      super(type, sourceSpan);
      this.tag = tag;
      this.template = template;
    }
    isEquivalent(e) {
      return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) && areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) && areAllEquivalent(this.template.expressions, e.template.expressions);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitTaggedTemplateExpr(this, context);
    }
  };
  var InstantiateExpr = class extends Expression {
    constructor(classExpr, args, type, sourceSpan) {
      super(type, sourceSpan);
      this.classExpr = classExpr;
      this.args = args;
    }
    isEquivalent(e) {
      return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitInstantiateExpr(this, context);
    }
  };
  var LiteralExpr = class extends Expression {
    constructor(value, type, sourceSpan) {
      super(type, sourceSpan);
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof LiteralExpr && this.value === e.value;
    }
    isConstant() {
      return true;
    }
    visitExpression(visitor, context) {
      return visitor.visitLiteralExpr(this, context);
    }
  };
  var TemplateLiteral = class {
    constructor(elements, expressions) {
      this.elements = elements;
      this.expressions = expressions;
    }
  };
  var TemplateLiteralElement = class {
    constructor(text, sourceSpan, rawText) {
      this.text = text;
      this.sourceSpan = sourceSpan;
      this.rawText = rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));
    }
  };
  var LiteralPiece = class {
    constructor(text, sourceSpan) {
      this.text = text;
      this.sourceSpan = sourceSpan;
    }
  };
  var PlaceholderPiece = class {
    constructor(text, sourceSpan, associatedMessage) {
      this.text = text;
      this.sourceSpan = sourceSpan;
      this.associatedMessage = associatedMessage;
    }
  };
  var MEANING_SEPARATOR$1 = "|";
  var ID_SEPARATOR$1 = "@@";
  var LEGACY_ID_INDICATOR = "\u241F";
  var LocalizedString = class extends Expression {
    constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
      super(STRING_TYPE, sourceSpan);
      this.metaBlock = metaBlock;
      this.messageParts = messageParts;
      this.placeHolderNames = placeHolderNames;
      this.expressions = expressions;
    }
    isEquivalent(e) {
      return false;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitLocalizedString(this, context);
    }
    serializeI18nHead() {
      let metaBlock = this.metaBlock.description || "";
      if (this.metaBlock.meaning) {
        metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;
      }
      if (this.metaBlock.customId) {
        metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;
      }
      if (this.metaBlock.legacyIds) {
        this.metaBlock.legacyIds.forEach((legacyId) => {
          metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;
        });
      }
      return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));
    }
    getMessagePartSourceSpan(i) {
      return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;
    }
    getPlaceholderSourceSpan(i) {
      return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan;
    }
    serializeI18nTemplatePart(partIndex) {
      const placeholder = this.placeHolderNames[partIndex - 1];
      const messagePart = this.messageParts[partIndex];
      let metaBlock = placeholder.text;
      if (placeholder.associatedMessage?.legacyIds.length === 0) {
        metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;
      }
      return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));
    }
  };
  var escapeSlashes = (str) => str.replace(/\\/g, "\\\\");
  var escapeStartingColon = (str) => str.replace(/^:/, "\\:");
  var escapeColons = (str) => str.replace(/:/g, "\\:");
  var escapeForTemplateLiteral = (str) => str.replace(/`/g, "\\`").replace(/\${/g, "$\\{");
  function createCookedRawString(metaBlock, messagePart, range) {
    if (metaBlock === "") {
      return {
        cooked: messagePart,
        raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),
        range
      };
    } else {
      return {
        cooked: `:${metaBlock}:${messagePart}`,
        raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),
        range
      };
    }
  }
  var ExternalExpr = class extends Expression {
    constructor(value, type, typeParams = null, sourceSpan) {
      super(type, sourceSpan);
      this.value = value;
      this.typeParams = typeParams;
    }
    isEquivalent(e) {
      return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitExternalExpr(this, context);
    }
  };
  var ConditionalExpr = class extends Expression {
    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
      super(type || trueCase.type, sourceSpan);
      this.condition = condition;
      this.falseCase = falseCase;
      this.trueCase = trueCase;
    }
    isEquivalent(e) {
      return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitConditionalExpr(this, context);
    }
  };
  var NotExpr = class extends Expression {
    constructor(condition, sourceSpan) {
      super(BOOL_TYPE, sourceSpan);
      this.condition = condition;
    }
    isEquivalent(e) {
      return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitNotExpr(this, context);
    }
  };
  var FnParam = class {
    constructor(name, type = null) {
      this.name = name;
      this.type = type;
    }
    isEquivalent(param) {
      return this.name === param.name;
    }
  };
  var FunctionExpr = class extends Expression {
    constructor(params, statements, type, sourceSpan, name) {
      super(type, sourceSpan);
      this.params = params;
      this.statements = statements;
      this.name = name;
    }
    isEquivalent(e) {
      return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitFunctionExpr(this, context);
    }
    toDeclStmt(name, modifiers) {
      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
    }
  };
  var UnaryOperatorExpr = class extends Expression {
    constructor(operator, expr, type, sourceSpan, parens = true) {
      super(type || NUMBER_TYPE, sourceSpan);
      this.operator = operator;
      this.expr = expr;
      this.parens = parens;
    }
    isEquivalent(e) {
      return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitUnaryOperatorExpr(this, context);
    }
  };
  var BinaryOperatorExpr = class extends Expression {
    constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
      super(type || lhs.type, sourceSpan);
      this.operator = operator;
      this.rhs = rhs;
      this.parens = parens;
      this.lhs = lhs;
    }
    isEquivalent(e) {
      return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitBinaryOperatorExpr(this, context);
    }
  };
  var ReadPropExpr = class extends Expression {
    constructor(receiver, name, type, sourceSpan) {
      super(type, sourceSpan);
      this.receiver = receiver;
      this.name = name;
    }
    isEquivalent(e) {
      return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitReadPropExpr(this, context);
    }
    set(value) {
      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
    }
  };
  var ReadKeyExpr = class extends Expression {
    constructor(receiver, index, type, sourceSpan) {
      super(type, sourceSpan);
      this.receiver = receiver;
      this.index = index;
    }
    isEquivalent(e) {
      return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context) {
      return visitor.visitReadKeyExpr(this, context);
    }
    set(value) {
      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
    }
  };
  var LiteralArrayExpr = class extends Expression {
    constructor(entries, type, sourceSpan) {
      super(type, sourceSpan);
      this.entries = entries;
    }
    isConstant() {
      return this.entries.every((e) => e.isConstant());
    }
    isEquivalent(e) {
      return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
    }
    visitExpression(visitor, context) {
      return visitor.visitLiteralArrayExpr(this, context);
    }
  };
  var LiteralMapEntry = class {
    constructor(key, value, quoted) {
      this.key = key;
      this.value = value;
      this.quoted = quoted;
    }
    isEquivalent(e) {
      return this.key === e.key && this.value.isEquivalent(e.value);
    }
  };
  var LiteralMapExpr = class extends Expression {
    constructor(entries, type, sourceSpan) {
      super(type, sourceSpan);
      this.entries = entries;
      this.valueType = null;
      if (type) {
        this.valueType = type.valueType;
      }
    }
    isEquivalent(e) {
      return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
    }
    isConstant() {
      return this.entries.every((e) => e.value.isConstant());
    }
    visitExpression(visitor, context) {
      return visitor.visitLiteralMapExpr(this, context);
    }
  };
  var NULL_EXPR = new LiteralExpr(null, null, null);
  var TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
  var StmtModifier;
  (function(StmtModifier2) {
    StmtModifier2[StmtModifier2["None"] = 0] = "None";
    StmtModifier2[StmtModifier2["Final"] = 1] = "Final";
    StmtModifier2[StmtModifier2["Private"] = 2] = "Private";
    StmtModifier2[StmtModifier2["Exported"] = 4] = "Exported";
    StmtModifier2[StmtModifier2["Static"] = 8] = "Static";
  })(StmtModifier || (StmtModifier = {}));
  var LeadingComment = class {
    constructor(text, multiline, trailingNewline) {
      this.text = text;
      this.multiline = multiline;
      this.trailingNewline = trailingNewline;
    }
    toString() {
      return this.multiline ? ` ${this.text} ` : this.text;
    }
  };
  var JSDocComment = class extends LeadingComment {
    constructor(tags) {
      super("", true, true);
      this.tags = tags;
    }
    toString() {
      return serializeTags(this.tags);
    }
  };
  var Statement = class {
    constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {
      this.modifiers = modifiers;
      this.sourceSpan = sourceSpan;
      this.leadingComments = leadingComments;
    }
    hasModifier(modifier) {
      return (this.modifiers & modifier) !== 0;
    }
    addLeadingComment(leadingComment) {
      this.leadingComments = this.leadingComments ?? [];
      this.leadingComments.push(leadingComment);
    }
  };
  var DeclareVarStmt = class extends Statement {
    constructor(name, value, type, modifiers, sourceSpan, leadingComments) {
      super(modifiers, sourceSpan, leadingComments);
      this.name = name;
      this.value = value;
      this.type = type || value && value.type || null;
    }
    isEquivalent(stmt) {
      return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
    }
    visitStatement(visitor, context) {
      return visitor.visitDeclareVarStmt(this, context);
    }
  };
  var DeclareFunctionStmt = class extends Statement {
    constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {
      super(modifiers, sourceSpan, leadingComments);
      this.name = name;
      this.params = params;
      this.statements = statements;
      this.type = type || null;
    }
    isEquivalent(stmt) {
      return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);
    }
    visitStatement(visitor, context) {
      return visitor.visitDeclareFunctionStmt(this, context);
    }
  };
  var ExpressionStatement = class extends Statement {
    constructor(expr, sourceSpan, leadingComments) {
      super(StmtModifier.None, sourceSpan, leadingComments);
      this.expr = expr;
    }
    isEquivalent(stmt) {
      return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
    }
    visitStatement(visitor, context) {
      return visitor.visitExpressionStmt(this, context);
    }
  };
  var ReturnStatement = class extends Statement {
    constructor(value, sourceSpan = null, leadingComments) {
      super(StmtModifier.None, sourceSpan, leadingComments);
      this.value = value;
    }
    isEquivalent(stmt) {
      return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
    }
    visitStatement(visitor, context) {
      return visitor.visitReturnStmt(this, context);
    }
  };
  var IfStmt = class extends Statement {
    constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {
      super(StmtModifier.None, sourceSpan, leadingComments);
      this.condition = condition;
      this.trueCase = trueCase;
      this.falseCase = falseCase;
    }
    isEquivalent(stmt) {
      return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);
    }
    visitStatement(visitor, context) {
      return visitor.visitIfStmt(this, context);
    }
  };
  function jsDocComment(tags = []) {
    return new JSDocComment(tags);
  }
  function variable(name, type, sourceSpan) {
    return new ReadVarExpr(name, type, sourceSpan);
  }
  function importExpr(id, typeParams = null, sourceSpan) {
    return new ExternalExpr(id, null, typeParams, sourceSpan);
  }
  function expressionType(expr, typeModifiers, typeParams) {
    return new ExpressionType(expr, typeModifiers, typeParams);
  }
  function typeofExpr(expr) {
    return new TypeofExpr(expr);
  }
  function literalArr(values, type, sourceSpan) {
    return new LiteralArrayExpr(values, type, sourceSpan);
  }
  function literalMap(values, type = null) {
    return new LiteralMapExpr(values.map((e) => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
  }
  function not(expr, sourceSpan) {
    return new NotExpr(expr, sourceSpan);
  }
  function fn(params, body, type, sourceSpan, name) {
    return new FunctionExpr(params, body, type, sourceSpan, name);
  }
  function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {
    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);
  }
  function taggedTemplate(tag, template, type, sourceSpan) {
    return new TaggedTemplateExpr(tag, template, type, sourceSpan);
  }
  function literal(value, type, sourceSpan) {
    return new LiteralExpr(value, type, sourceSpan);
  }
  function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
  }
  function isNull(exp) {
    return exp instanceof LiteralExpr && exp.value === null;
  }
  function tagToString(tag) {
    let out = "";
    if (tag.tagName) {
      out += ` @${tag.tagName}`;
    }
    if (tag.text) {
      if (tag.text.match(/\/\*|\*\//)) {
        throw new Error('JSDoc text cannot contain "/*" and "*/"');
      }
      out += " " + tag.text.replace(/@/g, "\\@");
    }
    return out;
  }
  function serializeTags(tags) {
    if (tags.length === 0)
      return "";
    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {
      return `*${tagToString(tags[0])} `;
    }
    let out = "*\n";
    for (const tag of tags) {
      out += " *";
      out += tagToString(tag).replace(/\n/g, "\n * ");
      out += "\n";
    }
    out += " ";
    return out;
  }
  var CONSTANT_PREFIX = "_c";
  var UNKNOWN_VALUE_KEY = variable("<unknown>");
  var KEY_CONTEXT = {};
  var POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
  var FixupExpression = class extends Expression {
    constructor(resolved) {
      super(resolved.type);
      this.resolved = resolved;
      this.original = resolved;
    }
    visitExpression(visitor, context) {
      if (context === KEY_CONTEXT) {
        return this.original.visitExpression(visitor, context);
      } else {
        return this.resolved.visitExpression(visitor, context);
      }
    }
    isEquivalent(e) {
      return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
    }
    isConstant() {
      return true;
    }
    fixup(expression) {
      this.resolved = expression;
      this.shared = true;
    }
  };
  var ConstantPool = class {
    constructor(isClosureCompilerEnabled = false) {
      this.isClosureCompilerEnabled = isClosureCompilerEnabled;
      this.statements = [];
      this.literals = /* @__PURE__ */ new Map();
      this.literalFactories = /* @__PURE__ */ new Map();
      this.nextNameIndex = 0;
    }
    getConstLiteral(literal2, forceShared) {
      if (literal2 instanceof LiteralExpr && !isLongStringLiteral(literal2) || literal2 instanceof FixupExpression) {
        return literal2;
      }
      const key = this.keyOf(literal2);
      let fixup = this.literals.get(key);
      let newValue = false;
      if (!fixup) {
        fixup = new FixupExpression(literal2);
        this.literals.set(key, fixup);
        newValue = true;
      }
      if (!newValue && !fixup.shared || newValue && forceShared) {
        const name = this.freshName();
        let definition;
        let usage;
        if (this.isClosureCompilerEnabled && isLongStringLiteral(literal2)) {
          definition = variable(name).set(new FunctionExpr([], [
            new ReturnStatement(literal2)
          ]));
          usage = variable(name).callFn([]);
        } else {
          definition = variable(name).set(literal2);
          usage = variable(name);
        }
        this.statements.push(definition.toDeclStmt(INFERRED_TYPE, StmtModifier.Final));
        fixup.fixup(usage);
      }
      return fixup;
    }
    getLiteralFactory(literal2) {
      if (literal2 instanceof LiteralArrayExpr) {
        const argumentsForKey = literal2.entries.map((e) => e.isConstant() ? e : UNKNOWN_VALUE_KEY);
        const key = this.keyOf(literalArr(argumentsForKey));
        return this._getLiteralFactory(key, literal2.entries, (entries) => literalArr(entries));
      } else {
        const expressionForKey = literalMap(literal2.entries.map((e) => ({
          key: e.key,
          value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
          quoted: e.quoted
        })));
        const key = this.keyOf(expressionForKey);
        return this._getLiteralFactory(key, literal2.entries.map((e) => e.value), (entries) => literalMap(entries.map((value, index) => ({
          key: literal2.entries[index].key,
          value,
          quoted: literal2.entries[index].quoted
        }))));
      }
    }
    _getLiteralFactory(key, values, resultMap) {
      let literalFactory = this.literalFactories.get(key);
      const literalFactoryArguments = values.filter((e) => !e.isConstant());
      if (!literalFactory) {
        const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
        const parameters = resultExpressions.filter(isVariable).map((e) => new FnParam(e.name, DYNAMIC_TYPE));
        const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
        const name = this.freshName();
        this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, StmtModifier.Final));
        literalFactory = variable(name);
        this.literalFactories.set(key, literalFactory);
      }
      return { literalFactory, literalFactoryArguments };
    }
    uniqueName(prefix) {
      return `${prefix}${this.nextNameIndex++}`;
    }
    freshName() {
      return this.uniqueName(CONSTANT_PREFIX);
    }
    keyOf(expression) {
      return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
    }
  };
  var KeyVisitor = class {
    constructor() {
      this.visitWrappedNodeExpr = invalid$1;
      this.visitWriteVarExpr = invalid$1;
      this.visitWriteKeyExpr = invalid$1;
      this.visitWritePropExpr = invalid$1;
      this.visitInvokeFunctionExpr = invalid$1;
      this.visitTaggedTemplateExpr = invalid$1;
      this.visitInstantiateExpr = invalid$1;
      this.visitConditionalExpr = invalid$1;
      this.visitNotExpr = invalid$1;
      this.visitAssertNotNullExpr = invalid$1;
      this.visitCastExpr = invalid$1;
      this.visitFunctionExpr = invalid$1;
      this.visitUnaryOperatorExpr = invalid$1;
      this.visitBinaryOperatorExpr = invalid$1;
      this.visitReadPropExpr = invalid$1;
      this.visitReadKeyExpr = invalid$1;
      this.visitCommaExpr = invalid$1;
      this.visitLocalizedString = invalid$1;
    }
    visitLiteralExpr(ast) {
      return `${typeof ast.value === "string" ? '"' + ast.value + '"' : ast.value}`;
    }
    visitLiteralArrayExpr(ast, context) {
      return `[${ast.entries.map((entry) => entry.visitExpression(this, context)).join(",")}]`;
    }
    visitLiteralMapExpr(ast, context) {
      const mapKey = (entry) => {
        const quote = entry.quoted ? '"' : "";
        return `${quote}${entry.key}${quote}`;
      };
      const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;
      return `{${ast.entries.map(mapEntry).join(",")}`;
    }
    visitExternalExpr(ast) {
      return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` : `EX:${ast.value.runtime.name}`;
    }
    visitReadVarExpr(node) {
      return `VAR:${node.name}`;
    }
    visitTypeofExpr(node, context) {
      return `TYPEOF:${node.expr.visitExpression(this, context)}`;
    }
  };
  function invalid$1(arg) {
    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
  }
  function isVariable(e) {
    return e instanceof ReadVarExpr;
  }
  function isLongStringLiteral(expr) {
    return expr instanceof LiteralExpr && typeof expr.value === "string" && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
  }
  var CORE = "@angular/core";
  var Identifiers = class {
  };
  Identifiers.NEW_METHOD = "factory";
  Identifiers.TRANSFORM_METHOD = "transform";
  Identifiers.PATCH_DEPS = "patchedDeps";
  Identifiers.core = { name: null, moduleName: CORE };
  Identifiers.namespaceHTML = { name: "\u0275\u0275namespaceHTML", moduleName: CORE };
  Identifiers.namespaceMathML = { name: "\u0275\u0275namespaceMathML", moduleName: CORE };
  Identifiers.namespaceSVG = { name: "\u0275\u0275namespaceSVG", moduleName: CORE };
  Identifiers.element = { name: "\u0275\u0275element", moduleName: CORE };
  Identifiers.elementStart = { name: "\u0275\u0275elementStart", moduleName: CORE };
  Identifiers.elementEnd = { name: "\u0275\u0275elementEnd", moduleName: CORE };
  Identifiers.advance = { name: "\u0275\u0275advance", moduleName: CORE };
  Identifiers.syntheticHostProperty = { name: "\u0275\u0275syntheticHostProperty", moduleName: CORE };
  Identifiers.syntheticHostListener = { name: "\u0275\u0275syntheticHostListener", moduleName: CORE };
  Identifiers.attribute = { name: "\u0275\u0275attribute", moduleName: CORE };
  Identifiers.attributeInterpolate1 = { name: "\u0275\u0275attributeInterpolate1", moduleName: CORE };
  Identifiers.attributeInterpolate2 = { name: "\u0275\u0275attributeInterpolate2", moduleName: CORE };
  Identifiers.attributeInterpolate3 = { name: "\u0275\u0275attributeInterpolate3", moduleName: CORE };
  Identifiers.attributeInterpolate4 = { name: "\u0275\u0275attributeInterpolate4", moduleName: CORE };
  Identifiers.attributeInterpolate5 = { name: "\u0275\u0275attributeInterpolate5", moduleName: CORE };
  Identifiers.attributeInterpolate6 = { name: "\u0275\u0275attributeInterpolate6", moduleName: CORE };
  Identifiers.attributeInterpolate7 = { name: "\u0275\u0275attributeInterpolate7", moduleName: CORE };
  Identifiers.attributeInterpolate8 = { name: "\u0275\u0275attributeInterpolate8", moduleName: CORE };
  Identifiers.attributeInterpolateV = { name: "\u0275\u0275attributeInterpolateV", moduleName: CORE };
  Identifiers.classProp = { name: "\u0275\u0275classProp", moduleName: CORE };
  Identifiers.elementContainerStart = { name: "\u0275\u0275elementContainerStart", moduleName: CORE };
  Identifiers.elementContainerEnd = { name: "\u0275\u0275elementContainerEnd", moduleName: CORE };
  Identifiers.elementContainer = { name: "\u0275\u0275elementContainer", moduleName: CORE };
  Identifiers.styleMap = { name: "\u0275\u0275styleMap", moduleName: CORE };
  Identifiers.styleMapInterpolate1 = { name: "\u0275\u0275styleMapInterpolate1", moduleName: CORE };
  Identifiers.styleMapInterpolate2 = { name: "\u0275\u0275styleMapInterpolate2", moduleName: CORE };
  Identifiers.styleMapInterpolate3 = { name: "\u0275\u0275styleMapInterpolate3", moduleName: CORE };
  Identifiers.styleMapInterpolate4 = { name: "\u0275\u0275styleMapInterpolate4", moduleName: CORE };
  Identifiers.styleMapInterpolate5 = { name: "\u0275\u0275styleMapInterpolate5", moduleName: CORE };
  Identifiers.styleMapInterpolate6 = { name: "\u0275\u0275styleMapInterpolate6", moduleName: CORE };
  Identifiers.styleMapInterpolate7 = { name: "\u0275\u0275styleMapInterpolate7", moduleName: CORE };
  Identifiers.styleMapInterpolate8 = { name: "\u0275\u0275styleMapInterpolate8", moduleName: CORE };
  Identifiers.styleMapInterpolateV = { name: "\u0275\u0275styleMapInterpolateV", moduleName: CORE };
  Identifiers.classMap = { name: "\u0275\u0275classMap", moduleName: CORE };
  Identifiers.classMapInterpolate1 = { name: "\u0275\u0275classMapInterpolate1", moduleName: CORE };
  Identifiers.classMapInterpolate2 = { name: "\u0275\u0275classMapInterpolate2", moduleName: CORE };
  Identifiers.classMapInterpolate3 = { name: "\u0275\u0275classMapInterpolate3", moduleName: CORE };
  Identifiers.classMapInterpolate4 = { name: "\u0275\u0275classMapInterpolate4", moduleName: CORE };
  Identifiers.classMapInterpolate5 = { name: "\u0275\u0275classMapInterpolate5", moduleName: CORE };
  Identifiers.classMapInterpolate6 = { name: "\u0275\u0275classMapInterpolate6", moduleName: CORE };
  Identifiers.classMapInterpolate7 = { name: "\u0275\u0275classMapInterpolate7", moduleName: CORE };
  Identifiers.classMapInterpolate8 = { name: "\u0275\u0275classMapInterpolate8", moduleName: CORE };
  Identifiers.classMapInterpolateV = { name: "\u0275\u0275classMapInterpolateV", moduleName: CORE };
  Identifiers.styleProp = { name: "\u0275\u0275styleProp", moduleName: CORE };
  Identifiers.stylePropInterpolate1 = { name: "\u0275\u0275stylePropInterpolate1", moduleName: CORE };
  Identifiers.stylePropInterpolate2 = { name: "\u0275\u0275stylePropInterpolate2", moduleName: CORE };
  Identifiers.stylePropInterpolate3 = { name: "\u0275\u0275stylePropInterpolate3", moduleName: CORE };
  Identifiers.stylePropInterpolate4 = { name: "\u0275\u0275stylePropInterpolate4", moduleName: CORE };
  Identifiers.stylePropInterpolate5 = { name: "\u0275\u0275stylePropInterpolate5", moduleName: CORE };
  Identifiers.stylePropInterpolate6 = { name: "\u0275\u0275stylePropInterpolate6", moduleName: CORE };
  Identifiers.stylePropInterpolate7 = { name: "\u0275\u0275stylePropInterpolate7", moduleName: CORE };
  Identifiers.stylePropInterpolate8 = { name: "\u0275\u0275stylePropInterpolate8", moduleName: CORE };
  Identifiers.stylePropInterpolateV = { name: "\u0275\u0275stylePropInterpolateV", moduleName: CORE };
  Identifiers.nextContext = { name: "\u0275\u0275nextContext", moduleName: CORE };
  Identifiers.templateCreate = { name: "\u0275\u0275template", moduleName: CORE };
  Identifiers.text = { name: "\u0275\u0275text", moduleName: CORE };
  Identifiers.enableBindings = { name: "\u0275\u0275enableBindings", moduleName: CORE };
  Identifiers.disableBindings = { name: "\u0275\u0275disableBindings", moduleName: CORE };
  Identifiers.getCurrentView = { name: "\u0275\u0275getCurrentView", moduleName: CORE };
  Identifiers.textInterpolate = { name: "\u0275\u0275textInterpolate", moduleName: CORE };
  Identifiers.textInterpolate1 = { name: "\u0275\u0275textInterpolate1", moduleName: CORE };
  Identifiers.textInterpolate2 = { name: "\u0275\u0275textInterpolate2", moduleName: CORE };
  Identifiers.textInterpolate3 = { name: "\u0275\u0275textInterpolate3", moduleName: CORE };
  Identifiers.textInterpolate4 = { name: "\u0275\u0275textInterpolate4", moduleName: CORE };
  Identifiers.textInterpolate5 = { name: "\u0275\u0275textInterpolate5", moduleName: CORE };
  Identifiers.textInterpolate6 = { name: "\u0275\u0275textInterpolate6", moduleName: CORE };
  Identifiers.textInterpolate7 = { name: "\u0275\u0275textInterpolate7", moduleName: CORE };
  Identifiers.textInterpolate8 = { name: "\u0275\u0275textInterpolate8", moduleName: CORE };
  Identifiers.textInterpolateV = { name: "\u0275\u0275textInterpolateV", moduleName: CORE };
  Identifiers.restoreView = { name: "\u0275\u0275restoreView", moduleName: CORE };
  Identifiers.pureFunction0 = { name: "\u0275\u0275pureFunction0", moduleName: CORE };
  Identifiers.pureFunction1 = { name: "\u0275\u0275pureFunction1", moduleName: CORE };
  Identifiers.pureFunction2 = { name: "\u0275\u0275pureFunction2", moduleName: CORE };
  Identifiers.pureFunction3 = { name: "\u0275\u0275pureFunction3", moduleName: CORE };
  Identifiers.pureFunction4 = { name: "\u0275\u0275pureFunction4", moduleName: CORE };
  Identifiers.pureFunction5 = { name: "\u0275\u0275pureFunction5", moduleName: CORE };
  Identifiers.pureFunction6 = { name: "\u0275\u0275pureFunction6", moduleName: CORE };
  Identifiers.pureFunction7 = { name: "\u0275\u0275pureFunction7", moduleName: CORE };
  Identifiers.pureFunction8 = { name: "\u0275\u0275pureFunction8", moduleName: CORE };
  Identifiers.pureFunctionV = { name: "\u0275\u0275pureFunctionV", moduleName: CORE };
  Identifiers.pipeBind1 = { name: "\u0275\u0275pipeBind1", moduleName: CORE };
  Identifiers.pipeBind2 = { name: "\u0275\u0275pipeBind2", moduleName: CORE };
  Identifiers.pipeBind3 = { name: "\u0275\u0275pipeBind3", moduleName: CORE };
  Identifiers.pipeBind4 = { name: "\u0275\u0275pipeBind4", moduleName: CORE };
  Identifiers.pipeBindV = { name: "\u0275\u0275pipeBindV", moduleName: CORE };
  Identifiers.hostProperty = { name: "\u0275\u0275hostProperty", moduleName: CORE };
  Identifiers.property = { name: "\u0275\u0275property", moduleName: CORE };
  Identifiers.propertyInterpolate = { name: "\u0275\u0275propertyInterpolate", moduleName: CORE };
  Identifiers.propertyInterpolate1 = { name: "\u0275\u0275propertyInterpolate1", moduleName: CORE };
  Identifiers.propertyInterpolate2 = { name: "\u0275\u0275propertyInterpolate2", moduleName: CORE };
  Identifiers.propertyInterpolate3 = { name: "\u0275\u0275propertyInterpolate3", moduleName: CORE };
  Identifiers.propertyInterpolate4 = { name: "\u0275\u0275propertyInterpolate4", moduleName: CORE };
  Identifiers.propertyInterpolate5 = { name: "\u0275\u0275propertyInterpolate5", moduleName: CORE };
  Identifiers.propertyInterpolate6 = { name: "\u0275\u0275propertyInterpolate6", moduleName: CORE };
  Identifiers.propertyInterpolate7 = { name: "\u0275\u0275propertyInterpolate7", moduleName: CORE };
  Identifiers.propertyInterpolate8 = { name: "\u0275\u0275propertyInterpolate8", moduleName: CORE };
  Identifiers.propertyInterpolateV = { name: "\u0275\u0275propertyInterpolateV", moduleName: CORE };
  Identifiers.i18n = { name: "\u0275\u0275i18n", moduleName: CORE };
  Identifiers.i18nAttributes = { name: "\u0275\u0275i18nAttributes", moduleName: CORE };
  Identifiers.i18nExp = { name: "\u0275\u0275i18nExp", moduleName: CORE };
  Identifiers.i18nStart = { name: "\u0275\u0275i18nStart", moduleName: CORE };
  Identifiers.i18nEnd = { name: "\u0275\u0275i18nEnd", moduleName: CORE };
  Identifiers.i18nApply = { name: "\u0275\u0275i18nApply", moduleName: CORE };
  Identifiers.i18nPostprocess = { name: "\u0275\u0275i18nPostprocess", moduleName: CORE };
  Identifiers.pipe = { name: "\u0275\u0275pipe", moduleName: CORE };
  Identifiers.projection = { name: "\u0275\u0275projection", moduleName: CORE };
  Identifiers.projectionDef = { name: "\u0275\u0275projectionDef", moduleName: CORE };
  Identifiers.reference = { name: "\u0275\u0275reference", moduleName: CORE };
  Identifiers.inject = { name: "\u0275\u0275inject", moduleName: CORE };
  Identifiers.injectAttribute = { name: "\u0275\u0275injectAttribute", moduleName: CORE };
  Identifiers.directiveInject = { name: "\u0275\u0275directiveInject", moduleName: CORE };
  Identifiers.invalidFactory = { name: "\u0275\u0275invalidFactory", moduleName: CORE };
  Identifiers.invalidFactoryDep = { name: "\u0275\u0275invalidFactoryDep", moduleName: CORE };
  Identifiers.templateRefExtractor = { name: "\u0275\u0275templateRefExtractor", moduleName: CORE };
  Identifiers.forwardRef = { name: "forwardRef", moduleName: CORE };
  Identifiers.resolveForwardRef = { name: "resolveForwardRef", moduleName: CORE };
  Identifiers.\u0275\u0275defineInjectable = { name: "\u0275\u0275defineInjectable", moduleName: CORE };
  Identifiers.declareInjectable = { name: "\u0275\u0275ngDeclareInjectable", moduleName: CORE };
  Identifiers.InjectableDeclaration = { name: "\u0275\u0275InjectableDeclaration", moduleName: CORE };
  Identifiers.resolveWindow = { name: "\u0275\u0275resolveWindow", moduleName: CORE };
  Identifiers.resolveDocument = { name: "\u0275\u0275resolveDocument", moduleName: CORE };
  Identifiers.resolveBody = { name: "\u0275\u0275resolveBody", moduleName: CORE };
  Identifiers.defineComponent = { name: "\u0275\u0275defineComponent", moduleName: CORE };
  Identifiers.declareComponent = { name: "\u0275\u0275ngDeclareComponent", moduleName: CORE };
  Identifiers.setComponentScope = { name: "\u0275\u0275setComponentScope", moduleName: CORE };
  Identifiers.ChangeDetectionStrategy = {
    name: "ChangeDetectionStrategy",
    moduleName: CORE
  };
  Identifiers.ViewEncapsulation = {
    name: "ViewEncapsulation",
    moduleName: CORE
  };
  Identifiers.ComponentDeclaration = {
    name: "\u0275\u0275ComponentDeclaration",
    moduleName: CORE
  };
  Identifiers.FactoryDeclaration = {
    name: "\u0275\u0275FactoryDeclaration",
    moduleName: CORE
  };
  Identifiers.declareFactory = { name: "\u0275\u0275ngDeclareFactory", moduleName: CORE };
  Identifiers.FactoryTarget = { name: "\u0275\u0275FactoryTarget", moduleName: CORE };
  Identifiers.defineDirective = { name: "\u0275\u0275defineDirective", moduleName: CORE };
  Identifiers.declareDirective = { name: "\u0275\u0275ngDeclareDirective", moduleName: CORE };
  Identifiers.DirectiveDeclaration = {
    name: "\u0275\u0275DirectiveDeclaration",
    moduleName: CORE
  };
  Identifiers.InjectorDef = { name: "\u0275\u0275InjectorDef", moduleName: CORE };
  Identifiers.InjectorDeclaration = { name: "\u0275\u0275InjectorDeclaration", moduleName: CORE };
  Identifiers.defineInjector = { name: "\u0275\u0275defineInjector", moduleName: CORE };
  Identifiers.declareInjector = { name: "\u0275\u0275ngDeclareInjector", moduleName: CORE };
  Identifiers.NgModuleDeclaration = {
    name: "\u0275\u0275NgModuleDeclaration",
    moduleName: CORE
  };
  Identifiers.ModuleWithProviders = {
    name: "ModuleWithProviders",
    moduleName: CORE
  };
  Identifiers.defineNgModule = { name: "\u0275\u0275defineNgModule", moduleName: CORE };
  Identifiers.declareNgModule = { name: "\u0275\u0275ngDeclareNgModule", moduleName: CORE };
  Identifiers.setNgModuleScope = { name: "\u0275\u0275setNgModuleScope", moduleName: CORE };
  Identifiers.PipeDeclaration = { name: "\u0275\u0275PipeDeclaration", moduleName: CORE };
  Identifiers.definePipe = { name: "\u0275\u0275definePipe", moduleName: CORE };
  Identifiers.declarePipe = { name: "\u0275\u0275ngDeclarePipe", moduleName: CORE };
  Identifiers.declareClassMetadata = { name: "\u0275\u0275ngDeclareClassMetadata", moduleName: CORE };
  Identifiers.setClassMetadata = { name: "\u0275setClassMetadata", moduleName: CORE };
  Identifiers.queryRefresh = { name: "\u0275\u0275queryRefresh", moduleName: CORE };
  Identifiers.viewQuery = { name: "\u0275\u0275viewQuery", moduleName: CORE };
  Identifiers.loadQuery = { name: "\u0275\u0275loadQuery", moduleName: CORE };
  Identifiers.contentQuery = { name: "\u0275\u0275contentQuery", moduleName: CORE };
  Identifiers.NgOnChangesFeature = { name: "\u0275\u0275NgOnChangesFeature", moduleName: CORE };
  Identifiers.InheritDefinitionFeature = { name: "\u0275\u0275InheritDefinitionFeature", moduleName: CORE };
  Identifiers.CopyDefinitionFeature = { name: "\u0275\u0275CopyDefinitionFeature", moduleName: CORE };
  Identifiers.ProvidersFeature = { name: "\u0275\u0275ProvidersFeature", moduleName: CORE };
  Identifiers.listener = { name: "\u0275\u0275listener", moduleName: CORE };
  Identifiers.getInheritedFactory = {
    name: "\u0275\u0275getInheritedFactory",
    moduleName: CORE
  };
  Identifiers.sanitizeHtml = { name: "\u0275\u0275sanitizeHtml", moduleName: CORE };
  Identifiers.sanitizeStyle = { name: "\u0275\u0275sanitizeStyle", moduleName: CORE };
  Identifiers.sanitizeResourceUrl = { name: "\u0275\u0275sanitizeResourceUrl", moduleName: CORE };
  Identifiers.sanitizeScript = { name: "\u0275\u0275sanitizeScript", moduleName: CORE };
  Identifiers.sanitizeUrl = { name: "\u0275\u0275sanitizeUrl", moduleName: CORE };
  Identifiers.sanitizeUrlOrResourceUrl = { name: "\u0275\u0275sanitizeUrlOrResourceUrl", moduleName: CORE };
  Identifiers.trustConstantHtml = { name: "\u0275\u0275trustConstantHtml", moduleName: CORE };
  Identifiers.trustConstantResourceUrl = { name: "\u0275\u0275trustConstantResourceUrl", moduleName: CORE };
  var VERSION$1 = 3;
  var JS_B64_PREFIX = "# sourceMappingURL=data:application/json;base64,";
  var SourceMapGenerator = class {
    constructor(file = null) {
      this.file = file;
      this.sourcesContent = /* @__PURE__ */ new Map();
      this.lines = [];
      this.lastCol0 = 0;
      this.hasMappings = false;
    }
    addSource(url, content = null) {
      if (!this.sourcesContent.has(url)) {
        this.sourcesContent.set(url, content);
      }
      return this;
    }
    addLine() {
      this.lines.push([]);
      this.lastCol0 = 0;
      return this;
    }
    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
      if (!this.currentLine) {
        throw new Error(`A line must be added before mappings can be added`);
      }
      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
        throw new Error(`Unknown source file "${sourceUrl}"`);
      }
      if (col0 == null) {
        throw new Error(`The column in the generated code must be provided`);
      }
      if (col0 < this.lastCol0) {
        throw new Error(`Mapping should be added in output order`);
      }
      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
        throw new Error(`The source location must be provided when a source url is provided`);
      }
      this.hasMappings = true;
      this.lastCol0 = col0;
      this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });
      return this;
    }
    get currentLine() {
      return this.lines.slice(-1)[0];
    }
    toJSON() {
      if (!this.hasMappings) {
        return null;
      }
      const sourcesIndex = /* @__PURE__ */ new Map();
      const sources = [];
      const sourcesContent = [];
      Array.from(this.sourcesContent.keys()).forEach((url, i) => {
        sourcesIndex.set(url, i);
        sources.push(url);
        sourcesContent.push(this.sourcesContent.get(url) || null);
      });
      let mappings = "";
      let lastCol0 = 0;
      let lastSourceIndex = 0;
      let lastSourceLine0 = 0;
      let lastSourceCol0 = 0;
      this.lines.forEach((segments) => {
        lastCol0 = 0;
        mappings += segments.map((segment) => {
          let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
          lastCol0 = segment.col0;
          if (segment.sourceUrl != null) {
            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
            lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
            segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
            lastSourceLine0 = segment.sourceLine0;
            segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
            lastSourceCol0 = segment.sourceCol0;
          }
          return segAsStr;
        }).join(",");
        mappings += ";";
      });
      mappings = mappings.slice(0, -1);
      return {
        "file": this.file || "",
        "version": VERSION$1,
        "sourceRoot": "",
        "sources": sources,
        "sourcesContent": sourcesContent,
        "mappings": mappings
      };
    }
    toJsComment() {
      return this.hasMappings ? "//" + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : "";
    }
  };
  function toBase64String(value) {
    let b64 = "";
    const encoded = utf8Encode(value);
    for (let i = 0; i < encoded.length; ) {
      const i1 = encoded[i++];
      const i2 = i < encoded.length ? encoded[i++] : null;
      const i3 = i < encoded.length ? encoded[i++] : null;
      b64 += toBase64Digit(i1 >> 2);
      b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));
      b64 += i2 === null ? "=" : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));
      b64 += i2 === null || i3 === null ? "=" : toBase64Digit(i3 & 63);
    }
    return b64;
  }
  function toBase64VLQ(value) {
    value = value < 0 ? (-value << 1) + 1 : value << 1;
    let out = "";
    do {
      let digit = value & 31;
      value = value >> 5;
      if (value > 0) {
        digit = digit | 32;
      }
      out += toBase64Digit(digit);
    } while (value > 0);
    return out;
  }
  var B64_DIGITS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  function toBase64Digit(value) {
    if (value < 0 || value >= 64) {
      throw new Error(`Can only encode value in the range [0, 63]`);
    }
    return B64_DIGITS[value];
  }
  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
  var _INDENT_WITH = "  ";
  var _EmittedLine = class {
    constructor(indent) {
      this.indent = indent;
      this.partsLength = 0;
      this.parts = [];
      this.srcSpans = [];
    }
  };
  var EmitterVisitorContext = class {
    constructor(_indent) {
      this._indent = _indent;
      this._lines = [new _EmittedLine(_indent)];
    }
    static createRoot() {
      return new EmitterVisitorContext(0);
    }
    get _currentLine() {
      return this._lines[this._lines.length - 1];
    }
    println(from2, lastPart = "") {
      this.print(from2 || null, lastPart, true);
    }
    lineIsEmpty() {
      return this._currentLine.parts.length === 0;
    }
    lineLength() {
      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
    }
    print(from2, part, newLine = false) {
      if (part.length > 0) {
        this._currentLine.parts.push(part);
        this._currentLine.partsLength += part.length;
        this._currentLine.srcSpans.push(from2 && from2.sourceSpan || null);
      }
      if (newLine) {
        this._lines.push(new _EmittedLine(this._indent));
      }
    }
    removeEmptyLastLine() {
      if (this.lineIsEmpty()) {
        this._lines.pop();
      }
    }
    incIndent() {
      this._indent++;
      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    }
    decIndent() {
      this._indent--;
      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    }
    toSource() {
      return this.sourceLines.map((l) => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join("") : "").join("\n");
    }
    toSourceMapGenerator(genFilePath, startsAtLine = 0) {
      const map2 = new SourceMapGenerator(genFilePath);
      let firstOffsetMapped = false;
      const mapFirstOffsetIfNeeded = () => {
        if (!firstOffsetMapped) {
          map2.addSource(genFilePath, " ").addMapping(0, genFilePath, 0, 0);
          firstOffsetMapped = true;
        }
      };
      for (let i = 0; i < startsAtLine; i++) {
        map2.addLine();
        mapFirstOffsetIfNeeded();
      }
      this.sourceLines.forEach((line, lineIdx) => {
        map2.addLine();
        const spans = line.srcSpans;
        const parts = line.parts;
        let col0 = line.indent * _INDENT_WITH.length;
        let spanIdx = 0;
        while (spanIdx < spans.length && !spans[spanIdx]) {
          col0 += parts[spanIdx].length;
          spanIdx++;
        }
        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
          firstOffsetMapped = true;
        } else {
          mapFirstOffsetIfNeeded();
        }
        while (spanIdx < spans.length) {
          const span = spans[spanIdx];
          const source = span.start.file;
          const sourceLine = span.start.line;
          const sourceCol = span.start.col;
          map2.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);
          col0 += parts[spanIdx].length;
          spanIdx++;
          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
            col0 += parts[spanIdx].length;
            spanIdx++;
          }
        }
      });
      return map2;
    }
    spanOf(line, column) {
      const emittedLine = this._lines[line];
      if (emittedLine) {
        let columnsLeft = column - _createIndent(emittedLine.indent).length;
        for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
          const part = emittedLine.parts[partIndex];
          if (part.length > columnsLeft) {
            return emittedLine.srcSpans[partIndex];
          }
          columnsLeft -= part.length;
        }
      }
      return null;
    }
    get sourceLines() {
      if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
        return this._lines.slice(0, -1);
      }
      return this._lines;
    }
  };
  var AbstractEmitterVisitor = class {
    constructor(_escapeDollarInStrings) {
      this._escapeDollarInStrings = _escapeDollarInStrings;
    }
    printLeadingComments(stmt, ctx) {
      if (stmt.leadingComments === void 0) {
        return;
      }
      for (const comment of stmt.leadingComments) {
        if (comment instanceof JSDocComment) {
          ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);
        } else {
          if (comment.multiline) {
            ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);
          } else {
            comment.text.split("\n").forEach((line) => {
              ctx.println(stmt, `// ${line}`);
            });
          }
        }
      }
    }
    visitExpressionStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      stmt.expr.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    }
    visitReturnStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, `return `);
      stmt.value.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    }
    visitIfStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, `if (`);
      stmt.condition.visitExpression(this, ctx);
      ctx.print(stmt, `) {`);
      const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
      if (stmt.trueCase.length <= 1 && !hasElseCase) {
        ctx.print(stmt, ` `);
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.removeEmptyLastLine();
        ctx.print(stmt, ` `);
      } else {
        ctx.println();
        ctx.incIndent();
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.decIndent();
        if (hasElseCase) {
          ctx.println(stmt, `} else {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.falseCase, ctx);
          ctx.decIndent();
        }
      }
      ctx.println(stmt, `}`);
      return null;
    }
    visitWriteVarExpr(expr, ctx) {
      const lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, "(");
      }
      ctx.print(expr, `${expr.name} = `);
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ")");
      }
      return null;
    }
    visitWriteKeyExpr(expr, ctx) {
      const lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, "(");
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, `[`);
      expr.index.visitExpression(this, ctx);
      ctx.print(expr, `] = `);
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ")");
      }
      return null;
    }
    visitWritePropExpr(expr, ctx) {
      const lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, "(");
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, `.${expr.name} = `);
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ")");
      }
      return null;
    }
    visitInvokeFunctionExpr(expr, ctx) {
      expr.fn.visitExpression(this, ctx);
      ctx.print(expr, `(`);
      this.visitAllExpressions(expr.args, ctx, ",");
      ctx.print(expr, `)`);
      return null;
    }
    visitTaggedTemplateExpr(expr, ctx) {
      expr.tag.visitExpression(this, ctx);
      ctx.print(expr, "`" + expr.template.elements[0].rawText);
      for (let i = 1; i < expr.template.elements.length; i++) {
        ctx.print(expr, "${");
        expr.template.expressions[i - 1].visitExpression(this, ctx);
        ctx.print(expr, `}${expr.template.elements[i].rawText}`);
      }
      ctx.print(expr, "`");
      return null;
    }
    visitWrappedNodeExpr(ast, ctx) {
      throw new Error("Abstract emitter cannot visit WrappedNodeExpr.");
    }
    visitTypeofExpr(expr, ctx) {
      ctx.print(expr, "typeof ");
      expr.expr.visitExpression(this, ctx);
    }
    visitReadVarExpr(ast, ctx) {
      ctx.print(ast, ast.name);
      return null;
    }
    visitInstantiateExpr(ast, ctx) {
      ctx.print(ast, `new `);
      ast.classExpr.visitExpression(this, ctx);
      ctx.print(ast, `(`);
      this.visitAllExpressions(ast.args, ctx, ",");
      ctx.print(ast, `)`);
      return null;
    }
    visitLiteralExpr(ast, ctx) {
      const value = ast.value;
      if (typeof value === "string") {
        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
      } else {
        ctx.print(ast, `${value}`);
      }
      return null;
    }
    visitLocalizedString(ast, ctx) {
      const head = ast.serializeI18nHead();
      ctx.print(ast, "$localize `" + head.raw);
      for (let i = 1; i < ast.messageParts.length; i++) {
        ctx.print(ast, "${");
        ast.expressions[i - 1].visitExpression(this, ctx);
        ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);
      }
      ctx.print(ast, "`");
      return null;
    }
    visitConditionalExpr(ast, ctx) {
      ctx.print(ast, `(`);
      ast.condition.visitExpression(this, ctx);
      ctx.print(ast, "? ");
      ast.trueCase.visitExpression(this, ctx);
      ctx.print(ast, ": ");
      ast.falseCase.visitExpression(this, ctx);
      ctx.print(ast, `)`);
      return null;
    }
    visitNotExpr(ast, ctx) {
      ctx.print(ast, "!");
      ast.condition.visitExpression(this, ctx);
      return null;
    }
    visitUnaryOperatorExpr(ast, ctx) {
      let opStr;
      switch (ast.operator) {
        case UnaryOperator.Plus:
          opStr = "+";
          break;
        case UnaryOperator.Minus:
          opStr = "-";
          break;
        default:
          throw new Error(`Unknown operator ${ast.operator}`);
      }
      if (ast.parens)
        ctx.print(ast, `(`);
      ctx.print(ast, opStr);
      ast.expr.visitExpression(this, ctx);
      if (ast.parens)
        ctx.print(ast, `)`);
      return null;
    }
    visitBinaryOperatorExpr(ast, ctx) {
      let opStr;
      switch (ast.operator) {
        case BinaryOperator.Equals:
          opStr = "==";
          break;
        case BinaryOperator.Identical:
          opStr = "===";
          break;
        case BinaryOperator.NotEquals:
          opStr = "!=";
          break;
        case BinaryOperator.NotIdentical:
          opStr = "!==";
          break;
        case BinaryOperator.And:
          opStr = "&&";
          break;
        case BinaryOperator.BitwiseAnd:
          opStr = "&";
          break;
        case BinaryOperator.Or:
          opStr = "||";
          break;
        case BinaryOperator.Plus:
          opStr = "+";
          break;
        case BinaryOperator.Minus:
          opStr = "-";
          break;
        case BinaryOperator.Divide:
          opStr = "/";
          break;
        case BinaryOperator.Multiply:
          opStr = "*";
          break;
        case BinaryOperator.Modulo:
          opStr = "%";
          break;
        case BinaryOperator.Lower:
          opStr = "<";
          break;
        case BinaryOperator.LowerEquals:
          opStr = "<=";
          break;
        case BinaryOperator.Bigger:
          opStr = ">";
          break;
        case BinaryOperator.BiggerEquals:
          opStr = ">=";
          break;
        case BinaryOperator.NullishCoalesce:
          opStr = "??";
          break;
        default:
          throw new Error(`Unknown operator ${ast.operator}`);
      }
      if (ast.parens)
        ctx.print(ast, `(`);
      ast.lhs.visitExpression(this, ctx);
      ctx.print(ast, ` ${opStr} `);
      ast.rhs.visitExpression(this, ctx);
      if (ast.parens)
        ctx.print(ast, `)`);
      return null;
    }
    visitReadPropExpr(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, `.`);
      ctx.print(ast, ast.name);
      return null;
    }
    visitReadKeyExpr(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, `[`);
      ast.index.visitExpression(this, ctx);
      ctx.print(ast, `]`);
      return null;
    }
    visitLiteralArrayExpr(ast, ctx) {
      ctx.print(ast, `[`);
      this.visitAllExpressions(ast.entries, ctx, ",");
      ctx.print(ast, `]`);
      return null;
    }
    visitLiteralMapExpr(ast, ctx) {
      ctx.print(ast, `{`);
      this.visitAllObjects((entry) => {
        ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
        entry.value.visitExpression(this, ctx);
      }, ast.entries, ctx, ",");
      ctx.print(ast, `}`);
      return null;
    }
    visitCommaExpr(ast, ctx) {
      ctx.print(ast, "(");
      this.visitAllExpressions(ast.parts, ctx, ",");
      ctx.print(ast, ")");
      return null;
    }
    visitAllExpressions(expressions, ctx, separator) {
      this.visitAllObjects((expr) => expr.visitExpression(this, ctx), expressions, ctx, separator);
    }
    visitAllObjects(handler, expressions, ctx, separator) {
      let incrementedIndent = false;
      for (let i = 0; i < expressions.length; i++) {
        if (i > 0) {
          if (ctx.lineLength() > 80) {
            ctx.print(null, separator, true);
            if (!incrementedIndent) {
              ctx.incIndent();
              ctx.incIndent();
              incrementedIndent = true;
            }
          } else {
            ctx.print(null, separator, false);
          }
        }
        handler(expressions[i]);
      }
      if (incrementedIndent) {
        ctx.decIndent();
        ctx.decIndent();
      }
    }
    visitAllStatements(statements, ctx) {
      statements.forEach((stmt) => stmt.visitStatement(this, ctx));
    }
  };
  function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
    if (input == null) {
      return null;
    }
    const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {
      if (match[0] == "$") {
        return escapeDollar ? "\\$" : "$";
      } else if (match[0] == "\n") {
        return "\\n";
      } else if (match[0] == "\r") {
        return "\\r";
      } else {
        return `\\${match[0]}`;
      }
    });
    const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
    return requiresQuotes ? `'${body}'` : body;
  }
  function _createIndent(count) {
    let res = "";
    for (let i = 0; i < count; i++) {
      res += _INDENT_WITH;
    }
    return res;
  }
  function typeWithParameters(type, numParams) {
    if (numParams === 0) {
      return expressionType(type);
    }
    const params = [];
    for (let i = 0; i < numParams; i++) {
      params.push(DYNAMIC_TYPE);
    }
    return expressionType(type, void 0, params);
  }
  var ANIMATE_SYMBOL_PREFIX = "@";
  function prepareSyntheticPropertyName(name) {
    return `${ANIMATE_SYMBOL_PREFIX}${name}`;
  }
  function prepareSyntheticListenerName(name, phase) {
    return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
  }
  function getSafePropertyAccessString(accessor, name) {
    const escapedName = escapeIdentifier(name, false, false);
    return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;
  }
  function prepareSyntheticListenerFunctionName(name, phase) {
    return `animation_${name}_${phase}`;
  }
  function jitOnlyGuardedExpression(expr) {
    return guardedExpression("ngJitMode", expr);
  }
  function guardedExpression(guard, expr) {
    const guardExpr = new ExternalExpr({ name: guard, moduleName: null });
    const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal("undefined"));
    const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, void 0, void 0, true);
    return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);
  }
  function wrapReference(value) {
    const wrapped = new WrappedNodeExpr(value);
    return { value: wrapped, type: wrapped };
  }
  function refsToArray(refs, shouldForwardDeclare) {
    const values = literalArr(refs.map((ref) => ref.value));
    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
  }
  function createMayBeForwardRefExpression(expression, forwardRef2) {
    return { expression, forwardRef: forwardRef2 };
  }
  function convertFromMaybeForwardRefExpression({ expression, forwardRef: forwardRef2 }) {
    switch (forwardRef2) {
      case 0:
      case 1:
        return expression;
      case 2:
        return generateForwardRef(expression);
    }
  }
  function generateForwardRef(expr) {
    return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);
  }
  var R3FactoryDelegateType;
  (function(R3FactoryDelegateType2) {
    R3FactoryDelegateType2[R3FactoryDelegateType2["Class"] = 0] = "Class";
    R3FactoryDelegateType2[R3FactoryDelegateType2["Function"] = 1] = "Function";
  })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
  var FactoryTarget$1;
  (function(FactoryTarget3) {
    FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
    FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
    FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
    FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
    FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
  })(FactoryTarget$1 || (FactoryTarget$1 = {}));
  function compileFactoryFunction(meta) {
    const t = variable("t");
    let baseFactoryVar = null;
    const typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;
    let ctorExpr = null;
    if (meta.deps !== null) {
      if (meta.deps !== "invalid") {
        ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));
      }
    } else {
      baseFactoryVar = variable(`\u0275${meta.name}_BaseFactory`);
      ctorExpr = baseFactoryVar.callFn([typeForCtor]);
    }
    const body = [];
    let retExpr = null;
    function makeConditionalFactory(nonCtorExpr) {
      const r = variable("r");
      body.push(r.set(NULL_EXPR).toDeclStmt());
      const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();
      body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
      return r;
    }
    if (isDelegatedFactoryMetadata(meta)) {
      const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);
      const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);
      retExpr = makeConditionalFactory(factoryExpr);
    } else if (isExpressionFactoryMetadata(meta)) {
      retExpr = makeConditionalFactory(meta.expression);
    } else {
      retExpr = ctorExpr;
    }
    if (retExpr === null) {
      body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());
    } else if (baseFactoryVar !== null) {
      const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);
      const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));
      body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));
    } else {
      body.push(new ReturnStatement(retExpr));
    }
    let factoryFn = fn([new FnParam("t", DYNAMIC_TYPE)], body, INFERRED_TYPE, void 0, `${meta.name}_Factory`);
    if (baseFactoryVar !== null) {
      factoryFn = fn([], [
        new DeclareVarStmt(baseFactoryVar.name),
        new ReturnStatement(factoryFn)
      ]).callFn([], void 0, true);
    }
    return {
      expression: factoryFn,
      statements: [],
      type: createFactoryType(meta)
    };
  }
  function createFactoryType(meta) {
    const ctorDepsType = meta.deps !== null && meta.deps !== "invalid" ? createCtorDepsType(meta.deps) : NONE_TYPE;
    return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));
  }
  function injectDependencies(deps, target) {
    return deps.map((dep, index) => compileInjectDependency(dep, target, index));
  }
  function compileInjectDependency(dep, target, index) {
    if (dep.token === null) {
      return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);
    } else if (dep.attributeNameType === null) {
      const flags = 0 | (dep.self ? 2 : 0) | (dep.skipSelf ? 4 : 0) | (dep.host ? 1 : 0) | (dep.optional ? 8 : 0) | (target === FactoryTarget$1.Pipe ? 16 : 0);
      let flagsParam = flags !== 0 || dep.optional ? literal(flags) : null;
      const injectArgs2 = [dep.token];
      if (flagsParam) {
        injectArgs2.push(flagsParam);
      }
      const injectFn = getInjectFn(target);
      return importExpr(injectFn).callFn(injectArgs2);
    } else {
      return importExpr(Identifiers.injectAttribute).callFn([dep.token]);
    }
  }
  function createCtorDepsType(deps) {
    let hasTypes = false;
    const attributeTypes = deps.map((dep) => {
      const type = createCtorDepType(dep);
      if (type !== null) {
        hasTypes = true;
        return type;
      } else {
        return literal(null);
      }
    });
    if (hasTypes) {
      return expressionType(literalArr(attributeTypes));
    } else {
      return NONE_TYPE;
    }
  }
  function createCtorDepType(dep) {
    const entries = [];
    if (dep.attributeNameType !== null) {
      entries.push({ key: "attribute", value: dep.attributeNameType, quoted: false });
    }
    if (dep.optional) {
      entries.push({ key: "optional", value: literal(true), quoted: false });
    }
    if (dep.host) {
      entries.push({ key: "host", value: literal(true), quoted: false });
    }
    if (dep.self) {
      entries.push({ key: "self", value: literal(true), quoted: false });
    }
    if (dep.skipSelf) {
      entries.push({ key: "skipSelf", value: literal(true), quoted: false });
    }
    return entries.length > 0 ? literalMap(entries) : null;
  }
  function isDelegatedFactoryMetadata(meta) {
    return meta.delegateType !== void 0;
  }
  function isExpressionFactoryMetadata(meta) {
    return meta.expression !== void 0;
  }
  function getInjectFn(target) {
    switch (target) {
      case FactoryTarget$1.Component:
      case FactoryTarget$1.Directive:
      case FactoryTarget$1.Pipe:
        return Identifiers.directiveInject;
      case FactoryTarget$1.NgModule:
      case FactoryTarget$1.Injectable:
      default:
        return Identifiers.inject;
    }
  }
  var Comment$1 = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(_visitor2) {
      throw new Error("visit() not implemented for Comment");
    }
  };
  var Text$3 = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor) {
      return visitor.visitText(this);
    }
  };
  var BoundText = class {
    constructor(value, sourceSpan, i18n) {
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitBoundText(this);
    }
  };
  var TextAttribute = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitTextAttribute(this);
    }
  };
  var BoundAttribute = class {
    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.i18n = i18n;
    }
    static fromBoundElementProperty(prop, i18n) {
      if (prop.keySpan === void 0) {
        throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);
      }
      return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);
    }
    visit(visitor) {
      return visitor.visitBoundAttribute(this);
    }
  };
  var BoundEvent = class {
    constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {
      this.name = name;
      this.type = type;
      this.handler = handler;
      this.target = target;
      this.phase = phase;
      this.sourceSpan = sourceSpan;
      this.handlerSpan = handlerSpan;
      this.keySpan = keySpan;
    }
    static fromParsedEvent(event) {
      const target = event.type === 0 ? event.targetOrPhase : null;
      const phase = event.type === 1 ? event.targetOrPhase : null;
      if (event.keySpan === void 0) {
        throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);
      }
      return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);
    }
    visit(visitor) {
      return visitor.visitBoundEvent(this);
    }
  };
  var Element$1 = class {
    constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
      this.name = name;
      this.attributes = attributes;
      this.inputs = inputs;
      this.outputs = outputs;
      this.children = children;
      this.references = references;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitElement(this);
    }
  };
  var Template = class {
    constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
      this.tagName = tagName;
      this.attributes = attributes;
      this.inputs = inputs;
      this.outputs = outputs;
      this.templateAttrs = templateAttrs;
      this.children = children;
      this.references = references;
      this.variables = variables;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitTemplate(this);
    }
  };
  var Content = class {
    constructor(selector, attributes, sourceSpan, i18n) {
      this.selector = selector;
      this.attributes = attributes;
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
      this.name = "ng-content";
    }
    visit(visitor) {
      return visitor.visitContent(this);
    }
  };
  var Variable = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
    visit(visitor) {
      return visitor.visitVariable(this);
    }
  };
  var Reference = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
    visit(visitor) {
      return visitor.visitReference(this);
    }
  };
  var Icu$1 = class {
    constructor(vars, placeholders, sourceSpan, i18n) {
      this.vars = vars;
      this.placeholders = placeholders;
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitIcu(this);
    }
  };
  function visitAll$1(visitor, nodes) {
    const result = [];
    if (visitor.visit) {
      for (const node of nodes) {
        const newNode = visitor.visit(node) || node.visit(visitor);
      }
    } else {
      for (const node of nodes) {
        const newNode = node.visit(visitor);
        if (newNode) {
          result.push(newNode);
        }
      }
    }
    return result;
  }
  var Message = class {
    constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
      this.nodes = nodes;
      this.placeholders = placeholders;
      this.placeholderToMessage = placeholderToMessage;
      this.meaning = meaning;
      this.description = description;
      this.customId = customId;
      this.id = this.customId;
      this.legacyIds = [];
      this.messageString = serializeMessage(this.nodes);
      if (nodes.length) {
        this.sources = [{
          filePath: nodes[0].sourceSpan.start.file.url,
          startLine: nodes[0].sourceSpan.start.line + 1,
          startCol: nodes[0].sourceSpan.start.col + 1,
          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
          endCol: nodes[0].sourceSpan.start.col + 1
        }];
      } else {
        this.sources = [];
      }
    }
  };
  var Text$2 = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitText(this, context);
    }
  };
  var Container = class {
    constructor(children, sourceSpan) {
      this.children = children;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitContainer(this, context);
    }
  };
  var Icu = class {
    constructor(expression, type, cases, sourceSpan) {
      this.expression = expression;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitIcu(this, context);
    }
  };
  var TagPlaceholder = class {
    constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan, startSourceSpan, endSourceSpan) {
      this.tag = tag;
      this.attrs = attrs;
      this.startName = startName;
      this.closeName = closeName;
      this.children = children;
      this.isVoid = isVoid;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitTagPlaceholder(this, context);
    }
  };
  var Placeholder = class {
    constructor(value, name, sourceSpan) {
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitPlaceholder(this, context);
    }
  };
  var IcuPlaceholder = class {
    constructor(value, name, sourceSpan) {
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitIcuPlaceholder(this, context);
    }
  };
  function serializeMessage(messageNodes) {
    const visitor = new LocalizeMessageStringVisitor();
    const str = messageNodes.map((n) => n.visit(visitor)).join("");
    return str;
  }
  var LocalizeMessageStringVisitor = class {
    visitText(text) {
      return text.value;
    }
    visitContainer(container) {
      return container.children.map((child) => child.visit(this)).join("");
    }
    visitIcu(icu) {
      const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(" ")}}`;
    }
    visitTagPlaceholder(ph) {
      const children = ph.children.map((child) => child.visit(this)).join("");
      return `{$${ph.startName}}${children}{$${ph.closeName}}`;
    }
    visitPlaceholder(ph) {
      return `{$${ph.name}}`;
    }
    visitIcuPlaceholder(ph) {
      return `{$${ph.name}}`;
    }
  };
  var _Visitor$2 = class {
    visitTag(tag) {
      const strAttrs = this._serializeAttributes(tag.attrs);
      if (tag.children.length == 0) {
        return `<${tag.name}${strAttrs}/>`;
      }
      const strChildren = tag.children.map((node) => node.visit(this));
      return `<${tag.name}${strAttrs}>${strChildren.join("")}</${tag.name}>`;
    }
    visitText(text) {
      return text.value;
    }
    visitDeclaration(decl) {
      return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;
    }
    _serializeAttributes(attrs) {
      const strAttrs = Object.keys(attrs).map((name) => `${name}="${attrs[name]}"`).join(" ");
      return strAttrs.length > 0 ? " " + strAttrs : "";
    }
    visitDoctype(doctype) {
      return `<!DOCTYPE ${doctype.rootTag} [
${doctype.dtd}
]>`;
    }
  };
  var _visitor = new _Visitor$2();
  function toPublicName(internalName) {
    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, "_");
  }
  var CLOSURE_TRANSLATION_VAR_PREFIX = "MSG_";
  var TRANSLATION_VAR_PREFIX = "i18n_";
  var I18N_ATTR = "i18n";
  var I18N_ATTR_PREFIX = "i18n-";
  var I18N_ICU_VAR_PREFIX = "VAR_";
  var I18N_ICU_MAPPING_PREFIX = "I18N_EXP_";
  var I18N_PLACEHOLDER_SYMBOL = "\uFFFD";
  function isI18nAttribute(name) {
    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
  }
  function isI18nRootNode(meta) {
    return meta instanceof Message;
  }
  function isSingleI18nIcu(meta) {
    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;
  }
  function hasI18nMeta(node) {
    return !!node.i18n;
  }
  function hasI18nAttrs(element2) {
    return element2.attrs.some((attr) => isI18nAttribute(attr.name));
  }
  function icuFromI18nMessage(message) {
    return message.nodes[0];
  }
  function wrapI18nPlaceholder(content, contextId = 0) {
    const blockId = contextId > 0 ? `:${contextId}` : "";
    return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
  }
  function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
    if (!strings.length)
      return "";
    let acc = "";
    const lastIdx = strings.length - 1;
    for (let i = 0; i < lastIdx; i++) {
      acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
    }
    acc += strings[lastIdx];
    return acc;
  }
  function getSeqNumberGenerator(startsAt = 0) {
    let current = startsAt;
    return () => current++;
  }
  function placeholdersToParams(placeholders) {
    const params = {};
    placeholders.forEach((values, key) => {
      params[key] = literal(values.length > 1 ? `[${values.join("|")}]` : values[0]);
    });
    return params;
  }
  function updatePlaceholderMap(map2, name, ...values) {
    const current = map2.get(name) || [];
    current.push(...values);
    map2.set(name, current);
  }
  function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
    const startIdx = bindingStartIndex;
    const placeholders = /* @__PURE__ */ new Map();
    const node = meta instanceof Message ? meta.nodes.find((node2) => node2 instanceof Container) : meta;
    if (node) {
      node.children.filter((child) => child instanceof Placeholder).forEach((child, idx) => {
        const content = wrapI18nPlaceholder(startIdx + idx, contextId);
        updatePlaceholderMap(placeholders, child.name, content);
      });
    }
    return placeholders;
  }
  function i18nFormatPlaceholderNames(params = {}, useCamelCase) {
    const _params = {};
    if (params && Object.keys(params).length) {
      Object.keys(params).forEach((key) => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);
    }
    return _params;
  }
  function formatI18nPlaceholderName(name, useCamelCase = true) {
    const publicName = toPublicName(name);
    if (!useCamelCase) {
      return publicName;
    }
    const chunks = publicName.split("_");
    if (chunks.length === 1) {
      return name.toLowerCase();
    }
    let postfix;
    if (/^\d+$/.test(chunks[chunks.length - 1])) {
      postfix = chunks.pop();
    }
    let raw = chunks.shift().toLowerCase();
    if (chunks.length) {
      raw += chunks.map((c) => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join("");
    }
    return postfix ? `${raw}_${postfix}` : raw;
  }
  function getTranslationConstPrefix(extra) {
    return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();
  }
  function declareI18nVariable(variable2) {
    return new DeclareVarStmt(variable2.name, void 0, INFERRED_TYPE, void 0, variable2.sourceSpan);
  }
  var UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
  var TEMPORARY_NAME = "_t";
  var CONTEXT_NAME = "ctx";
  var RENDER_FLAGS = "rf";
  var REFERENCE_PREFIX = "_r";
  var IMPLICIT_REFERENCE = "$implicit";
  var NON_BINDABLE_ATTR = "ngNonBindable";
  var RESTORED_VIEW_CONTEXT_NAME = "restoredCtx";
  var MAX_CHAIN_LENGTH = 500;
  var CHAINABLE_INSTRUCTIONS = /* @__PURE__ */ new Set([
    Identifiers.element,
    Identifiers.elementStart,
    Identifiers.elementEnd,
    Identifiers.elementContainer,
    Identifiers.elementContainerStart,
    Identifiers.elementContainerEnd,
    Identifiers.i18nExp,
    Identifiers.listener,
    Identifiers.classProp,
    Identifiers.syntheticHostListener,
    Identifiers.hostProperty,
    Identifiers.syntheticHostProperty,
    Identifiers.property,
    Identifiers.propertyInterpolate1,
    Identifiers.propertyInterpolate2,
    Identifiers.propertyInterpolate3,
    Identifiers.propertyInterpolate4,
    Identifiers.propertyInterpolate5,
    Identifiers.propertyInterpolate6,
    Identifiers.propertyInterpolate7,
    Identifiers.propertyInterpolate8,
    Identifiers.propertyInterpolateV,
    Identifiers.attribute,
    Identifiers.attributeInterpolate1,
    Identifiers.attributeInterpolate2,
    Identifiers.attributeInterpolate3,
    Identifiers.attributeInterpolate4,
    Identifiers.attributeInterpolate5,
    Identifiers.attributeInterpolate6,
    Identifiers.attributeInterpolate7,
    Identifiers.attributeInterpolate8,
    Identifiers.attributeInterpolateV,
    Identifiers.styleProp,
    Identifiers.stylePropInterpolate1,
    Identifiers.stylePropInterpolate2,
    Identifiers.stylePropInterpolate3,
    Identifiers.stylePropInterpolate4,
    Identifiers.stylePropInterpolate5,
    Identifiers.stylePropInterpolate6,
    Identifiers.stylePropInterpolate7,
    Identifiers.stylePropInterpolate8,
    Identifiers.stylePropInterpolateV,
    Identifiers.textInterpolate,
    Identifiers.textInterpolate1,
    Identifiers.textInterpolate2,
    Identifiers.textInterpolate3,
    Identifiers.textInterpolate4,
    Identifiers.textInterpolate5,
    Identifiers.textInterpolate6,
    Identifiers.textInterpolate7,
    Identifiers.textInterpolate8,
    Identifiers.textInterpolateV
  ]);
  function invokeInstruction(span, reference, params) {
    return importExpr(reference, null, span).callFn(params, span);
  }
  function temporaryAllocator(statements, name) {
    let temp = null;
    return () => {
      if (!temp) {
        statements.push(new DeclareVarStmt(TEMPORARY_NAME, void 0, DYNAMIC_TYPE));
        temp = variable(name);
      }
      return temp;
    };
  }
  function invalid(arg) {
    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
  }
  function asLiteral(value) {
    if (Array.isArray(value)) {
      return literalArr(value.map(asLiteral));
    }
    return literal(value, INFERRED_TYPE);
  }
  function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
    if (Object.getOwnPropertyNames(keys).length > 0) {
      return mapToExpression(keys, keepDeclared);
    }
    return null;
  }
  function mapToExpression(map2, keepDeclared) {
    return literalMap(Object.getOwnPropertyNames(map2).map((key) => {
      const value = map2[key];
      let declaredName;
      let publicName;
      let minifiedName;
      let needsDeclaredName;
      if (Array.isArray(value)) {
        [publicName, declaredName] = value;
        minifiedName = key;
        needsDeclaredName = publicName !== declaredName;
      } else {
        [declaredName, publicName] = splitAtColon(key, [key, value]);
        minifiedName = declaredName;
        needsDeclaredName = publicName !== declaredName && key.includes(":");
      }
      return {
        key: minifiedName,
        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
        value: keepDeclared && needsDeclaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)
      };
    }));
  }
  function trimTrailingNulls(parameters) {
    while (isNull(parameters[parameters.length - 1])) {
      parameters.pop();
    }
    return parameters;
  }
  function getQueryPredicate(query, constantPool) {
    if (Array.isArray(query.predicate)) {
      let predicate = [];
      query.predicate.forEach((selector) => {
        const selectors = selector.split(",").map((token) => literal(token.trim()));
        predicate.push(...selectors);
      });
      return constantPool.getConstLiteral(literalArr(predicate), true);
    } else {
      switch (query.predicate.forwardRef) {
        case 0:
        case 2:
          return query.predicate.expression;
        case 1:
          return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);
      }
    }
  }
  var DefinitionMap = class {
    constructor() {
      this.values = [];
    }
    set(key, value) {
      if (value) {
        this.values.push({ key, value, quoted: false });
      }
    }
    toLiteralMap() {
      return literalMap(this.values);
    }
  };
  function getInterpolationArgsLength(interpolation) {
    const { expressions, strings } = interpolation;
    if (expressions.length === 1 && strings.length === 2 && strings[0] === "" && strings[1] === "") {
      return 1;
    } else {
      return expressions.length + strings.length;
    }
  }
  function getInstructionStatements(instructions) {
    const statements = [];
    let pendingExpression = null;
    let pendingExpressionType = null;
    let chainLength = 0;
    for (const current of instructions) {
      const resolvedParams = (typeof current.paramsOrFn === "function" ? current.paramsOrFn() : current.paramsOrFn) ?? [];
      const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];
      if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference && CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {
        pendingExpression = pendingExpression.callFn(params, pendingExpression.sourceSpan);
        chainLength++;
      } else {
        if (pendingExpression !== null) {
          statements.push(pendingExpression.toStmt());
        }
        pendingExpression = invokeInstruction(current.span, current.reference, params);
        pendingExpressionType = current.reference;
        chainLength = 0;
      }
    }
    if (pendingExpression !== null) {
      statements.push(pendingExpression.toStmt());
    }
    return statements;
  }
  function compileInjectable2(meta, resolveForwardRefs) {
    let result = null;
    const factoryMeta = {
      name: meta.name,
      type: meta.type,
      internalType: meta.internalType,
      typeArgumentCount: meta.typeArgumentCount,
      deps: [],
      target: FactoryTarget$1.Injectable
    };
    if (meta.useClass !== void 0) {
      const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);
      let deps = void 0;
      if (meta.deps !== void 0) {
        deps = meta.deps;
      }
      if (deps !== void 0) {
        result = compileFactoryFunction({
          ...factoryMeta,
          delegate: meta.useClass.expression,
          delegateDeps: deps,
          delegateType: R3FactoryDelegateType.Class
        });
      } else if (useClassOnSelf) {
        result = compileFactoryFunction(factoryMeta);
      } else {
        result = {
          statements: [],
          expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)
        };
      }
    } else if (meta.useFactory !== void 0) {
      if (meta.deps !== void 0) {
        result = compileFactoryFunction({
          ...factoryMeta,
          delegate: meta.useFactory,
          delegateDeps: meta.deps || [],
          delegateType: R3FactoryDelegateType.Function
        });
      } else {
        result = {
          statements: [],
          expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
        };
      }
    } else if (meta.useValue !== void 0) {
      result = compileFactoryFunction({
        ...factoryMeta,
        expression: meta.useValue.expression
      });
    } else if (meta.useExisting !== void 0) {
      result = compileFactoryFunction({
        ...factoryMeta,
        expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])
      });
    } else {
      result = {
        statements: [],
        expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)
      };
    }
    const token = meta.internalType;
    const injectableProps = new DefinitionMap();
    injectableProps.set("token", token);
    injectableProps.set("factory", result.expression);
    if (meta.providedIn.expression.value !== null) {
      injectableProps.set("providedIn", convertFromMaybeForwardRefExpression(meta.providedIn));
    }
    const expression = importExpr(Identifiers.\u0275\u0275defineInjectable).callFn([injectableProps.toLiteralMap()], void 0, true);
    return {
      expression,
      type: createInjectableType(meta),
      statements: result.statements
    };
  }
  function createInjectableType(meta) {
    return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
  }
  function delegateToFactory(type, internalType, unwrapForwardRefs) {
    if (type.node === internalType.node) {
      return internalType.prop("\u0275fac");
    }
    if (!unwrapForwardRefs) {
      return createFactoryFunction(internalType);
    }
    const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);
    return createFactoryFunction(unwrappedType);
  }
  function createFactoryFunction(type) {
    return fn([new FnParam("t", DYNAMIC_TYPE)], [new ReturnStatement(type.prop("\u0275fac").callFn([variable("t")]))]);
  }
  var UNUSABLE_INTERPOLATION_REGEXPS = [
    /^\s*$/,
    /[<>]/,
    /^[{}]$/,
    /&(#|[a-z])/i,
    /^\/\//
  ];
  function assertInterpolationSymbols(identifier, value) {
    if (value != null && !(Array.isArray(value) && value.length == 2)) {
      throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
    } else if (value != null) {
      const start = value[0];
      const end = value[1];
      UNUSABLE_INTERPOLATION_REGEXPS.forEach((regexp) => {
        if (regexp.test(start) || regexp.test(end)) {
          throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
        }
      });
    }
  }
  var InterpolationConfig = class {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }
    static fromArray(markers) {
      if (!markers) {
        return DEFAULT_INTERPOLATION_CONFIG;
      }
      assertInterpolationSymbols("interpolation", markers);
      return new InterpolationConfig(markers[0], markers[1]);
    }
  };
  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig("{{", "}}");
  var $EOF = 0;
  var $BSPACE = 8;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $HASH = 35;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $7 = 55;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $F = 70;
  var $X = 88;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $a = 97;
  var $b = 98;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $x = 120;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  var $BT = 96;
  function isWhitespace(code) {
    return code >= $TAB && code <= $SPACE || code == $NBSP;
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isAsciiLetter(code) {
    return code >= $a && code <= $z || code >= $A && code <= $Z;
  }
  function isAsciiHexDigit(code) {
    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
  }
  function isNewLine(code) {
    return code === $LF || code === $CR;
  }
  function isOctalDigit(code) {
    return $0 <= code && code <= $7;
  }
  function isQuote(code) {
    return code === $SQ || code === $DQ || code === $BT;
  }
  var ParseLocation = class {
    constructor(file, offset, line, col) {
      this.file = file;
      this.offset = offset;
      this.line = line;
      this.col = col;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(delta) {
      const source = this.file.content;
      const len = source.length;
      let offset = this.offset;
      let line = this.line;
      let col = this.col;
      while (offset > 0 && delta < 0) {
        offset--;
        delta++;
        const ch = source.charCodeAt(offset);
        if (ch == $LF) {
          line--;
          const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
          col = priorLine > 0 ? offset - priorLine : offset;
        } else {
          col--;
        }
      }
      while (offset < len && delta > 0) {
        const ch = source.charCodeAt(offset);
        offset++;
        delta--;
        if (ch == $LF) {
          line++;
          col = 0;
        } else {
          col++;
        }
      }
      return new ParseLocation(this.file, offset, line, col);
    }
    getContext(maxChars, maxLines) {
      const content = this.file.content;
      let startOffset = this.offset;
      if (startOffset != null) {
        if (startOffset > content.length - 1) {
          startOffset = content.length - 1;
        }
        let endOffset = startOffset;
        let ctxChars = 0;
        let ctxLines = 0;
        while (ctxChars < maxChars && startOffset > 0) {
          startOffset--;
          ctxChars++;
          if (content[startOffset] == "\n") {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }
        ctxChars = 0;
        ctxLines = 0;
        while (ctxChars < maxChars && endOffset < content.length - 1) {
          endOffset++;
          ctxChars++;
          if (content[endOffset] == "\n") {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }
        return {
          before: content.substring(startOffset, this.offset),
          after: content.substring(this.offset, endOffset + 1)
        };
      }
      return null;
    }
  };
  var ParseSourceFile = class {
    constructor(content, url) {
      this.content = content;
      this.url = url;
    }
  };
  var ParseSourceSpan = class {
    constructor(start, end, fullStart = start, details = null) {
      this.start = start;
      this.end = end;
      this.fullStart = fullStart;
      this.details = details;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  var ParseErrorLevel;
  (function(ParseErrorLevel2) {
    ParseErrorLevel2[ParseErrorLevel2["WARNING"] = 0] = "WARNING";
    ParseErrorLevel2[ParseErrorLevel2["ERROR"] = 1] = "ERROR";
  })(ParseErrorLevel || (ParseErrorLevel = {}));
  var ParseError = class {
    constructor(span, msg, level = ParseErrorLevel.ERROR) {
      this.span = span;
      this.msg = msg;
      this.level = level;
    }
    contextualMessage() {
      const ctx = this.span.start.getContext(100, 3);
      return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` : this.msg;
    }
    toString() {
      const details = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${details}`;
    }
  };
  function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
    const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
    const sourceFile = new ParseSourceFile("", sourceFileName);
    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
  }
  var _anonymousTypeIndex = 0;
  function identifierName(compileIdentifier) {
    if (!compileIdentifier || !compileIdentifier.reference) {
      return null;
    }
    const ref = compileIdentifier.reference;
    if (ref["__anonymousType"]) {
      return ref["__anonymousType"];
    }
    if (ref["__forward_ref__"]) {
      return "__forward_ref__";
    }
    let identifier = stringify2(ref);
    if (identifier.indexOf("(") >= 0) {
      identifier = `anonymous_${_anonymousTypeIndex++}`;
      ref["__anonymousType"] = identifier;
    } else {
      identifier = sanitizeIdentifier(identifier);
    }
    return identifier;
  }
  function sanitizeIdentifier(name) {
    return name.replace(/\W/g, "_");
  }
  var makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})';
  var AbstractJsEmitterVisitor = class extends AbstractEmitterVisitor {
    constructor() {
      super(false);
    }
    visitWrappedNodeExpr(ast, ctx) {
      throw new Error("Cannot emit a WrappedNodeExpr in Javascript.");
    }
    visitDeclareVarStmt(stmt, ctx) {
      ctx.print(stmt, `var ${stmt.name}`);
      if (stmt.value) {
        ctx.print(stmt, " = ");
        stmt.value.visitExpression(this, ctx);
      }
      ctx.println(stmt, `;`);
      return null;
    }
    visitTaggedTemplateExpr(ast, ctx) {
      const elements = ast.template.elements;
      ast.tag.visitExpression(this, ctx);
      ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);
      ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.text, false)).join(", ")}], `);
      ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.rawText, false)).join(", ")}])`);
      ast.template.expressions.forEach((expression) => {
        ctx.print(ast, ", ");
        expression.visitExpression(this, ctx);
      });
      ctx.print(ast, ")");
      return null;
    }
    visitFunctionExpr(ast, ctx) {
      ctx.print(ast, `function${ast.name ? " " + ast.name : ""}(`);
      this._visitParams(ast.params, ctx);
      ctx.println(ast, `) {`);
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print(ast, `}`);
      return null;
    }
    visitDeclareFunctionStmt(stmt, ctx) {
      ctx.print(stmt, `function ${stmt.name}(`);
      this._visitParams(stmt.params, ctx);
      ctx.println(stmt, `) {`);
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println(stmt, `}`);
      return null;
    }
    visitLocalizedString(ast, ctx) {
      ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);
      const parts = [ast.serializeI18nHead()];
      for (let i = 1; i < ast.messageParts.length; i++) {
        parts.push(ast.serializeI18nTemplatePart(i));
      }
      ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.cooked, false)).join(", ")}], `);
      ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.raw, false)).join(", ")}])`);
      ast.expressions.forEach((expression) => {
        ctx.print(ast, ", ");
        expression.visitExpression(this, ctx);
      });
      ctx.print(ast, ")");
      return null;
    }
    _visitParams(params, ctx) {
      this.visitAllObjects((param) => ctx.print(null, param.name), params, ctx, ",");
    }
  };
  var policy2;
  function getPolicy2() {
    if (policy2 === void 0) {
      policy2 = null;
      if (_global3.trustedTypes) {
        try {
          policy2 = _global3.trustedTypes.createPolicy("angular#unsafe-jit", {
            createScript: (s) => s
          });
        } catch {
        }
      }
    }
    return policy2;
  }
  function trustedScriptFromString2(script) {
    return getPolicy2()?.createScript(script) || script;
  }
  function newTrustedFunctionForJIT(...args) {
    if (!_global3.trustedTypes) {
      return new Function(...args);
    }
    const fnArgs = args.slice(0, -1).join(",");
    const fnBody = args[args.length - 1];
    const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
    const fn2 = _global3["eval"](trustedScriptFromString2(body));
    if (fn2.bind === void 0) {
      return new Function(...args);
    }
    fn2.toString = () => body;
    return fn2.bind(_global3);
  }
  var JitEvaluator = class {
    evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {
      const converter = new JitEmitterVisitor(refResolver);
      const ctx = EmitterVisitorContext.createRoot();
      if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
        statements = [
          literal("use strict").toStmt(),
          ...statements
        ];
      }
      converter.visitAllStatements(statements, ctx);
      converter.createReturnStmt(ctx);
      return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
    }
    evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
      let fnBody = `"use strict";${ctx.toSource()}
//# sourceURL=${sourceUrl}`;
      const fnArgNames = [];
      const fnArgValues = [];
      for (const argName in vars) {
        fnArgValues.push(vars[argName]);
        fnArgNames.push(argName);
      }
      if (createSourceMap) {
        const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat("return null;")).toString();
        const headerLines = emptyFn.slice(0, emptyFn.indexOf("return null;")).split("\n").length - 1;
        fnBody += `
${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
      }
      const fn2 = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));
      return this.executeFunction(fn2, fnArgValues);
    }
    executeFunction(fn2, args) {
      return fn2(...args);
    }
  };
  var JitEmitterVisitor = class extends AbstractJsEmitterVisitor {
    constructor(refResolver) {
      super();
      this.refResolver = refResolver;
      this._evalArgNames = [];
      this._evalArgValues = [];
      this._evalExportedVars = [];
    }
    createReturnStmt(ctx) {
      const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map((resultVar) => new LiteralMapEntry(resultVar, variable(resultVar), false))));
      stmt.visitStatement(this, ctx);
    }
    getArgs() {
      const result = {};
      for (let i = 0; i < this._evalArgNames.length; i++) {
        result[this._evalArgNames[i]] = this._evalArgValues[i];
      }
      return result;
    }
    visitExternalExpr(ast, ctx) {
      this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);
      return null;
    }
    visitWrappedNodeExpr(ast, ctx) {
      this._emitReferenceToExternal(ast, ast.node, ctx);
      return null;
    }
    visitDeclareVarStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return super.visitDeclareVarStmt(stmt, ctx);
    }
    visitDeclareFunctionStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return super.visitDeclareFunctionStmt(stmt, ctx);
    }
    _emitReferenceToExternal(ast, value, ctx) {
      let id = this._evalArgValues.indexOf(value);
      if (id === -1) {
        id = this._evalArgValues.length;
        this._evalArgValues.push(value);
        const name = identifierName({ reference: value }) || "val";
        this._evalArgNames.push(`jit_${name}_${id}`);
      }
      ctx.print(ast, this._evalArgNames[id]);
    }
  };
  function isUseStrictStatement(statement) {
    return statement.isEquivalent(literal("use strict").toStmt());
  }
  function compileInjector(meta) {
    const definitionMap = new DefinitionMap();
    if (meta.providers !== null) {
      definitionMap.set("providers", meta.providers);
    }
    if (meta.imports.length > 0) {
      definitionMap.set("imports", literalArr(meta.imports));
    }
    const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createInjectorType(meta);
    return { expression, type, statements: [] };
  }
  function createInjectorType(meta) {
    return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));
  }
  var R3JitReflector = class {
    constructor(context) {
      this.context = context;
    }
    resolveExternalReference(ref) {
      if (ref.moduleName !== "@angular/core") {
        throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
      }
      if (!this.context.hasOwnProperty(ref.name)) {
        throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
      }
      return this.context[ref.name];
    }
  };
  function compileNgModule2(meta) {
    const { internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;
    const statements = [];
    const definitionMap = new DefinitionMap();
    definitionMap.set("type", internalType);
    if (bootstrap.length > 0) {
      definitionMap.set("bootstrap", refsToArray(bootstrap, containsForwardDecls));
    }
    if (emitInline) {
      if (declarations.length > 0) {
        definitionMap.set("declarations", refsToArray(declarations, containsForwardDecls));
      }
      if (imports.length > 0) {
        definitionMap.set("imports", refsToArray(imports, containsForwardDecls));
      }
      if (exports.length > 0) {
        definitionMap.set("exports", refsToArray(exports, containsForwardDecls));
      }
    } else {
      const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);
      if (setNgModuleScopeCall !== null) {
        statements.push(setNgModuleScopeCall);
      }
    }
    if (schemas !== null && schemas.length > 0) {
      definitionMap.set("schemas", literalArr(schemas.map((ref) => ref.value)));
    }
    if (id !== null) {
      definitionMap.set("id", id);
    }
    const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createNgModuleType(meta);
    return { expression, type, statements };
  }
  function compileNgModuleDeclarationExpression(meta) {
    const definitionMap = new DefinitionMap();
    definitionMap.set("type", new WrappedNodeExpr(meta.type));
    if (meta.bootstrap !== void 0) {
      definitionMap.set("bootstrap", new WrappedNodeExpr(meta.bootstrap));
    }
    if (meta.declarations !== void 0) {
      definitionMap.set("declarations", new WrappedNodeExpr(meta.declarations));
    }
    if (meta.imports !== void 0) {
      definitionMap.set("imports", new WrappedNodeExpr(meta.imports));
    }
    if (meta.exports !== void 0) {
      definitionMap.set("exports", new WrappedNodeExpr(meta.exports));
    }
    if (meta.schemas !== void 0) {
      definitionMap.set("schemas", new WrappedNodeExpr(meta.schemas));
    }
    if (meta.id !== void 0) {
      definitionMap.set("id", new WrappedNodeExpr(meta.id));
    }
    return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);
  }
  function createNgModuleType({ type: moduleType, declarations, imports, exports }) {
    return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [
      new ExpressionType(moduleType.type),
      tupleTypeOf(declarations),
      tupleTypeOf(imports),
      tupleTypeOf(exports)
    ]));
  }
  function generateSetNgModuleScopeCall(meta) {
    const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;
    const scopeMap = new DefinitionMap();
    if (declarations.length > 0) {
      scopeMap.set("declarations", refsToArray(declarations, containsForwardDecls));
    }
    if (imports.length > 0) {
      scopeMap.set("imports", refsToArray(imports, containsForwardDecls));
    }
    if (exports.length > 0) {
      scopeMap.set("exports", refsToArray(exports, containsForwardDecls));
    }
    if (Object.keys(scopeMap.values).length === 0) {
      return null;
    }
    const fnCall = new InvokeFunctionExpr(importExpr(Identifiers.setNgModuleScope), [moduleType, scopeMap.toLiteralMap()]);
    const guardedCall = jitOnlyGuardedExpression(fnCall);
    const iife = new FunctionExpr([], [guardedCall.toStmt()]);
    const iifeCall = new InvokeFunctionExpr(iife, []);
    return iifeCall.toStmt();
  }
  function tupleTypeOf(exp) {
    const types = exp.map((ref) => typeofExpr(ref.type));
    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
  }
  function compilePipeFromMetadata(metadata) {
    const definitionMapValues = [];
    definitionMapValues.push({ key: "name", value: literal(metadata.pipeName), quoted: false });
    definitionMapValues.push({ key: "type", value: metadata.type.value, quoted: false });
    definitionMapValues.push({ key: "pure", value: literal(metadata.pure), quoted: false });
    const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], void 0, true);
    const type = createPipeType(metadata);
    return { expression, type, statements: [] };
  }
  function createPipeType(metadata) {
    return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [
      typeWithParameters(metadata.type.type, metadata.typeArgumentCount),
      new ExpressionType(new LiteralExpr(metadata.pipeName))
    ]));
  }
  var ParserError = class {
    constructor(message, input, errLocation, ctxLocation) {
      this.input = input;
      this.errLocation = errLocation;
      this.ctxLocation = ctxLocation;
      this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
    }
  };
  var ParseSpan = class {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }
    toAbsolute(absoluteOffset) {
      return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
    }
  };
  var AST = class {
    constructor(span, sourceSpan) {
      this.span = span;
      this.sourceSpan = sourceSpan;
    }
    toString() {
      return "AST";
    }
  };
  var ASTWithName = class extends AST {
    constructor(span, sourceSpan, nameSpan) {
      super(span, sourceSpan);
      this.nameSpan = nameSpan;
    }
  };
  var Quote = class extends AST {
    constructor(span, sourceSpan, prefix, uninterpretedExpression, location2) {
      super(span, sourceSpan);
      this.prefix = prefix;
      this.uninterpretedExpression = uninterpretedExpression;
      this.location = location2;
    }
    visit(visitor, context = null) {
      return visitor.visitQuote(this, context);
    }
    toString() {
      return "Quote";
    }
  };
  var EmptyExpr = class extends AST {
    visit(visitor, context = null) {
    }
  };
  var ImplicitReceiver = class extends AST {
    visit(visitor, context = null) {
      return visitor.visitImplicitReceiver(this, context);
    }
  };
  var ThisReceiver = class extends ImplicitReceiver {
    visit(visitor, context = null) {
      return visitor.visitThisReceiver?.(this, context);
    }
  };
  var Chain = class extends AST {
    constructor(span, sourceSpan, expressions) {
      super(span, sourceSpan);
      this.expressions = expressions;
    }
    visit(visitor, context = null) {
      return visitor.visitChain(this, context);
    }
  };
  var Conditional = class extends AST {
    constructor(span, sourceSpan, condition, trueExp, falseExp) {
      super(span, sourceSpan);
      this.condition = condition;
      this.trueExp = trueExp;
      this.falseExp = falseExp;
    }
    visit(visitor, context = null) {
      return visitor.visitConditional(this, context);
    }
  };
  var PropertyRead = class extends ASTWithName {
    constructor(span, sourceSpan, nameSpan, receiver, name) {
      super(span, sourceSpan, nameSpan);
      this.receiver = receiver;
      this.name = name;
    }
    visit(visitor, context = null) {
      return visitor.visitPropertyRead(this, context);
    }
  };
  var PropertyWrite = class extends ASTWithName {
    constructor(span, sourceSpan, nameSpan, receiver, name, value) {
      super(span, sourceSpan, nameSpan);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    visit(visitor, context = null) {
      return visitor.visitPropertyWrite(this, context);
    }
  };
  var SafePropertyRead = class extends ASTWithName {
    constructor(span, sourceSpan, nameSpan, receiver, name) {
      super(span, sourceSpan, nameSpan);
      this.receiver = receiver;
      this.name = name;
    }
    visit(visitor, context = null) {
      return visitor.visitSafePropertyRead(this, context);
    }
  };
  var KeyedRead = class extends AST {
    constructor(span, sourceSpan, receiver, key) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.key = key;
    }
    visit(visitor, context = null) {
      return visitor.visitKeyedRead(this, context);
    }
  };
  var SafeKeyedRead = class extends AST {
    constructor(span, sourceSpan, receiver, key) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.key = key;
    }
    visit(visitor, context = null) {
      return visitor.visitSafeKeyedRead(this, context);
    }
  };
  var KeyedWrite = class extends AST {
    constructor(span, sourceSpan, receiver, key, value) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.key = key;
      this.value = value;
    }
    visit(visitor, context = null) {
      return visitor.visitKeyedWrite(this, context);
    }
  };
  var BindingPipe = class extends ASTWithName {
    constructor(span, sourceSpan, exp, name, args, nameSpan) {
      super(span, sourceSpan, nameSpan);
      this.exp = exp;
      this.name = name;
      this.args = args;
    }
    visit(visitor, context = null) {
      return visitor.visitPipe(this, context);
    }
  };
  var LiteralPrimitive = class extends AST {
    constructor(span, sourceSpan, value) {
      super(span, sourceSpan);
      this.value = value;
    }
    visit(visitor, context = null) {
      return visitor.visitLiteralPrimitive(this, context);
    }
  };
  var LiteralArray = class extends AST {
    constructor(span, sourceSpan, expressions) {
      super(span, sourceSpan);
      this.expressions = expressions;
    }
    visit(visitor, context = null) {
      return visitor.visitLiteralArray(this, context);
    }
  };
  var LiteralMap = class extends AST {
    constructor(span, sourceSpan, keys, values) {
      super(span, sourceSpan);
      this.keys = keys;
      this.values = values;
    }
    visit(visitor, context = null) {
      return visitor.visitLiteralMap(this, context);
    }
  };
  var Interpolation = class extends AST {
    constructor(span, sourceSpan, strings, expressions) {
      super(span, sourceSpan);
      this.strings = strings;
      this.expressions = expressions;
    }
    visit(visitor, context = null) {
      return visitor.visitInterpolation(this, context);
    }
  };
  var Binary = class extends AST {
    constructor(span, sourceSpan, operation, left, right) {
      super(span, sourceSpan);
      this.operation = operation;
      this.left = left;
      this.right = right;
    }
    visit(visitor, context = null) {
      return visitor.visitBinary(this, context);
    }
  };
  var Unary = class extends Binary {
    constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {
      super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);
      this.operator = operator;
      this.expr = expr;
      this.left = null;
      this.right = null;
      this.operation = null;
    }
    static createMinus(span, sourceSpan, expr) {
      return new Unary(span, sourceSpan, "-", expr, "-", new LiteralPrimitive(span, sourceSpan, 0), expr);
    }
    static createPlus(span, sourceSpan, expr) {
      return new Unary(span, sourceSpan, "+", expr, "-", expr, new LiteralPrimitive(span, sourceSpan, 0));
    }
    visit(visitor, context = null) {
      if (visitor.visitUnary !== void 0) {
        return visitor.visitUnary(this, context);
      }
      return visitor.visitBinary(this, context);
    }
  };
  var PrefixNot = class extends AST {
    constructor(span, sourceSpan, expression) {
      super(span, sourceSpan);
      this.expression = expression;
    }
    visit(visitor, context = null) {
      return visitor.visitPrefixNot(this, context);
    }
  };
  var NonNullAssert = class extends AST {
    constructor(span, sourceSpan, expression) {
      super(span, sourceSpan);
      this.expression = expression;
    }
    visit(visitor, context = null) {
      return visitor.visitNonNullAssert(this, context);
    }
  };
  var Call = class extends AST {
    constructor(span, sourceSpan, receiver, args, argumentSpan) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.args = args;
      this.argumentSpan = argumentSpan;
    }
    visit(visitor, context = null) {
      return visitor.visitCall(this, context);
    }
  };
  var SafeCall = class extends AST {
    constructor(span, sourceSpan, receiver, args, argumentSpan) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.args = args;
      this.argumentSpan = argumentSpan;
    }
    visit(visitor, context = null) {
      return visitor.visitSafeCall(this, context);
    }
  };
  var AbsoluteSourceSpan = class {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }
  };
  var ASTWithSource = class extends AST {
    constructor(ast, source, location2, absoluteOffset, errors) {
      super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
      this.ast = ast;
      this.source = source;
      this.location = location2;
      this.errors = errors;
    }
    visit(visitor, context = null) {
      if (visitor.visitASTWithSource) {
        return visitor.visitASTWithSource(this, context);
      }
      return this.ast.visit(visitor, context);
    }
    toString() {
      return `${this.source} in ${this.location}`;
    }
  };
  var VariableBinding = class {
    constructor(sourceSpan, key, value) {
      this.sourceSpan = sourceSpan;
      this.key = key;
      this.value = value;
    }
  };
  var ExpressionBinding = class {
    constructor(sourceSpan, key, value) {
      this.sourceSpan = sourceSpan;
      this.key = key;
      this.value = value;
    }
  };
  var RecursiveAstVisitor = class {
    visit(ast, context) {
      ast.visit(this, context);
    }
    visitUnary(ast, context) {
      this.visit(ast.expr, context);
    }
    visitBinary(ast, context) {
      this.visit(ast.left, context);
      this.visit(ast.right, context);
    }
    visitChain(ast, context) {
      this.visitAll(ast.expressions, context);
    }
    visitConditional(ast, context) {
      this.visit(ast.condition, context);
      this.visit(ast.trueExp, context);
      this.visit(ast.falseExp, context);
    }
    visitPipe(ast, context) {
      this.visit(ast.exp, context);
      this.visitAll(ast.args, context);
    }
    visitImplicitReceiver(ast, context) {
    }
    visitThisReceiver(ast, context) {
    }
    visitInterpolation(ast, context) {
      this.visitAll(ast.expressions, context);
    }
    visitKeyedRead(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.key, context);
    }
    visitKeyedWrite(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.key, context);
      this.visit(ast.value, context);
    }
    visitLiteralArray(ast, context) {
      this.visitAll(ast.expressions, context);
    }
    visitLiteralMap(ast, context) {
      this.visitAll(ast.values, context);
    }
    visitLiteralPrimitive(ast, context) {
    }
    visitPrefixNot(ast, context) {
      this.visit(ast.expression, context);
    }
    visitNonNullAssert(ast, context) {
      this.visit(ast.expression, context);
    }
    visitPropertyRead(ast, context) {
      this.visit(ast.receiver, context);
    }
    visitPropertyWrite(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.value, context);
    }
    visitSafePropertyRead(ast, context) {
      this.visit(ast.receiver, context);
    }
    visitSafeKeyedRead(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.key, context);
    }
    visitCall(ast, context) {
      this.visit(ast.receiver, context);
      this.visitAll(ast.args, context);
    }
    visitSafeCall(ast, context) {
      this.visit(ast.receiver, context);
      this.visitAll(ast.args, context);
    }
    visitQuote(ast, context) {
    }
    visitAll(asts, context) {
      for (const ast of asts) {
        this.visit(ast, context);
      }
    }
  };
  var AstTransformer = class {
    visitImplicitReceiver(ast, context) {
      return ast;
    }
    visitThisReceiver(ast, context) {
      return ast;
    }
    visitInterpolation(ast, context) {
      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
    }
    visitLiteralPrimitive(ast, context) {
      return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
    }
    visitPropertyRead(ast, context) {
      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
    }
    visitPropertyWrite(ast, context) {
      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
    }
    visitSafePropertyRead(ast, context) {
      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
    }
    visitLiteralArray(ast, context) {
      return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
    }
    visitLiteralMap(ast, context) {
      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
    }
    visitUnary(ast, context) {
      switch (ast.operator) {
        case "+":
          return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));
        case "-":
          return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));
        default:
          throw new Error(`Unknown unary operator ${ast.operator}`);
      }
    }
    visitBinary(ast, context) {
      return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
    }
    visitPrefixNot(ast, context) {
      return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
    }
    visitNonNullAssert(ast, context) {
      return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
    }
    visitConditional(ast, context) {
      return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    }
    visitPipe(ast, context) {
      return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
    }
    visitKeyedRead(ast, context) {
      return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
    }
    visitKeyedWrite(ast, context) {
      return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));
    }
    visitCall(ast, context) {
      return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
    }
    visitSafeCall(ast, context) {
      return new SafeCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
    }
    visitAll(asts) {
      const res = [];
      for (let i = 0; i < asts.length; ++i) {
        res[i] = asts[i].visit(this);
      }
      return res;
    }
    visitChain(ast, context) {
      return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
    }
    visitQuote(ast, context) {
      return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);
    }
    visitSafeKeyedRead(ast, context) {
      return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
    }
  };
  var AstMemoryEfficientTransformer = class {
    visitImplicitReceiver(ast, context) {
      return ast;
    }
    visitThisReceiver(ast, context) {
      return ast;
    }
    visitInterpolation(ast, context) {
      const expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions)
        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
      return ast;
    }
    visitLiteralPrimitive(ast, context) {
      return ast;
    }
    visitPropertyRead(ast, context) {
      const receiver = ast.receiver.visit(this);
      if (receiver !== ast.receiver) {
        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
      }
      return ast;
    }
    visitPropertyWrite(ast, context) {
      const receiver = ast.receiver.visit(this);
      const value = ast.value.visit(this);
      if (receiver !== ast.receiver || value !== ast.value) {
        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
      }
      return ast;
    }
    visitSafePropertyRead(ast, context) {
      const receiver = ast.receiver.visit(this);
      if (receiver !== ast.receiver) {
        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
      }
      return ast;
    }
    visitLiteralArray(ast, context) {
      const expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions) {
        return new LiteralArray(ast.span, ast.sourceSpan, expressions);
      }
      return ast;
    }
    visitLiteralMap(ast, context) {
      const values = this.visitAll(ast.values);
      if (values !== ast.values) {
        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
      }
      return ast;
    }
    visitUnary(ast, context) {
      const expr = ast.expr.visit(this);
      if (expr !== ast.expr) {
        switch (ast.operator) {
          case "+":
            return Unary.createPlus(ast.span, ast.sourceSpan, expr);
          case "-":
            return Unary.createMinus(ast.span, ast.sourceSpan, expr);
          default:
            throw new Error(`Unknown unary operator ${ast.operator}`);
        }
      }
      return ast;
    }
    visitBinary(ast, context) {
      const left = ast.left.visit(this);
      const right = ast.right.visit(this);
      if (left !== ast.left || right !== ast.right) {
        return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
      }
      return ast;
    }
    visitPrefixNot(ast, context) {
      const expression = ast.expression.visit(this);
      if (expression !== ast.expression) {
        return new PrefixNot(ast.span, ast.sourceSpan, expression);
      }
      return ast;
    }
    visitNonNullAssert(ast, context) {
      const expression = ast.expression.visit(this);
      if (expression !== ast.expression) {
        return new NonNullAssert(ast.span, ast.sourceSpan, expression);
      }
      return ast;
    }
    visitConditional(ast, context) {
      const condition = ast.condition.visit(this);
      const trueExp = ast.trueExp.visit(this);
      const falseExp = ast.falseExp.visit(this);
      if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
        return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
      }
      return ast;
    }
    visitPipe(ast, context) {
      const exp = ast.exp.visit(this);
      const args = this.visitAll(ast.args);
      if (exp !== ast.exp || args !== ast.args) {
        return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
      }
      return ast;
    }
    visitKeyedRead(ast, context) {
      const obj = ast.receiver.visit(this);
      const key = ast.key.visit(this);
      if (obj !== ast.receiver || key !== ast.key) {
        return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
      }
      return ast;
    }
    visitKeyedWrite(ast, context) {
      const obj = ast.receiver.visit(this);
      const key = ast.key.visit(this);
      const value = ast.value.visit(this);
      if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {
        return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
      }
      return ast;
    }
    visitAll(asts) {
      const res = [];
      let modified = false;
      for (let i = 0; i < asts.length; ++i) {
        const original = asts[i];
        const value = original.visit(this);
        res[i] = value;
        modified = modified || value !== original;
      }
      return modified ? res : asts;
    }
    visitChain(ast, context) {
      const expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions) {
        return new Chain(ast.span, ast.sourceSpan, expressions);
      }
      return ast;
    }
    visitCall(ast, context) {
      const receiver = ast.receiver.visit(this);
      const args = this.visitAll(ast.args);
      if (receiver !== ast.receiver || args !== ast.args) {
        return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
      }
      return ast;
    }
    visitSafeCall(ast, context) {
      const receiver = ast.receiver.visit(this);
      const args = this.visitAll(ast.args);
      if (receiver !== ast.receiver || args !== ast.args) {
        return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
      }
      return ast;
    }
    visitQuote(ast, context) {
      return ast;
    }
    visitSafeKeyedRead(ast, context) {
      const obj = ast.receiver.visit(this);
      const key = ast.key.visit(this);
      if (obj !== ast.receiver || key !== ast.key) {
        return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);
      }
      return ast;
    }
  };
  var ParsedProperty = class {
    constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.expression = expression;
      this.type = type;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
      this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
    }
  };
  var ParsedPropertyType;
  (function(ParsedPropertyType2) {
    ParsedPropertyType2[ParsedPropertyType2["DEFAULT"] = 0] = "DEFAULT";
    ParsedPropertyType2[ParsedPropertyType2["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
    ParsedPropertyType2[ParsedPropertyType2["ANIMATION"] = 2] = "ANIMATION";
  })(ParsedPropertyType || (ParsedPropertyType = {}));
  var ParsedEvent = class {
    constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {
      this.name = name;
      this.targetOrPhase = targetOrPhase;
      this.type = type;
      this.handler = handler;
      this.sourceSpan = sourceSpan;
      this.handlerSpan = handlerSpan;
      this.keySpan = keySpan;
    }
  };
  var ParsedVariable = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
  };
  var BoundElementProperty = class {
    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
  };
  var EventHandlerVars = class {
  };
  EventHandlerVars.event = variable("$event");
  function convertActionBinding(localResolver, implicitReceiver, action, bindingId, baseSourceSpan, implicitReceiverAccesses, globals) {
    if (!localResolver) {
      localResolver = new DefaultLocalResolver(globals);
    }
    const actionWithoutBuiltins = convertPropertyBindingBuiltins({
      createLiteralArrayConverter: (argCount) => {
        return (args) => literalArr(args);
      },
      createLiteralMapConverter: (keys) => {
        return (values) => {
          const entries = keys.map((k, i) => ({
            key: k.key,
            value: values[i],
            quoted: k.quoted
          }));
          return literalMap(entries);
        };
      },
      createPipeConverter: (name) => {
        throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
      }
    }, action);
    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, false, baseSourceSpan, implicitReceiverAccesses);
    const actionStmts = [];
    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
    if (visitor.usesImplicitReceiver) {
      localResolver.notifyImplicitReceiverUse();
    }
    const lastIndex = actionStmts.length - 1;
    if (lastIndex >= 0) {
      const lastStatement = actionStmts[lastIndex];
      if (lastStatement instanceof ExpressionStatement) {
        actionStmts[lastIndex] = new ReturnStatement(lastStatement.expr);
      }
    }
    return actionStmts;
  }
  function convertPropertyBindingBuiltins(converterFactory, ast) {
    return convertBuiltins(converterFactory, ast);
  }
  var ConvertPropertyBindingResult = class {
    constructor(stmts, currValExpr) {
      this.stmts = stmts;
      this.currValExpr = currValExpr;
    }
  };
  function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {
    if (!localResolver) {
      localResolver = new DefaultLocalResolver();
    }
    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, false);
    const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
    const stmts = getStatementsFromVisitor(visitor, bindingId);
    if (visitor.usesImplicitReceiver) {
      localResolver.notifyImplicitReceiverUse();
    }
    return new ConvertPropertyBindingResult(stmts, outputExpr);
  }
  function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
    const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, true);
    const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);
    if (visitor.usesImplicitReceiver) {
      localResolver.notifyImplicitReceiverUse();
    }
    const stmts = getStatementsFromVisitor(visitor, bindingId);
    const args = outputExpr.args;
    return { stmts, args };
  }
  function getStatementsFromVisitor(visitor, bindingId) {
    const stmts = [];
    for (let i = 0; i < visitor.temporaryCount; i++) {
      stmts.push(temporaryDeclaration(bindingId, i));
    }
    return stmts;
  }
  function convertBuiltins(converterFactory, ast) {
    const visitor = new _BuiltinAstConverter(converterFactory);
    return ast.visit(visitor);
  }
  function temporaryName(bindingId, temporaryNumber) {
    return `tmp_${bindingId}_${temporaryNumber}`;
  }
  function temporaryDeclaration(bindingId, temporaryNumber) {
    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));
  }
  function prependTemporaryDecls(temporaryCount, bindingId, statements) {
    for (let i = temporaryCount - 1; i >= 0; i--) {
      statements.unshift(temporaryDeclaration(bindingId, i));
    }
  }
  var _Mode;
  (function(_Mode2) {
    _Mode2[_Mode2["Statement"] = 0] = "Statement";
    _Mode2[_Mode2["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
    if (mode !== _Mode.Statement) {
      throw new Error(`Expected a statement, but saw ${ast}`);
    }
  }
  function ensureExpressionMode(mode, ast) {
    if (mode !== _Mode.Expression) {
      throw new Error(`Expected an expression, but saw ${ast}`);
    }
  }
  function convertToStatementIfNeeded(mode, expr) {
    if (mode === _Mode.Statement) {
      return expr.toStmt();
    } else {
      return expr;
    }
  }
  var _BuiltinAstConverter = class extends AstTransformer {
    constructor(_converterFactory) {
      super();
      this._converterFactory = _converterFactory;
    }
    visitPipe(ast, context) {
      const args = [ast.exp, ...ast.args].map((ast2) => ast2.visit(this, context));
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
    }
    visitLiteralArray(ast, context) {
      const args = ast.expressions.map((ast2) => ast2.visit(this, context));
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
    }
    visitLiteralMap(ast, context) {
      const args = ast.values.map((ast2) => ast2.visit(this, context));
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
    }
  };
  var _AstToIrVisitor = class {
    constructor(_localResolver, _implicitReceiver, bindingId, supportsInterpolation, baseSourceSpan, implicitReceiverAccesses) {
      this._localResolver = _localResolver;
      this._implicitReceiver = _implicitReceiver;
      this.bindingId = bindingId;
      this.supportsInterpolation = supportsInterpolation;
      this.baseSourceSpan = baseSourceSpan;
      this.implicitReceiverAccesses = implicitReceiverAccesses;
      this._nodeMap = /* @__PURE__ */ new Map();
      this._resultMap = /* @__PURE__ */ new Map();
      this._currentTemporary = 0;
      this.temporaryCount = 0;
      this.usesImplicitReceiver = false;
    }
    visitUnary(ast, mode) {
      let op;
      switch (ast.operator) {
        case "+":
          op = UnaryOperator.Plus;
          break;
        case "-":
          op = UnaryOperator.Minus;
          break;
        default:
          throw new Error(`Unsupported operator ${ast.operator}`);
      }
      return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), void 0, this.convertSourceSpan(ast.span)));
    }
    visitBinary(ast, mode) {
      let op;
      switch (ast.operation) {
        case "+":
          op = BinaryOperator.Plus;
          break;
        case "-":
          op = BinaryOperator.Minus;
          break;
        case "*":
          op = BinaryOperator.Multiply;
          break;
        case "/":
          op = BinaryOperator.Divide;
          break;
        case "%":
          op = BinaryOperator.Modulo;
          break;
        case "&&":
          op = BinaryOperator.And;
          break;
        case "||":
          op = BinaryOperator.Or;
          break;
        case "==":
          op = BinaryOperator.Equals;
          break;
        case "!=":
          op = BinaryOperator.NotEquals;
          break;
        case "===":
          op = BinaryOperator.Identical;
          break;
        case "!==":
          op = BinaryOperator.NotIdentical;
          break;
        case "<":
          op = BinaryOperator.Lower;
          break;
        case ">":
          op = BinaryOperator.Bigger;
          break;
        case "<=":
          op = BinaryOperator.LowerEquals;
          break;
        case ">=":
          op = BinaryOperator.BiggerEquals;
          break;
        case "??":
          return this.convertNullishCoalesce(ast, mode);
        default:
          throw new Error(`Unsupported operation ${ast.operation}`);
      }
      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), void 0, this.convertSourceSpan(ast.span)));
    }
    visitChain(ast, mode) {
      ensureStatementMode(mode, ast);
      return this.visitAll(ast.expressions, mode);
    }
    visitConditional(ast, mode) {
      const value = this._visit(ast.condition, _Mode.Expression);
      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
    }
    visitPipe(ast, mode) {
      throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
    }
    visitImplicitReceiver(ast, mode) {
      ensureExpressionMode(mode, ast);
      this.usesImplicitReceiver = true;
      return this._implicitReceiver;
    }
    visitThisReceiver(ast, mode) {
      return this.visitImplicitReceiver(ast, mode);
    }
    visitInterpolation(ast, mode) {
      if (!this.supportsInterpolation) {
        throw new Error("Unexpected interpolation");
      }
      ensureExpressionMode(mode, ast);
      let args = [];
      for (let i = 0; i < ast.strings.length - 1; i++) {
        args.push(literal(ast.strings[i]));
        args.push(this._visit(ast.expressions[i], _Mode.Expression));
      }
      args.push(literal(ast.strings[ast.strings.length - 1]));
      const strings = ast.strings;
      if (strings.length === 2 && strings[0] === "" && strings[1] === "") {
        args = [args[1]];
      } else if (ast.expressions.length >= 9) {
        args = [literalArr(args)];
      }
      return new InterpolationExpression(args);
    }
    visitKeyedRead(ast, mode) {
      const leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
      }
    }
    visitKeyedWrite(ast, mode) {
      const obj = this._visit(ast.receiver, _Mode.Expression);
      const key = this._visit(ast.key, _Mode.Expression);
      const value = this._visit(ast.value, _Mode.Expression);
      if (obj === this._implicitReceiver) {
        this._localResolver.maybeRestoreView();
      }
      return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    }
    visitLiteralArray(ast, mode) {
      throw new Error(`Illegal State: literal arrays should have been converted into functions`);
    }
    visitLiteralMap(ast, mode) {
      throw new Error(`Illegal State: literal maps should have been converted into functions`);
    }
    visitLiteralPrimitive(ast, mode) {
      const type = ast.value === null || ast.value === void 0 || ast.value === true || ast.value === true ? INFERRED_TYPE : void 0;
      return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
    }
    _getLocal(name, receiver) {
      if (this._localResolver.globals?.has(name) && receiver instanceof ThisReceiver) {
        return null;
      }
      return this._localResolver.getLocal(name);
    }
    visitPrefixNot(ast, mode) {
      return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
    }
    visitNonNullAssert(ast, mode) {
      return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));
    }
    visitPropertyRead(ast, mode) {
      const leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        let result = null;
        const prevUsesImplicitReceiver = this.usesImplicitReceiver;
        const receiver = this._visit(ast.receiver, _Mode.Expression);
        if (receiver === this._implicitReceiver) {
          result = this._getLocal(ast.name, ast.receiver);
          if (result) {
            this.usesImplicitReceiver = prevUsesImplicitReceiver;
            this.addImplicitReceiverAccess(ast.name);
          }
        }
        if (result == null) {
          result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
        }
        return convertToStatementIfNeeded(mode, result);
      }
    }
    visitPropertyWrite(ast, mode) {
      const receiver = this._visit(ast.receiver, _Mode.Expression);
      const prevUsesImplicitReceiver = this.usesImplicitReceiver;
      let varExpr = null;
      if (receiver === this._implicitReceiver) {
        const localExpr = this._getLocal(ast.name, ast.receiver);
        if (localExpr) {
          if (localExpr instanceof ReadPropExpr) {
            varExpr = localExpr;
            this.usesImplicitReceiver = prevUsesImplicitReceiver;
            this.addImplicitReceiverAccess(ast.name);
          } else {
            const receiver2 = ast.name;
            const value = ast.value instanceof PropertyRead ? ast.value.name : void 0;
            throw new Error(`Cannot assign value "${value}" to template variable "${receiver2}". Template variables are read-only.`);
          }
        }
      }
      if (varExpr === null) {
        varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
      }
      return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
    }
    visitSafePropertyRead(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
    visitSafeKeyedRead(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
    visitAll(asts, mode) {
      return asts.map((ast) => this._visit(ast, mode));
    }
    visitQuote(ast, mode) {
      throw new Error(`Quotes are not supported for evaluation!
        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);
    }
    visitCall(ast, mode) {
      const leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      }
      const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
      if (ast instanceof BuiltinFunctionCall) {
        return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));
      }
      const receiver = ast.receiver;
      if (receiver instanceof PropertyRead && receiver.receiver instanceof ImplicitReceiver && !(receiver.receiver instanceof ThisReceiver) && receiver.name === "$any") {
        if (convertedArgs.length !== 1) {
          throw new Error(`Invalid call to $any, expected 1 argument but received ${convertedArgs.length || "none"}`);
        }
        return convertToStatementIfNeeded(mode, convertedArgs[0]);
      }
      const call = this._visit(receiver, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));
      return convertToStatementIfNeeded(mode, call);
    }
    visitSafeCall(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
    _visit(ast, mode) {
      const result = this._resultMap.get(ast);
      if (result)
        return result;
      return (this._nodeMap.get(ast) || ast).visit(this, mode);
    }
    convertSafeAccess(ast, leftMostSafe, mode) {
      let guardedExpression2 = this._visit(leftMostSafe.receiver, _Mode.Expression);
      let temporary = void 0;
      if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {
        temporary = this.allocateTemporary();
        guardedExpression2 = temporary.set(guardedExpression2);
        this._resultMap.set(leftMostSafe.receiver, temporary);
      }
      const condition = guardedExpression2.isBlank();
      if (leftMostSafe instanceof SafeCall) {
        this._nodeMap.set(leftMostSafe, new Call(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args, leftMostSafe.argumentSpan));
      } else if (leftMostSafe instanceof SafeKeyedRead) {
        this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));
      } else {
        this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
      }
      const access = this._visit(ast, _Mode.Expression);
      this._nodeMap.delete(leftMostSafe);
      if (temporary) {
        this.releaseTemporary(temporary);
      }
      return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));
    }
    convertNullishCoalesce(ast, mode) {
      const left = this._visit(ast.left, _Mode.Expression);
      const right = this._visit(ast.right, _Mode.Expression);
      const temporary = this.allocateTemporary();
      this.releaseTemporary(temporary);
      return convertToStatementIfNeeded(mode, temporary.set(left).notIdentical(NULL_EXPR).and(temporary.notIdentical(literal(void 0))).conditional(temporary, right));
    }
    leftMostSafeNode(ast) {
      const visit = (visitor, ast2) => {
        return (this._nodeMap.get(ast2) || ast2).visit(visitor);
      };
      return ast.visit({
        visitUnary(ast2) {
          return null;
        },
        visitBinary(ast2) {
          return null;
        },
        visitChain(ast2) {
          return null;
        },
        visitConditional(ast2) {
          return null;
        },
        visitCall(ast2) {
          return visit(this, ast2.receiver);
        },
        visitSafeCall(ast2) {
          return visit(this, ast2.receiver) || ast2;
        },
        visitImplicitReceiver(ast2) {
          return null;
        },
        visitThisReceiver(ast2) {
          return null;
        },
        visitInterpolation(ast2) {
          return null;
        },
        visitKeyedRead(ast2) {
          return visit(this, ast2.receiver);
        },
        visitKeyedWrite(ast2) {
          return null;
        },
        visitLiteralArray(ast2) {
          return null;
        },
        visitLiteralMap(ast2) {
          return null;
        },
        visitLiteralPrimitive(ast2) {
          return null;
        },
        visitPipe(ast2) {
          return null;
        },
        visitPrefixNot(ast2) {
          return null;
        },
        visitNonNullAssert(ast2) {
          return null;
        },
        visitPropertyRead(ast2) {
          return visit(this, ast2.receiver);
        },
        visitPropertyWrite(ast2) {
          return null;
        },
        visitQuote(ast2) {
          return null;
        },
        visitSafePropertyRead(ast2) {
          return visit(this, ast2.receiver) || ast2;
        },
        visitSafeKeyedRead(ast2) {
          return visit(this, ast2.receiver) || ast2;
        }
      });
    }
    needsTemporaryInSafeAccess(ast) {
      const visit = (visitor, ast2) => {
        return ast2 && (this._nodeMap.get(ast2) || ast2).visit(visitor);
      };
      const visitSome = (visitor, ast2) => {
        return ast2.some((ast3) => visit(visitor, ast3));
      };
      return ast.visit({
        visitUnary(ast2) {
          return visit(this, ast2.expr);
        },
        visitBinary(ast2) {
          return visit(this, ast2.left) || visit(this, ast2.right);
        },
        visitChain(ast2) {
          return false;
        },
        visitConditional(ast2) {
          return visit(this, ast2.condition) || visit(this, ast2.trueExp) || visit(this, ast2.falseExp);
        },
        visitCall(ast2) {
          return true;
        },
        visitSafeCall(ast2) {
          return true;
        },
        visitImplicitReceiver(ast2) {
          return false;
        },
        visitThisReceiver(ast2) {
          return false;
        },
        visitInterpolation(ast2) {
          return visitSome(this, ast2.expressions);
        },
        visitKeyedRead(ast2) {
          return false;
        },
        visitKeyedWrite(ast2) {
          return false;
        },
        visitLiteralArray(ast2) {
          return true;
        },
        visitLiteralMap(ast2) {
          return true;
        },
        visitLiteralPrimitive(ast2) {
          return false;
        },
        visitPipe(ast2) {
          return true;
        },
        visitPrefixNot(ast2) {
          return visit(this, ast2.expression);
        },
        visitNonNullAssert(ast2) {
          return visit(this, ast2.expression);
        },
        visitPropertyRead(ast2) {
          return false;
        },
        visitPropertyWrite(ast2) {
          return false;
        },
        visitQuote(ast2) {
          return false;
        },
        visitSafePropertyRead(ast2) {
          return false;
        },
        visitSafeKeyedRead(ast2) {
          return false;
        }
      });
    }
    allocateTemporary() {
      const tempNumber = this._currentTemporary++;
      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
      return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
    }
    releaseTemporary(temporary) {
      this._currentTemporary--;
      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
        throw new Error(`Temporary ${temporary.name} released out of order`);
      }
    }
    convertSourceSpan(span) {
      if (this.baseSourceSpan) {
        const start = this.baseSourceSpan.start.moveBy(span.start);
        const end = this.baseSourceSpan.start.moveBy(span.end);
        const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);
        return new ParseSourceSpan(start, end, fullStart);
      } else {
        return null;
      }
    }
    addImplicitReceiverAccess(name) {
      if (this.implicitReceiverAccesses) {
        this.implicitReceiverAccesses.add(name);
      }
    }
  };
  function flattenStatements(arg, output) {
    if (Array.isArray(arg)) {
      arg.forEach((entry) => flattenStatements(entry, output));
    } else {
      output.push(arg);
    }
  }
  function unsupported() {
    throw new Error("Unsupported operation");
  }
  var InterpolationExpression = class extends Expression {
    constructor(args) {
      super(null, null);
      this.args = args;
      this.isConstant = unsupported;
      this.isEquivalent = unsupported;
      this.visitExpression = unsupported;
    }
  };
  var DefaultLocalResolver = class {
    constructor(globals) {
      this.globals = globals;
    }
    notifyImplicitReceiverUse() {
    }
    maybeRestoreView() {
    }
    getLocal(name) {
      if (name === EventHandlerVars.event.name) {
        return EventHandlerVars.event;
      }
      return null;
    }
  };
  var BuiltinFunctionCall = class extends Call {
    constructor(span, sourceSpan, args, converter) {
      super(span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);
      this.converter = converter;
    }
  };
  var ShadowCss = class {
    constructor() {
      this.strictStyling = true;
    }
    shimCssText(cssText, selector, hostSelector = "") {
      const commentsWithHash = extractCommentsWithHash(cssText);
      cssText = stripComments(cssText);
      cssText = this._insertDirectives(cssText);
      const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
      return [scopedCssText, ...commentsWithHash].join("\n");
    }
    _insertDirectives(cssText) {
      cssText = this._insertPolyfillDirectivesInCssText(cssText);
      return this._insertPolyfillRulesInCssText(cssText);
    }
    _insertPolyfillDirectivesInCssText(cssText) {
      return cssText.replace(_cssContentNextSelectorRe, function(...m) {
        return m[2] + "{";
      });
    }
    _insertPolyfillRulesInCssText(cssText) {
      return cssText.replace(_cssContentRuleRe, (...m) => {
        const rule = m[0].replace(m[1], "").replace(m[2], "");
        return m[4] + rule;
      });
    }
    _scopeCssText(cssText, scopeSelector, hostSelector) {
      const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
      cssText = this._insertPolyfillHostInCssText(cssText);
      cssText = this._convertColonHost(cssText);
      cssText = this._convertColonHostContext(cssText);
      cssText = this._convertShadowDOMSelectors(cssText);
      if (scopeSelector) {
        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
      }
      cssText = cssText + "\n" + unscopedRules;
      return cssText.trim();
    }
    _extractUnscopedRulesFromCssText(cssText) {
      let r = "";
      let m;
      _cssContentUnscopedRuleRe.lastIndex = 0;
      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
        const rule = m[0].replace(m[2], "").replace(m[1], m[4]);
        r += rule + "\n\n";
      }
      return r;
    }
    _convertColonHost(cssText) {
      return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {
        if (hostSelectors) {
          const convertedSelectors = [];
          const hostSelectorArray = hostSelectors.split(",").map((p) => p.trim());
          for (const hostSelector of hostSelectorArray) {
            if (!hostSelector)
              break;
            const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, "") + otherSelectors;
            convertedSelectors.push(convertedSelector);
          }
          return convertedSelectors.join(",");
        } else {
          return _polyfillHostNoCombinator + otherSelectors;
        }
      });
    }
    _convertColonHostContext(cssText) {
      return cssText.replace(_cssColonHostContextReGlobal, (selectorText) => {
        const contextSelectorGroups = [[]];
        let match;
        while (match = _cssColonHostContextRe.exec(selectorText)) {
          const newContextSelectors = (match[1] ?? "").trim().split(",").map((m) => m.trim()).filter((m) => m !== "");
          const contextSelectorGroupsLength = contextSelectorGroups.length;
          repeatGroups(contextSelectorGroups, newContextSelectors.length);
          for (let i = 0; i < newContextSelectors.length; i++) {
            for (let j = 0; j < contextSelectorGroupsLength; j++) {
              contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);
            }
          }
          selectorText = match[2];
        }
        return contextSelectorGroups.map((contextSelectors) => combineHostContextSelectors(contextSelectors, selectorText)).join(", ");
      });
    }
    _convertShadowDOMSelectors(cssText) {
      return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, " "), cssText);
    }
    _scopeSelectors(cssText, scopeSelector, hostSelector) {
      return processRules(cssText, (rule) => {
        let selector = rule.selector;
        let content = rule.content;
        if (rule.selector[0] !== "@") {
          selector = this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
        } else if (rule.selector.startsWith("@media") || rule.selector.startsWith("@supports") || rule.selector.startsWith("@document") || rule.selector.startsWith("@layer")) {
          content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
        } else if (rule.selector.startsWith("@font-face") || rule.selector.startsWith("@page")) {
          content = this._stripScopingSelectors(rule.content);
        }
        return new CssRule(selector, content);
      });
    }
    _stripScopingSelectors(cssText) {
      return processRules(cssText, (rule) => {
        const selector = rule.selector.replace(_shadowDeepSelectors, " ").replace(_polyfillHostNoCombinatorRe, " ");
        return new CssRule(selector, rule.content);
      });
    }
    _scopeSelector(selector, scopeSelector, hostSelector, strict) {
      return selector.split(",").map((part) => part.trim().split(_shadowDeepSelectors)).map((deepParts) => {
        const [shallowPart, ...otherParts] = deepParts;
        const applyScope = (shallowPart2) => {
          if (this._selectorNeedsScoping(shallowPart2, scopeSelector)) {
            return strict ? this._applyStrictSelectorScope(shallowPart2, scopeSelector, hostSelector) : this._applySelectorScope(shallowPart2, scopeSelector, hostSelector);
          } else {
            return shallowPart2;
          }
        };
        return [applyScope(shallowPart), ...otherParts].join(" ");
      }).join(", ");
    }
    _selectorNeedsScoping(selector, scopeSelector) {
      const re = this._makeScopeMatcher(scopeSelector);
      return !re.test(selector);
    }
    _makeScopeMatcher(scopeSelector) {
      const lre = /\[/g;
      const rre = /\]/g;
      scopeSelector = scopeSelector.replace(lre, "\\[").replace(rre, "\\]");
      return new RegExp("^(" + scopeSelector + ")" + _selectorReSuffix, "m");
    }
    _applySelectorScope(selector, scopeSelector, hostSelector) {
      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    }
    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
      _polyfillHostRe.lastIndex = 0;
      if (_polyfillHostRe.test(selector)) {
        const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
        return selector.replace(_polyfillHostNoCombinatorRe, (hnc, selector2) => {
          return selector2.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
            return before + replaceBy + colon + after;
          });
        }).replace(_polyfillHostRe, replaceBy + " ");
      }
      return scopeSelector + " " + selector;
    }
    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
      const isRe = /\[is=([^\]]*)\]/g;
      scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
      const attrName = "[" + scopeSelector + "]";
      const _scopeSelectorPart = (p) => {
        let scopedP = p.trim();
        if (!scopedP) {
          return "";
        }
        if (p.indexOf(_polyfillHostNoCombinator) > -1) {
          scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
        } else {
          const t = p.replace(_polyfillHostRe, "");
          if (t.length > 0) {
            const matches = t.match(/([^:]*)(:*)(.*)/);
            if (matches) {
              scopedP = matches[1] + attrName + matches[2] + matches[3];
            }
          }
        }
        return scopedP;
      };
      const safeContent = new SafeSelector(selector);
      selector = safeContent.content();
      let scopedSelector = "";
      let startIndex = 0;
      let res;
      const sep = /( |>|\+|~(?!=))\s*/g;
      const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
      let shouldScope = !hasHost;
      while ((res = sep.exec(selector)) !== null) {
        const separator = res[1];
        const part2 = selector.slice(startIndex, res.index).trim();
        shouldScope = shouldScope || part2.indexOf(_polyfillHostNoCombinator) > -1;
        const scopedPart = shouldScope ? _scopeSelectorPart(part2) : part2;
        scopedSelector += `${scopedPart} ${separator} `;
        startIndex = sep.lastIndex;
      }
      const part = selector.substring(startIndex);
      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
      scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
      return safeContent.restore(scopedSelector);
    }
    _insertPolyfillHostInCssText(selector) {
      return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);
    }
  };
  var SafeSelector = class {
    constructor(selector) {
      this.placeholders = [];
      this.index = 0;
      selector = this._escapeRegexMatches(selector, /(\[[^\]]*\])/g);
      selector = this._escapeRegexMatches(selector, /(\\.)/g);
      this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
        const replaceBy = `__ph-${this.index}__`;
        this.placeholders.push(exp);
        this.index++;
        return pseudo + replaceBy;
      });
    }
    restore(content) {
      return content.replace(/__ph-(\d+)__/g, (_ph, index) => this.placeholders[+index]);
    }
    content() {
      return this._content;
    }
    _escapeRegexMatches(content, pattern) {
      return content.replace(pattern, (_, keep) => {
        const replaceBy = `__ph-${this.index}__`;
        this.placeholders.push(keep);
        this.index++;
        return replaceBy;
      });
    }
  };
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _polyfillHost = "-shadowcsshost";
  var _polyfillHostContext = "-shadowcsscontext";
  var _parenSuffix = "(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))?([^,{]*)";
  var _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, "gim");
  var _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, "gim");
  var _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, "im");
  var _polyfillHostNoCombinator = _polyfillHost + "-no-combinator";
  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
  var _shadowDOMSelectorsRe = [
    /::shadow/g,
    /::content/g,
    /\/shadow-deep\//g,
    /\/shadow\//g
  ];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
  var _selectorReSuffix = "([>\\s~+[.,{:][\\s\\S]*)?$";
  var _polyfillHostRe = /-shadowcsshost/gim;
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*[\s\S]*?\*\//g;
  function stripComments(input) {
    return input.replace(_commentRe, "");
  }
  var _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
  function extractCommentsWithHash(input) {
    return input.match(_commentWithHashRe) || [];
  }
  var BLOCK_PLACEHOLDER = "%BLOCK%";
  var QUOTE_PLACEHOLDER = "%QUOTED%";
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _quotedRe = /%QUOTED%/g;
  var CONTENT_PAIRS = /* @__PURE__ */ new Map([["{", "}"]]);
  var QUOTE_PAIRS = /* @__PURE__ */ new Map([[`"`, `"`], [`'`, `'`]]);
  var CssRule = class {
    constructor(selector, content) {
      this.selector = selector;
      this.content = content;
    }
  };
  function processRules(input, ruleCallback) {
    const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);
    const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);
    let nextBlockIndex = 0;
    let nextQuoteIndex = 0;
    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
      const selector = m[2];
      let content = "";
      let suffix = m[4];
      let contentPrefix = "";
      if (suffix && suffix.startsWith("{" + BLOCK_PLACEHOLDER)) {
        content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
        suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
        contentPrefix = "{";
      }
      const rule = ruleCallback(new CssRule(selector, content));
      return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
    }).replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);
  }
  var StringWithEscapedBlocks = class {
    constructor(escapedString, blocks) {
      this.escapedString = escapedString;
      this.blocks = blocks;
    }
  };
  function escapeBlocks(input, charPairs, placeholder) {
    const resultParts = [];
    const escapedBlocks = [];
    let openCharCount = 0;
    let nonBlockStartIndex = 0;
    let blockStartIndex = -1;
    let openChar;
    let closeChar;
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if (char === "\\") {
        i++;
      } else if (char === closeChar) {
        openCharCount--;
        if (openCharCount === 0) {
          escapedBlocks.push(input.substring(blockStartIndex, i));
          resultParts.push(placeholder);
          nonBlockStartIndex = i;
          blockStartIndex = -1;
          openChar = closeChar = void 0;
        }
      } else if (char === openChar) {
        openCharCount++;
      } else if (openCharCount === 0 && charPairs.has(char)) {
        openChar = char;
        closeChar = charPairs.get(char);
        openCharCount = 1;
        blockStartIndex = i + 1;
        resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));
      }
    }
    if (blockStartIndex !== -1) {
      escapedBlocks.push(input.substring(blockStartIndex));
      resultParts.push(placeholder);
    } else {
      resultParts.push(input.substring(nonBlockStartIndex));
    }
    return new StringWithEscapedBlocks(resultParts.join(""), escapedBlocks);
  }
  function combineHostContextSelectors(contextSelectors, otherSelectors) {
    const hostMarker = _polyfillHostNoCombinator;
    _polyfillHostRe.lastIndex = 0;
    const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);
    if (contextSelectors.length === 0) {
      return hostMarker + otherSelectors;
    }
    const combined = [contextSelectors.pop() || ""];
    while (contextSelectors.length > 0) {
      const length = combined.length;
      const contextSelector = contextSelectors.pop();
      for (let i = 0; i < length; i++) {
        const previousSelectors = combined[i];
        combined[length * 2 + i] = previousSelectors + " " + contextSelector;
        combined[length + i] = contextSelector + " " + previousSelectors;
        combined[i] = contextSelector + previousSelectors;
      }
    }
    return combined.map((s) => otherSelectorsHasHost ? `${s}${otherSelectors}` : `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`).join(",");
  }
  function repeatGroups(groups, multiples) {
    const length = groups.length;
    for (let i = 1; i < multiples; i++) {
      for (let j = 0; j < length; j++) {
        groups[j + i * length] = groups[j].slice(0);
      }
    }
  }
  function parse(value) {
    const styles = [];
    let i = 0;
    let parenDepth = 0;
    let quote = 0;
    let valueStart = 0;
    let propStart = 0;
    let currentProp = null;
    let valueHasQuotes = false;
    while (i < value.length) {
      const token = value.charCodeAt(i++);
      switch (token) {
        case 40:
          parenDepth++;
          break;
        case 41:
          parenDepth--;
          break;
        case 39:
          valueHasQuotes = valueHasQuotes || valueStart > 0;
          if (quote === 0) {
            quote = 39;
          } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {
            quote = 0;
          }
          break;
        case 34:
          valueHasQuotes = valueHasQuotes || valueStart > 0;
          if (quote === 0) {
            quote = 34;
          } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {
            quote = 0;
          }
          break;
        case 58:
          if (!currentProp && parenDepth === 0 && quote === 0) {
            currentProp = hyphenate(value.substring(propStart, i - 1).trim());
            valueStart = i;
          }
          break;
        case 59:
          if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {
            const styleVal = value.substring(valueStart, i - 1).trim();
            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
            propStart = i;
            valueStart = 0;
            currentProp = null;
            valueHasQuotes = false;
          }
          break;
      }
    }
    if (currentProp && valueStart) {
      const styleVal = value.substr(valueStart).trim();
      styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
    }
    return styles;
  }
  function stripUnnecessaryQuotes(value) {
    const qS = value.charCodeAt(0);
    const qE = value.charCodeAt(value.length - 1);
    if (qS == qE && (qS == 39 || qS == 34)) {
      const tempValue = value.substring(1, value.length - 1);
      if (tempValue.indexOf("'") == -1 && tempValue.indexOf('"') == -1) {
        value = tempValue;
      }
    }
    return value;
  }
  function hyphenate(value) {
    return value.replace(/[a-z][A-Z]/g, (v) => {
      return v.charAt(0) + "-" + v.charAt(1);
    }).toLowerCase();
  }
  var IMPORTANT_FLAG = "!important";
  var MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
  var StylingBuilder = class {
    constructor(_directiveExpr) {
      this._directiveExpr = _directiveExpr;
      this._hasInitialValues = false;
      this.hasBindings = false;
      this.hasBindingsWithPipes = false;
      this._classMapInput = null;
      this._styleMapInput = null;
      this._singleStyleInputs = null;
      this._singleClassInputs = null;
      this._lastStylingInput = null;
      this._firstStylingInput = null;
      this._stylesIndex = /* @__PURE__ */ new Map();
      this._classesIndex = /* @__PURE__ */ new Map();
      this._initialStyleValues = [];
      this._initialClassValues = [];
    }
    registerBoundInput(input) {
      let binding = null;
      let name = input.name;
      switch (input.type) {
        case 0:
          binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
          break;
        case 3:
          binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
          break;
        case 2:
          binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
          break;
      }
      return binding ? true : false;
    }
    registerInputBasedOnName(name, expression, sourceSpan) {
      let binding = null;
      const prefix = name.substring(0, 6);
      const isStyle = name === "style" || prefix === "style." || prefix === "style!";
      const isClass = !isStyle && (name === "class" || prefix === "class." || prefix === "class!");
      if (isStyle || isClass) {
        const isMapBased = name.charAt(5) !== ".";
        const property = name.substr(isMapBased ? 5 : 6);
        if (isStyle) {
          binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
        } else {
          binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
        }
      }
      return binding;
    }
    registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
      if (isEmptyExpression(value)) {
        return null;
      }
      if (!isCssCustomProperty(name)) {
        name = hyphenate(name);
      }
      const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);
      suffix = typeof suffix === "string" && suffix.length !== 0 ? suffix : bindingSuffix;
      const entry = { name: property, suffix, value, sourceSpan, hasOverrideFlag };
      if (isMapBased) {
        this._styleMapInput = entry;
      } else {
        (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
        registerIntoMap(this._stylesIndex, property);
      }
      this._lastStylingInput = entry;
      this._firstStylingInput = this._firstStylingInput || entry;
      this._checkForPipes(value);
      this.hasBindings = true;
      return entry;
    }
    registerClassInput(name, isMapBased, value, sourceSpan) {
      if (isEmptyExpression(value)) {
        return null;
      }
      const { property, hasOverrideFlag } = parseProperty(name);
      const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };
      if (isMapBased) {
        this._classMapInput = entry;
      } else {
        (this._singleClassInputs = this._singleClassInputs || []).push(entry);
        registerIntoMap(this._classesIndex, property);
      }
      this._lastStylingInput = entry;
      this._firstStylingInput = this._firstStylingInput || entry;
      this._checkForPipes(value);
      this.hasBindings = true;
      return entry;
    }
    _checkForPipes(value) {
      if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {
        this.hasBindingsWithPipes = true;
      }
    }
    registerStyleAttr(value) {
      this._initialStyleValues = parse(value);
      this._hasInitialValues = true;
    }
    registerClassAttr(value) {
      this._initialClassValues = value.trim().split(/\s+/g);
      this._hasInitialValues = true;
    }
    populateInitialStylingAttrs(attrs) {
      if (this._initialClassValues.length) {
        attrs.push(literal(1));
        for (let i = 0; i < this._initialClassValues.length; i++) {
          attrs.push(literal(this._initialClassValues[i]));
        }
      }
      if (this._initialStyleValues.length) {
        attrs.push(literal(2));
        for (let i = 0; i < this._initialStyleValues.length; i += 2) {
          attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
        }
      }
    }
    assignHostAttrs(attrs, definitionMap) {
      if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
        this.populateInitialStylingAttrs(attrs);
        definitionMap.set("hostAttrs", literalArr(attrs));
      }
    }
    buildClassMapInstruction(valueConverter) {
      if (this._classMapInput) {
        return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
      }
      return null;
    }
    buildStyleMapInstruction(valueConverter) {
      if (this._styleMapInput) {
        return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
      }
      return null;
    }
    _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
      let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
      const mapValue = stylingInput.value.visit(valueConverter);
      let reference;
      if (mapValue instanceof Interpolation) {
        totalBindingSlotsRequired += mapValue.expressions.length;
        reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);
      } else {
        reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;
      }
      return {
        reference,
        calls: [{
          supportsInterpolation: true,
          sourceSpan: stylingInput.sourceSpan,
          allocateBindingSlots: totalBindingSlotsRequired,
          params: (convertFn) => {
            const convertResult = convertFn(mapValue);
            const params = Array.isArray(convertResult) ? convertResult : [convertResult];
            return params;
          }
        }]
      };
    }
    _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
      const instructions = [];
      inputs.forEach((input) => {
        const previousInstruction = instructions[instructions.length - 1];
        const value = input.value.visit(valueConverter);
        let referenceForCall = reference;
        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
        if (value instanceof Interpolation) {
          totalBindingSlotsRequired += value.expressions.length;
          if (getInterpolationExpressionFn) {
            referenceForCall = getInterpolationExpressionFn(value);
          }
        }
        const call = {
          sourceSpan: input.sourceSpan,
          allocateBindingSlots: totalBindingSlotsRequired,
          supportsInterpolation: !!getInterpolationExpressionFn,
          params: (convertFn) => {
            const params = [];
            params.push(literal(input.name));
            const convertResult = convertFn(value);
            if (Array.isArray(convertResult)) {
              params.push(...convertResult);
            } else {
              params.push(convertResult);
            }
            if (!isClassBased && input.suffix !== null) {
              params.push(literal(input.suffix));
            }
            return params;
          }
        };
        if (previousInstruction && previousInstruction.reference === referenceForCall) {
          previousInstruction.calls.push(call);
        } else {
          instructions.push({ reference: referenceForCall, calls: [call] });
        }
      });
      return instructions;
    }
    _buildClassInputs(valueConverter) {
      if (this._singleClassInputs) {
        return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);
      }
      return [];
    }
    _buildStyleInputs(valueConverter) {
      if (this._singleStyleInputs) {
        return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
      }
      return [];
    }
    buildUpdateLevelInstructions(valueConverter) {
      const instructions = [];
      if (this.hasBindings) {
        const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);
        if (styleMapInstruction) {
          instructions.push(styleMapInstruction);
        }
        const classMapInstruction = this.buildClassMapInstruction(valueConverter);
        if (classMapInstruction) {
          instructions.push(classMapInstruction);
        }
        instructions.push(...this._buildStyleInputs(valueConverter));
        instructions.push(...this._buildClassInputs(valueConverter));
      }
      return instructions;
    }
  };
  function registerIntoMap(map2, key) {
    if (!map2.has(key)) {
      map2.set(key, map2.size);
    }
  }
  function parseProperty(name) {
    let hasOverrideFlag = false;
    const overrideIndex = name.indexOf(IMPORTANT_FLAG);
    if (overrideIndex !== -1) {
      name = overrideIndex > 0 ? name.substring(0, overrideIndex) : "";
      hasOverrideFlag = true;
    }
    let suffix = null;
    let property = name;
    const unitIndex = name.lastIndexOf(".");
    if (unitIndex > 0) {
      suffix = name.substr(unitIndex + 1);
      property = name.substring(0, unitIndex);
    }
    return { property, suffix, hasOverrideFlag };
  }
  function getClassMapInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers.classMap;
      case 3:
        return Identifiers.classMapInterpolate1;
      case 5:
        return Identifiers.classMapInterpolate2;
      case 7:
        return Identifiers.classMapInterpolate3;
      case 9:
        return Identifiers.classMapInterpolate4;
      case 11:
        return Identifiers.classMapInterpolate5;
      case 13:
        return Identifiers.classMapInterpolate6;
      case 15:
        return Identifiers.classMapInterpolate7;
      case 17:
        return Identifiers.classMapInterpolate8;
      default:
        return Identifiers.classMapInterpolateV;
    }
  }
  function getStyleMapInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers.styleMap;
      case 3:
        return Identifiers.styleMapInterpolate1;
      case 5:
        return Identifiers.styleMapInterpolate2;
      case 7:
        return Identifiers.styleMapInterpolate3;
      case 9:
        return Identifiers.styleMapInterpolate4;
      case 11:
        return Identifiers.styleMapInterpolate5;
      case 13:
        return Identifiers.styleMapInterpolate6;
      case 15:
        return Identifiers.styleMapInterpolate7;
      case 17:
        return Identifiers.styleMapInterpolate8;
      default:
        return Identifiers.styleMapInterpolateV;
    }
  }
  function getStylePropInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers.styleProp;
      case 3:
        return Identifiers.stylePropInterpolate1;
      case 5:
        return Identifiers.stylePropInterpolate2;
      case 7:
        return Identifiers.stylePropInterpolate3;
      case 9:
        return Identifiers.stylePropInterpolate4;
      case 11:
        return Identifiers.stylePropInterpolate5;
      case 13:
        return Identifiers.stylePropInterpolate6;
      case 15:
        return Identifiers.stylePropInterpolate7;
      case 17:
        return Identifiers.stylePropInterpolate8;
      default:
        return Identifiers.stylePropInterpolateV;
    }
  }
  function isCssCustomProperty(name) {
    return name.startsWith("--");
  }
  function isEmptyExpression(ast) {
    if (ast instanceof ASTWithSource) {
      ast = ast.ast;
    }
    return ast instanceof EmptyExpr;
  }
  var TokenType;
  (function(TokenType2) {
    TokenType2[TokenType2["Character"] = 0] = "Character";
    TokenType2[TokenType2["Identifier"] = 1] = "Identifier";
    TokenType2[TokenType2["PrivateIdentifier"] = 2] = "PrivateIdentifier";
    TokenType2[TokenType2["Keyword"] = 3] = "Keyword";
    TokenType2[TokenType2["String"] = 4] = "String";
    TokenType2[TokenType2["Operator"] = 5] = "Operator";
    TokenType2[TokenType2["Number"] = 6] = "Number";
    TokenType2[TokenType2["Error"] = 7] = "Error";
  })(TokenType || (TokenType = {}));
  var KEYWORDS = ["var", "let", "as", "null", "undefined", "true", "false", "if", "else", "this"];
  var Lexer = class {
    tokenize(text) {
      const scanner = new _Scanner(text);
      const tokens = [];
      let token = scanner.scanToken();
      while (token != null) {
        tokens.push(token);
        token = scanner.scanToken();
      }
      return tokens;
    }
  };
  var Token = class {
    constructor(index, end, type, numValue, strValue) {
      this.index = index;
      this.end = end;
      this.type = type;
      this.numValue = numValue;
      this.strValue = strValue;
    }
    isCharacter(code) {
      return this.type == TokenType.Character && this.numValue == code;
    }
    isNumber() {
      return this.type == TokenType.Number;
    }
    isString() {
      return this.type == TokenType.String;
    }
    isOperator(operator) {
      return this.type == TokenType.Operator && this.strValue == operator;
    }
    isIdentifier() {
      return this.type == TokenType.Identifier;
    }
    isPrivateIdentifier() {
      return this.type == TokenType.PrivateIdentifier;
    }
    isKeyword() {
      return this.type == TokenType.Keyword;
    }
    isKeywordLet() {
      return this.type == TokenType.Keyword && this.strValue == "let";
    }
    isKeywordAs() {
      return this.type == TokenType.Keyword && this.strValue == "as";
    }
    isKeywordNull() {
      return this.type == TokenType.Keyword && this.strValue == "null";
    }
    isKeywordUndefined() {
      return this.type == TokenType.Keyword && this.strValue == "undefined";
    }
    isKeywordTrue() {
      return this.type == TokenType.Keyword && this.strValue == "true";
    }
    isKeywordFalse() {
      return this.type == TokenType.Keyword && this.strValue == "false";
    }
    isKeywordThis() {
      return this.type == TokenType.Keyword && this.strValue == "this";
    }
    isError() {
      return this.type == TokenType.Error;
    }
    toNumber() {
      return this.type == TokenType.Number ? this.numValue : -1;
    }
    toString() {
      switch (this.type) {
        case TokenType.Character:
        case TokenType.Identifier:
        case TokenType.Keyword:
        case TokenType.Operator:
        case TokenType.PrivateIdentifier:
        case TokenType.String:
        case TokenType.Error:
          return this.strValue;
        case TokenType.Number:
          return this.numValue.toString();
        default:
          return null;
      }
    }
  };
  function newCharacterToken(index, end, code) {
    return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));
  }
  function newIdentifierToken(index, end, text) {
    return new Token(index, end, TokenType.Identifier, 0, text);
  }
  function newPrivateIdentifierToken(index, end, text) {
    return new Token(index, end, TokenType.PrivateIdentifier, 0, text);
  }
  function newKeywordToken(index, end, text) {
    return new Token(index, end, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, end, text) {
    return new Token(index, end, TokenType.Operator, 0, text);
  }
  function newStringToken(index, end, text) {
    return new Token(index, end, TokenType.String, 0, text);
  }
  function newNumberToken(index, end, n) {
    return new Token(index, end, TokenType.Number, n, "");
  }
  function newErrorToken(index, end, message) {
    return new Token(index, end, TokenType.Error, 0, message);
  }
  var EOF = new Token(-1, -1, TokenType.Character, 0, "");
  var _Scanner = class {
    constructor(input) {
      this.input = input;
      this.peek = 0;
      this.index = -1;
      this.length = input.length;
      this.advance();
    }
    advance() {
      this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
    }
    scanToken() {
      const input = this.input, length = this.length;
      let peek = this.peek, index = this.index;
      while (peek <= $SPACE) {
        if (++index >= length) {
          peek = $EOF;
          break;
        } else {
          peek = input.charCodeAt(index);
        }
      }
      this.peek = peek;
      this.index = index;
      if (index >= length) {
        return null;
      }
      if (isIdentifierStart(peek))
        return this.scanIdentifier();
      if (isDigit(peek))
        return this.scanNumber(index);
      const start = index;
      switch (peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);
        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, peek);
        case $SQ:
        case $DQ:
          return this.scanString();
        case $HASH:
          return this.scanPrivateIdentifier();
        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
          return this.scanOperator(start, String.fromCharCode(peek));
        case $QUESTION:
          return this.scanQuestion(start);
        case $LT:
        case $GT:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, "=");
        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, "=", $EQ, "=");
        case $AMPERSAND:
          return this.scanComplexOperator(start, "&", $AMPERSAND, "&");
        case $BAR:
          return this.scanComplexOperator(start, "|", $BAR, "|");
        case $NBSP:
          while (isWhitespace(this.peek))
            this.advance();
          return this.scanToken();
      }
      this.advance();
      return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
    }
    scanCharacter(start, code) {
      this.advance();
      return newCharacterToken(start, this.index, code);
    }
    scanOperator(start, str) {
      this.advance();
      return newOperatorToken(start, this.index, str);
    }
    scanComplexOperator(start, one, twoCode, two, threeCode, three) {
      this.advance();
      let str = one;
      if (this.peek == twoCode) {
        this.advance();
        str += two;
      }
      if (threeCode != null && this.peek == threeCode) {
        this.advance();
        str += three;
      }
      return newOperatorToken(start, this.index, str);
    }
    scanIdentifier() {
      const start = this.index;
      this.advance();
      while (isIdentifierPart(this.peek))
        this.advance();
      const str = this.input.substring(start, this.index);
      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);
    }
    scanPrivateIdentifier() {
      const start = this.index;
      this.advance();
      if (!isIdentifierStart(this.peek)) {
        return this.error("Invalid character [#]", -1);
      }
      while (isIdentifierPart(this.peek))
        this.advance();
      const identifierName2 = this.input.substring(start, this.index);
      return newPrivateIdentifierToken(start, this.index, identifierName2);
    }
    scanNumber(start) {
      let simple = this.index === start;
      let hasSeparators = false;
      this.advance();
      while (true) {
        if (isDigit(this.peek)) {
        } else if (this.peek === $_) {
          if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {
            return this.error("Invalid numeric separator", 0);
          }
          hasSeparators = true;
        } else if (this.peek === $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek))
            this.advance();
          if (!isDigit(this.peek))
            return this.error("Invalid exponent", -1);
          simple = false;
        } else {
          break;
        }
        this.advance();
      }
      let str = this.input.substring(start, this.index);
      if (hasSeparators) {
        str = str.replace(/_/g, "");
      }
      const value = simple ? parseIntAutoRadix(str) : parseFloat(str);
      return newNumberToken(start, this.index, value);
    }
    scanString() {
      const start = this.index;
      const quote = this.peek;
      this.advance();
      let buffer = "";
      let marker = this.index;
      const input = this.input;
      while (this.peek != quote) {
        if (this.peek == $BACKSLASH) {
          buffer += input.substring(marker, this.index);
          this.advance();
          let unescapedCode;
          this.peek = this.peek;
          if (this.peek == $u) {
            const hex = input.substring(this.index + 1, this.index + 5);
            if (/^[0-9a-f]+$/i.test(hex)) {
              unescapedCode = parseInt(hex, 16);
            } else {
              return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
            }
            for (let i = 0; i < 5; i++) {
              this.advance();
            }
          } else {
            unescapedCode = unescape(this.peek);
            this.advance();
          }
          buffer += String.fromCharCode(unescapedCode);
          marker = this.index;
        } else if (this.peek == $EOF) {
          return this.error("Unterminated quote", 0);
        } else {
          this.advance();
        }
      }
      const last = input.substring(marker, this.index);
      this.advance();
      return newStringToken(start, this.index, buffer + last);
    }
    scanQuestion(start) {
      this.advance();
      let str = "?";
      if (this.peek === $QUESTION || this.peek === $PERIOD) {
        str += this.peek === $PERIOD ? "." : "?";
        this.advance();
      }
      return newOperatorToken(start, this.index, str);
    }
    error(message, offset) {
      const position = this.index + offset;
      return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
    }
  };
  function isIdentifierStart(code) {
    return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
  }
  function isIdentifier(input) {
    if (input.length == 0)
      return false;
    const scanner = new _Scanner(input);
    if (!isIdentifierStart(scanner.peek))
      return false;
    scanner.advance();
    while (scanner.peek !== $EOF) {
      if (!isIdentifierPart(scanner.peek))
        return false;
      scanner.advance();
    }
    return true;
  }
  function isIdentifierPart(code) {
    return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  function parseIntAutoRadix(text) {
    const result = parseInt(text);
    if (isNaN(result)) {
      throw new Error("Invalid integer literal when parsing " + text);
    }
    return result;
  }
  var SplitInterpolation = class {
    constructor(strings, expressions, offsets) {
      this.strings = strings;
      this.expressions = expressions;
      this.offsets = offsets;
    }
  };
  var TemplateBindingParseResult = class {
    constructor(templateBindings, warnings, errors) {
      this.templateBindings = templateBindings;
      this.warnings = warnings;
      this.errors = errors;
    }
  };
  var Parser$1 = class {
    constructor(_lexer) {
      this._lexer = _lexer;
      this.errors = [];
    }
    parseAction(input, isAssignmentEvent, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      this._checkNoInterpolation(input, location2, interpolationConfig);
      const sourceToLex = this._stripComments(input);
      const tokens = this._lexer.tokenize(sourceToLex);
      let flags = 1;
      if (isAssignmentEvent) {
        flags |= 2;
      }
      const ast = new _ParseAST(input, location2, absoluteOffset, tokens, flags, this.errors, 0).parseChain();
      return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
    }
    parseBinding(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const ast = this._parseBindingAst(input, location2, absoluteOffset, interpolationConfig);
      return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
    }
    checkSimpleExpression(ast) {
      const checker = new SimpleExpressionChecker();
      ast.visit(checker);
      return checker.errors;
    }
    parseSimpleBinding(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const ast = this._parseBindingAst(input, location2, absoluteOffset, interpolationConfig);
      const errors = this.checkSimpleExpression(ast);
      if (errors.length > 0) {
        this._reportError(`Host binding expression cannot contain ${errors.join(" ")}`, input, location2);
      }
      return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
    }
    _reportError(message, input, errLocation, ctxLocation) {
      this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
    }
    _parseBindingAst(input, location2, absoluteOffset, interpolationConfig) {
      const quote = this._parseQuote(input, location2, absoluteOffset);
      if (quote != null) {
        return quote;
      }
      this._checkNoInterpolation(input, location2, interpolationConfig);
      const sourceToLex = this._stripComments(input);
      const tokens = this._lexer.tokenize(sourceToLex);
      return new _ParseAST(input, location2, absoluteOffset, tokens, 0, this.errors, 0).parseChain();
    }
    _parseQuote(input, location2, absoluteOffset) {
      if (input == null)
        return null;
      const prefixSeparatorIndex = input.indexOf(":");
      if (prefixSeparatorIndex == -1)
        return null;
      const prefix = input.substring(0, prefixSeparatorIndex).trim();
      if (!isIdentifier(prefix))
        return null;
      const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
      const span = new ParseSpan(0, input.length);
      return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location2);
    }
    parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
      const tokens = this._lexer.tokenize(templateValue);
      const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, 0, this.errors, 0);
      return parser.parseTemplateBindings({
        source: templateKey,
        span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)
      });
    }
    parseInterpolation(input, location2, absoluteOffset, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const { strings, expressions, offsets } = this.splitInterpolation(input, location2, interpolatedTokens, interpolationConfig);
      if (expressions.length === 0)
        return null;
      const expressionNodes = [];
      for (let i = 0; i < expressions.length; ++i) {
        const expressionText = expressions[i].text;
        const sourceToLex = this._stripComments(expressionText);
        const tokens = this._lexer.tokenize(sourceToLex);
        const ast = new _ParseAST(input, location2, absoluteOffset, tokens, 0, this.errors, offsets[i]).parseChain();
        expressionNodes.push(ast);
      }
      return this.createInterpolationAst(strings.map((s) => s.text), expressionNodes, input, location2, absoluteOffset);
    }
    parseInterpolationExpression(expression, location2, absoluteOffset) {
      const sourceToLex = this._stripComments(expression);
      const tokens = this._lexer.tokenize(sourceToLex);
      const ast = new _ParseAST(expression, location2, absoluteOffset, tokens, 0, this.errors, 0).parseChain();
      const strings = ["", ""];
      return this.createInterpolationAst(strings, [ast], expression, location2, absoluteOffset);
    }
    createInterpolationAst(strings, expressions, input, location2, absoluteOffset) {
      const span = new ParseSpan(0, input.length);
      const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
      return new ASTWithSource(interpolation, input, location2, absoluteOffset, this.errors);
    }
    splitInterpolation(input, location2, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const strings = [];
      const expressions = [];
      const offsets = [];
      const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;
      let i = 0;
      let atInterpolation = false;
      let extendLastString = false;
      let { start: interpStart, end: interpEnd } = interpolationConfig;
      while (i < input.length) {
        if (!atInterpolation) {
          const start = i;
          i = input.indexOf(interpStart, i);
          if (i === -1) {
            i = input.length;
          }
          const text = input.substring(start, i);
          strings.push({ text, start, end: i });
          atInterpolation = true;
        } else {
          const fullStart = i;
          const exprStart = fullStart + interpStart.length;
          const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);
          if (exprEnd === -1) {
            atInterpolation = false;
            extendLastString = true;
            break;
          }
          const fullEnd = exprEnd + interpEnd.length;
          const text = input.substring(exprStart, exprEnd);
          if (text.trim().length === 0) {
            this._reportError("Blank expressions are not allowed in interpolated strings", input, `at column ${i} in`, location2);
          }
          expressions.push({ text, start: fullStart, end: fullEnd });
          const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;
          const offset = startInOriginalTemplate + interpStart.length;
          offsets.push(offset);
          i = fullEnd;
          atInterpolation = false;
        }
      }
      if (!atInterpolation) {
        if (extendLastString) {
          const piece = strings[strings.length - 1];
          piece.text += input.substring(i);
          piece.end = input.length;
        } else {
          strings.push({ text: input.substring(i), start: i, end: input.length });
        }
      }
      return new SplitInterpolation(strings, expressions, offsets);
    }
    wrapLiteralPrimitive(input, location2, absoluteOffset) {
      const span = new ParseSpan(0, input == null ? 0 : input.length);
      return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location2, absoluteOffset, this.errors);
    }
    _stripComments(input) {
      const i = this._commentStart(input);
      return i != null ? input.substring(0, i) : input;
    }
    _commentStart(input) {
      let outerQuote = null;
      for (let i = 0; i < input.length - 1; i++) {
        const char = input.charCodeAt(i);
        const nextChar = input.charCodeAt(i + 1);
        if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
          return i;
        if (outerQuote === char) {
          outerQuote = null;
        } else if (outerQuote == null && isQuote(char)) {
          outerQuote = char;
        }
      }
      return null;
    }
    _checkNoInterpolation(input, location2, { start, end }) {
      let startIndex = -1;
      let endIndex = -1;
      for (const charIndex of this._forEachUnquotedChar(input, 0)) {
        if (startIndex === -1) {
          if (input.startsWith(start)) {
            startIndex = charIndex;
          }
        } else {
          endIndex = this._getInterpolationEndIndex(input, end, charIndex);
          if (endIndex > -1) {
            break;
          }
        }
      }
      if (startIndex > -1 && endIndex > -1) {
        this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location2);
      }
    }
    _getInterpolationEndIndex(input, expressionEnd, start) {
      for (const charIndex of this._forEachUnquotedChar(input, start)) {
        if (input.startsWith(expressionEnd, charIndex)) {
          return charIndex;
        }
        if (input.startsWith("//", charIndex)) {
          return input.indexOf(expressionEnd, charIndex);
        }
      }
      return -1;
    }
    *_forEachUnquotedChar(input, start) {
      let currentQuote = null;
      let escapeCount = 0;
      for (let i = start; i < input.length; i++) {
        const char = input[i];
        if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0) {
          currentQuote = currentQuote === null ? char : null;
        } else if (currentQuote === null) {
          yield i;
        }
        escapeCount = char === "\\" ? escapeCount + 1 : 0;
      }
    }
  };
  var ParseContextFlags;
  (function(ParseContextFlags2) {
    ParseContextFlags2[ParseContextFlags2["None"] = 0] = "None";
    ParseContextFlags2[ParseContextFlags2["Writable"] = 1] = "Writable";
  })(ParseContextFlags || (ParseContextFlags = {}));
  var _ParseAST = class {
    constructor(input, location2, absoluteOffset, tokens, parseFlags, errors, offset) {
      this.input = input;
      this.location = location2;
      this.absoluteOffset = absoluteOffset;
      this.tokens = tokens;
      this.parseFlags = parseFlags;
      this.errors = errors;
      this.offset = offset;
      this.rparensExpected = 0;
      this.rbracketsExpected = 0;
      this.rbracesExpected = 0;
      this.context = ParseContextFlags.None;
      this.sourceSpanCache = /* @__PURE__ */ new Map();
      this.index = 0;
    }
    peek(offset) {
      const i = this.index + offset;
      return i < this.tokens.length ? this.tokens[i] : EOF;
    }
    get next() {
      return this.peek(0);
    }
    get atEOF() {
      return this.index >= this.tokens.length;
    }
    get inputIndex() {
      return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
    }
    get currentEndIndex() {
      if (this.index > 0) {
        const curToken = this.peek(-1);
        return curToken.end + this.offset;
      }
      if (this.tokens.length === 0) {
        return this.input.length + this.offset;
      }
      return this.next.index + this.offset;
    }
    get currentAbsoluteOffset() {
      return this.absoluteOffset + this.inputIndex;
    }
    span(start, artificialEndIndex) {
      let endIndex = this.currentEndIndex;
      if (artificialEndIndex !== void 0 && artificialEndIndex > this.currentEndIndex) {
        endIndex = artificialEndIndex;
      }
      if (start > endIndex) {
        const tmp = endIndex;
        endIndex = start;
        start = tmp;
      }
      return new ParseSpan(start, endIndex);
    }
    sourceSpan(start, artificialEndIndex) {
      const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;
      if (!this.sourceSpanCache.has(serial)) {
        this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
      }
      return this.sourceSpanCache.get(serial);
    }
    advance() {
      this.index++;
    }
    withContext(context, cb) {
      this.context |= context;
      const ret = cb();
      this.context ^= context;
      return ret;
    }
    consumeOptionalCharacter(code) {
      if (this.next.isCharacter(code)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    }
    peekKeywordLet() {
      return this.next.isKeywordLet();
    }
    peekKeywordAs() {
      return this.next.isKeywordAs();
    }
    expectCharacter(code) {
      if (this.consumeOptionalCharacter(code))
        return;
      this.error(`Missing expected ${String.fromCharCode(code)}`);
    }
    consumeOptionalOperator(op) {
      if (this.next.isOperator(op)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    }
    expectOperator(operator) {
      if (this.consumeOptionalOperator(operator))
        return;
      this.error(`Missing expected operator ${operator}`);
    }
    prettyPrintToken(tok) {
      return tok === EOF ? "end of input" : `token ${tok}`;
    }
    expectIdentifierOrKeyword() {
      const n = this.next;
      if (!n.isIdentifier() && !n.isKeyword()) {
        if (n.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(n, "expected identifier or keyword");
        } else {
          this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);
        }
        return null;
      }
      this.advance();
      return n.toString();
    }
    expectIdentifierOrKeywordOrString() {
      const n = this.next;
      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
        if (n.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(n, "expected identifier, keyword or string");
        } else {
          this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);
        }
        return "";
      }
      this.advance();
      return n.toString();
    }
    parseChain() {
      const exprs = [];
      const start = this.inputIndex;
      while (this.index < this.tokens.length) {
        const expr = this.parsePipe();
        exprs.push(expr);
        if (this.consumeOptionalCharacter($SEMICOLON)) {
          if (!(this.parseFlags & 1)) {
            this.error("Binding expression cannot contain chained expression");
          }
          while (this.consumeOptionalCharacter($SEMICOLON)) {
          }
        } else if (this.index < this.tokens.length) {
          this.error(`Unexpected token '${this.next}'`);
        }
      }
      if (exprs.length == 0) {
        const artificialStart = this.offset;
        const artificialEnd = this.offset + this.input.length;
        return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
      }
      if (exprs.length == 1)
        return exprs[0];
      return new Chain(this.span(start), this.sourceSpan(start), exprs);
    }
    parsePipe() {
      const start = this.inputIndex;
      let result = this.parseExpression();
      if (this.consumeOptionalOperator("|")) {
        if (this.parseFlags & 1) {
          this.error("Cannot have a pipe in an action expression");
        }
        do {
          const nameStart = this.inputIndex;
          let nameId = this.expectIdentifierOrKeyword();
          let nameSpan;
          let fullSpanEnd = void 0;
          if (nameId !== null) {
            nameSpan = this.sourceSpan(nameStart);
          } else {
            nameId = "";
            fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;
            nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
          }
          const args = [];
          while (this.consumeOptionalCharacter($COLON)) {
            args.push(this.parseExpression());
          }
          result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
        } while (this.consumeOptionalOperator("|"));
      }
      return result;
    }
    parseExpression() {
      return this.parseConditional();
    }
    parseConditional() {
      const start = this.inputIndex;
      const result = this.parseLogicalOr();
      if (this.consumeOptionalOperator("?")) {
        const yes = this.parsePipe();
        let no;
        if (!this.consumeOptionalCharacter($COLON)) {
          const end = this.inputIndex;
          const expression = this.input.substring(start, end);
          this.error(`Conditional expression ${expression} requires all 3 expressions`);
          no = new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          no = this.parsePipe();
        }
        return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
      } else {
        return result;
      }
    }
    parseLogicalOr() {
      const start = this.inputIndex;
      let result = this.parseLogicalAnd();
      while (this.consumeOptionalOperator("||")) {
        const right = this.parseLogicalAnd();
        result = new Binary(this.span(start), this.sourceSpan(start), "||", result, right);
      }
      return result;
    }
    parseLogicalAnd() {
      const start = this.inputIndex;
      let result = this.parseNullishCoalescing();
      while (this.consumeOptionalOperator("&&")) {
        const right = this.parseNullishCoalescing();
        result = new Binary(this.span(start), this.sourceSpan(start), "&&", result, right);
      }
      return result;
    }
    parseNullishCoalescing() {
      const start = this.inputIndex;
      let result = this.parseEquality();
      while (this.consumeOptionalOperator("??")) {
        const right = this.parseEquality();
        result = new Binary(this.span(start), this.sourceSpan(start), "??", result, right);
      }
      return result;
    }
    parseEquality() {
      const start = this.inputIndex;
      let result = this.parseRelational();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "==":
          case "===":
          case "!=":
          case "!==":
            this.advance();
            const right = this.parseRelational();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parseRelational() {
      const start = this.inputIndex;
      let result = this.parseAdditive();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "<":
          case ">":
          case "<=":
          case ">=":
            this.advance();
            const right = this.parseAdditive();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parseAdditive() {
      const start = this.inputIndex;
      let result = this.parseMultiplicative();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "+":
          case "-":
            this.advance();
            let right = this.parseMultiplicative();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parseMultiplicative() {
      const start = this.inputIndex;
      let result = this.parsePrefix();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "*":
          case "%":
          case "/":
            this.advance();
            let right = this.parsePrefix();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parsePrefix() {
      if (this.next.type == TokenType.Operator) {
        const start = this.inputIndex;
        const operator = this.next.strValue;
        let result;
        switch (operator) {
          case "+":
            this.advance();
            result = this.parsePrefix();
            return Unary.createPlus(this.span(start), this.sourceSpan(start), result);
          case "-":
            this.advance();
            result = this.parsePrefix();
            return Unary.createMinus(this.span(start), this.sourceSpan(start), result);
          case "!":
            this.advance();
            result = this.parsePrefix();
            return new PrefixNot(this.span(start), this.sourceSpan(start), result);
        }
      }
      return this.parseCallChain();
    }
    parseCallChain() {
      const start = this.inputIndex;
      let result = this.parsePrimary();
      while (true) {
        if (this.consumeOptionalCharacter($PERIOD)) {
          result = this.parseAccessMember(result, start, false);
        } else if (this.consumeOptionalOperator("?.")) {
          if (this.consumeOptionalCharacter($LPAREN)) {
            result = this.parseCall(result, start, true);
          } else {
            result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMember(result, start, true);
          }
        } else if (this.consumeOptionalCharacter($LBRACKET)) {
          result = this.parseKeyedReadOrWrite(result, start, false);
        } else if (this.consumeOptionalCharacter($LPAREN)) {
          result = this.parseCall(result, start, false);
        } else if (this.consumeOptionalOperator("!")) {
          result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);
        } else {
          return result;
        }
      }
    }
    parsePrimary() {
      const start = this.inputIndex;
      if (this.consumeOptionalCharacter($LPAREN)) {
        this.rparensExpected++;
        const result = this.parsePipe();
        this.rparensExpected--;
        this.expectCharacter($RPAREN);
        return result;
      } else if (this.next.isKeywordNull()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
      } else if (this.next.isKeywordUndefined()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
      } else if (this.next.isKeywordTrue()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
      } else if (this.next.isKeywordFalse()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
      } else if (this.next.isKeywordThis()) {
        this.advance();
        return new ThisReceiver(this.span(start), this.sourceSpan(start));
      } else if (this.consumeOptionalCharacter($LBRACKET)) {
        this.rbracketsExpected++;
        const elements = this.parseExpressionList($RBRACKET);
        this.rbracketsExpected--;
        this.expectCharacter($RBRACKET);
        return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
      } else if (this.next.isCharacter($LBRACE)) {
        return this.parseLiteralMap();
      } else if (this.next.isIdentifier()) {
        return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
      } else if (this.next.isNumber()) {
        const value = this.next.toNumber();
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
      } else if (this.next.isString()) {
        const literalValue = this.next.toString();
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
      } else if (this.next.isPrivateIdentifier()) {
        this._reportErrorForPrivateIdentifier(this.next, null);
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      } else if (this.index >= this.tokens.length) {
        this.error(`Unexpected end of expression: ${this.input}`);
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      } else {
        this.error(`Unexpected token ${this.next}`);
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      }
    }
    parseExpressionList(terminator) {
      const result = [];
      do {
        if (!this.next.isCharacter(terminator)) {
          result.push(this.parsePipe());
        } else {
          break;
        }
      } while (this.consumeOptionalCharacter($COMMA));
      return result;
    }
    parseLiteralMap() {
      const keys = [];
      const values = [];
      const start = this.inputIndex;
      this.expectCharacter($LBRACE);
      if (!this.consumeOptionalCharacter($RBRACE)) {
        this.rbracesExpected++;
        do {
          const keyStart = this.inputIndex;
          const quoted = this.next.isString();
          const key = this.expectIdentifierOrKeywordOrString();
          keys.push({ key, quoted });
          if (quoted) {
            this.expectCharacter($COLON);
            values.push(this.parsePipe());
          } else if (this.consumeOptionalCharacter($COLON)) {
            values.push(this.parsePipe());
          } else {
            const span = this.span(keyStart);
            const sourceSpan = this.sourceSpan(keyStart);
            values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));
          }
        } while (this.consumeOptionalCharacter($COMMA));
        this.rbracesExpected--;
        this.expectCharacter($RBRACE);
      }
      return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
    }
    parseAccessMember(readReceiver, start, isSafe) {
      const nameStart = this.inputIndex;
      const id = this.withContext(ParseContextFlags.Writable, () => {
        const id2 = this.expectIdentifierOrKeyword() ?? "";
        if (id2.length === 0) {
          this.error(`Expected identifier for property access`, readReceiver.span.end);
        }
        return id2;
      });
      const nameSpan = this.sourceSpan(nameStart);
      let receiver;
      if (isSafe) {
        if (this.consumeOptionalAssignment()) {
          this.error("The '?.' operator cannot be used in the assignment");
          receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
        }
      } else {
        if (this.consumeOptionalAssignment()) {
          if (!(this.parseFlags & 1)) {
            this.error("Bindings cannot contain assignments");
            return new EmptyExpr(this.span(start), this.sourceSpan(start));
          }
          const value = this.parseConditional();
          receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);
        } else {
          receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
        }
      }
      return receiver;
    }
    parseCall(receiver, start, isSafe) {
      const argumentStart = this.inputIndex;
      this.rparensExpected++;
      const args = this.parseCallArguments();
      const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
      this.expectCharacter($RPAREN);
      this.rparensExpected--;
      const span = this.span(start);
      const sourceSpan = this.sourceSpan(start);
      return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) : new Call(span, sourceSpan, receiver, args, argumentSpan);
    }
    consumeOptionalAssignment() {
      if (this.parseFlags & 2 && this.next.isOperator("!") && this.peek(1).isOperator("=")) {
        this.advance();
        this.advance();
        return true;
      }
      return this.consumeOptionalOperator("=");
    }
    parseCallArguments() {
      if (this.next.isCharacter($RPAREN))
        return [];
      const positionals = [];
      do {
        positionals.push(this.parsePipe());
      } while (this.consumeOptionalCharacter($COMMA));
      return positionals;
    }
    expectTemplateBindingKey() {
      let result = "";
      let operatorFound = false;
      const start = this.currentAbsoluteOffset;
      do {
        result += this.expectIdentifierOrKeywordOrString();
        operatorFound = this.consumeOptionalOperator("-");
        if (operatorFound) {
          result += "-";
        }
      } while (operatorFound);
      return {
        source: result,
        span: new AbsoluteSourceSpan(start, start + result.length)
      };
    }
    parseTemplateBindings(templateKey) {
      const bindings = [];
      bindings.push(...this.parseDirectiveKeywordBindings(templateKey));
      while (this.index < this.tokens.length) {
        const letBinding = this.parseLetBinding();
        if (letBinding) {
          bindings.push(letBinding);
        } else {
          const key = this.expectTemplateBindingKey();
          const binding = this.parseAsBinding(key);
          if (binding) {
            bindings.push(binding);
          } else {
            key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
            bindings.push(...this.parseDirectiveKeywordBindings(key));
          }
        }
        this.consumeStatementTerminator();
      }
      return new TemplateBindingParseResult(bindings, [], this.errors);
    }
    parseKeyedReadOrWrite(receiver, start, isSafe) {
      return this.withContext(ParseContextFlags.Writable, () => {
        this.rbracketsExpected++;
        const key = this.parsePipe();
        if (key instanceof EmptyExpr) {
          this.error(`Key access cannot be empty`);
        }
        this.rbracketsExpected--;
        this.expectCharacter($RBRACKET);
        if (this.consumeOptionalOperator("=")) {
          if (isSafe) {
            this.error("The '?.' operator cannot be used in the assignment");
          } else {
            const value = this.parseConditional();
            return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);
          }
        } else {
          return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);
        }
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      });
    }
    parseDirectiveKeywordBindings(key) {
      const bindings = [];
      this.consumeOptionalCharacter($COLON);
      const value = this.getDirectiveBoundTarget();
      let spanEnd = this.currentAbsoluteOffset;
      const asBinding = this.parseAsBinding(key);
      if (!asBinding) {
        this.consumeStatementTerminator();
        spanEnd = this.currentAbsoluteOffset;
      }
      const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
      bindings.push(new ExpressionBinding(sourceSpan, key, value));
      if (asBinding) {
        bindings.push(asBinding);
      }
      return bindings;
    }
    getDirectiveBoundTarget() {
      if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
        return null;
      }
      const ast = this.parsePipe();
      const { start, end } = ast.span;
      const value = this.input.substring(start, end);
      return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
    }
    parseAsBinding(value) {
      if (!this.peekKeywordAs()) {
        return null;
      }
      this.advance();
      const key = this.expectTemplateBindingKey();
      this.consumeStatementTerminator();
      const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
      return new VariableBinding(sourceSpan, key, value);
    }
    parseLetBinding() {
      if (!this.peekKeywordLet()) {
        return null;
      }
      const spanStart = this.currentAbsoluteOffset;
      this.advance();
      const key = this.expectTemplateBindingKey();
      let value = null;
      if (this.consumeOptionalOperator("=")) {
        value = this.expectTemplateBindingKey();
      }
      this.consumeStatementTerminator();
      const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
      return new VariableBinding(sourceSpan, key, value);
    }
    consumeStatementTerminator() {
      this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
    }
    error(message, index = null) {
      this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
      this.skip();
    }
    locationText(index = null) {
      if (index == null)
        index = this.index;
      return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;
    }
    _reportErrorForPrivateIdentifier(token, extraMessage) {
      let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;
      if (extraMessage !== null) {
        errorMessage += `, ${extraMessage}`;
      }
      this.error(errorMessage);
    }
    skip() {
      let n = this.next;
      while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator("|") && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !n.isOperator("="))) {
        if (this.next.isError()) {
          this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
        }
        this.advance();
        n = this.next;
      }
    }
  };
  var SimpleExpressionChecker = class extends RecursiveAstVisitor {
    constructor() {
      super(...arguments);
      this.errors = [];
    }
    visitPipe() {
      this.errors.push("pipes");
    }
  };
  function getIndexMapForOriginalTemplate(interpolatedTokens) {
    let offsetMap = /* @__PURE__ */ new Map();
    let consumedInOriginalTemplate = 0;
    let consumedInInput = 0;
    let tokenIndex = 0;
    while (tokenIndex < interpolatedTokens.length) {
      const currentToken = interpolatedTokens[tokenIndex];
      if (currentToken.type === 9) {
        const [decoded, encoded] = currentToken.parts;
        consumedInOriginalTemplate += encoded.length;
        consumedInInput += decoded.length;
      } else {
        const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);
        consumedInInput += lengthOfParts;
        consumedInOriginalTemplate += lengthOfParts;
      }
      offsetMap.set(consumedInInput, consumedInOriginalTemplate);
      tokenIndex++;
    }
    return offsetMap;
  }
  var NodeWithI18n = class {
    constructor(sourceSpan, i18n) {
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    }
  };
  var Text2 = class extends NodeWithI18n {
    constructor(value, sourceSpan, tokens, i18n) {
      super(sourceSpan, i18n);
      this.value = value;
      this.tokens = tokens;
    }
    visit(visitor, context) {
      return visitor.visitText(this, context);
    }
  };
  var Expansion = class extends NodeWithI18n {
    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
      super(sourceSpan, i18n);
      this.switchValue = switchValue;
      this.type = type;
      this.cases = cases;
      this.switchValueSourceSpan = switchValueSourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitExpansion(this, context);
    }
  };
  var ExpansionCase = class {
    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
      this.value = value;
      this.expression = expression;
      this.sourceSpan = sourceSpan;
      this.valueSourceSpan = valueSourceSpan;
      this.expSourceSpan = expSourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitExpansionCase(this, context);
    }
  };
  var Attribute2 = class extends NodeWithI18n {
    constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {
      super(sourceSpan, i18n);
      this.name = name;
      this.value = value;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.valueTokens = valueTokens;
    }
    visit(visitor, context) {
      return visitor.visitAttribute(this, context);
    }
  };
  var Element2 = class extends NodeWithI18n {
    constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {
      super(sourceSpan, i18n);
      this.name = name;
      this.attrs = attrs;
      this.children = children;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitElement(this, context);
    }
  };
  var Comment = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context) {
      return visitor.visitComment(this, context);
    }
  };
  function visitAll(visitor, nodes, context = null) {
    const result = [];
    const visit = visitor.visit ? (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) : (ast) => ast.visit(visitor, context);
    nodes.forEach((ast) => {
      const astResult = visit(ast);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  var NAMED_ENTITIES = {
    "AElig": "\xC6",
    "AMP": "&",
    "amp": "&",
    "Aacute": "\xC1",
    "Abreve": "\u0102",
    "Acirc": "\xC2",
    "Acy": "\u0410",
    "Afr": "\u{1D504}",
    "Agrave": "\xC0",
    "Alpha": "\u0391",
    "Amacr": "\u0100",
    "And": "\u2A53",
    "Aogon": "\u0104",
    "Aopf": "\u{1D538}",
    "ApplyFunction": "\u2061",
    "af": "\u2061",
    "Aring": "\xC5",
    "angst": "\xC5",
    "Ascr": "\u{1D49C}",
    "Assign": "\u2254",
    "colone": "\u2254",
    "coloneq": "\u2254",
    "Atilde": "\xC3",
    "Auml": "\xC4",
    "Backslash": "\u2216",
    "setminus": "\u2216",
    "setmn": "\u2216",
    "smallsetminus": "\u2216",
    "ssetmn": "\u2216",
    "Barv": "\u2AE7",
    "Barwed": "\u2306",
    "doublebarwedge": "\u2306",
    "Bcy": "\u0411",
    "Because": "\u2235",
    "becaus": "\u2235",
    "because": "\u2235",
    "Bernoullis": "\u212C",
    "Bscr": "\u212C",
    "bernou": "\u212C",
    "Beta": "\u0392",
    "Bfr": "\u{1D505}",
    "Bopf": "\u{1D539}",
    "Breve": "\u02D8",
    "breve": "\u02D8",
    "Bumpeq": "\u224E",
    "HumpDownHump": "\u224E",
    "bump": "\u224E",
    "CHcy": "\u0427",
    "COPY": "\xA9",
    "copy": "\xA9",
    "Cacute": "\u0106",
    "Cap": "\u22D2",
    "CapitalDifferentialD": "\u2145",
    "DD": "\u2145",
    "Cayleys": "\u212D",
    "Cfr": "\u212D",
    "Ccaron": "\u010C",
    "Ccedil": "\xC7",
    "Ccirc": "\u0108",
    "Cconint": "\u2230",
    "Cdot": "\u010A",
    "Cedilla": "\xB8",
    "cedil": "\xB8",
    "CenterDot": "\xB7",
    "centerdot": "\xB7",
    "middot": "\xB7",
    "Chi": "\u03A7",
    "CircleDot": "\u2299",
    "odot": "\u2299",
    "CircleMinus": "\u2296",
    "ominus": "\u2296",
    "CirclePlus": "\u2295",
    "oplus": "\u2295",
    "CircleTimes": "\u2297",
    "otimes": "\u2297",
    "ClockwiseContourIntegral": "\u2232",
    "cwconint": "\u2232",
    "CloseCurlyDoubleQuote": "\u201D",
    "rdquo": "\u201D",
    "rdquor": "\u201D",
    "CloseCurlyQuote": "\u2019",
    "rsquo": "\u2019",
    "rsquor": "\u2019",
    "Colon": "\u2237",
    "Proportion": "\u2237",
    "Colone": "\u2A74",
    "Congruent": "\u2261",
    "equiv": "\u2261",
    "Conint": "\u222F",
    "DoubleContourIntegral": "\u222F",
    "ContourIntegral": "\u222E",
    "conint": "\u222E",
    "oint": "\u222E",
    "Copf": "\u2102",
    "complexes": "\u2102",
    "Coproduct": "\u2210",
    "coprod": "\u2210",
    "CounterClockwiseContourIntegral": "\u2233",
    "awconint": "\u2233",
    "Cross": "\u2A2F",
    "Cscr": "\u{1D49E}",
    "Cup": "\u22D3",
    "CupCap": "\u224D",
    "asympeq": "\u224D",
    "DDotrahd": "\u2911",
    "DJcy": "\u0402",
    "DScy": "\u0405",
    "DZcy": "\u040F",
    "Dagger": "\u2021",
    "ddagger": "\u2021",
    "Darr": "\u21A1",
    "Dashv": "\u2AE4",
    "DoubleLeftTee": "\u2AE4",
    "Dcaron": "\u010E",
    "Dcy": "\u0414",
    "Del": "\u2207",
    "nabla": "\u2207",
    "Delta": "\u0394",
    "Dfr": "\u{1D507}",
    "DiacriticalAcute": "\xB4",
    "acute": "\xB4",
    "DiacriticalDot": "\u02D9",
    "dot": "\u02D9",
    "DiacriticalDoubleAcute": "\u02DD",
    "dblac": "\u02DD",
    "DiacriticalGrave": "`",
    "grave": "`",
    "DiacriticalTilde": "\u02DC",
    "tilde": "\u02DC",
    "Diamond": "\u22C4",
    "diam": "\u22C4",
    "diamond": "\u22C4",
    "DifferentialD": "\u2146",
    "dd": "\u2146",
    "Dopf": "\u{1D53B}",
    "Dot": "\xA8",
    "DoubleDot": "\xA8",
    "die": "\xA8",
    "uml": "\xA8",
    "DotDot": "\u20DC",
    "DotEqual": "\u2250",
    "doteq": "\u2250",
    "esdot": "\u2250",
    "DoubleDownArrow": "\u21D3",
    "Downarrow": "\u21D3",
    "dArr": "\u21D3",
    "DoubleLeftArrow": "\u21D0",
    "Leftarrow": "\u21D0",
    "lArr": "\u21D0",
    "DoubleLeftRightArrow": "\u21D4",
    "Leftrightarrow": "\u21D4",
    "hArr": "\u21D4",
    "iff": "\u21D4",
    "DoubleLongLeftArrow": "\u27F8",
    "Longleftarrow": "\u27F8",
    "xlArr": "\u27F8",
    "DoubleLongLeftRightArrow": "\u27FA",
    "Longleftrightarrow": "\u27FA",
    "xhArr": "\u27FA",
    "DoubleLongRightArrow": "\u27F9",
    "Longrightarrow": "\u27F9",
    "xrArr": "\u27F9",
    "DoubleRightArrow": "\u21D2",
    "Implies": "\u21D2",
    "Rightarrow": "\u21D2",
    "rArr": "\u21D2",
    "DoubleRightTee": "\u22A8",
    "vDash": "\u22A8",
    "DoubleUpArrow": "\u21D1",
    "Uparrow": "\u21D1",
    "uArr": "\u21D1",
    "DoubleUpDownArrow": "\u21D5",
    "Updownarrow": "\u21D5",
    "vArr": "\u21D5",
    "DoubleVerticalBar": "\u2225",
    "par": "\u2225",
    "parallel": "\u2225",
    "shortparallel": "\u2225",
    "spar": "\u2225",
    "DownArrow": "\u2193",
    "ShortDownArrow": "\u2193",
    "darr": "\u2193",
    "downarrow": "\u2193",
    "DownArrowBar": "\u2913",
    "DownArrowUpArrow": "\u21F5",
    "duarr": "\u21F5",
    "DownBreve": "\u0311",
    "DownLeftRightVector": "\u2950",
    "DownLeftTeeVector": "\u295E",
    "DownLeftVector": "\u21BD",
    "leftharpoondown": "\u21BD",
    "lhard": "\u21BD",
    "DownLeftVectorBar": "\u2956",
    "DownRightTeeVector": "\u295F",
    "DownRightVector": "\u21C1",
    "rhard": "\u21C1",
    "rightharpoondown": "\u21C1",
    "DownRightVectorBar": "\u2957",
    "DownTee": "\u22A4",
    "top": "\u22A4",
    "DownTeeArrow": "\u21A7",
    "mapstodown": "\u21A7",
    "Dscr": "\u{1D49F}",
    "Dstrok": "\u0110",
    "ENG": "\u014A",
    "ETH": "\xD0",
    "Eacute": "\xC9",
    "Ecaron": "\u011A",
    "Ecirc": "\xCA",
    "Ecy": "\u042D",
    "Edot": "\u0116",
    "Efr": "\u{1D508}",
    "Egrave": "\xC8",
    "Element": "\u2208",
    "in": "\u2208",
    "isin": "\u2208",
    "isinv": "\u2208",
    "Emacr": "\u0112",
    "EmptySmallSquare": "\u25FB",
    "EmptyVerySmallSquare": "\u25AB",
    "Eogon": "\u0118",
    "Eopf": "\u{1D53C}",
    "Epsilon": "\u0395",
    "Equal": "\u2A75",
    "EqualTilde": "\u2242",
    "eqsim": "\u2242",
    "esim": "\u2242",
    "Equilibrium": "\u21CC",
    "rightleftharpoons": "\u21CC",
    "rlhar": "\u21CC",
    "Escr": "\u2130",
    "expectation": "\u2130",
    "Esim": "\u2A73",
    "Eta": "\u0397",
    "Euml": "\xCB",
    "Exists": "\u2203",
    "exist": "\u2203",
    "ExponentialE": "\u2147",
    "ee": "\u2147",
    "exponentiale": "\u2147",
    "Fcy": "\u0424",
    "Ffr": "\u{1D509}",
    "FilledSmallSquare": "\u25FC",
    "FilledVerySmallSquare": "\u25AA",
    "blacksquare": "\u25AA",
    "squarf": "\u25AA",
    "squf": "\u25AA",
    "Fopf": "\u{1D53D}",
    "ForAll": "\u2200",
    "forall": "\u2200",
    "Fouriertrf": "\u2131",
    "Fscr": "\u2131",
    "GJcy": "\u0403",
    "GT": ">",
    "gt": ">",
    "Gamma": "\u0393",
    "Gammad": "\u03DC",
    "Gbreve": "\u011E",
    "Gcedil": "\u0122",
    "Gcirc": "\u011C",
    "Gcy": "\u0413",
    "Gdot": "\u0120",
    "Gfr": "\u{1D50A}",
    "Gg": "\u22D9",
    "ggg": "\u22D9",
    "Gopf": "\u{1D53E}",
    "GreaterEqual": "\u2265",
    "ge": "\u2265",
    "geq": "\u2265",
    "GreaterEqualLess": "\u22DB",
    "gel": "\u22DB",
    "gtreqless": "\u22DB",
    "GreaterFullEqual": "\u2267",
    "gE": "\u2267",
    "geqq": "\u2267",
    "GreaterGreater": "\u2AA2",
    "GreaterLess": "\u2277",
    "gl": "\u2277",
    "gtrless": "\u2277",
    "GreaterSlantEqual": "\u2A7E",
    "geqslant": "\u2A7E",
    "ges": "\u2A7E",
    "GreaterTilde": "\u2273",
    "gsim": "\u2273",
    "gtrsim": "\u2273",
    "Gscr": "\u{1D4A2}",
    "Gt": "\u226B",
    "NestedGreaterGreater": "\u226B",
    "gg": "\u226B",
    "HARDcy": "\u042A",
    "Hacek": "\u02C7",
    "caron": "\u02C7",
    "Hat": "^",
    "Hcirc": "\u0124",
    "Hfr": "\u210C",
    "Poincareplane": "\u210C",
    "HilbertSpace": "\u210B",
    "Hscr": "\u210B",
    "hamilt": "\u210B",
    "Hopf": "\u210D",
    "quaternions": "\u210D",
    "HorizontalLine": "\u2500",
    "boxh": "\u2500",
    "Hstrok": "\u0126",
    "HumpEqual": "\u224F",
    "bumpe": "\u224F",
    "bumpeq": "\u224F",
    "IEcy": "\u0415",
    "IJlig": "\u0132",
    "IOcy": "\u0401",
    "Iacute": "\xCD",
    "Icirc": "\xCE",
    "Icy": "\u0418",
    "Idot": "\u0130",
    "Ifr": "\u2111",
    "Im": "\u2111",
    "image": "\u2111",
    "imagpart": "\u2111",
    "Igrave": "\xCC",
    "Imacr": "\u012A",
    "ImaginaryI": "\u2148",
    "ii": "\u2148",
    "Int": "\u222C",
    "Integral": "\u222B",
    "int": "\u222B",
    "Intersection": "\u22C2",
    "bigcap": "\u22C2",
    "xcap": "\u22C2",
    "InvisibleComma": "\u2063",
    "ic": "\u2063",
    "InvisibleTimes": "\u2062",
    "it": "\u2062",
    "Iogon": "\u012E",
    "Iopf": "\u{1D540}",
    "Iota": "\u0399",
    "Iscr": "\u2110",
    "imagline": "\u2110",
    "Itilde": "\u0128",
    "Iukcy": "\u0406",
    "Iuml": "\xCF",
    "Jcirc": "\u0134",
    "Jcy": "\u0419",
    "Jfr": "\u{1D50D}",
    "Jopf": "\u{1D541}",
    "Jscr": "\u{1D4A5}",
    "Jsercy": "\u0408",
    "Jukcy": "\u0404",
    "KHcy": "\u0425",
    "KJcy": "\u040C",
    "Kappa": "\u039A",
    "Kcedil": "\u0136",
    "Kcy": "\u041A",
    "Kfr": "\u{1D50E}",
    "Kopf": "\u{1D542}",
    "Kscr": "\u{1D4A6}",
    "LJcy": "\u0409",
    "LT": "<",
    "lt": "<",
    "Lacute": "\u0139",
    "Lambda": "\u039B",
    "Lang": "\u27EA",
    "Laplacetrf": "\u2112",
    "Lscr": "\u2112",
    "lagran": "\u2112",
    "Larr": "\u219E",
    "twoheadleftarrow": "\u219E",
    "Lcaron": "\u013D",
    "Lcedil": "\u013B",
    "Lcy": "\u041B",
    "LeftAngleBracket": "\u27E8",
    "lang": "\u27E8",
    "langle": "\u27E8",
    "LeftArrow": "\u2190",
    "ShortLeftArrow": "\u2190",
    "larr": "\u2190",
    "leftarrow": "\u2190",
    "slarr": "\u2190",
    "LeftArrowBar": "\u21E4",
    "larrb": "\u21E4",
    "LeftArrowRightArrow": "\u21C6",
    "leftrightarrows": "\u21C6",
    "lrarr": "\u21C6",
    "LeftCeiling": "\u2308",
    "lceil": "\u2308",
    "LeftDoubleBracket": "\u27E6",
    "lobrk": "\u27E6",
    "LeftDownTeeVector": "\u2961",
    "LeftDownVector": "\u21C3",
    "dharl": "\u21C3",
    "downharpoonleft": "\u21C3",
    "LeftDownVectorBar": "\u2959",
    "LeftFloor": "\u230A",
    "lfloor": "\u230A",
    "LeftRightArrow": "\u2194",
    "harr": "\u2194",
    "leftrightarrow": "\u2194",
    "LeftRightVector": "\u294E",
    "LeftTee": "\u22A3",
    "dashv": "\u22A3",
    "LeftTeeArrow": "\u21A4",
    "mapstoleft": "\u21A4",
    "LeftTeeVector": "\u295A",
    "LeftTriangle": "\u22B2",
    "vartriangleleft": "\u22B2",
    "vltri": "\u22B2",
    "LeftTriangleBar": "\u29CF",
    "LeftTriangleEqual": "\u22B4",
    "ltrie": "\u22B4",
    "trianglelefteq": "\u22B4",
    "LeftUpDownVector": "\u2951",
    "LeftUpTeeVector": "\u2960",
    "LeftUpVector": "\u21BF",
    "uharl": "\u21BF",
    "upharpoonleft": "\u21BF",
    "LeftUpVectorBar": "\u2958",
    "LeftVector": "\u21BC",
    "leftharpoonup": "\u21BC",
    "lharu": "\u21BC",
    "LeftVectorBar": "\u2952",
    "LessEqualGreater": "\u22DA",
    "leg": "\u22DA",
    "lesseqgtr": "\u22DA",
    "LessFullEqual": "\u2266",
    "lE": "\u2266",
    "leqq": "\u2266",
    "LessGreater": "\u2276",
    "lessgtr": "\u2276",
    "lg": "\u2276",
    "LessLess": "\u2AA1",
    "LessSlantEqual": "\u2A7D",
    "leqslant": "\u2A7D",
    "les": "\u2A7D",
    "LessTilde": "\u2272",
    "lesssim": "\u2272",
    "lsim": "\u2272",
    "Lfr": "\u{1D50F}",
    "Ll": "\u22D8",
    "Lleftarrow": "\u21DA",
    "lAarr": "\u21DA",
    "Lmidot": "\u013F",
    "LongLeftArrow": "\u27F5",
    "longleftarrow": "\u27F5",
    "xlarr": "\u27F5",
    "LongLeftRightArrow": "\u27F7",
    "longleftrightarrow": "\u27F7",
    "xharr": "\u27F7",
    "LongRightArrow": "\u27F6",
    "longrightarrow": "\u27F6",
    "xrarr": "\u27F6",
    "Lopf": "\u{1D543}",
    "LowerLeftArrow": "\u2199",
    "swarr": "\u2199",
    "swarrow": "\u2199",
    "LowerRightArrow": "\u2198",
    "searr": "\u2198",
    "searrow": "\u2198",
    "Lsh": "\u21B0",
    "lsh": "\u21B0",
    "Lstrok": "\u0141",
    "Lt": "\u226A",
    "NestedLessLess": "\u226A",
    "ll": "\u226A",
    "Map": "\u2905",
    "Mcy": "\u041C",
    "MediumSpace": "\u205F",
    "Mellintrf": "\u2133",
    "Mscr": "\u2133",
    "phmmat": "\u2133",
    "Mfr": "\u{1D510}",
    "MinusPlus": "\u2213",
    "mnplus": "\u2213",
    "mp": "\u2213",
    "Mopf": "\u{1D544}",
    "Mu": "\u039C",
    "NJcy": "\u040A",
    "Nacute": "\u0143",
    "Ncaron": "\u0147",
    "Ncedil": "\u0145",
    "Ncy": "\u041D",
    "NegativeMediumSpace": "\u200B",
    "NegativeThickSpace": "\u200B",
    "NegativeThinSpace": "\u200B",
    "NegativeVeryThinSpace": "\u200B",
    "ZeroWidthSpace": "\u200B",
    "NewLine": "\n",
    "Nfr": "\u{1D511}",
    "NoBreak": "\u2060",
    "NonBreakingSpace": "\xA0",
    "nbsp": "\xA0",
    "Nopf": "\u2115",
    "naturals": "\u2115",
    "Not": "\u2AEC",
    "NotCongruent": "\u2262",
    "nequiv": "\u2262",
    "NotCupCap": "\u226D",
    "NotDoubleVerticalBar": "\u2226",
    "npar": "\u2226",
    "nparallel": "\u2226",
    "nshortparallel": "\u2226",
    "nspar": "\u2226",
    "NotElement": "\u2209",
    "notin": "\u2209",
    "notinva": "\u2209",
    "NotEqual": "\u2260",
    "ne": "\u2260",
    "NotEqualTilde": "\u2242\u0338",
    "nesim": "\u2242\u0338",
    "NotExists": "\u2204",
    "nexist": "\u2204",
    "nexists": "\u2204",
    "NotGreater": "\u226F",
    "ngt": "\u226F",
    "ngtr": "\u226F",
    "NotGreaterEqual": "\u2271",
    "nge": "\u2271",
    "ngeq": "\u2271",
    "NotGreaterFullEqual": "\u2267\u0338",
    "ngE": "\u2267\u0338",
    "ngeqq": "\u2267\u0338",
    "NotGreaterGreater": "\u226B\u0338",
    "nGtv": "\u226B\u0338",
    "NotGreaterLess": "\u2279",
    "ntgl": "\u2279",
    "NotGreaterSlantEqual": "\u2A7E\u0338",
    "ngeqslant": "\u2A7E\u0338",
    "nges": "\u2A7E\u0338",
    "NotGreaterTilde": "\u2275",
    "ngsim": "\u2275",
    "NotHumpDownHump": "\u224E\u0338",
    "nbump": "\u224E\u0338",
    "NotHumpEqual": "\u224F\u0338",
    "nbumpe": "\u224F\u0338",
    "NotLeftTriangle": "\u22EA",
    "nltri": "\u22EA",
    "ntriangleleft": "\u22EA",
    "NotLeftTriangleBar": "\u29CF\u0338",
    "NotLeftTriangleEqual": "\u22EC",
    "nltrie": "\u22EC",
    "ntrianglelefteq": "\u22EC",
    "NotLess": "\u226E",
    "nless": "\u226E",
    "nlt": "\u226E",
    "NotLessEqual": "\u2270",
    "nle": "\u2270",
    "nleq": "\u2270",
    "NotLessGreater": "\u2278",
    "ntlg": "\u2278",
    "NotLessLess": "\u226A\u0338",
    "nLtv": "\u226A\u0338",
    "NotLessSlantEqual": "\u2A7D\u0338",
    "nleqslant": "\u2A7D\u0338",
    "nles": "\u2A7D\u0338",
    "NotLessTilde": "\u2274",
    "nlsim": "\u2274",
    "NotNestedGreaterGreater": "\u2AA2\u0338",
    "NotNestedLessLess": "\u2AA1\u0338",
    "NotPrecedes": "\u2280",
    "npr": "\u2280",
    "nprec": "\u2280",
    "NotPrecedesEqual": "\u2AAF\u0338",
    "npre": "\u2AAF\u0338",
    "npreceq": "\u2AAF\u0338",
    "NotPrecedesSlantEqual": "\u22E0",
    "nprcue": "\u22E0",
    "NotReverseElement": "\u220C",
    "notni": "\u220C",
    "notniva": "\u220C",
    "NotRightTriangle": "\u22EB",
    "nrtri": "\u22EB",
    "ntriangleright": "\u22EB",
    "NotRightTriangleBar": "\u29D0\u0338",
    "NotRightTriangleEqual": "\u22ED",
    "nrtrie": "\u22ED",
    "ntrianglerighteq": "\u22ED",
    "NotSquareSubset": "\u228F\u0338",
    "NotSquareSubsetEqual": "\u22E2",
    "nsqsube": "\u22E2",
    "NotSquareSuperset": "\u2290\u0338",
    "NotSquareSupersetEqual": "\u22E3",
    "nsqsupe": "\u22E3",
    "NotSubset": "\u2282\u20D2",
    "nsubset": "\u2282\u20D2",
    "vnsub": "\u2282\u20D2",
    "NotSubsetEqual": "\u2288",
    "nsube": "\u2288",
    "nsubseteq": "\u2288",
    "NotSucceeds": "\u2281",
    "nsc": "\u2281",
    "nsucc": "\u2281",
    "NotSucceedsEqual": "\u2AB0\u0338",
    "nsce": "\u2AB0\u0338",
    "nsucceq": "\u2AB0\u0338",
    "NotSucceedsSlantEqual": "\u22E1",
    "nsccue": "\u22E1",
    "NotSucceedsTilde": "\u227F\u0338",
    "NotSuperset": "\u2283\u20D2",
    "nsupset": "\u2283\u20D2",
    "vnsup": "\u2283\u20D2",
    "NotSupersetEqual": "\u2289",
    "nsupe": "\u2289",
    "nsupseteq": "\u2289",
    "NotTilde": "\u2241",
    "nsim": "\u2241",
    "NotTildeEqual": "\u2244",
    "nsime": "\u2244",
    "nsimeq": "\u2244",
    "NotTildeFullEqual": "\u2247",
    "ncong": "\u2247",
    "NotTildeTilde": "\u2249",
    "nap": "\u2249",
    "napprox": "\u2249",
    "NotVerticalBar": "\u2224",
    "nmid": "\u2224",
    "nshortmid": "\u2224",
    "nsmid": "\u2224",
    "Nscr": "\u{1D4A9}",
    "Ntilde": "\xD1",
    "Nu": "\u039D",
    "OElig": "\u0152",
    "Oacute": "\xD3",
    "Ocirc": "\xD4",
    "Ocy": "\u041E",
    "Odblac": "\u0150",
    "Ofr": "\u{1D512}",
    "Ograve": "\xD2",
    "Omacr": "\u014C",
    "Omega": "\u03A9",
    "ohm": "\u03A9",
    "Omicron": "\u039F",
    "Oopf": "\u{1D546}",
    "OpenCurlyDoubleQuote": "\u201C",
    "ldquo": "\u201C",
    "OpenCurlyQuote": "\u2018",
    "lsquo": "\u2018",
    "Or": "\u2A54",
    "Oscr": "\u{1D4AA}",
    "Oslash": "\xD8",
    "Otilde": "\xD5",
    "Otimes": "\u2A37",
    "Ouml": "\xD6",
    "OverBar": "\u203E",
    "oline": "\u203E",
    "OverBrace": "\u23DE",
    "OverBracket": "\u23B4",
    "tbrk": "\u23B4",
    "OverParenthesis": "\u23DC",
    "PartialD": "\u2202",
    "part": "\u2202",
    "Pcy": "\u041F",
    "Pfr": "\u{1D513}",
    "Phi": "\u03A6",
    "Pi": "\u03A0",
    "PlusMinus": "\xB1",
    "plusmn": "\xB1",
    "pm": "\xB1",
    "Popf": "\u2119",
    "primes": "\u2119",
    "Pr": "\u2ABB",
    "Precedes": "\u227A",
    "pr": "\u227A",
    "prec": "\u227A",
    "PrecedesEqual": "\u2AAF",
    "pre": "\u2AAF",
    "preceq": "\u2AAF",
    "PrecedesSlantEqual": "\u227C",
    "prcue": "\u227C",
    "preccurlyeq": "\u227C",
    "PrecedesTilde": "\u227E",
    "precsim": "\u227E",
    "prsim": "\u227E",
    "Prime": "\u2033",
    "Product": "\u220F",
    "prod": "\u220F",
    "Proportional": "\u221D",
    "prop": "\u221D",
    "propto": "\u221D",
    "varpropto": "\u221D",
    "vprop": "\u221D",
    "Pscr": "\u{1D4AB}",
    "Psi": "\u03A8",
    "QUOT": '"',
    "quot": '"',
    "Qfr": "\u{1D514}",
    "Qopf": "\u211A",
    "rationals": "\u211A",
    "Qscr": "\u{1D4AC}",
    "RBarr": "\u2910",
    "drbkarow": "\u2910",
    "REG": "\xAE",
    "circledR": "\xAE",
    "reg": "\xAE",
    "Racute": "\u0154",
    "Rang": "\u27EB",
    "Rarr": "\u21A0",
    "twoheadrightarrow": "\u21A0",
    "Rarrtl": "\u2916",
    "Rcaron": "\u0158",
    "Rcedil": "\u0156",
    "Rcy": "\u0420",
    "Re": "\u211C",
    "Rfr": "\u211C",
    "real": "\u211C",
    "realpart": "\u211C",
    "ReverseElement": "\u220B",
    "SuchThat": "\u220B",
    "ni": "\u220B",
    "niv": "\u220B",
    "ReverseEquilibrium": "\u21CB",
    "leftrightharpoons": "\u21CB",
    "lrhar": "\u21CB",
    "ReverseUpEquilibrium": "\u296F",
    "duhar": "\u296F",
    "Rho": "\u03A1",
    "RightAngleBracket": "\u27E9",
    "rang": "\u27E9",
    "rangle": "\u27E9",
    "RightArrow": "\u2192",
    "ShortRightArrow": "\u2192",
    "rarr": "\u2192",
    "rightarrow": "\u2192",
    "srarr": "\u2192",
    "RightArrowBar": "\u21E5",
    "rarrb": "\u21E5",
    "RightArrowLeftArrow": "\u21C4",
    "rightleftarrows": "\u21C4",
    "rlarr": "\u21C4",
    "RightCeiling": "\u2309",
    "rceil": "\u2309",
    "RightDoubleBracket": "\u27E7",
    "robrk": "\u27E7",
    "RightDownTeeVector": "\u295D",
    "RightDownVector": "\u21C2",
    "dharr": "\u21C2",
    "downharpoonright": "\u21C2",
    "RightDownVectorBar": "\u2955",
    "RightFloor": "\u230B",
    "rfloor": "\u230B",
    "RightTee": "\u22A2",
    "vdash": "\u22A2",
    "RightTeeArrow": "\u21A6",
    "map": "\u21A6",
    "mapsto": "\u21A6",
    "RightTeeVector": "\u295B",
    "RightTriangle": "\u22B3",
    "vartriangleright": "\u22B3",
    "vrtri": "\u22B3",
    "RightTriangleBar": "\u29D0",
    "RightTriangleEqual": "\u22B5",
    "rtrie": "\u22B5",
    "trianglerighteq": "\u22B5",
    "RightUpDownVector": "\u294F",
    "RightUpTeeVector": "\u295C",
    "RightUpVector": "\u21BE",
    "uharr": "\u21BE",
    "upharpoonright": "\u21BE",
    "RightUpVectorBar": "\u2954",
    "RightVector": "\u21C0",
    "rharu": "\u21C0",
    "rightharpoonup": "\u21C0",
    "RightVectorBar": "\u2953",
    "Ropf": "\u211D",
    "reals": "\u211D",
    "RoundImplies": "\u2970",
    "Rrightarrow": "\u21DB",
    "rAarr": "\u21DB",
    "Rscr": "\u211B",
    "realine": "\u211B",
    "Rsh": "\u21B1",
    "rsh": "\u21B1",
    "RuleDelayed": "\u29F4",
    "SHCHcy": "\u0429",
    "SHcy": "\u0428",
    "SOFTcy": "\u042C",
    "Sacute": "\u015A",
    "Sc": "\u2ABC",
    "Scaron": "\u0160",
    "Scedil": "\u015E",
    "Scirc": "\u015C",
    "Scy": "\u0421",
    "Sfr": "\u{1D516}",
    "ShortUpArrow": "\u2191",
    "UpArrow": "\u2191",
    "uarr": "\u2191",
    "uparrow": "\u2191",
    "Sigma": "\u03A3",
    "SmallCircle": "\u2218",
    "compfn": "\u2218",
    "Sopf": "\u{1D54A}",
    "Sqrt": "\u221A",
    "radic": "\u221A",
    "Square": "\u25A1",
    "squ": "\u25A1",
    "square": "\u25A1",
    "SquareIntersection": "\u2293",
    "sqcap": "\u2293",
    "SquareSubset": "\u228F",
    "sqsub": "\u228F",
    "sqsubset": "\u228F",
    "SquareSubsetEqual": "\u2291",
    "sqsube": "\u2291",
    "sqsubseteq": "\u2291",
    "SquareSuperset": "\u2290",
    "sqsup": "\u2290",
    "sqsupset": "\u2290",
    "SquareSupersetEqual": "\u2292",
    "sqsupe": "\u2292",
    "sqsupseteq": "\u2292",
    "SquareUnion": "\u2294",
    "sqcup": "\u2294",
    "Sscr": "\u{1D4AE}",
    "Star": "\u22C6",
    "sstarf": "\u22C6",
    "Sub": "\u22D0",
    "Subset": "\u22D0",
    "SubsetEqual": "\u2286",
    "sube": "\u2286",
    "subseteq": "\u2286",
    "Succeeds": "\u227B",
    "sc": "\u227B",
    "succ": "\u227B",
    "SucceedsEqual": "\u2AB0",
    "sce": "\u2AB0",
    "succeq": "\u2AB0",
    "SucceedsSlantEqual": "\u227D",
    "sccue": "\u227D",
    "succcurlyeq": "\u227D",
    "SucceedsTilde": "\u227F",
    "scsim": "\u227F",
    "succsim": "\u227F",
    "Sum": "\u2211",
    "sum": "\u2211",
    "Sup": "\u22D1",
    "Supset": "\u22D1",
    "Superset": "\u2283",
    "sup": "\u2283",
    "supset": "\u2283",
    "SupersetEqual": "\u2287",
    "supe": "\u2287",
    "supseteq": "\u2287",
    "THORN": "\xDE",
    "TRADE": "\u2122",
    "trade": "\u2122",
    "TSHcy": "\u040B",
    "TScy": "\u0426",
    "Tab": "	",
    "Tau": "\u03A4",
    "Tcaron": "\u0164",
    "Tcedil": "\u0162",
    "Tcy": "\u0422",
    "Tfr": "\u{1D517}",
    "Therefore": "\u2234",
    "there4": "\u2234",
    "therefore": "\u2234",
    "Theta": "\u0398",
    "ThickSpace": "\u205F\u200A",
    "ThinSpace": "\u2009",
    "thinsp": "\u2009",
    "Tilde": "\u223C",
    "sim": "\u223C",
    "thicksim": "\u223C",
    "thksim": "\u223C",
    "TildeEqual": "\u2243",
    "sime": "\u2243",
    "simeq": "\u2243",
    "TildeFullEqual": "\u2245",
    "cong": "\u2245",
    "TildeTilde": "\u2248",
    "ap": "\u2248",
    "approx": "\u2248",
    "asymp": "\u2248",
    "thickapprox": "\u2248",
    "thkap": "\u2248",
    "Topf": "\u{1D54B}",
    "TripleDot": "\u20DB",
    "tdot": "\u20DB",
    "Tscr": "\u{1D4AF}",
    "Tstrok": "\u0166",
    "Uacute": "\xDA",
    "Uarr": "\u219F",
    "Uarrocir": "\u2949",
    "Ubrcy": "\u040E",
    "Ubreve": "\u016C",
    "Ucirc": "\xDB",
    "Ucy": "\u0423",
    "Udblac": "\u0170",
    "Ufr": "\u{1D518}",
    "Ugrave": "\xD9",
    "Umacr": "\u016A",
    "UnderBar": "_",
    "lowbar": "_",
    "UnderBrace": "\u23DF",
    "UnderBracket": "\u23B5",
    "bbrk": "\u23B5",
    "UnderParenthesis": "\u23DD",
    "Union": "\u22C3",
    "bigcup": "\u22C3",
    "xcup": "\u22C3",
    "UnionPlus": "\u228E",
    "uplus": "\u228E",
    "Uogon": "\u0172",
    "Uopf": "\u{1D54C}",
    "UpArrowBar": "\u2912",
    "UpArrowDownArrow": "\u21C5",
    "udarr": "\u21C5",
    "UpDownArrow": "\u2195",
    "updownarrow": "\u2195",
    "varr": "\u2195",
    "UpEquilibrium": "\u296E",
    "udhar": "\u296E",
    "UpTee": "\u22A5",
    "bot": "\u22A5",
    "bottom": "\u22A5",
    "perp": "\u22A5",
    "UpTeeArrow": "\u21A5",
    "mapstoup": "\u21A5",
    "UpperLeftArrow": "\u2196",
    "nwarr": "\u2196",
    "nwarrow": "\u2196",
    "UpperRightArrow": "\u2197",
    "nearr": "\u2197",
    "nearrow": "\u2197",
    "Upsi": "\u03D2",
    "upsih": "\u03D2",
    "Upsilon": "\u03A5",
    "Uring": "\u016E",
    "Uscr": "\u{1D4B0}",
    "Utilde": "\u0168",
    "Uuml": "\xDC",
    "VDash": "\u22AB",
    "Vbar": "\u2AEB",
    "Vcy": "\u0412",
    "Vdash": "\u22A9",
    "Vdashl": "\u2AE6",
    "Vee": "\u22C1",
    "bigvee": "\u22C1",
    "xvee": "\u22C1",
    "Verbar": "\u2016",
    "Vert": "\u2016",
    "VerticalBar": "\u2223",
    "mid": "\u2223",
    "shortmid": "\u2223",
    "smid": "\u2223",
    "VerticalLine": "|",
    "verbar": "|",
    "vert": "|",
    "VerticalSeparator": "\u2758",
    "VerticalTilde": "\u2240",
    "wr": "\u2240",
    "wreath": "\u2240",
    "VeryThinSpace": "\u200A",
    "hairsp": "\u200A",
    "Vfr": "\u{1D519}",
    "Vopf": "\u{1D54D}",
    "Vscr": "\u{1D4B1}",
    "Vvdash": "\u22AA",
    "Wcirc": "\u0174",
    "Wedge": "\u22C0",
    "bigwedge": "\u22C0",
    "xwedge": "\u22C0",
    "Wfr": "\u{1D51A}",
    "Wopf": "\u{1D54E}",
    "Wscr": "\u{1D4B2}",
    "Xfr": "\u{1D51B}",
    "Xi": "\u039E",
    "Xopf": "\u{1D54F}",
    "Xscr": "\u{1D4B3}",
    "YAcy": "\u042F",
    "YIcy": "\u0407",
    "YUcy": "\u042E",
    "Yacute": "\xDD",
    "Ycirc": "\u0176",
    "Ycy": "\u042B",
    "Yfr": "\u{1D51C}",
    "Yopf": "\u{1D550}",
    "Yscr": "\u{1D4B4}",
    "Yuml": "\u0178",
    "ZHcy": "\u0416",
    "Zacute": "\u0179",
    "Zcaron": "\u017D",
    "Zcy": "\u0417",
    "Zdot": "\u017B",
    "Zeta": "\u0396",
    "Zfr": "\u2128",
    "zeetrf": "\u2128",
    "Zopf": "\u2124",
    "integers": "\u2124",
    "Zscr": "\u{1D4B5}",
    "aacute": "\xE1",
    "abreve": "\u0103",
    "ac": "\u223E",
    "mstpos": "\u223E",
    "acE": "\u223E\u0333",
    "acd": "\u223F",
    "acirc": "\xE2",
    "acy": "\u0430",
    "aelig": "\xE6",
    "afr": "\u{1D51E}",
    "agrave": "\xE0",
    "alefsym": "\u2135",
    "aleph": "\u2135",
    "alpha": "\u03B1",
    "amacr": "\u0101",
    "amalg": "\u2A3F",
    "and": "\u2227",
    "wedge": "\u2227",
    "andand": "\u2A55",
    "andd": "\u2A5C",
    "andslope": "\u2A58",
    "andv": "\u2A5A",
    "ang": "\u2220",
    "angle": "\u2220",
    "ange": "\u29A4",
    "angmsd": "\u2221",
    "measuredangle": "\u2221",
    "angmsdaa": "\u29A8",
    "angmsdab": "\u29A9",
    "angmsdac": "\u29AA",
    "angmsdad": "\u29AB",
    "angmsdae": "\u29AC",
    "angmsdaf": "\u29AD",
    "angmsdag": "\u29AE",
    "angmsdah": "\u29AF",
    "angrt": "\u221F",
    "angrtvb": "\u22BE",
    "angrtvbd": "\u299D",
    "angsph": "\u2222",
    "angzarr": "\u237C",
    "aogon": "\u0105",
    "aopf": "\u{1D552}",
    "apE": "\u2A70",
    "apacir": "\u2A6F",
    "ape": "\u224A",
    "approxeq": "\u224A",
    "apid": "\u224B",
    "apos": "'",
    "aring": "\xE5",
    "ascr": "\u{1D4B6}",
    "ast": "*",
    "midast": "*",
    "atilde": "\xE3",
    "auml": "\xE4",
    "awint": "\u2A11",
    "bNot": "\u2AED",
    "backcong": "\u224C",
    "bcong": "\u224C",
    "backepsilon": "\u03F6",
    "bepsi": "\u03F6",
    "backprime": "\u2035",
    "bprime": "\u2035",
    "backsim": "\u223D",
    "bsim": "\u223D",
    "backsimeq": "\u22CD",
    "bsime": "\u22CD",
    "barvee": "\u22BD",
    "barwed": "\u2305",
    "barwedge": "\u2305",
    "bbrktbrk": "\u23B6",
    "bcy": "\u0431",
    "bdquo": "\u201E",
    "ldquor": "\u201E",
    "bemptyv": "\u29B0",
    "beta": "\u03B2",
    "beth": "\u2136",
    "between": "\u226C",
    "twixt": "\u226C",
    "bfr": "\u{1D51F}",
    "bigcirc": "\u25EF",
    "xcirc": "\u25EF",
    "bigodot": "\u2A00",
    "xodot": "\u2A00",
    "bigoplus": "\u2A01",
    "xoplus": "\u2A01",
    "bigotimes": "\u2A02",
    "xotime": "\u2A02",
    "bigsqcup": "\u2A06",
    "xsqcup": "\u2A06",
    "bigstar": "\u2605",
    "starf": "\u2605",
    "bigtriangledown": "\u25BD",
    "xdtri": "\u25BD",
    "bigtriangleup": "\u25B3",
    "xutri": "\u25B3",
    "biguplus": "\u2A04",
    "xuplus": "\u2A04",
    "bkarow": "\u290D",
    "rbarr": "\u290D",
    "blacklozenge": "\u29EB",
    "lozf": "\u29EB",
    "blacktriangle": "\u25B4",
    "utrif": "\u25B4",
    "blacktriangledown": "\u25BE",
    "dtrif": "\u25BE",
    "blacktriangleleft": "\u25C2",
    "ltrif": "\u25C2",
    "blacktriangleright": "\u25B8",
    "rtrif": "\u25B8",
    "blank": "\u2423",
    "blk12": "\u2592",
    "blk14": "\u2591",
    "blk34": "\u2593",
    "block": "\u2588",
    "bne": "=\u20E5",
    "bnequiv": "\u2261\u20E5",
    "bnot": "\u2310",
    "bopf": "\u{1D553}",
    "bowtie": "\u22C8",
    "boxDL": "\u2557",
    "boxDR": "\u2554",
    "boxDl": "\u2556",
    "boxDr": "\u2553",
    "boxH": "\u2550",
    "boxHD": "\u2566",
    "boxHU": "\u2569",
    "boxHd": "\u2564",
    "boxHu": "\u2567",
    "boxUL": "\u255D",
    "boxUR": "\u255A",
    "boxUl": "\u255C",
    "boxUr": "\u2559",
    "boxV": "\u2551",
    "boxVH": "\u256C",
    "boxVL": "\u2563",
    "boxVR": "\u2560",
    "boxVh": "\u256B",
    "boxVl": "\u2562",
    "boxVr": "\u255F",
    "boxbox": "\u29C9",
    "boxdL": "\u2555",
    "boxdR": "\u2552",
    "boxdl": "\u2510",
    "boxdr": "\u250C",
    "boxhD": "\u2565",
    "boxhU": "\u2568",
    "boxhd": "\u252C",
    "boxhu": "\u2534",
    "boxminus": "\u229F",
    "minusb": "\u229F",
    "boxplus": "\u229E",
    "plusb": "\u229E",
    "boxtimes": "\u22A0",
    "timesb": "\u22A0",
    "boxuL": "\u255B",
    "boxuR": "\u2558",
    "boxul": "\u2518",
    "boxur": "\u2514",
    "boxv": "\u2502",
    "boxvH": "\u256A",
    "boxvL": "\u2561",
    "boxvR": "\u255E",
    "boxvh": "\u253C",
    "boxvl": "\u2524",
    "boxvr": "\u251C",
    "brvbar": "\xA6",
    "bscr": "\u{1D4B7}",
    "bsemi": "\u204F",
    "bsol": "\\",
    "bsolb": "\u29C5",
    "bsolhsub": "\u27C8",
    "bull": "\u2022",
    "bullet": "\u2022",
    "bumpE": "\u2AAE",
    "cacute": "\u0107",
    "cap": "\u2229",
    "capand": "\u2A44",
    "capbrcup": "\u2A49",
    "capcap": "\u2A4B",
    "capcup": "\u2A47",
    "capdot": "\u2A40",
    "caps": "\u2229\uFE00",
    "caret": "\u2041",
    "ccaps": "\u2A4D",
    "ccaron": "\u010D",
    "ccedil": "\xE7",
    "ccirc": "\u0109",
    "ccups": "\u2A4C",
    "ccupssm": "\u2A50",
    "cdot": "\u010B",
    "cemptyv": "\u29B2",
    "cent": "\xA2",
    "cfr": "\u{1D520}",
    "chcy": "\u0447",
    "check": "\u2713",
    "checkmark": "\u2713",
    "chi": "\u03C7",
    "cir": "\u25CB",
    "cirE": "\u29C3",
    "circ": "\u02C6",
    "circeq": "\u2257",
    "cire": "\u2257",
    "circlearrowleft": "\u21BA",
    "olarr": "\u21BA",
    "circlearrowright": "\u21BB",
    "orarr": "\u21BB",
    "circledS": "\u24C8",
    "oS": "\u24C8",
    "circledast": "\u229B",
    "oast": "\u229B",
    "circledcirc": "\u229A",
    "ocir": "\u229A",
    "circleddash": "\u229D",
    "odash": "\u229D",
    "cirfnint": "\u2A10",
    "cirmid": "\u2AEF",
    "cirscir": "\u29C2",
    "clubs": "\u2663",
    "clubsuit": "\u2663",
    "colon": ":",
    "comma": ",",
    "commat": "@",
    "comp": "\u2201",
    "complement": "\u2201",
    "congdot": "\u2A6D",
    "copf": "\u{1D554}",
    "copysr": "\u2117",
    "crarr": "\u21B5",
    "cross": "\u2717",
    "cscr": "\u{1D4B8}",
    "csub": "\u2ACF",
    "csube": "\u2AD1",
    "csup": "\u2AD0",
    "csupe": "\u2AD2",
    "ctdot": "\u22EF",
    "cudarrl": "\u2938",
    "cudarrr": "\u2935",
    "cuepr": "\u22DE",
    "curlyeqprec": "\u22DE",
    "cuesc": "\u22DF",
    "curlyeqsucc": "\u22DF",
    "cularr": "\u21B6",
    "curvearrowleft": "\u21B6",
    "cularrp": "\u293D",
    "cup": "\u222A",
    "cupbrcap": "\u2A48",
    "cupcap": "\u2A46",
    "cupcup": "\u2A4A",
    "cupdot": "\u228D",
    "cupor": "\u2A45",
    "cups": "\u222A\uFE00",
    "curarr": "\u21B7",
    "curvearrowright": "\u21B7",
    "curarrm": "\u293C",
    "curlyvee": "\u22CE",
    "cuvee": "\u22CE",
    "curlywedge": "\u22CF",
    "cuwed": "\u22CF",
    "curren": "\xA4",
    "cwint": "\u2231",
    "cylcty": "\u232D",
    "dHar": "\u2965",
    "dagger": "\u2020",
    "daleth": "\u2138",
    "dash": "\u2010",
    "hyphen": "\u2010",
    "dbkarow": "\u290F",
    "rBarr": "\u290F",
    "dcaron": "\u010F",
    "dcy": "\u0434",
    "ddarr": "\u21CA",
    "downdownarrows": "\u21CA",
    "ddotseq": "\u2A77",
    "eDDot": "\u2A77",
    "deg": "\xB0",
    "delta": "\u03B4",
    "demptyv": "\u29B1",
    "dfisht": "\u297F",
    "dfr": "\u{1D521}",
    "diamondsuit": "\u2666",
    "diams": "\u2666",
    "digamma": "\u03DD",
    "gammad": "\u03DD",
    "disin": "\u22F2",
    "div": "\xF7",
    "divide": "\xF7",
    "divideontimes": "\u22C7",
    "divonx": "\u22C7",
    "djcy": "\u0452",
    "dlcorn": "\u231E",
    "llcorner": "\u231E",
    "dlcrop": "\u230D",
    "dollar": "$",
    "dopf": "\u{1D555}",
    "doteqdot": "\u2251",
    "eDot": "\u2251",
    "dotminus": "\u2238",
    "minusd": "\u2238",
    "dotplus": "\u2214",
    "plusdo": "\u2214",
    "dotsquare": "\u22A1",
    "sdotb": "\u22A1",
    "drcorn": "\u231F",
    "lrcorner": "\u231F",
    "drcrop": "\u230C",
    "dscr": "\u{1D4B9}",
    "dscy": "\u0455",
    "dsol": "\u29F6",
    "dstrok": "\u0111",
    "dtdot": "\u22F1",
    "dtri": "\u25BF",
    "triangledown": "\u25BF",
    "dwangle": "\u29A6",
    "dzcy": "\u045F",
    "dzigrarr": "\u27FF",
    "eacute": "\xE9",
    "easter": "\u2A6E",
    "ecaron": "\u011B",
    "ecir": "\u2256",
    "eqcirc": "\u2256",
    "ecirc": "\xEA",
    "ecolon": "\u2255",
    "eqcolon": "\u2255",
    "ecy": "\u044D",
    "edot": "\u0117",
    "efDot": "\u2252",
    "fallingdotseq": "\u2252",
    "efr": "\u{1D522}",
    "eg": "\u2A9A",
    "egrave": "\xE8",
    "egs": "\u2A96",
    "eqslantgtr": "\u2A96",
    "egsdot": "\u2A98",
    "el": "\u2A99",
    "elinters": "\u23E7",
    "ell": "\u2113",
    "els": "\u2A95",
    "eqslantless": "\u2A95",
    "elsdot": "\u2A97",
    "emacr": "\u0113",
    "empty": "\u2205",
    "emptyset": "\u2205",
    "emptyv": "\u2205",
    "varnothing": "\u2205",
    "emsp13": "\u2004",
    "emsp14": "\u2005",
    "emsp": "\u2003",
    "eng": "\u014B",
    "ensp": "\u2002",
    "eogon": "\u0119",
    "eopf": "\u{1D556}",
    "epar": "\u22D5",
    "eparsl": "\u29E3",
    "eplus": "\u2A71",
    "epsi": "\u03B5",
    "epsilon": "\u03B5",
    "epsiv": "\u03F5",
    "straightepsilon": "\u03F5",
    "varepsilon": "\u03F5",
    "equals": "=",
    "equest": "\u225F",
    "questeq": "\u225F",
    "equivDD": "\u2A78",
    "eqvparsl": "\u29E5",
    "erDot": "\u2253",
    "risingdotseq": "\u2253",
    "erarr": "\u2971",
    "escr": "\u212F",
    "eta": "\u03B7",
    "eth": "\xF0",
    "euml": "\xEB",
    "euro": "\u20AC",
    "excl": "!",
    "fcy": "\u0444",
    "female": "\u2640",
    "ffilig": "\uFB03",
    "fflig": "\uFB00",
    "ffllig": "\uFB04",
    "ffr": "\u{1D523}",
    "filig": "\uFB01",
    "fjlig": "fj",
    "flat": "\u266D",
    "fllig": "\uFB02",
    "fltns": "\u25B1",
    "fnof": "\u0192",
    "fopf": "\u{1D557}",
    "fork": "\u22D4",
    "pitchfork": "\u22D4",
    "forkv": "\u2AD9",
    "fpartint": "\u2A0D",
    "frac12": "\xBD",
    "half": "\xBD",
    "frac13": "\u2153",
    "frac14": "\xBC",
    "frac15": "\u2155",
    "frac16": "\u2159",
    "frac18": "\u215B",
    "frac23": "\u2154",
    "frac25": "\u2156",
    "frac34": "\xBE",
    "frac35": "\u2157",
    "frac38": "\u215C",
    "frac45": "\u2158",
    "frac56": "\u215A",
    "frac58": "\u215D",
    "frac78": "\u215E",
    "frasl": "\u2044",
    "frown": "\u2322",
    "sfrown": "\u2322",
    "fscr": "\u{1D4BB}",
    "gEl": "\u2A8C",
    "gtreqqless": "\u2A8C",
    "gacute": "\u01F5",
    "gamma": "\u03B3",
    "gap": "\u2A86",
    "gtrapprox": "\u2A86",
    "gbreve": "\u011F",
    "gcirc": "\u011D",
    "gcy": "\u0433",
    "gdot": "\u0121",
    "gescc": "\u2AA9",
    "gesdot": "\u2A80",
    "gesdoto": "\u2A82",
    "gesdotol": "\u2A84",
    "gesl": "\u22DB\uFE00",
    "gesles": "\u2A94",
    "gfr": "\u{1D524}",
    "gimel": "\u2137",
    "gjcy": "\u0453",
    "glE": "\u2A92",
    "gla": "\u2AA5",
    "glj": "\u2AA4",
    "gnE": "\u2269",
    "gneqq": "\u2269",
    "gnap": "\u2A8A",
    "gnapprox": "\u2A8A",
    "gne": "\u2A88",
    "gneq": "\u2A88",
    "gnsim": "\u22E7",
    "gopf": "\u{1D558}",
    "gscr": "\u210A",
    "gsime": "\u2A8E",
    "gsiml": "\u2A90",
    "gtcc": "\u2AA7",
    "gtcir": "\u2A7A",
    "gtdot": "\u22D7",
    "gtrdot": "\u22D7",
    "gtlPar": "\u2995",
    "gtquest": "\u2A7C",
    "gtrarr": "\u2978",
    "gvertneqq": "\u2269\uFE00",
    "gvnE": "\u2269\uFE00",
    "hardcy": "\u044A",
    "harrcir": "\u2948",
    "harrw": "\u21AD",
    "leftrightsquigarrow": "\u21AD",
    "hbar": "\u210F",
    "hslash": "\u210F",
    "planck": "\u210F",
    "plankv": "\u210F",
    "hcirc": "\u0125",
    "hearts": "\u2665",
    "heartsuit": "\u2665",
    "hellip": "\u2026",
    "mldr": "\u2026",
    "hercon": "\u22B9",
    "hfr": "\u{1D525}",
    "hksearow": "\u2925",
    "searhk": "\u2925",
    "hkswarow": "\u2926",
    "swarhk": "\u2926",
    "hoarr": "\u21FF",
    "homtht": "\u223B",
    "hookleftarrow": "\u21A9",
    "larrhk": "\u21A9",
    "hookrightarrow": "\u21AA",
    "rarrhk": "\u21AA",
    "hopf": "\u{1D559}",
    "horbar": "\u2015",
    "hscr": "\u{1D4BD}",
    "hstrok": "\u0127",
    "hybull": "\u2043",
    "iacute": "\xED",
    "icirc": "\xEE",
    "icy": "\u0438",
    "iecy": "\u0435",
    "iexcl": "\xA1",
    "ifr": "\u{1D526}",
    "igrave": "\xEC",
    "iiiint": "\u2A0C",
    "qint": "\u2A0C",
    "iiint": "\u222D",
    "tint": "\u222D",
    "iinfin": "\u29DC",
    "iiota": "\u2129",
    "ijlig": "\u0133",
    "imacr": "\u012B",
    "imath": "\u0131",
    "inodot": "\u0131",
    "imof": "\u22B7",
    "imped": "\u01B5",
    "incare": "\u2105",
    "infin": "\u221E",
    "infintie": "\u29DD",
    "intcal": "\u22BA",
    "intercal": "\u22BA",
    "intlarhk": "\u2A17",
    "intprod": "\u2A3C",
    "iprod": "\u2A3C",
    "iocy": "\u0451",
    "iogon": "\u012F",
    "iopf": "\u{1D55A}",
    "iota": "\u03B9",
    "iquest": "\xBF",
    "iscr": "\u{1D4BE}",
    "isinE": "\u22F9",
    "isindot": "\u22F5",
    "isins": "\u22F4",
    "isinsv": "\u22F3",
    "itilde": "\u0129",
    "iukcy": "\u0456",
    "iuml": "\xEF",
    "jcirc": "\u0135",
    "jcy": "\u0439",
    "jfr": "\u{1D527}",
    "jmath": "\u0237",
    "jopf": "\u{1D55B}",
    "jscr": "\u{1D4BF}",
    "jsercy": "\u0458",
    "jukcy": "\u0454",
    "kappa": "\u03BA",
    "kappav": "\u03F0",
    "varkappa": "\u03F0",
    "kcedil": "\u0137",
    "kcy": "\u043A",
    "kfr": "\u{1D528}",
    "kgreen": "\u0138",
    "khcy": "\u0445",
    "kjcy": "\u045C",
    "kopf": "\u{1D55C}",
    "kscr": "\u{1D4C0}",
    "lAtail": "\u291B",
    "lBarr": "\u290E",
    "lEg": "\u2A8B",
    "lesseqqgtr": "\u2A8B",
    "lHar": "\u2962",
    "lacute": "\u013A",
    "laemptyv": "\u29B4",
    "lambda": "\u03BB",
    "langd": "\u2991",
    "lap": "\u2A85",
    "lessapprox": "\u2A85",
    "laquo": "\xAB",
    "larrbfs": "\u291F",
    "larrfs": "\u291D",
    "larrlp": "\u21AB",
    "looparrowleft": "\u21AB",
    "larrpl": "\u2939",
    "larrsim": "\u2973",
    "larrtl": "\u21A2",
    "leftarrowtail": "\u21A2",
    "lat": "\u2AAB",
    "latail": "\u2919",
    "late": "\u2AAD",
    "lates": "\u2AAD\uFE00",
    "lbarr": "\u290C",
    "lbbrk": "\u2772",
    "lbrace": "{",
    "lcub": "{",
    "lbrack": "[",
    "lsqb": "[",
    "lbrke": "\u298B",
    "lbrksld": "\u298F",
    "lbrkslu": "\u298D",
    "lcaron": "\u013E",
    "lcedil": "\u013C",
    "lcy": "\u043B",
    "ldca": "\u2936",
    "ldrdhar": "\u2967",
    "ldrushar": "\u294B",
    "ldsh": "\u21B2",
    "le": "\u2264",
    "leq": "\u2264",
    "leftleftarrows": "\u21C7",
    "llarr": "\u21C7",
    "leftthreetimes": "\u22CB",
    "lthree": "\u22CB",
    "lescc": "\u2AA8",
    "lesdot": "\u2A7F",
    "lesdoto": "\u2A81",
    "lesdotor": "\u2A83",
    "lesg": "\u22DA\uFE00",
    "lesges": "\u2A93",
    "lessdot": "\u22D6",
    "ltdot": "\u22D6",
    "lfisht": "\u297C",
    "lfr": "\u{1D529}",
    "lgE": "\u2A91",
    "lharul": "\u296A",
    "lhblk": "\u2584",
    "ljcy": "\u0459",
    "llhard": "\u296B",
    "lltri": "\u25FA",
    "lmidot": "\u0140",
    "lmoust": "\u23B0",
    "lmoustache": "\u23B0",
    "lnE": "\u2268",
    "lneqq": "\u2268",
    "lnap": "\u2A89",
    "lnapprox": "\u2A89",
    "lne": "\u2A87",
    "lneq": "\u2A87",
    "lnsim": "\u22E6",
    "loang": "\u27EC",
    "loarr": "\u21FD",
    "longmapsto": "\u27FC",
    "xmap": "\u27FC",
    "looparrowright": "\u21AC",
    "rarrlp": "\u21AC",
    "lopar": "\u2985",
    "lopf": "\u{1D55D}",
    "loplus": "\u2A2D",
    "lotimes": "\u2A34",
    "lowast": "\u2217",
    "loz": "\u25CA",
    "lozenge": "\u25CA",
    "lpar": "(",
    "lparlt": "\u2993",
    "lrhard": "\u296D",
    "lrm": "\u200E",
    "lrtri": "\u22BF",
    "lsaquo": "\u2039",
    "lscr": "\u{1D4C1}",
    "lsime": "\u2A8D",
    "lsimg": "\u2A8F",
    "lsquor": "\u201A",
    "sbquo": "\u201A",
    "lstrok": "\u0142",
    "ltcc": "\u2AA6",
    "ltcir": "\u2A79",
    "ltimes": "\u22C9",
    "ltlarr": "\u2976",
    "ltquest": "\u2A7B",
    "ltrPar": "\u2996",
    "ltri": "\u25C3",
    "triangleleft": "\u25C3",
    "lurdshar": "\u294A",
    "luruhar": "\u2966",
    "lvertneqq": "\u2268\uFE00",
    "lvnE": "\u2268\uFE00",
    "mDDot": "\u223A",
    "macr": "\xAF",
    "strns": "\xAF",
    "male": "\u2642",
    "malt": "\u2720",
    "maltese": "\u2720",
    "marker": "\u25AE",
    "mcomma": "\u2A29",
    "mcy": "\u043C",
    "mdash": "\u2014",
    "mfr": "\u{1D52A}",
    "mho": "\u2127",
    "micro": "\xB5",
    "midcir": "\u2AF0",
    "minus": "\u2212",
    "minusdu": "\u2A2A",
    "mlcp": "\u2ADB",
    "models": "\u22A7",
    "mopf": "\u{1D55E}",
    "mscr": "\u{1D4C2}",
    "mu": "\u03BC",
    "multimap": "\u22B8",
    "mumap": "\u22B8",
    "nGg": "\u22D9\u0338",
    "nGt": "\u226B\u20D2",
    "nLeftarrow": "\u21CD",
    "nlArr": "\u21CD",
    "nLeftrightarrow": "\u21CE",
    "nhArr": "\u21CE",
    "nLl": "\u22D8\u0338",
    "nLt": "\u226A\u20D2",
    "nRightarrow": "\u21CF",
    "nrArr": "\u21CF",
    "nVDash": "\u22AF",
    "nVdash": "\u22AE",
    "nacute": "\u0144",
    "nang": "\u2220\u20D2",
    "napE": "\u2A70\u0338",
    "napid": "\u224B\u0338",
    "napos": "\u0149",
    "natur": "\u266E",
    "natural": "\u266E",
    "ncap": "\u2A43",
    "ncaron": "\u0148",
    "ncedil": "\u0146",
    "ncongdot": "\u2A6D\u0338",
    "ncup": "\u2A42",
    "ncy": "\u043D",
    "ndash": "\u2013",
    "neArr": "\u21D7",
    "nearhk": "\u2924",
    "nedot": "\u2250\u0338",
    "nesear": "\u2928",
    "toea": "\u2928",
    "nfr": "\u{1D52B}",
    "nharr": "\u21AE",
    "nleftrightarrow": "\u21AE",
    "nhpar": "\u2AF2",
    "nis": "\u22FC",
    "nisd": "\u22FA",
    "njcy": "\u045A",
    "nlE": "\u2266\u0338",
    "nleqq": "\u2266\u0338",
    "nlarr": "\u219A",
    "nleftarrow": "\u219A",
    "nldr": "\u2025",
    "nopf": "\u{1D55F}",
    "not": "\xAC",
    "notinE": "\u22F9\u0338",
    "notindot": "\u22F5\u0338",
    "notinvb": "\u22F7",
    "notinvc": "\u22F6",
    "notnivb": "\u22FE",
    "notnivc": "\u22FD",
    "nparsl": "\u2AFD\u20E5",
    "npart": "\u2202\u0338",
    "npolint": "\u2A14",
    "nrarr": "\u219B",
    "nrightarrow": "\u219B",
    "nrarrc": "\u2933\u0338",
    "nrarrw": "\u219D\u0338",
    "nscr": "\u{1D4C3}",
    "nsub": "\u2284",
    "nsubE": "\u2AC5\u0338",
    "nsubseteqq": "\u2AC5\u0338",
    "nsup": "\u2285",
    "nsupE": "\u2AC6\u0338",
    "nsupseteqq": "\u2AC6\u0338",
    "ntilde": "\xF1",
    "nu": "\u03BD",
    "num": "#",
    "numero": "\u2116",
    "numsp": "\u2007",
    "nvDash": "\u22AD",
    "nvHarr": "\u2904",
    "nvap": "\u224D\u20D2",
    "nvdash": "\u22AC",
    "nvge": "\u2265\u20D2",
    "nvgt": ">\u20D2",
    "nvinfin": "\u29DE",
    "nvlArr": "\u2902",
    "nvle": "\u2264\u20D2",
    "nvlt": "<\u20D2",
    "nvltrie": "\u22B4\u20D2",
    "nvrArr": "\u2903",
    "nvrtrie": "\u22B5\u20D2",
    "nvsim": "\u223C\u20D2",
    "nwArr": "\u21D6",
    "nwarhk": "\u2923",
    "nwnear": "\u2927",
    "oacute": "\xF3",
    "ocirc": "\xF4",
    "ocy": "\u043E",
    "odblac": "\u0151",
    "odiv": "\u2A38",
    "odsold": "\u29BC",
    "oelig": "\u0153",
    "ofcir": "\u29BF",
    "ofr": "\u{1D52C}",
    "ogon": "\u02DB",
    "ograve": "\xF2",
    "ogt": "\u29C1",
    "ohbar": "\u29B5",
    "olcir": "\u29BE",
    "olcross": "\u29BB",
    "olt": "\u29C0",
    "omacr": "\u014D",
    "omega": "\u03C9",
    "omicron": "\u03BF",
    "omid": "\u29B6",
    "oopf": "\u{1D560}",
    "opar": "\u29B7",
    "operp": "\u29B9",
    "or": "\u2228",
    "vee": "\u2228",
    "ord": "\u2A5D",
    "order": "\u2134",
    "orderof": "\u2134",
    "oscr": "\u2134",
    "ordf": "\xAA",
    "ordm": "\xBA",
    "origof": "\u22B6",
    "oror": "\u2A56",
    "orslope": "\u2A57",
    "orv": "\u2A5B",
    "oslash": "\xF8",
    "osol": "\u2298",
    "otilde": "\xF5",
    "otimesas": "\u2A36",
    "ouml": "\xF6",
    "ovbar": "\u233D",
    "para": "\xB6",
    "parsim": "\u2AF3",
    "parsl": "\u2AFD",
    "pcy": "\u043F",
    "percnt": "%",
    "period": ".",
    "permil": "\u2030",
    "pertenk": "\u2031",
    "pfr": "\u{1D52D}",
    "phi": "\u03C6",
    "phiv": "\u03D5",
    "straightphi": "\u03D5",
    "varphi": "\u03D5",
    "phone": "\u260E",
    "pi": "\u03C0",
    "piv": "\u03D6",
    "varpi": "\u03D6",
    "planckh": "\u210E",
    "plus": "+",
    "plusacir": "\u2A23",
    "pluscir": "\u2A22",
    "plusdu": "\u2A25",
    "pluse": "\u2A72",
    "plussim": "\u2A26",
    "plustwo": "\u2A27",
    "pointint": "\u2A15",
    "popf": "\u{1D561}",
    "pound": "\xA3",
    "prE": "\u2AB3",
    "prap": "\u2AB7",
    "precapprox": "\u2AB7",
    "precnapprox": "\u2AB9",
    "prnap": "\u2AB9",
    "precneqq": "\u2AB5",
    "prnE": "\u2AB5",
    "precnsim": "\u22E8",
    "prnsim": "\u22E8",
    "prime": "\u2032",
    "profalar": "\u232E",
    "profline": "\u2312",
    "profsurf": "\u2313",
    "prurel": "\u22B0",
    "pscr": "\u{1D4C5}",
    "psi": "\u03C8",
    "puncsp": "\u2008",
    "qfr": "\u{1D52E}",
    "qopf": "\u{1D562}",
    "qprime": "\u2057",
    "qscr": "\u{1D4C6}",
    "quatint": "\u2A16",
    "quest": "?",
    "rAtail": "\u291C",
    "rHar": "\u2964",
    "race": "\u223D\u0331",
    "racute": "\u0155",
    "raemptyv": "\u29B3",
    "rangd": "\u2992",
    "range": "\u29A5",
    "raquo": "\xBB",
    "rarrap": "\u2975",
    "rarrbfs": "\u2920",
    "rarrc": "\u2933",
    "rarrfs": "\u291E",
    "rarrpl": "\u2945",
    "rarrsim": "\u2974",
    "rarrtl": "\u21A3",
    "rightarrowtail": "\u21A3",
    "rarrw": "\u219D",
    "rightsquigarrow": "\u219D",
    "ratail": "\u291A",
    "ratio": "\u2236",
    "rbbrk": "\u2773",
    "rbrace": "}",
    "rcub": "}",
    "rbrack": "]",
    "rsqb": "]",
    "rbrke": "\u298C",
    "rbrksld": "\u298E",
    "rbrkslu": "\u2990",
    "rcaron": "\u0159",
    "rcedil": "\u0157",
    "rcy": "\u0440",
    "rdca": "\u2937",
    "rdldhar": "\u2969",
    "rdsh": "\u21B3",
    "rect": "\u25AD",
    "rfisht": "\u297D",
    "rfr": "\u{1D52F}",
    "rharul": "\u296C",
    "rho": "\u03C1",
    "rhov": "\u03F1",
    "varrho": "\u03F1",
    "rightrightarrows": "\u21C9",
    "rrarr": "\u21C9",
    "rightthreetimes": "\u22CC",
    "rthree": "\u22CC",
    "ring": "\u02DA",
    "rlm": "\u200F",
    "rmoust": "\u23B1",
    "rmoustache": "\u23B1",
    "rnmid": "\u2AEE",
    "roang": "\u27ED",
    "roarr": "\u21FE",
    "ropar": "\u2986",
    "ropf": "\u{1D563}",
    "roplus": "\u2A2E",
    "rotimes": "\u2A35",
    "rpar": ")",
    "rpargt": "\u2994",
    "rppolint": "\u2A12",
    "rsaquo": "\u203A",
    "rscr": "\u{1D4C7}",
    "rtimes": "\u22CA",
    "rtri": "\u25B9",
    "triangleright": "\u25B9",
    "rtriltri": "\u29CE",
    "ruluhar": "\u2968",
    "rx": "\u211E",
    "sacute": "\u015B",
    "scE": "\u2AB4",
    "scap": "\u2AB8",
    "succapprox": "\u2AB8",
    "scaron": "\u0161",
    "scedil": "\u015F",
    "scirc": "\u015D",
    "scnE": "\u2AB6",
    "succneqq": "\u2AB6",
    "scnap": "\u2ABA",
    "succnapprox": "\u2ABA",
    "scnsim": "\u22E9",
    "succnsim": "\u22E9",
    "scpolint": "\u2A13",
    "scy": "\u0441",
    "sdot": "\u22C5",
    "sdote": "\u2A66",
    "seArr": "\u21D8",
    "sect": "\xA7",
    "semi": ";",
    "seswar": "\u2929",
    "tosa": "\u2929",
    "sext": "\u2736",
    "sfr": "\u{1D530}",
    "sharp": "\u266F",
    "shchcy": "\u0449",
    "shcy": "\u0448",
    "shy": "\xAD",
    "sigma": "\u03C3",
    "sigmaf": "\u03C2",
    "sigmav": "\u03C2",
    "varsigma": "\u03C2",
    "simdot": "\u2A6A",
    "simg": "\u2A9E",
    "simgE": "\u2AA0",
    "siml": "\u2A9D",
    "simlE": "\u2A9F",
    "simne": "\u2246",
    "simplus": "\u2A24",
    "simrarr": "\u2972",
    "smashp": "\u2A33",
    "smeparsl": "\u29E4",
    "smile": "\u2323",
    "ssmile": "\u2323",
    "smt": "\u2AAA",
    "smte": "\u2AAC",
    "smtes": "\u2AAC\uFE00",
    "softcy": "\u044C",
    "sol": "/",
    "solb": "\u29C4",
    "solbar": "\u233F",
    "sopf": "\u{1D564}",
    "spades": "\u2660",
    "spadesuit": "\u2660",
    "sqcaps": "\u2293\uFE00",
    "sqcups": "\u2294\uFE00",
    "sscr": "\u{1D4C8}",
    "star": "\u2606",
    "sub": "\u2282",
    "subset": "\u2282",
    "subE": "\u2AC5",
    "subseteqq": "\u2AC5",
    "subdot": "\u2ABD",
    "subedot": "\u2AC3",
    "submult": "\u2AC1",
    "subnE": "\u2ACB",
    "subsetneqq": "\u2ACB",
    "subne": "\u228A",
    "subsetneq": "\u228A",
    "subplus": "\u2ABF",
    "subrarr": "\u2979",
    "subsim": "\u2AC7",
    "subsub": "\u2AD5",
    "subsup": "\u2AD3",
    "sung": "\u266A",
    "sup1": "\xB9",
    "sup2": "\xB2",
    "sup3": "\xB3",
    "supE": "\u2AC6",
    "supseteqq": "\u2AC6",
    "supdot": "\u2ABE",
    "supdsub": "\u2AD8",
    "supedot": "\u2AC4",
    "suphsol": "\u27C9",
    "suphsub": "\u2AD7",
    "suplarr": "\u297B",
    "supmult": "\u2AC2",
    "supnE": "\u2ACC",
    "supsetneqq": "\u2ACC",
    "supne": "\u228B",
    "supsetneq": "\u228B",
    "supplus": "\u2AC0",
    "supsim": "\u2AC8",
    "supsub": "\u2AD4",
    "supsup": "\u2AD6",
    "swArr": "\u21D9",
    "swnwar": "\u292A",
    "szlig": "\xDF",
    "target": "\u2316",
    "tau": "\u03C4",
    "tcaron": "\u0165",
    "tcedil": "\u0163",
    "tcy": "\u0442",
    "telrec": "\u2315",
    "tfr": "\u{1D531}",
    "theta": "\u03B8",
    "thetasym": "\u03D1",
    "thetav": "\u03D1",
    "vartheta": "\u03D1",
    "thorn": "\xFE",
    "times": "\xD7",
    "timesbar": "\u2A31",
    "timesd": "\u2A30",
    "topbot": "\u2336",
    "topcir": "\u2AF1",
    "topf": "\u{1D565}",
    "topfork": "\u2ADA",
    "tprime": "\u2034",
    "triangle": "\u25B5",
    "utri": "\u25B5",
    "triangleq": "\u225C",
    "trie": "\u225C",
    "tridot": "\u25EC",
    "triminus": "\u2A3A",
    "triplus": "\u2A39",
    "trisb": "\u29CD",
    "tritime": "\u2A3B",
    "trpezium": "\u23E2",
    "tscr": "\u{1D4C9}",
    "tscy": "\u0446",
    "tshcy": "\u045B",
    "tstrok": "\u0167",
    "uHar": "\u2963",
    "uacute": "\xFA",
    "ubrcy": "\u045E",
    "ubreve": "\u016D",
    "ucirc": "\xFB",
    "ucy": "\u0443",
    "udblac": "\u0171",
    "ufisht": "\u297E",
    "ufr": "\u{1D532}",
    "ugrave": "\xF9",
    "uhblk": "\u2580",
    "ulcorn": "\u231C",
    "ulcorner": "\u231C",
    "ulcrop": "\u230F",
    "ultri": "\u25F8",
    "umacr": "\u016B",
    "uogon": "\u0173",
    "uopf": "\u{1D566}",
    "upsi": "\u03C5",
    "upsilon": "\u03C5",
    "upuparrows": "\u21C8",
    "uuarr": "\u21C8",
    "urcorn": "\u231D",
    "urcorner": "\u231D",
    "urcrop": "\u230E",
    "uring": "\u016F",
    "urtri": "\u25F9",
    "uscr": "\u{1D4CA}",
    "utdot": "\u22F0",
    "utilde": "\u0169",
    "uuml": "\xFC",
    "uwangle": "\u29A7",
    "vBar": "\u2AE8",
    "vBarv": "\u2AE9",
    "vangrt": "\u299C",
    "varsubsetneq": "\u228A\uFE00",
    "vsubne": "\u228A\uFE00",
    "varsubsetneqq": "\u2ACB\uFE00",
    "vsubnE": "\u2ACB\uFE00",
    "varsupsetneq": "\u228B\uFE00",
    "vsupne": "\u228B\uFE00",
    "varsupsetneqq": "\u2ACC\uFE00",
    "vsupnE": "\u2ACC\uFE00",
    "vcy": "\u0432",
    "veebar": "\u22BB",
    "veeeq": "\u225A",
    "vellip": "\u22EE",
    "vfr": "\u{1D533}",
    "vopf": "\u{1D567}",
    "vscr": "\u{1D4CB}",
    "vzigzag": "\u299A",
    "wcirc": "\u0175",
    "wedbar": "\u2A5F",
    "wedgeq": "\u2259",
    "weierp": "\u2118",
    "wp": "\u2118",
    "wfr": "\u{1D534}",
    "wopf": "\u{1D568}",
    "wscr": "\u{1D4CC}",
    "xfr": "\u{1D535}",
    "xi": "\u03BE",
    "xnis": "\u22FB",
    "xopf": "\u{1D569}",
    "xscr": "\u{1D4CD}",
    "yacute": "\xFD",
    "yacy": "\u044F",
    "ycirc": "\u0177",
    "ycy": "\u044B",
    "yen": "\xA5",
    "yfr": "\u{1D536}",
    "yicy": "\u0457",
    "yopf": "\u{1D56A}",
    "yscr": "\u{1D4CE}",
    "yucy": "\u044E",
    "yuml": "\xFF",
    "zacute": "\u017A",
    "zcaron": "\u017E",
    "zcy": "\u0437",
    "zdot": "\u017C",
    "zeta": "\u03B6",
    "zfr": "\u{1D537}",
    "zhcy": "\u0436",
    "zigrarr": "\u21DD",
    "zopf": "\u{1D56B}",
    "zscr": "\u{1D4CF}",
    "zwj": "\u200D",
    "zwnj": "\u200C"
  };
  var NGSP_UNICODE = "\uE500";
  NAMED_ENTITIES["ngsp"] = NGSP_UNICODE;
  var TokenError = class extends ParseError {
    constructor(errorMsg, tokenType, span) {
      super(span, errorMsg);
      this.tokenType = tokenType;
    }
  };
  var TokenizeResult = class {
    constructor(tokens, errors, nonNormalizedIcuExpressions) {
      this.tokens = tokens;
      this.errors = errors;
      this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
    }
  };
  function tokenize(source, url, getTagDefinition, options = {}) {
    const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
    tokenizer.tokenize();
    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
  }
  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
    const char = charCode === $EOF ? "EOF" : String.fromCharCode(charCode);
    return `Unexpected character "${char}"`;
  }
  function _unknownEntityErrorMsg(entitySrc) {
    return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
  }
  function _unparsableEntityErrorMsg(type, entityStr) {
    return `Unable to parse entity "${entityStr}" - ${type} character reference entities must end with ";"`;
  }
  var CharacterReferenceType;
  (function(CharacterReferenceType2) {
    CharacterReferenceType2["HEX"] = "hexadecimal";
    CharacterReferenceType2["DEC"] = "decimal";
  })(CharacterReferenceType || (CharacterReferenceType = {}));
  var _ControlFlowError = class {
    constructor(error3) {
      this.error = error3;
    }
  };
  var _Tokenizer = class {
    constructor(_file, _getTagDefinition, options) {
      this._getTagDefinition = _getTagDefinition;
      this._currentTokenStart = null;
      this._currentTokenType = null;
      this._expansionCaseStack = [];
      this._inInterpolation = false;
      this.tokens = [];
      this.errors = [];
      this.nonNormalizedIcuExpressions = [];
      this._tokenizeIcu = options.tokenizeExpansionForms || false;
      this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
      this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map((c) => c.codePointAt(0) || 0);
      const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };
      this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);
      this._preserveLineEndings = options.preserveLineEndings || false;
      this._escapedString = options.escapedString || false;
      this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
      try {
        this._cursor.init();
      } catch (e) {
        this.handleError(e);
      }
    }
    _processCarriageReturns(content) {
      if (this._preserveLineEndings) {
        return content;
      }
      return content.replace(_CR_OR_CRLF_REGEXP, "\n");
    }
    tokenize() {
      while (this._cursor.peek() !== $EOF) {
        const start = this._cursor.clone();
        try {
          if (this._attemptCharCode($LT)) {
            if (this._attemptCharCode($BANG)) {
              if (this._attemptCharCode($LBRACKET)) {
                this._consumeCdata(start);
              } else if (this._attemptCharCode($MINUS)) {
                this._consumeComment(start);
              } else {
                this._consumeDocType(start);
              }
            } else if (this._attemptCharCode($SLASH)) {
              this._consumeTagClose(start);
            } else {
              this._consumeTagOpen(start);
            }
          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
            this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
          }
        } catch (e) {
          this.handleError(e);
        }
      }
      this._beginToken(24);
      this._endToken([]);
    }
    _tokenizeExpansionForm() {
      if (this.isExpansionFormStart()) {
        this._consumeExpansionFormStart();
        return true;
      }
      if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
        this._consumeExpansionCaseStart();
        return true;
      }
      if (this._cursor.peek() === $RBRACE) {
        if (this._isInExpansionCase()) {
          this._consumeExpansionCaseEnd();
          return true;
        }
        if (this._isInExpansionForm()) {
          this._consumeExpansionFormEnd();
          return true;
        }
      }
      return false;
    }
    _beginToken(type, start = this._cursor.clone()) {
      this._currentTokenStart = start;
      this._currentTokenType = type;
    }
    _endToken(parts, end) {
      if (this._currentTokenStart === null) {
        throw new TokenError("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(end));
      }
      if (this._currentTokenType === null) {
        throw new TokenError("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      }
      const token = {
        type: this._currentTokenType,
        parts,
        sourceSpan: (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)
      };
      this.tokens.push(token);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return token;
    }
    _createError(msg, span) {
      if (this._isInExpansionForm()) {
        msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
      }
      const error3 = new TokenError(msg, this._currentTokenType, span);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return new _ControlFlowError(error3);
    }
    handleError(e) {
      if (e instanceof CursorError) {
        e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
      }
      if (e instanceof _ControlFlowError) {
        this.errors.push(e.error);
      } else {
        throw e;
      }
    }
    _attemptCharCode(charCode) {
      if (this._cursor.peek() === charCode) {
        this._cursor.advance();
        return true;
      }
      return false;
    }
    _attemptCharCodeCaseInsensitive(charCode) {
      if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
        this._cursor.advance();
        return true;
      }
      return false;
    }
    _requireCharCode(charCode) {
      const location2 = this._cursor.clone();
      if (!this._attemptCharCode(charCode)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location2));
      }
    }
    _attemptStr(chars) {
      const len = chars.length;
      if (this._cursor.charsLeft() < len) {
        return false;
      }
      const initialPosition = this._cursor.clone();
      for (let i = 0; i < len; i++) {
        if (!this._attemptCharCode(chars.charCodeAt(i))) {
          this._cursor = initialPosition;
          return false;
        }
      }
      return true;
    }
    _attemptStrCaseInsensitive(chars) {
      for (let i = 0; i < chars.length; i++) {
        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    _requireStr(chars) {
      const location2 = this._cursor.clone();
      if (!this._attemptStr(chars)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location2));
      }
    }
    _attemptCharCodeUntilFn(predicate) {
      while (!predicate(this._cursor.peek())) {
        this._cursor.advance();
      }
    }
    _requireCharCodeUntilFn(predicate, len) {
      const start = this._cursor.clone();
      this._attemptCharCodeUntilFn(predicate);
      if (this._cursor.diff(start) < len) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
      }
    }
    _attemptUntilChar(char) {
      while (this._cursor.peek() !== char) {
        this._cursor.advance();
      }
    }
    _readChar() {
      const char = String.fromCodePoint(this._cursor.peek());
      this._cursor.advance();
      return char;
    }
    _consumeEntity(textTokenType) {
      this._beginToken(9);
      const start = this._cursor.clone();
      this._cursor.advance();
      if (this._attemptCharCode($HASH)) {
        const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
        const codeStart = this._cursor.clone();
        this._attemptCharCodeUntilFn(isDigitEntityEnd);
        if (this._cursor.peek() != $SEMICOLON) {
          this._cursor.advance();
          const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
          throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
        }
        const strNum = this._cursor.getChars(codeStart);
        this._cursor.advance();
        try {
          const charCode = parseInt(strNum, isHex ? 16 : 10);
          this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
        } catch {
          throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
        }
      } else {
        const nameStart = this._cursor.clone();
        this._attemptCharCodeUntilFn(isNamedEntityEnd);
        if (this._cursor.peek() != $SEMICOLON) {
          this._beginToken(textTokenType, start);
          this._cursor = nameStart;
          this._endToken(["&"]);
        } else {
          const name = this._cursor.getChars(nameStart);
          this._cursor.advance();
          const char = NAMED_ENTITIES[name];
          if (!char) {
            throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
          }
          this._endToken([char, `&${name};`]);
        }
      }
    }
    _consumeRawText(consumeEntities, endMarkerPredicate) {
      this._beginToken(consumeEntities ? 6 : 7);
      const parts = [];
      while (true) {
        const tagCloseStart = this._cursor.clone();
        const foundEndMarker = endMarkerPredicate();
        this._cursor = tagCloseStart;
        if (foundEndMarker) {
          break;
        }
        if (consumeEntities && this._cursor.peek() === $AMPERSAND) {
          this._endToken([this._processCarriageReturns(parts.join(""))]);
          parts.length = 0;
          this._consumeEntity(6);
          this._beginToken(6);
        } else {
          parts.push(this._readChar());
        }
      }
      this._endToken([this._processCarriageReturns(parts.join(""))]);
    }
    _consumeComment(start) {
      this._beginToken(10, start);
      this._requireCharCode($MINUS);
      this._endToken([]);
      this._consumeRawText(false, () => this._attemptStr("-->"));
      this._beginToken(11);
      this._requireStr("-->");
      this._endToken([]);
    }
    _consumeCdata(start) {
      this._beginToken(12, start);
      this._requireStr("CDATA[");
      this._endToken([]);
      this._consumeRawText(false, () => this._attemptStr("]]>"));
      this._beginToken(13);
      this._requireStr("]]>");
      this._endToken([]);
    }
    _consumeDocType(start) {
      this._beginToken(18, start);
      const contentStart = this._cursor.clone();
      this._attemptUntilChar($GT);
      const content = this._cursor.getChars(contentStart);
      this._cursor.advance();
      this._endToken([content]);
    }
    _consumePrefixAndName() {
      const nameOrPrefixStart = this._cursor.clone();
      let prefix = "";
      while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
        this._cursor.advance();
      }
      let nameStart;
      if (this._cursor.peek() === $COLON) {
        prefix = this._cursor.getChars(nameOrPrefixStart);
        this._cursor.advance();
        nameStart = this._cursor.clone();
      } else {
        nameStart = nameOrPrefixStart;
      }
      this._requireCharCodeUntilFn(isNameEnd, prefix === "" ? 0 : 1);
      const name = this._cursor.getChars(nameStart);
      return [prefix, name];
    }
    _consumeTagOpen(start) {
      let tagName;
      let prefix;
      let openTagToken;
      try {
        if (!isAsciiLetter(this._cursor.peek())) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
        }
        openTagToken = this._consumeTagOpenStart(start);
        prefix = openTagToken.parts[0];
        tagName = openTagToken.parts[1];
        this._attemptCharCodeUntilFn(isNotWhitespace);
        while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT && this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {
          this._consumeAttributeName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          if (this._attemptCharCode($EQ)) {
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._consumeAttributeValue();
          }
          this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        this._consumeTagOpenEnd();
      } catch (e) {
        if (e instanceof _ControlFlowError) {
          if (openTagToken) {
            openTagToken.type = 4;
          } else {
            this._beginToken(5, start);
            this._endToken(["<"]);
          }
          return;
        }
        throw e;
      }
      const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);
      if (contentTokenType === TagContentType.RAW_TEXT) {
        this._consumeRawTextWithTagClose(prefix, tagName, false);
      } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
        this._consumeRawTextWithTagClose(prefix, tagName, true);
      }
    }
    _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {
      this._consumeRawText(consumeEntities, () => {
        if (!this._attemptCharCode($LT))
          return false;
        if (!this._attemptCharCode($SLASH))
          return false;
        this._attemptCharCodeUntilFn(isNotWhitespace);
        if (!this._attemptStrCaseInsensitive(tagName))
          return false;
        this._attemptCharCodeUntilFn(isNotWhitespace);
        return this._attemptCharCode($GT);
      });
      this._beginToken(3);
      this._requireCharCodeUntilFn((code) => code === $GT, 3);
      this._cursor.advance();
      this._endToken([prefix, tagName]);
    }
    _consumeTagOpenStart(start) {
      this._beginToken(0, start);
      const parts = this._consumePrefixAndName();
      return this._endToken(parts);
    }
    _consumeAttributeName() {
      const attrNameStart = this._cursor.peek();
      if (attrNameStart === $SQ || attrNameStart === $DQ) {
        throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
      }
      this._beginToken(14);
      const prefixAndName = this._consumePrefixAndName();
      this._endToken(prefixAndName);
    }
    _consumeAttributeValue() {
      let value;
      if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
        const quoteChar = this._cursor.peek();
        this._consumeQuote(quoteChar);
        const endPredicate = () => this._cursor.peek() === quoteChar;
        this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);
        this._consumeQuote(quoteChar);
      } else {
        const endPredicate = () => isNameEnd(this._cursor.peek());
        this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);
      }
    }
    _consumeQuote(quoteChar) {
      this._beginToken(15);
      this._requireCharCode(quoteChar);
      this._endToken([String.fromCodePoint(quoteChar)]);
    }
    _consumeTagOpenEnd() {
      const tokenType = this._attemptCharCode($SLASH) ? 2 : 1;
      this._beginToken(tokenType);
      this._requireCharCode($GT);
      this._endToken([]);
    }
    _consumeTagClose(start) {
      this._beginToken(3, start);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      const prefixAndName = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._requireCharCode($GT);
      this._endToken(prefixAndName);
    }
    _consumeExpansionFormStart() {
      this._beginToken(19);
      this._requireCharCode($LBRACE);
      this._endToken([]);
      this._expansionCaseStack.push(19);
      this._beginToken(7);
      const condition = this._readUntil($COMMA);
      const normalizedCondition = this._processCarriageReturns(condition);
      if (this._i18nNormalizeLineEndingsInICUs) {
        this._endToken([normalizedCondition]);
      } else {
        const conditionToken = this._endToken([condition]);
        if (normalizedCondition !== condition) {
          this.nonNormalizedIcuExpressions.push(conditionToken);
        }
      }
      this._requireCharCode($COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(7);
      const type = this._readUntil($COMMA);
      this._endToken([type]);
      this._requireCharCode($COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
    }
    _consumeExpansionCaseStart() {
      this._beginToken(20);
      const value = this._readUntil($LBRACE).trim();
      this._endToken([value]);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(21);
      this._requireCharCode($LBRACE);
      this._endToken([]);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.push(21);
    }
    _consumeExpansionCaseEnd() {
      this._beginToken(22);
      this._requireCharCode($RBRACE);
      this._endToken([]);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.pop();
    }
    _consumeExpansionFormEnd() {
      this._beginToken(23);
      this._requireCharCode($RBRACE);
      this._endToken([]);
      this._expansionCaseStack.pop();
    }
    _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
      this._beginToken(textTokenType);
      const parts = [];
      while (!endPredicate()) {
        const current = this._cursor.clone();
        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
          this._endToken([this._processCarriageReturns(parts.join(""))], current);
          parts.length = 0;
          this._consumeInterpolation(interpolationTokenType, current, endInterpolation);
          this._beginToken(textTokenType);
        } else if (this._cursor.peek() === $AMPERSAND) {
          this._endToken([this._processCarriageReturns(parts.join(""))]);
          parts.length = 0;
          this._consumeEntity(textTokenType);
          this._beginToken(textTokenType);
        } else {
          parts.push(this._readChar());
        }
      }
      this._inInterpolation = false;
      this._endToken([this._processCarriageReturns(parts.join(""))]);
    }
    _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {
      const parts = [];
      this._beginToken(interpolationTokenType, interpolationStart);
      parts.push(this._interpolationConfig.start);
      const expressionStart = this._cursor.clone();
      let inQuote = null;
      let inComment = false;
      while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {
        const current = this._cursor.clone();
        if (this._isTagStart()) {
          this._cursor = current;
          parts.push(this._getProcessedChars(expressionStart, current));
          this._endToken(parts);
          return;
        }
        if (inQuote === null) {
          if (this._attemptStr(this._interpolationConfig.end)) {
            parts.push(this._getProcessedChars(expressionStart, current));
            parts.push(this._interpolationConfig.end);
            this._endToken(parts);
            return;
          } else if (this._attemptStr("//")) {
            inComment = true;
          }
        }
        const char = this._cursor.peek();
        this._cursor.advance();
        if (char === $BACKSLASH) {
          this._cursor.advance();
        } else if (char === inQuote) {
          inQuote = null;
        } else if (!inComment && inQuote === null && isQuote(char)) {
          inQuote = char;
        }
      }
      parts.push(this._getProcessedChars(expressionStart, this._cursor));
      this._endToken(parts);
    }
    _getProcessedChars(start, end) {
      return this._processCarriageReturns(end.getChars(start));
    }
    _isTextEnd() {
      if (this._isTagStart() || this._cursor.peek() === $EOF) {
        return true;
      }
      if (this._tokenizeIcu && !this._inInterpolation) {
        if (this.isExpansionFormStart()) {
          return true;
        }
        if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
          return true;
        }
      }
      return false;
    }
    _isTagStart() {
      if (this._cursor.peek() === $LT) {
        const tmp = this._cursor.clone();
        tmp.advance();
        const code = tmp.peek();
        if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {
          return true;
        }
      }
      return false;
    }
    _readUntil(char) {
      const start = this._cursor.clone();
      this._attemptUntilChar(char);
      return this._cursor.getChars(start);
    }
    _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21;
    }
    _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19;
    }
    isExpansionFormStart() {
      if (this._cursor.peek() !== $LBRACE) {
        return false;
      }
      if (this._interpolationConfig) {
        const start = this._cursor.clone();
        const isInterpolation = this._attemptStr(this._interpolationConfig.start);
        this._cursor = start;
        return !isInterpolation;
      }
      return true;
    }
  };
  function isNotWhitespace(code) {
    return !isWhitespace(code) || code === $EOF;
  }
  function isNameEnd(code) {
    return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;
  }
  function isPrefixEnd(code) {
    return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
  }
  function isDigitEntityEnd(code) {
    return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
    return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);
  }
  function isExpansionCaseStart(peek) {
    return peek !== $RBRACE;
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
    return code >= $a && code <= $z ? code - $a + $A : code;
  }
  function mergeTextTokens(srcTokens) {
    const dstTokens = [];
    let lastDstToken = void 0;
    for (let i = 0; i < srcTokens.length; i++) {
      const token = srcTokens[i];
      if (lastDstToken && lastDstToken.type === 5 && token.type === 5 || lastDstToken && lastDstToken.type === 16 && token.type === 16) {
        lastDstToken.parts[0] += token.parts[0];
        lastDstToken.sourceSpan.end = token.sourceSpan.end;
      } else {
        lastDstToken = token;
        dstTokens.push(lastDstToken);
      }
    }
    return dstTokens;
  }
  var PlainCharacterCursor = class {
    constructor(fileOrCursor, range) {
      if (fileOrCursor instanceof PlainCharacterCursor) {
        this.file = fileOrCursor.file;
        this.input = fileOrCursor.input;
        this.end = fileOrCursor.end;
        const state = fileOrCursor.state;
        this.state = {
          peek: state.peek,
          offset: state.offset,
          line: state.line,
          column: state.column
        };
      } else {
        if (!range) {
          throw new Error("Programming error: the range argument must be provided with a file argument.");
        }
        this.file = fileOrCursor;
        this.input = fileOrCursor.content;
        this.end = range.endPos;
        this.state = {
          peek: -1,
          offset: range.startPos,
          line: range.startLine,
          column: range.startCol
        };
      }
    }
    clone() {
      return new PlainCharacterCursor(this);
    }
    peek() {
      return this.state.peek;
    }
    charsLeft() {
      return this.end - this.state.offset;
    }
    diff(other) {
      return this.state.offset - other.state.offset;
    }
    advance() {
      this.advanceState(this.state);
    }
    init() {
      this.updatePeek(this.state);
    }
    getSpan(start, leadingTriviaCodePoints) {
      start = start || this;
      let fullStart = start;
      if (leadingTriviaCodePoints) {
        while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
          if (fullStart === start) {
            start = start.clone();
          }
          start.advance();
        }
      }
      const startLocation = this.locationFromCursor(start);
      const endLocation = this.locationFromCursor(this);
      const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
      return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
    }
    getChars(start) {
      return this.input.substring(start.state.offset, this.state.offset);
    }
    charAt(pos) {
      return this.input.charCodeAt(pos);
    }
    advanceState(state) {
      if (state.offset >= this.end) {
        this.state = state;
        throw new CursorError('Unexpected character "EOF"', this);
      }
      const currentChar = this.charAt(state.offset);
      if (currentChar === $LF) {
        state.line++;
        state.column = 0;
      } else if (!isNewLine(currentChar)) {
        state.column++;
      }
      state.offset++;
      this.updatePeek(state);
    }
    updatePeek(state) {
      state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
    }
    locationFromCursor(cursor) {
      return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
    }
  };
  var EscapedCharacterCursor = class extends PlainCharacterCursor {
    constructor(fileOrCursor, range) {
      if (fileOrCursor instanceof EscapedCharacterCursor) {
        super(fileOrCursor);
        this.internalState = { ...fileOrCursor.internalState };
      } else {
        super(fileOrCursor, range);
        this.internalState = this.state;
      }
    }
    advance() {
      this.state = this.internalState;
      super.advance();
      this.processEscapeSequence();
    }
    init() {
      super.init();
      this.processEscapeSequence();
    }
    clone() {
      return new EscapedCharacterCursor(this);
    }
    getChars(start) {
      const cursor = start.clone();
      let chars = "";
      while (cursor.internalState.offset < this.internalState.offset) {
        chars += String.fromCodePoint(cursor.peek());
        cursor.advance();
      }
      return chars;
    }
    processEscapeSequence() {
      const peek = () => this.internalState.peek;
      if (peek() === $BACKSLASH) {
        this.internalState = { ...this.state };
        this.advanceState(this.internalState);
        if (peek() === $n) {
          this.state.peek = $LF;
        } else if (peek() === $r) {
          this.state.peek = $CR;
        } else if (peek() === $v) {
          this.state.peek = $VTAB;
        } else if (peek() === $t) {
          this.state.peek = $TAB;
        } else if (peek() === $b) {
          this.state.peek = $BSPACE;
        } else if (peek() === $f) {
          this.state.peek = $FF;
        } else if (peek() === $u) {
          this.advanceState(this.internalState);
          if (peek() === $LBRACE) {
            this.advanceState(this.internalState);
            const digitStart = this.clone();
            let length = 0;
            while (peek() !== $RBRACE) {
              this.advanceState(this.internalState);
              length++;
            }
            this.state.peek = this.decodeHexDigits(digitStart, length);
          } else {
            const digitStart = this.clone();
            this.advanceState(this.internalState);
            this.advanceState(this.internalState);
            this.advanceState(this.internalState);
            this.state.peek = this.decodeHexDigits(digitStart, 4);
          }
        } else if (peek() === $x) {
          this.advanceState(this.internalState);
          const digitStart = this.clone();
          this.advanceState(this.internalState);
          this.state.peek = this.decodeHexDigits(digitStart, 2);
        } else if (isOctalDigit(peek())) {
          let octal = "";
          let length = 0;
          let previous = this.clone();
          while (isOctalDigit(peek()) && length < 3) {
            previous = this.clone();
            octal += String.fromCodePoint(peek());
            this.advanceState(this.internalState);
            length++;
          }
          this.state.peek = parseInt(octal, 8);
          this.internalState = previous.internalState;
        } else if (isNewLine(this.internalState.peek)) {
          this.advanceState(this.internalState);
          this.state = this.internalState;
        } else {
          this.state.peek = this.internalState.peek;
        }
      }
    }
    decodeHexDigits(start, length) {
      const hex = this.input.substr(start.internalState.offset, length);
      const charCode = parseInt(hex, 16);
      if (!isNaN(charCode)) {
        return charCode;
      } else {
        start.state = start.internalState;
        throw new CursorError("Invalid hexadecimal escape sequence", start);
      }
    }
  };
  var CursorError = class {
    constructor(msg, cursor) {
      this.msg = msg;
      this.cursor = cursor;
    }
  };
  var TreeError = class extends ParseError {
    constructor(elementName, span, msg) {
      super(span, msg);
      this.elementName = elementName;
    }
    static create(elementName, span, msg) {
      return new TreeError(elementName, span, msg);
    }
  };
  var ParseTreeResult = class {
    constructor(rootNodes, errors) {
      this.rootNodes = rootNodes;
      this.errors = errors;
    }
  };
  var Parser = class {
    constructor(getTagDefinition) {
      this.getTagDefinition = getTagDefinition;
    }
    parse(source, url, options) {
      const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
      const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
      parser.build();
      return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
    }
  };
  var _TreeBuilder = class {
    constructor(tokens, getTagDefinition) {
      this.tokens = tokens;
      this.getTagDefinition = getTagDefinition;
      this._index = -1;
      this._elementStack = [];
      this.rootNodes = [];
      this.errors = [];
      this._advance();
    }
    build() {
      while (this._peek.type !== 24) {
        if (this._peek.type === 0 || this._peek.type === 4) {
          this._consumeStartTag(this._advance());
        } else if (this._peek.type === 3) {
          this._consumeEndTag(this._advance());
        } else if (this._peek.type === 12) {
          this._closeVoidElement();
          this._consumeCdata(this._advance());
        } else if (this._peek.type === 10) {
          this._closeVoidElement();
          this._consumeComment(this._advance());
        } else if (this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6) {
          this._closeVoidElement();
          this._consumeText(this._advance());
        } else if (this._peek.type === 19) {
          this._consumeExpansion(this._advance());
        } else {
          this._advance();
        }
      }
    }
    _advance() {
      const prev = this._peek;
      if (this._index < this.tokens.length - 1) {
        this._index++;
      }
      this._peek = this.tokens[this._index];
      return prev;
    }
    _advanceIf(type) {
      if (this._peek.type === type) {
        return this._advance();
      }
      return null;
    }
    _consumeCdata(_startToken) {
      this._consumeText(this._advance());
      this._advanceIf(13);
    }
    _consumeComment(token) {
      const text = this._advanceIf(7);
      this._advanceIf(11);
      const value = text != null ? text.parts[0].trim() : null;
      this._addToParent(new Comment(value, token.sourceSpan));
    }
    _consumeExpansion(token) {
      const switchValue = this._advance();
      const type = this._advance();
      const cases = [];
      while (this._peek.type === 20) {
        const expCase = this._parseExpansionCase();
        if (!expCase)
          return;
        cases.push(expCase);
      }
      if (this._peek.type !== 23) {
        this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
        return;
      }
      const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);
      this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
      this._advance();
    }
    _parseExpansionCase() {
      const value = this._advance();
      if (this._peek.type !== 21) {
        this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
        return null;
      }
      const start = this._advance();
      const exp = this._collectExpansionExpTokens(start);
      if (!exp)
        return null;
      const end = this._advance();
      exp.push({ type: 24, parts: [], sourceSpan: end.sourceSpan });
      const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
      expansionCaseParser.build();
      if (expansionCaseParser.errors.length > 0) {
        this.errors = this.errors.concat(expansionCaseParser.errors);
        return null;
      }
      const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
      const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
      return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    }
    _collectExpansionExpTokens(start) {
      const exp = [];
      const expansionFormStack = [21];
      while (true) {
        if (this._peek.type === 19 || this._peek.type === 21) {
          expansionFormStack.push(this._peek.type);
        }
        if (this._peek.type === 22) {
          if (lastOnStack(expansionFormStack, 21)) {
            expansionFormStack.pop();
            if (expansionFormStack.length === 0)
              return exp;
          } else {
            this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
            return null;
          }
        }
        if (this._peek.type === 23) {
          if (lastOnStack(expansionFormStack, 19)) {
            expansionFormStack.pop();
          } else {
            this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
            return null;
          }
        }
        if (this._peek.type === 24) {
          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
          return null;
        }
        exp.push(this._advance());
      }
    }
    _consumeText(token) {
      const tokens = [token];
      const startSpan = token.sourceSpan;
      let text = token.parts[0];
      if (text.length > 0 && text[0] === "\n") {
        const parent = this._getParentElement();
        if (parent != null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {
          text = text.substring(1);
          tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };
        }
      }
      while (this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9) {
        token = this._advance();
        tokens.push(token);
        if (token.type === 8) {
          text += token.parts.join("").replace(/&([^;]+);/g, decodeEntity);
        } else if (token.type === 9) {
          text += token.parts[0];
        } else {
          text += token.parts.join("");
        }
      }
      if (text.length > 0) {
        const endSpan = token.sourceSpan;
        this._addToParent(new Text2(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
      }
    }
    _closeVoidElement() {
      const el = this._getParentElement();
      if (el && this.getTagDefinition(el.name).isVoid) {
        this._elementStack.pop();
      }
    }
    _consumeStartTag(startTagToken) {
      const [prefix, name] = startTagToken.parts;
      const attrs = [];
      while (this._peek.type === 14) {
        attrs.push(this._consumeAttr(this._advance()));
      }
      const fullName = this._getElementFullName(prefix, name, this._getParentElement());
      let selfClosing = false;
      if (this._peek.type === 2) {
        this._advance();
        selfClosing = true;
        const tagDef = this.getTagDefinition(fullName);
        if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
          this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
        }
      } else if (this._peek.type === 1) {
        this._advance();
        selfClosing = false;
      }
      const end = this._peek.sourceSpan.fullStart;
      const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
      const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
      const el = new Element2(fullName, attrs, [], span, startSpan, void 0);
      this._pushElement(el);
      if (selfClosing) {
        this._popElement(fullName, span);
      } else if (startTagToken.type === 4) {
        this._popElement(fullName, null);
        this.errors.push(TreeError.create(fullName, span, `Opening tag "${fullName}" not terminated.`));
      }
    }
    _pushElement(el) {
      const parentEl = this._getParentElement();
      if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
        this._elementStack.pop();
      }
      this._addToParent(el);
      this._elementStack.push(el);
    }
    _consumeEndTag(endTagToken) {
      const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
      if (this.getTagDefinition(fullName).isVoid) {
        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
      } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
        const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
      }
    }
    _popElement(fullName, endSourceSpan) {
      let unexpectedCloseTagDetected = false;
      for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
        const el = this._elementStack[stackIndex];
        if (el.name === fullName) {
          el.endSourceSpan = endSourceSpan;
          el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;
          this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
          return !unexpectedCloseTagDetected;
        }
        if (!this.getTagDefinition(el.name).closedByParent) {
          unexpectedCloseTagDetected = true;
        }
      }
      return false;
    }
    _consumeAttr(attrName) {
      const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
      let attrEnd = attrName.sourceSpan.end;
      if (this._peek.type === 15) {
        this._advance();
      }
      let value = "";
      const valueTokens = [];
      let valueStartSpan = void 0;
      let valueEnd = void 0;
      const nextTokenType = this._peek.type;
      if (nextTokenType === 16) {
        valueStartSpan = this._peek.sourceSpan;
        valueEnd = this._peek.sourceSpan.end;
        while (this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9) {
          const valueToken = this._advance();
          valueTokens.push(valueToken);
          if (valueToken.type === 17) {
            value += valueToken.parts.join("").replace(/&([^;]+);/g, decodeEntity);
          } else if (valueToken.type === 9) {
            value += valueToken.parts[0];
          } else {
            value += valueToken.parts.join("");
          }
          valueEnd = attrEnd = valueToken.sourceSpan.end;
        }
      }
      if (this._peek.type === 15) {
        const quoteToken = this._advance();
        attrEnd = quoteToken.sourceSpan.end;
      }
      const valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
      return new Attribute2(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : void 0, void 0);
    }
    _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
    _addToParent(node) {
      const parent = this._getParentElement();
      if (parent != null) {
        parent.children.push(node);
      } else {
        this.rootNodes.push(node);
      }
    }
    _getElementFullName(prefix, localName, parentElement) {
      if (prefix === "") {
        prefix = this.getTagDefinition(localName).implicitNamespacePrefix || "";
        if (prefix === "" && parentElement != null) {
          const parentTagName = splitNsName(parentElement.name)[1];
          const parentTagDefinition = this.getTagDefinition(parentTagName);
          if (!parentTagDefinition.preventNamespaceInheritance) {
            prefix = getNsPrefix(parentElement.name);
          }
        }
      }
      return mergeNsAndName(prefix, localName);
    }
  };
  function lastOnStack(stack, element2) {
    return stack.length > 0 && stack[stack.length - 1] === element2;
  }
  function decodeEntity(match, entity) {
    if (NAMED_ENTITIES[entity] !== void 0) {
      return NAMED_ENTITIES[entity] || match;
    }
    if (/^#x[a-f0-9]+$/i.test(entity)) {
      return String.fromCodePoint(parseInt(entity.slice(2), 16));
    }
    if (/^#\d+$/.test(entity)) {
      return String.fromCodePoint(parseInt(entity.slice(1), 10));
    }
    return match;
  }
  var HtmlParser = class extends Parser {
    constructor() {
      super(getHtmlTagDefinition);
    }
    parse(source, url, options) {
      return super.parse(source, url, options);
    }
  };
  var PRESERVE_WS_ATTR_NAME = "ngPreserveWhitespaces";
  var SKIP_WS_TRIM_TAGS = /* @__PURE__ */ new Set(["pre", "template", "textarea", "script", "style"]);
  var WS_CHARS = " \f\n\r	\v\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF";
  var NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
  var WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, "g");
  function hasPreserveWhitespacesAttr(attrs) {
    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
  }
  function replaceNgsp2(value) {
    return value.replace(new RegExp(NGSP_UNICODE, "g"), " ");
  }
  var WhitespaceVisitor = class {
    visitElement(element2, context) {
      if (SKIP_WS_TRIM_TAGS.has(element2.name) || hasPreserveWhitespacesAttr(element2.attrs)) {
        return new Element2(element2.name, visitAll(this, element2.attrs), element2.children, element2.sourceSpan, element2.startSourceSpan, element2.endSourceSpan, element2.i18n);
      }
      return new Element2(element2.name, element2.attrs, visitAllWithSiblings(this, element2.children), element2.sourceSpan, element2.startSourceSpan, element2.endSourceSpan, element2.i18n);
    }
    visitAttribute(attribute, context) {
      return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
    }
    visitText(text, context) {
      const isNotBlank = text.value.match(NO_WS_REGEXP);
      const hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);
      if (isNotBlank || hasExpansionSibling) {
        const tokens = text.tokens.map((token) => token.type === 5 ? createWhitespaceProcessedTextToken(token) : token);
        const value = processWhitespace(text.value);
        return new Text2(value, text.sourceSpan, tokens, text.i18n);
      }
      return null;
    }
    visitComment(comment, context) {
      return comment;
    }
    visitExpansion(expansion, context) {
      return expansion;
    }
    visitExpansionCase(expansionCase, context) {
      return expansionCase;
    }
  };
  function createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {
    return { type, parts: [processWhitespace(parts[0])], sourceSpan };
  }
  function processWhitespace(text) {
    return replaceNgsp2(text).replace(WS_REPLACE_REGEXP, " ");
  }
  function visitAllWithSiblings(visitor, nodes) {
    const result = [];
    nodes.forEach((ast, i) => {
      const context = { prev: nodes[i - 1], next: nodes[i + 1] };
      const astResult = ast.visit(visitor, context);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  function mapLiteral(obj, quoted = false) {
    return literalMap(Object.keys(obj).map((key) => ({
      key,
      quoted,
      value: obj[key]
    })));
  }
  var _SECURITY_SCHEMA;
  function SECURITY_SCHEMA() {
    if (!_SECURITY_SCHEMA) {
      _SECURITY_SCHEMA = {};
      registerContext(SecurityContext2.HTML, [
        "iframe|srcdoc",
        "*|innerHTML",
        "*|outerHTML"
      ]);
      registerContext(SecurityContext2.STYLE, ["*|style"]);
      registerContext(SecurityContext2.URL, [
        "*|formAction",
        "area|href",
        "area|ping",
        "audio|src",
        "a|href",
        "a|ping",
        "blockquote|cite",
        "body|background",
        "del|cite",
        "form|action",
        "img|src",
        "img|srcset",
        "input|src",
        "ins|cite",
        "q|cite",
        "source|src",
        "source|srcset",
        "track|src",
        "video|poster",
        "video|src"
      ]);
      registerContext(SecurityContext2.RESOURCE_URL, [
        "applet|code",
        "applet|codebase",
        "base|href",
        "embed|src",
        "frame|src",
        "head|profile",
        "html|manifest",
        "iframe|src",
        "link|href",
        "media|src",
        "object|codebase",
        "object|data",
        "script|src"
      ]);
    }
    return _SECURITY_SCHEMA;
  }
  function registerContext(ctx, specs) {
    for (const spec of specs)
      _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
  }
  var ElementSchemaRegistry = class {
  };
  var BOOLEAN = "boolean";
  var NUMBER = "number";
  var STRING = "string";
  var OBJECT = "object";
  var SCHEMA = [
    "[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored",
    "[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate",
    "abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate",
    "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume",
    ":svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex",
    ":svg:graphics^:svg:|",
    ":svg:animation^:svg:|*begin,*end,*repeat",
    ":svg:geometry^:svg:|",
    ":svg:componentTransferFunction^:svg:|",
    ":svg:gradient^:svg:|",
    ":svg:textContent^:svg:graphics|",
    ":svg:textPositioning^:svg:textContent|",
    "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username",
    "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username",
    "audio^media|",
    "br^[HTMLElement]|clear",
    "base^[HTMLElement]|href,target",
    "body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink",
    "button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value",
    "canvas^[HTMLElement]|#height,#width",
    "content^[HTMLElement]|select",
    "dl^[HTMLElement]|!compact",
    "datalist^[HTMLElement]|",
    "details^[HTMLElement]|!open",
    "dialog^[HTMLElement]|!open,returnValue",
    "dir^[HTMLElement]|!compact",
    "div^[HTMLElement]|align",
    "embed^[HTMLElement]|align,height,name,src,type,width",
    "fieldset^[HTMLElement]|!disabled,name",
    "font^[HTMLElement]|color,face,size",
    "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target",
    "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src",
    "frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows",
    "hr^[HTMLElement]|align,color,!noShade,size,width",
    "head^[HTMLElement]|",
    "h1,h2,h3,h4,h5,h6^[HTMLElement]|align",
    "html^[HTMLElement]|version",
    "iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width",
    "img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width",
    "input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width",
    "li^[HTMLElement]|type,#value",
    "label^[HTMLElement]|htmlFor",
    "legend^[HTMLElement]|align",
    "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type",
    "map^[HTMLElement]|name",
    "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width",
    "menu^[HTMLElement]|!compact",
    "meta^[HTMLElement]|content,httpEquiv,name,scheme",
    "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value",
    "ins,del^[HTMLElement]|cite,dateTime",
    "ol^[HTMLElement]|!compact,!reversed,#start,type",
    "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width",
    "optgroup^[HTMLElement]|!disabled,label",
    "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value",
    "output^[HTMLElement]|defaultValue,%htmlFor,name,value",
    "p^[HTMLElement]|align",
    "param^[HTMLElement]|name,type,value,valueType",
    "picture^[HTMLElement]|",
    "pre^[HTMLElement]|#width",
    "progress^[HTMLElement]|#max,#value",
    "q,blockquote,cite^[HTMLElement]|",
    "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type",
    "select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value",
    "shadow^[HTMLElement]|",
    "slot^[HTMLElement]|name",
    "source^[HTMLElement]|media,sizes,src,srcset,type",
    "span^[HTMLElement]|",
    "style^[HTMLElement]|!disabled,media,type",
    "caption^[HTMLElement]|align",
    "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width",
    "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width",
    "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width",
    "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign",
    "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign",
    "template^[HTMLElement]|",
    "textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap",
    "title^[HTMLElement]|text",
    "track^[HTMLElement]|!default,kind,label,src,srclang",
    "ul^[HTMLElement]|!compact,type",
    "unknown^[HTMLElement]|",
    "video^media|#height,poster,#width",
    ":svg:a^:svg:graphics|",
    ":svg:animate^:svg:animation|",
    ":svg:animateMotion^:svg:animation|",
    ":svg:animateTransform^:svg:animation|",
    ":svg:circle^:svg:geometry|",
    ":svg:clipPath^:svg:graphics|",
    ":svg:defs^:svg:graphics|",
    ":svg:desc^:svg:|",
    ":svg:discard^:svg:|",
    ":svg:ellipse^:svg:geometry|",
    ":svg:feBlend^:svg:|",
    ":svg:feColorMatrix^:svg:|",
    ":svg:feComponentTransfer^:svg:|",
    ":svg:feComposite^:svg:|",
    ":svg:feConvolveMatrix^:svg:|",
    ":svg:feDiffuseLighting^:svg:|",
    ":svg:feDisplacementMap^:svg:|",
    ":svg:feDistantLight^:svg:|",
    ":svg:feDropShadow^:svg:|",
    ":svg:feFlood^:svg:|",
    ":svg:feFuncA^:svg:componentTransferFunction|",
    ":svg:feFuncB^:svg:componentTransferFunction|",
    ":svg:feFuncG^:svg:componentTransferFunction|",
    ":svg:feFuncR^:svg:componentTransferFunction|",
    ":svg:feGaussianBlur^:svg:|",
    ":svg:feImage^:svg:|",
    ":svg:feMerge^:svg:|",
    ":svg:feMergeNode^:svg:|",
    ":svg:feMorphology^:svg:|",
    ":svg:feOffset^:svg:|",
    ":svg:fePointLight^:svg:|",
    ":svg:feSpecularLighting^:svg:|",
    ":svg:feSpotLight^:svg:|",
    ":svg:feTile^:svg:|",
    ":svg:feTurbulence^:svg:|",
    ":svg:filter^:svg:|",
    ":svg:foreignObject^:svg:graphics|",
    ":svg:g^:svg:graphics|",
    ":svg:image^:svg:graphics|",
    ":svg:line^:svg:geometry|",
    ":svg:linearGradient^:svg:gradient|",
    ":svg:mpath^:svg:|",
    ":svg:marker^:svg:|",
    ":svg:mask^:svg:|",
    ":svg:metadata^:svg:|",
    ":svg:path^:svg:geometry|",
    ":svg:pattern^:svg:|",
    ":svg:polygon^:svg:geometry|",
    ":svg:polyline^:svg:geometry|",
    ":svg:radialGradient^:svg:gradient|",
    ":svg:rect^:svg:geometry|",
    ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan",
    ":svg:script^:svg:|type",
    ":svg:set^:svg:animation|",
    ":svg:stop^:svg:|",
    ":svg:style^:svg:|!disabled,media,title,type",
    ":svg:switch^:svg:graphics|",
    ":svg:symbol^:svg:|",
    ":svg:tspan^:svg:textPositioning|",
    ":svg:text^:svg:textPositioning|",
    ":svg:textPath^:svg:textContent|",
    ":svg:title^:svg:|",
    ":svg:use^:svg:graphics|",
    ":svg:view^:svg:|#zoomAndPan",
    "data^[HTMLElement]|value",
    "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name",
    "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default",
    "summary^[HTMLElement]|",
    "time^[HTMLElement]|dateTime",
    ":svg:cursor^:svg:|"
  ];
  var _ATTR_TO_PROP = {
    "class": "className",
    "for": "htmlFor",
    "formaction": "formAction",
    "innerHtml": "innerHTML",
    "readonly": "readOnly",
    "tabindex": "tabIndex"
  };
  var _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {
    inverted[_ATTR_TO_PROP[attr]] = attr;
    return inverted;
  }, {});
  var DomElementSchemaRegistry = class extends ElementSchemaRegistry {
    constructor() {
      super();
      this._schema = {};
      this._eventSchema = {};
      SCHEMA.forEach((encodedType) => {
        const type = {};
        const events = /* @__PURE__ */ new Set();
        const [strType, strProperties] = encodedType.split("|");
        const properties = strProperties.split(",");
        const [typeNames, superName] = strType.split("^");
        typeNames.split(",").forEach((tag) => {
          this._schema[tag.toLowerCase()] = type;
          this._eventSchema[tag.toLowerCase()] = events;
        });
        const superType = superName && this._schema[superName.toLowerCase()];
        if (superType) {
          Object.keys(superType).forEach((prop) => {
            type[prop] = superType[prop];
          });
          for (const superEvent of this._eventSchema[superName.toLowerCase()]) {
            events.add(superEvent);
          }
        }
        properties.forEach((property) => {
          if (property.length > 0) {
            switch (property[0]) {
              case "*":
                events.add(property.substring(1));
                break;
              case "!":
                type[property.substring(1)] = BOOLEAN;
                break;
              case "#":
                type[property.substring(1)] = NUMBER;
                break;
              case "%":
                type[property.substring(1)] = OBJECT;
                break;
              default:
                type[property] = STRING;
            }
          }
        });
      });
    }
    hasProperty(tagName, propName, schemaMetas) {
      if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA2.name)) {
        return true;
      }
      if (tagName.indexOf("-") > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return false;
        }
        if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA2.name)) {
          return true;
        }
      }
      const elementProperties = this._schema[tagName.toLowerCase()] || this._schema["unknown"];
      return !!elementProperties[propName];
    }
    hasElement(tagName, schemaMetas) {
      if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA2.name)) {
        return true;
      }
      if (tagName.indexOf("-") > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return true;
        }
        if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA2.name)) {
          return true;
        }
      }
      return !!this._schema[tagName.toLowerCase()];
    }
    securityContext(tagName, propName, isAttribute) {
      if (isAttribute) {
        propName = this.getMappedPropName(propName);
      }
      tagName = tagName.toLowerCase();
      propName = propName.toLowerCase();
      let ctx = SECURITY_SCHEMA()[tagName + "|" + propName];
      if (ctx) {
        return ctx;
      }
      ctx = SECURITY_SCHEMA()["*|" + propName];
      return ctx ? ctx : SecurityContext2.NONE;
    }
    getMappedPropName(propName) {
      return _ATTR_TO_PROP[propName] || propName;
    }
    getDefaultComponentElementName() {
      return "ng-component";
    }
    validateProperty(name) {
      if (name.toLowerCase().startsWith("on")) {
        const msg = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
        return { error: true, msg };
      } else {
        return { error: false };
      }
    }
    validateAttribute(name) {
      if (name.toLowerCase().startsWith("on")) {
        const msg = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
        return { error: true, msg };
      } else {
        return { error: false };
      }
    }
    allKnownElementNames() {
      return Object.keys(this._schema);
    }
    allKnownAttributesOfElement(tagName) {
      const elementProperties = this._schema[tagName.toLowerCase()] || this._schema["unknown"];
      return Object.keys(elementProperties).map((prop) => _PROP_TO_ATTR[prop] ?? prop);
    }
    allKnownEventsOfElement(tagName) {
      return Array.from(this._eventSchema[tagName.toLowerCase()] ?? []);
    }
    normalizeAnimationStyleProperty(propName) {
      return dashCaseToCamelCase(propName);
    }
    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
      let unit = "";
      const strVal = val.toString().trim();
      let errorMsg = null;
      if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== "0") {
        if (typeof val === "number") {
          unit = "px";
        } else {
          const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
          if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
            errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
          }
        }
      }
      return { error: errorMsg, value: strVal + unit };
    }
  };
  function _isPixelDimensionStyle(prop) {
    switch (prop) {
      case "width":
      case "height":
      case "minWidth":
      case "minHeight":
      case "maxWidth":
      case "maxHeight":
      case "left":
      case "top":
      case "bottom":
      case "right":
      case "fontSize":
      case "outlineWidth":
      case "outlineOffset":
      case "paddingTop":
      case "paddingLeft":
      case "paddingBottom":
      case "paddingRight":
      case "marginTop":
      case "marginLeft":
      case "marginBottom":
      case "marginRight":
      case "borderRadius":
      case "borderWidth":
      case "borderTopWidth":
      case "borderLeftWidth":
      case "borderRightWidth":
      case "borderBottomWidth":
      case "textIndent":
        return true;
      default:
        return false;
    }
  }
  var TRUSTED_TYPES_SINKS = /* @__PURE__ */ new Set([
    "iframe|srcdoc",
    "*|innerhtml",
    "*|outerhtml",
    "embed|src",
    "object|codebase",
    "object|data"
  ]);
  function isTrustedTypesSink(tagName, propName) {
    tagName = tagName.toLowerCase();
    propName = propName.toLowerCase();
    return TRUSTED_TYPES_SINKS.has(tagName + "|" + propName) || TRUSTED_TYPES_SINKS.has("*|" + propName);
  }
  var PROPERTY_PARTS_SEPARATOR = ".";
  var ATTRIBUTE_PREFIX = "attr";
  var CLASS_PREFIX = "class";
  var STYLE_PREFIX = "style";
  var TEMPLATE_ATTR_PREFIX$1 = "*";
  var ANIMATE_PROP_PREFIX = "animate-";
  var BindingParser = class {
    constructor(_exprParser, _interpolationConfig, _schemaRegistry, errors) {
      this._exprParser = _exprParser;
      this._interpolationConfig = _interpolationConfig;
      this._schemaRegistry = _schemaRegistry;
      this.errors = errors;
    }
    get interpolationConfig() {
      return this._interpolationConfig;
    }
    createBoundHostProperties(properties, sourceSpan) {
      const boundProps = [];
      for (const propName of Object.keys(properties)) {
        const expression = properties[propName];
        if (typeof expression === "string") {
          this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, void 0, [], boundProps, sourceSpan);
        } else {
          this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
        }
      }
      return boundProps;
    }
    createDirectiveHostEventAsts(hostListeners, sourceSpan) {
      const targetEvents = [];
      for (const propName of Object.keys(hostListeners)) {
        const expression = hostListeners[propName];
        if (typeof expression === "string") {
          this.parseEvent(propName, expression, false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);
        } else {
          this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
        }
      }
      return targetEvents;
    }
    parseInterpolation(value, sourceSpan, interpolatedTokens) {
      const sourceInfo = sourceSpan.start.toString();
      const absoluteOffset = sourceSpan.fullStart.offset;
      try {
        const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    parseInterpolationExpression(expression, sourceSpan) {
      const sourceInfo = sourceSpan.start.toString();
      const absoluteOffset = sourceSpan.start.offset;
      try {
        const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {
      const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;
      const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);
      for (const binding of bindings) {
        const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
        const key = binding.key.source;
        const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);
        if (binding instanceof VariableBinding) {
          const value = binding.value ? binding.value.source : "$implicit";
          const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : void 0;
          targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
        } else if (binding.value) {
          const srcSpan = isIvyAst ? bindingSpan : sourceSpan;
          const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);
          this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        } else {
          targetMatchableAttrs.push([key, ""]);
          this.parseLiteralAttr(key, null, keySpan, absoluteValueOffset, void 0, targetMatchableAttrs, targetProps, keySpan);
        }
      }
    }
    _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
      const sourceInfo = sourceSpan.start.toString();
      try {
        const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);
        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
        bindingsResult.warnings.forEach((warning) => {
          this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
        });
        return bindingsResult.templateBindings;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return [];
      }
    }
    parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      if (isAnimationLabel(name)) {
        name = name.substring(1);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
        if (value) {
          this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid. Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
        }
        this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      } else {
        targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, "", absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));
      }
    }
    parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      if (name.length === 0) {
        this._reportError(`Property name is missing in binding`, sourceSpan);
      }
      let isAnimationProp2 = false;
      if (name.startsWith(ANIMATE_PROP_PREFIX)) {
        isAnimationProp2 = true;
        name = name.substring(ANIMATE_PROP_PREFIX.length);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));
        }
      } else if (isAnimationLabel(name)) {
        isAnimationProp2 = true;
        name = name.substring(1);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
      }
      if (isAnimationProp2) {
        this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      } else {
        this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      }
    }
    parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {
      const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);
      if (expr) {
        this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        return true;
      }
      return false;
    }
    _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));
    }
    _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
      if (name.length === 0) {
        this._reportError("Animation trigger is missing", sourceSpan);
      }
      const ast = this._parseBinding(expression || "undefined", false, valueSpan || sourceSpan, absoluteOffset);
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));
    }
    _parseBinding(value, isHostBinding2, sourceSpan, absoluteOffset) {
      const sourceInfo = (sourceSpan && sourceSpan.start || "(unknown)").toString();
      try {
        const ast = isHostBinding2 ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {
      if (boundProp.isAnimation) {
        return new BoundElementProperty(boundProp.name, 4, SecurityContext2.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
      }
      let unit = null;
      let bindingType = void 0;
      let boundPropertyName = null;
      const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
      let securityContexts = void 0;
      if (parts.length > 1) {
        if (parts[0] == ATTRIBUTE_PREFIX) {
          boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);
          if (!skipValidation) {
            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
          }
          securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
          const nsSeparatorIdx = boundPropertyName.indexOf(":");
          if (nsSeparatorIdx > -1) {
            const ns = boundPropertyName.substring(0, nsSeparatorIdx);
            const name = boundPropertyName.substring(nsSeparatorIdx + 1);
            boundPropertyName = mergeNsAndName(ns, name);
          }
          bindingType = 1;
        } else if (parts[0] == CLASS_PREFIX) {
          boundPropertyName = parts[1];
          bindingType = 2;
          securityContexts = [SecurityContext2.NONE];
        } else if (parts[0] == STYLE_PREFIX) {
          unit = parts.length > 2 ? parts[2] : null;
          boundPropertyName = parts[1];
          bindingType = 3;
          securityContexts = [SecurityContext2.STYLE];
        }
      }
      if (boundPropertyName === null) {
        const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);
        boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
        bindingType = 0;
        if (!skipValidation) {
          this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
        }
      }
      return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
    }
    parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
      if (name.length === 0) {
        this._reportError(`Event name is missing in binding`, sourceSpan);
      }
      if (isAnimationLabel(name)) {
        name = name.substr(1);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
        this._parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);
      } else {
        this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);
      }
    }
    calcPossibleSecurityContexts(selector, propName, isAttribute) {
      const prop = this._schemaRegistry.getMappedPropName(propName);
      return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
    }
    _parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan) {
      const matches = splitAtPeriod(name, [name, ""]);
      const eventName = matches[0];
      const phase = matches[1].toLowerCase();
      const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);
      targetEvents.push(new ParsedEvent(eventName, phase, 1, ast, sourceSpan, handlerSpan, keySpan));
      if (eventName.length === 0) {
        this._reportError(`Animation event name is missing in binding`, sourceSpan);
      }
      if (phase) {
        if (phase !== "start" && phase !== "done") {
          this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
        }
      } else {
        this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
      }
    }
    _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
      const [target, eventName] = splitAtColon(name, [null, name]);
      const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);
      targetMatchableAttrs.push([name, ast.source]);
      targetEvents.push(new ParsedEvent(eventName, target, 0, ast, sourceSpan, handlerSpan, keySpan));
    }
    _parseAction(value, isAssignmentEvent, sourceSpan) {
      const sourceInfo = (sourceSpan && sourceSpan.start || "(unknown").toString();
      const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;
      try {
        const ast = this._exprParser.parseAction(value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);
        if (ast) {
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        }
        if (!ast || ast.ast instanceof EmptyExpr) {
          this._reportError(`Empty expressions are not allowed`, sourceSpan);
          return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
        }
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
      this.errors.push(new ParseError(sourceSpan, message, level));
    }
    _reportExpressionParserErrors(errors, sourceSpan) {
      for (const error3 of errors) {
        this._reportError(error3.message, sourceSpan);
      }
    }
    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
      const report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);
      if (report.error) {
        this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
      }
    }
  };
  function isAnimationLabel(name) {
    return name[0] == "@";
  }
  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
    const ctxs = [];
    CssSelector.parse(selector).forEach((selector2) => {
      const elementNames = selector2.element ? [selector2.element] : registry.allKnownElementNames();
      const notElementNames = new Set(selector2.notSelectors.filter((selector3) => selector3.isElementSelector()).map((selector3) => selector3.element));
      const possibleElementNames = elementNames.filter((elementName) => !notElementNames.has(elementName));
      ctxs.push(...possibleElementNames.map((elementName) => registry.securityContext(elementName, propName, isAttribute)));
    });
    return ctxs.length === 0 ? [SecurityContext2.NONE] : Array.from(new Set(ctxs)).sort();
  }
  function moveParseSourceSpan(sourceSpan, absoluteSpan) {
    const startDiff = absoluteSpan.start - sourceSpan.start.offset;
    const endDiff = absoluteSpan.end - sourceSpan.end.offset;
    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);
  }
  function isStyleUrlResolvable(url) {
    if (url == null || url.length === 0 || url[0] == "/")
      return false;
    const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
    return schemeMatch === null || schemeMatch[1] == "package" || schemeMatch[1] == "asset";
  }
  var URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;
  var NG_CONTENT_SELECT_ATTR$1 = "select";
  var LINK_ELEMENT = "link";
  var LINK_STYLE_REL_ATTR = "rel";
  var LINK_STYLE_HREF_ATTR = "href";
  var LINK_STYLE_REL_VALUE = "stylesheet";
  var STYLE_ELEMENT = "style";
  var SCRIPT_ELEMENT = "script";
  var NG_NON_BINDABLE_ATTR = "ngNonBindable";
  var NG_PROJECT_AS = "ngProjectAs";
  function preparseElement(ast) {
    let selectAttr = null;
    let hrefAttr = null;
    let relAttr = null;
    let nonBindable = false;
    let projectAs = "";
    ast.attrs.forEach((attr) => {
      const lcAttrName = attr.name.toLowerCase();
      if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {
        selectAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
        hrefAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
        relAttr = attr.value;
      } else if (attr.name == NG_NON_BINDABLE_ATTR) {
        nonBindable = true;
      } else if (attr.name == NG_PROJECT_AS) {
        if (attr.value.length > 0) {
          projectAs = attr.value;
        }
      }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    const nodeName = ast.name.toLowerCase();
    let type = PreparsedElementType.OTHER;
    if (isNgContent(nodeName)) {
      type = PreparsedElementType.NG_CONTENT;
    } else if (nodeName == STYLE_ELEMENT) {
      type = PreparsedElementType.STYLE;
    } else if (nodeName == SCRIPT_ELEMENT) {
      type = PreparsedElementType.SCRIPT;
    } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
      type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType;
  (function(PreparsedElementType2) {
    PreparsedElementType2[PreparsedElementType2["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType2[PreparsedElementType2["STYLE"] = 1] = "STYLE";
    PreparsedElementType2[PreparsedElementType2["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType2[PreparsedElementType2["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType2[PreparsedElementType2["OTHER"] = 4] = "OTHER";
  })(PreparsedElementType || (PreparsedElementType = {}));
  var PreparsedElement = class {
    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
      this.type = type;
      this.selectAttr = selectAttr;
      this.hrefAttr = hrefAttr;
      this.nonBindable = nonBindable;
      this.projectAs = projectAs;
    }
  };
  function normalizeNgContentSelect(selectAttr) {
    if (selectAttr === null || selectAttr.length === 0) {
      return "*";
    }
    return selectAttr;
  }
  var BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;
  var KW_BIND_IDX = 1;
  var KW_LET_IDX = 2;
  var KW_REF_IDX = 3;
  var KW_ON_IDX = 4;
  var KW_BINDON_IDX = 5;
  var KW_AT_IDX = 6;
  var IDENT_KW_IDX = 7;
  var BINDING_DELIMS = {
    BANANA_BOX: { start: "[(", end: ")]" },
    PROPERTY: { start: "[", end: "]" },
    EVENT: { start: "(", end: ")" }
  };
  var TEMPLATE_ATTR_PREFIX = "*";
  function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
    const transformer = new HtmlAstToIvyAst(bindingParser, options);
    const ivyNodes = visitAll(transformer, htmlNodes);
    const allErrors = bindingParser.errors.concat(transformer.errors);
    const result = {
      nodes: ivyNodes,
      errors: allErrors,
      styleUrls: transformer.styleUrls,
      styles: transformer.styles,
      ngContentSelectors: transformer.ngContentSelectors
    };
    if (options.collectCommentNodes) {
      result.commentNodes = transformer.commentNodes;
    }
    return result;
  }
  var HtmlAstToIvyAst = class {
    constructor(bindingParser, options) {
      this.bindingParser = bindingParser;
      this.options = options;
      this.errors = [];
      this.styles = [];
      this.styleUrls = [];
      this.ngContentSelectors = [];
      this.commentNodes = [];
      this.inI18nBlock = false;
    }
    visitElement(element2) {
      const isI18nRootElement = isI18nRootNode(element2.i18n);
      if (isI18nRootElement) {
        if (this.inI18nBlock) {
          this.reportError("Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.", element2.sourceSpan);
        }
        this.inI18nBlock = true;
      }
      const preparsedElement = preparseElement(element2);
      if (preparsedElement.type === PreparsedElementType.SCRIPT) {
        return null;
      } else if (preparsedElement.type === PreparsedElementType.STYLE) {
        const contents = textContents(element2);
        if (contents !== null) {
          this.styles.push(contents);
        }
        return null;
      } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
        this.styleUrls.push(preparsedElement.hrefAttr);
        return null;
      }
      const isTemplateElement2 = isNgTemplate(element2.name);
      const parsedProperties = [];
      const boundEvents = [];
      const variables = [];
      const references = [];
      const attributes = [];
      const i18nAttrsMeta = {};
      const templateParsedProperties = [];
      const templateVariables = [];
      let elementHasInlineTemplate = false;
      for (const attribute of element2.attrs) {
        let hasBinding = false;
        const normalizedName = normalizeAttributeName(attribute.name);
        let isTemplateBinding = false;
        if (attribute.i18n) {
          i18nAttrsMeta[attribute.name] = attribute.i18n;
        }
        if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
          if (elementHasInlineTemplate) {
            this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
          }
          isTemplateBinding = true;
          elementHasInlineTemplate = true;
          const templateValue = attribute.value;
          const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
          const parsedVariables = [];
          const absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : attribute.sourceSpan.start.offset + attribute.name.length;
          this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true);
          templateVariables.push(...parsedVariables.map((v) => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));
        } else {
          hasBinding = this.parseAttribute(isTemplateElement2, attribute, [], parsedProperties, boundEvents, variables, references);
        }
        if (!hasBinding && !isTemplateBinding) {
          attributes.push(this.visitAttribute(attribute));
        }
      }
      const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element2.children);
      let parsedElement;
      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
        if (element2.children && !element2.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {
          this.reportError(`<ng-content> element cannot have content.`, element2.sourceSpan);
        }
        const selector = preparsedElement.selectAttr;
        const attrs = element2.attrs.map((attr) => this.visitAttribute(attr));
        parsedElement = new Content(selector, attrs, element2.sourceSpan, element2.i18n);
        this.ngContentSelectors.push(selector);
      } else if (isTemplateElement2) {
        const attrs = this.extractAttributes(element2.name, parsedProperties, i18nAttrsMeta);
        parsedElement = new Template(element2.name, attributes, attrs.bound, boundEvents, [], children, references, variables, element2.sourceSpan, element2.startSourceSpan, element2.endSourceSpan, element2.i18n);
      } else {
        const attrs = this.extractAttributes(element2.name, parsedProperties, i18nAttrsMeta);
        parsedElement = new Element$1(element2.name, attributes, attrs.bound, boundEvents, children, references, element2.sourceSpan, element2.startSourceSpan, element2.endSourceSpan, element2.i18n);
      }
      if (elementHasInlineTemplate) {
        const attrs = this.extractAttributes("ng-template", templateParsedProperties, i18nAttrsMeta);
        const templateAttrs = [];
        attrs.literal.forEach((attr) => templateAttrs.push(attr));
        attrs.bound.forEach((attr) => templateAttrs.push(attr));
        const hoistedAttrs = parsedElement instanceof Element$1 ? {
          attributes: parsedElement.attributes,
          inputs: parsedElement.inputs,
          outputs: parsedElement.outputs
        } : { attributes: [], inputs: [], outputs: [] };
        const i18n = isTemplateElement2 && isI18nRootElement ? void 0 : element2.i18n;
        const name = parsedElement instanceof Template ? null : parsedElement.name;
        parsedElement = new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [], templateVariables, element2.sourceSpan, element2.startSourceSpan, element2.endSourceSpan, i18n);
      }
      if (isI18nRootElement) {
        this.inI18nBlock = false;
      }
      return parsedElement;
    }
    visitAttribute(attribute) {
      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    }
    visitText(text) {
      return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);
    }
    visitExpansion(expansion) {
      if (!expansion.i18n) {
        return null;
      }
      if (!isI18nRootNode(expansion.i18n)) {
        throw new Error(`Invalid type "${expansion.i18n.constructor}" for "i18n" property of ${expansion.sourceSpan.toString()}. Expected a "Message"`);
      }
      const message = expansion.i18n;
      const vars = {};
      const placeholders = {};
      Object.keys(message.placeholders).forEach((key) => {
        const value = message.placeholders[key];
        if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
          const formattedKey = key.trim();
          const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);
          vars[formattedKey] = new BoundText(ast, value.sourceSpan);
        } else {
          placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);
        }
      });
      return new Icu$1(vars, placeholders, expansion.sourceSpan, message);
    }
    visitExpansionCase(expansionCase) {
      return null;
    }
    visitComment(comment) {
      if (this.options.collectCommentNodes) {
        this.commentNodes.push(new Comment$1(comment.value || "", comment.sourceSpan));
      }
      return null;
    }
    extractAttributes(elementName, properties, i18nPropsMeta) {
      const bound = [];
      const literal2 = [];
      properties.forEach((prop) => {
        const i18n = i18nPropsMeta[prop.name];
        if (prop.isLiteral) {
          literal2.push(new TextAttribute(prop.name, prop.expression.source || "", prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
        } else {
          const bep = this.bindingParser.createBoundElementProperty(elementName, prop, true, false);
          bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
        }
      });
      return { bound, literal: literal2 };
    }
    parseAttribute(isTemplateElement2, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
      const name = normalizeAttributeName(attribute.name);
      const value = attribute.value;
      const srcSpan = attribute.sourceSpan;
      const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
      function createKeySpan(srcSpan2, prefix, identifier) {
        const normalizationAdjustment = attribute.name.length - name.length;
        const keySpanStart = srcSpan2.start.moveBy(prefix.length + normalizationAdjustment);
        const keySpanEnd = keySpanStart.moveBy(identifier.length);
        return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
      }
      const bindParts = name.match(BIND_NAME_REGEXP);
      if (bindParts) {
        if (bindParts[KW_BIND_IDX] != null) {
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
        } else if (bindParts[KW_LET_IDX]) {
          if (isTemplateElement2) {
            const identifier = bindParts[IDENT_KW_IDX];
            const keySpan2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);
            this.parseVariable(identifier, value, srcSpan, keySpan2, attribute.valueSpan, variables);
          } else {
            this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
          }
        } else if (bindParts[KW_REF_IDX]) {
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);
          this.parseReference(identifier, value, srcSpan, keySpan2, attribute.valueSpan, references);
        } else if (bindParts[KW_ON_IDX]) {
          const events = [];
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);
          this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan2);
          addEvents(events, boundEvents);
        } else if (bindParts[KW_BINDON_IDX]) {
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan2);
        } else if (bindParts[KW_AT_IDX]) {
          const keySpan2 = createKeySpan(srcSpan, "", name);
          this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
        }
        return true;
      }
      let delims = null;
      if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
        delims = BINDING_DELIMS.BANANA_BOX;
      } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
        delims = BINDING_DELIMS.PROPERTY;
      } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
        delims = BINDING_DELIMS.EVENT;
      }
      if (delims !== null && name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
        const identifier = name.substring(delims.start.length, name.length - delims.end.length);
        const keySpan2 = createKeySpan(srcSpan, delims.start, identifier);
        if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan2);
        } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
        } else {
          const events = [];
          this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan2);
          addEvents(events, boundEvents);
        }
        return true;
      }
      const keySpan = createKeySpan(srcSpan, "", name);
      const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, attribute.valueTokens ?? null);
      return hasBinding;
    }
    _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {
      const valueNoNgsp = replaceNgsp2(value);
      const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);
      return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);
    }
    parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {
      if (identifier.indexOf("-") > -1) {
        this.reportError(`"-" is not allowed in variable names`, sourceSpan);
      } else if (identifier.length === 0) {
        this.reportError(`Variable does not have a name`, sourceSpan);
      }
      variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));
    }
    parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {
      if (identifier.indexOf("-") > -1) {
        this.reportError(`"-" is not allowed in reference names`, sourceSpan);
      } else if (identifier.length === 0) {
        this.reportError(`Reference does not have a name`, sourceSpan);
      } else if (references.some((reference) => reference.name === identifier)) {
        this.reportError(`Reference "#${identifier}" is defined more than once`, sourceSpan);
      }
      references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));
    }
    parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
      const events = [];
      this.bindingParser.parseEvent(`${name}Change`, `${expression} =$event`, true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);
      addEvents(events, boundEvents);
    }
    reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
      this.errors.push(new ParseError(sourceSpan, message, level));
    }
  };
  var NonBindableVisitor = class {
    visitElement(ast) {
      const preparsedElement = preparseElement(ast);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
        return null;
      }
      const children = visitAll(this, ast.children, null);
      return new Element$1(ast.name, visitAll(this, ast.attrs), [], [], children, [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
    }
    visitComment(comment) {
      return null;
    }
    visitAttribute(attribute) {
      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    }
    visitText(text) {
      return new Text$3(text.value, text.sourceSpan);
    }
    visitExpansion(expansion) {
      return null;
    }
    visitExpansionCase(expansionCase) {
      return null;
    }
  };
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  function normalizeAttributeName(attrName) {
    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
  }
  function addEvents(events, boundEvents) {
    boundEvents.push(...events.map((e) => BoundEvent.fromParsedEvent(e)));
  }
  function isEmptyTextNode(node) {
    return node instanceof Text2 && node.value.trim().length == 0;
  }
  function isCommentNode(node) {
    return node instanceof Comment;
  }
  function textContents(node) {
    if (node.children.length !== 1 || !(node.children[0] instanceof Text2)) {
      return null;
    } else {
      return node.children[0].value;
    }
  }
  var TagType;
  (function(TagType2) {
    TagType2[TagType2["ELEMENT"] = 0] = "ELEMENT";
    TagType2[TagType2["TEMPLATE"] = 1] = "TEMPLATE";
  })(TagType || (TagType = {}));
  function setupRegistry() {
    return { getUniqueId: getSeqNumberGenerator(), icus: /* @__PURE__ */ new Map() };
  }
  var I18nContext = class {
    constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
      this.index = index;
      this.ref = ref;
      this.level = level;
      this.templateIndex = templateIndex;
      this.meta = meta;
      this.registry = registry;
      this.bindings = /* @__PURE__ */ new Set();
      this.placeholders = /* @__PURE__ */ new Map();
      this.isEmitted = false;
      this._unresolvedCtxCount = 0;
      this._registry = registry || setupRegistry();
      this.id = this._registry.getUniqueId();
    }
    appendTag(type, node, index, closed) {
      if (node.isVoid && closed) {
        return;
      }
      const ph = node.isVoid || !closed ? node.startName : node.closeName;
      const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };
      updatePlaceholderMap(this.placeholders, ph, content);
    }
    get icus() {
      return this._registry.icus;
    }
    get isRoot() {
      return this.level === 0;
    }
    get isResolved() {
      return this._unresolvedCtxCount === 0;
    }
    getSerializedPlaceholders() {
      const result = /* @__PURE__ */ new Map();
      this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
      return result;
    }
    appendBinding(binding) {
      this.bindings.add(binding);
    }
    appendIcu(name, ref) {
      updatePlaceholderMap(this._registry.icus, name, ref);
    }
    appendBoundText(node) {
      const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
      phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
    }
    appendTemplate(node, index) {
      this.appendTag(TagType.TEMPLATE, node, index, false);
      this.appendTag(TagType.TEMPLATE, node, index, true);
      this._unresolvedCtxCount++;
    }
    appendElement(node, index, closed) {
      this.appendTag(TagType.ELEMENT, node, index, closed);
    }
    appendProjection(node, index) {
      this.appendTag(TagType.ELEMENT, node, index, false);
      this.appendTag(TagType.ELEMENT, node, index, true);
    }
    forkChildContext(index, templateIndex, meta) {
      return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
    }
    reconcileChildContext(context) {
      ["start", "close"].forEach((op) => {
        const key = context.meta[`${op}Name`];
        const phs = this.placeholders.get(key) || [];
        const tag = phs.find(findTemplateFn(this.id, context.templateIndex));
        if (tag) {
          tag.ctx = context.id;
        }
      });
      const childPhs = context.placeholders;
      childPhs.forEach((values, key) => {
        const phs = this.placeholders.get(key);
        if (!phs) {
          this.placeholders.set(key, values);
          return;
        }
        const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));
        if (tmplIdx >= 0) {
          const isCloseTag = key.startsWith("CLOSE");
          const isTemplateTag = key.endsWith("NG-TEMPLATE");
          if (isTemplateTag) {
            phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
          } else {
            const idx = isCloseTag ? values.length - 1 : 0;
            values[idx].tmpl = phs[tmplIdx];
            phs.splice(tmplIdx, 1, ...values);
          }
        } else {
          phs.push(...values);
        }
        this.placeholders.set(key, phs);
      });
      this._unresolvedCtxCount--;
    }
  };
  function wrap(symbol, index, contextId, closed) {
    const state = closed ? "/" : "";
    return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
  }
  function wrapTag(symbol, { index, ctx, isVoid }, closed) {
    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);
  }
  function findTemplateFn(ctx, templateIndex) {
    return (token) => typeof token === "object" && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;
  }
  function serializePlaceholderValue(value) {
    const element2 = (data, closed) => wrapTag("#", data, closed);
    const template = (data, closed) => wrapTag("*", data, closed);
    const projection = (data, closed) => wrapTag("!", data, closed);
    switch (value.type) {
      case TagType.ELEMENT:
        if (value.closed) {
          return element2(value, true) + (value.tmpl ? template(value.tmpl, true) : "");
        }
        if (value.tmpl) {
          return template(value.tmpl) + element2(value) + (value.isVoid ? template(value.tmpl, true) : "");
        }
        return element2(value);
      case TagType.TEMPLATE:
        return template(value, value.closed);
      default:
        return value;
    }
  }
  var IcuSerializerVisitor = class {
    visitText(text) {
      return text.value;
    }
    visitContainer(container) {
      return container.children.map((child) => child.visit(this)).join("");
    }
    visitIcu(icu) {
      const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(" ")}}`;
      return result;
    }
    visitTagPlaceholder(ph) {
      return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map((child) => child.visit(this)).join("")}${this.formatPh(ph.closeName)}`;
    }
    visitPlaceholder(ph) {
      return this.formatPh(ph.name);
    }
    visitIcuPlaceholder(ph, context) {
      return this.formatPh(ph.name);
    }
    formatPh(value) {
      return `{${formatI18nPlaceholderName(value, false)}}`;
    }
  };
  var serializer = new IcuSerializerVisitor();
  function serializeIcuNode(icu) {
    return icu.visit(serializer);
  }
  var TAG_TO_PLACEHOLDER_NAMES = {
    "A": "LINK",
    "B": "BOLD_TEXT",
    "BR": "LINE_BREAK",
    "EM": "EMPHASISED_TEXT",
    "H1": "HEADING_LEVEL1",
    "H2": "HEADING_LEVEL2",
    "H3": "HEADING_LEVEL3",
    "H4": "HEADING_LEVEL4",
    "H5": "HEADING_LEVEL5",
    "H6": "HEADING_LEVEL6",
    "HR": "HORIZONTAL_RULE",
    "I": "ITALIC_TEXT",
    "LI": "LIST_ITEM",
    "LINK": "MEDIA_LINK",
    "OL": "ORDERED_LIST",
    "P": "PARAGRAPH",
    "Q": "QUOTATION",
    "S": "STRIKETHROUGH_TEXT",
    "SMALL": "SMALL_TEXT",
    "SUB": "SUBSTRIPT",
    "SUP": "SUPERSCRIPT",
    "TBODY": "TABLE_BODY",
    "TD": "TABLE_CELL",
    "TFOOT": "TABLE_FOOTER",
    "TH": "TABLE_HEADER_CELL",
    "THEAD": "TABLE_HEADER",
    "TR": "TABLE_ROW",
    "TT": "MONOSPACED_TEXT",
    "U": "UNDERLINED_TEXT",
    "UL": "UNORDERED_LIST"
  };
  var PlaceholderRegistry = class {
    constructor() {
      this._placeHolderNameCounts = {};
      this._signatureToName = {};
    }
    getStartTagPlaceholderName(tag, attrs, isVoid) {
      const signature = this._hashTag(tag, attrs, isVoid);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      const upperTag = tag.toUpperCase();
      const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
      const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
      this._signatureToName[signature] = name;
      return name;
    }
    getCloseTagPlaceholderName(tag) {
      const signature = this._hashClosingTag(tag);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      const upperTag = tag.toUpperCase();
      const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
      const name = this._generateUniqueName(`CLOSE_${baseName}`);
      this._signatureToName[signature] = name;
      return name;
    }
    getPlaceholderName(name, content) {
      const upperName = name.toUpperCase();
      const signature = `PH: ${upperName}=${content}`;
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      const uniqueName = this._generateUniqueName(upperName);
      this._signatureToName[signature] = uniqueName;
      return uniqueName;
    }
    getUniquePlaceholder(name) {
      return this._generateUniqueName(name.toUpperCase());
    }
    _hashTag(tag, attrs, isVoid) {
      const start = `<${tag}`;
      const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join("");
      const end = isVoid ? "/>" : `></${tag}>`;
      return start + strAttrs + end;
    }
    _hashClosingTag(tag) {
      return this._hashTag(`/${tag}`, {}, false);
    }
    _generateUniqueName(base) {
      const seen = this._placeHolderNameCounts.hasOwnProperty(base);
      if (!seen) {
        this._placeHolderNameCounts[base] = 1;
        return base;
      }
      const id = this._placeHolderNameCounts[base];
      this._placeHolderNameCounts[base] = id + 1;
      return `${base}_${id}`;
    }
  };
  var _expParser = new Parser$1(new Lexer());
  function createI18nMessageFactory(interpolationConfig) {
    const visitor = new _I18nVisitor(_expParser, interpolationConfig);
    return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
  }
  function noopVisitNodeFn(_html, i18n) {
    return i18n;
  }
  var _I18nVisitor = class {
    constructor(_expressionParser, _interpolationConfig) {
      this._expressionParser = _expressionParser;
      this._interpolationConfig = _interpolationConfig;
    }
    toI18nMessage(nodes, meaning = "", description = "", customId = "", visitNodeFn) {
      const context = {
        isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
        icuDepth: 0,
        placeholderRegistry: new PlaceholderRegistry(),
        placeholderToContent: {},
        placeholderToMessage: {},
        visitNodeFn: visitNodeFn || noopVisitNodeFn
      };
      const i18nodes = visitAll(this, nodes, context);
      return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);
    }
    visitElement(el, context) {
      const children = visitAll(this, el.children, context);
      const attrs = {};
      el.attrs.forEach((attr) => {
        attrs[attr.name] = attr.value;
      });
      const isVoid = getHtmlTagDefinition(el.name).isVoid;
      const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
      context.placeholderToContent[startPhName] = {
        text: el.startSourceSpan.toString(),
        sourceSpan: el.startSourceSpan
      };
      let closePhName = "";
      if (!isVoid) {
        closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);
        context.placeholderToContent[closePhName] = {
          text: `</${el.name}>`,
          sourceSpan: el.endSourceSpan ?? el.sourceSpan
        };
      }
      const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
      return context.visitNodeFn(el, node);
    }
    visitAttribute(attribute, context) {
      const node = attribute.valueTokens === void 0 || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);
      return context.visitNodeFn(attribute, node);
    }
    visitText(text, context) {
      const node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);
      return context.visitNodeFn(text, node);
    }
    visitComment(comment, context) {
      return null;
    }
    visitExpansion(icu, context) {
      context.icuDepth++;
      const i18nIcuCases = {};
      const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
      icu.cases.forEach((caze) => {
        i18nIcuCases[caze.value] = new Container(caze.expression.map((node2) => node2.visit(this, context)), caze.expSourceSpan);
      });
      context.icuDepth--;
      if (context.isIcu || context.icuDepth > 0) {
        const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
        i18nIcu.expressionPlaceholder = expPh;
        context.placeholderToContent[expPh] = {
          text: icu.switchValue,
          sourceSpan: icu.switchValueSourceSpan
        };
        return context.visitNodeFn(icu, i18nIcu);
      }
      const phName = context.placeholderRegistry.getPlaceholderName("ICU", icu.sourceSpan.toString());
      context.placeholderToMessage[phName] = this.toI18nMessage([icu], "", "", "", void 0);
      const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
      return context.visitNodeFn(icu, node);
    }
    visitExpansionCase(_icuCase, _context) {
      throw new Error("Unreachable code");
    }
    _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {
      const nodes = [];
      let hasInterpolation = false;
      for (const token of tokens) {
        switch (token.type) {
          case 8:
          case 17:
            hasInterpolation = true;
            const expression = token.parts[1];
            const baseName = extractPlaceholderName(expression) || "INTERPOLATION";
            const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);
            context.placeholderToContent[phName] = {
              text: token.parts.join(""),
              sourceSpan: token.sourceSpan
            };
            nodes.push(new Placeholder(expression, phName, token.sourceSpan));
            break;
          default:
            if (token.parts[0].length > 0) {
              const previous = nodes[nodes.length - 1];
              if (previous instanceof Text$2) {
                previous.value += token.parts[0];
                previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);
              } else {
                nodes.push(new Text$2(token.parts[0], token.sourceSpan));
              }
            }
            break;
        }
      }
      if (hasInterpolation) {
        reusePreviousSourceSpans(nodes, previousI18n);
        return new Container(nodes, sourceSpan);
      } else {
        return nodes[0];
      }
    }
  };
  function reusePreviousSourceSpans(nodes, previousI18n) {
    if (previousI18n instanceof Message) {
      assertSingleContainerMessage(previousI18n);
      previousI18n = previousI18n.nodes[0];
    }
    if (previousI18n instanceof Container) {
      assertEquivalentNodes(previousI18n.children, nodes);
      for (let i = 0; i < nodes.length; i++) {
        nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;
      }
    }
  }
  function assertSingleContainerMessage(message) {
    const nodes = message.nodes;
    if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {
      throw new Error("Unexpected previous i18n message - expected it to consist of only a single `Container` node.");
    }
  }
  function assertEquivalentNodes(previousNodes, nodes) {
    if (previousNodes.length !== nodes.length) {
      throw new Error("The number of i18n message children changed between first and second pass.");
    }
    if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {
      throw new Error("The types of the i18n message children changed between first and second pass.");
    }
  }
  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
  function extractPlaceholderName(input) {
    return input.split(_CUSTOM_PH_EXP)[2];
  }
  var I18nError = class extends ParseError {
    constructor(span, msg) {
      super(span, msg);
    }
  };
  var setI18nRefs = (htmlNode, i18nNode) => {
    if (htmlNode instanceof NodeWithI18n) {
      if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
        i18nNode.previousMessage = htmlNode.i18n;
      }
      htmlNode.i18n = i18nNode;
    }
    return i18nNode;
  };
  var I18nMetaVisitor = class {
    constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {
      this.interpolationConfig = interpolationConfig;
      this.keepI18nAttrs = keepI18nAttrs;
      this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
      this.hasI18nMeta = false;
      this._errors = [];
      this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
    }
    _generateI18nMessage(nodes, meta = "", visitNodeFn) {
      const { meaning, description, customId } = this._parseMetadata(meta);
      const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);
      this._setMessageId(message, meta);
      this._setLegacyIds(message, meta);
      return message;
    }
    visitAllWithErrors(nodes) {
      const result = nodes.map((node) => node.visit(this, null));
      return new ParseTreeResult(result, this._errors);
    }
    visitElement(element2) {
      let message = void 0;
      if (hasI18nAttrs(element2)) {
        this.hasI18nMeta = true;
        const attrs = [];
        const attrsMeta = {};
        for (const attr of element2.attrs) {
          if (attr.name === I18N_ATTR) {
            const i18n = element2.i18n || attr.value;
            message = this._generateI18nMessage(element2.children, i18n, setI18nRefs);
            if (message.nodes.length === 0) {
              message = void 0;
            }
            element2.i18n = message;
          } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
            const name = attr.name.slice(I18N_ATTR_PREFIX.length);
            if (isTrustedTypesSink(element2.name, name)) {
              this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);
            } else {
              attrsMeta[name] = attr.value;
            }
          } else {
            attrs.push(attr);
          }
        }
        if (Object.keys(attrsMeta).length) {
          for (const attr of attrs) {
            const meta = attrsMeta[attr.name];
            if (meta !== void 0 && attr.value) {
              attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
            }
          }
        }
        if (!this.keepI18nAttrs) {
          element2.attrs = attrs;
        }
      }
      visitAll(this, element2.children, message);
      return element2;
    }
    visitExpansion(expansion, currentMessage) {
      let message;
      const meta = expansion.i18n;
      this.hasI18nMeta = true;
      if (meta instanceof IcuPlaceholder) {
        const name = meta.name;
        message = this._generateI18nMessage([expansion], meta);
        const icu = icuFromI18nMessage(message);
        icu.name = name;
        if (currentMessage !== null) {
          currentMessage.placeholderToMessage[name] = message;
        }
      } else {
        message = this._generateI18nMessage([expansion], currentMessage || meta);
      }
      expansion.i18n = message;
      return expansion;
    }
    visitText(text) {
      return text;
    }
    visitAttribute(attribute) {
      return attribute;
    }
    visitComment(comment) {
      return comment;
    }
    visitExpansionCase(expansionCase) {
      return expansionCase;
    }
    _parseMetadata(meta) {
      return typeof meta === "string" ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};
    }
    _setMessageId(message, meta) {
      if (!message.id) {
        message.id = meta instanceof Message && meta.id || decimalDigest(message);
      }
    }
    _setLegacyIds(message, meta) {
      if (this.enableI18nLegacyMessageIdFormat) {
        message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
      } else if (typeof meta !== "string") {
        const previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : void 0;
        message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
      }
    }
    _reportError(node, msg) {
      this._errors.push(new I18nError(node.sourceSpan, msg));
    }
  };
  var I18N_MEANING_SEPARATOR = "|";
  var I18N_ID_SEPARATOR = "@@";
  function parseI18nMeta(meta = "") {
    let customId;
    let meaning;
    let description;
    meta = meta.trim();
    if (meta) {
      const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
      const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
      let meaningAndDesc;
      [meaningAndDesc, customId] = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ""];
      [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ["", meaningAndDesc];
    }
    return { customId, meaning, description };
  }
  function i18nMetaToJSDoc(meta) {
    const tags = [];
    if (meta.description) {
      tags.push({ tagName: "desc", text: meta.description });
    } else {
      tags.push({ tagName: "suppress", text: "{msgDescriptions}" });
    }
    if (meta.meaning) {
      tags.push({ tagName: "meaning", text: meta.meaning });
    }
    return jsDocComment(tags);
  }
  var GOOG_GET_MSG = "goog.getMsg";
  function createGoogleGetMsgStatements(variable$1, message, closureVar, params) {
    const messageString = serializeI18nMessageForGetMsg(message);
    const args = [literal(messageString)];
    if (Object.keys(params).length) {
      args.push(mapLiteral(params, true));
    }
    const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();
    googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));
    const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));
    return [googGetMsgStmt, i18nAssignmentStmt];
  }
  var GetMsgSerializerVisitor = class {
    formatPh(value) {
      return `{$${formatI18nPlaceholderName(value)}}`;
    }
    visitText(text) {
      return text.value;
    }
    visitContainer(container) {
      return container.children.map((child) => child.visit(this)).join("");
    }
    visitIcu(icu) {
      return serializeIcuNode(icu);
    }
    visitTagPlaceholder(ph) {
      return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map((child) => child.visit(this)).join("")}${this.formatPh(ph.closeName)}`;
    }
    visitPlaceholder(ph) {
      return this.formatPh(ph.name);
    }
    visitIcuPlaceholder(ph, context) {
      return this.formatPh(ph.name);
    }
  };
  var serializerVisitor = new GetMsgSerializerVisitor();
  function serializeI18nMessageForGetMsg(message) {
    return message.nodes.map((node) => node.visit(serializerVisitor, null)).join("");
  }
  function createLocalizeStatements(variable2, message, params) {
    const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);
    const sourceSpan = getSourceSpan(message);
    const expressions = placeHolders.map((ph) => params[ph.text]);
    const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);
    const variableInitialization = variable2.set(localizedString$1);
    return [new ExpressionStatement(variableInitialization)];
  }
  var LocalizeSerializerVisitor = class {
    constructor(placeholderToMessage, pieces) {
      this.placeholderToMessage = placeholderToMessage;
      this.pieces = pieces;
    }
    visitText(text) {
      if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {
        this.pieces[this.pieces.length - 1].text += text.value;
      } else {
        const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);
        this.pieces.push(new LiteralPiece(text.value, sourceSpan));
      }
    }
    visitContainer(container) {
      container.children.forEach((child) => child.visit(this));
    }
    visitIcu(icu) {
      this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));
    }
    visitTagPlaceholder(ph) {
      this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));
      if (!ph.isVoid) {
        ph.children.forEach((child) => child.visit(this));
        this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));
      }
    }
    visitPlaceholder(ph) {
      this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
    }
    visitIcuPlaceholder(ph) {
      this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));
    }
    createPlaceholderPiece(name, sourceSpan, associatedMessage) {
      return new PlaceholderPiece(formatI18nPlaceholderName(name, false), sourceSpan, associatedMessage);
    }
  };
  function serializeI18nMessageForLocalize(message) {
    const pieces = [];
    const serializerVisitor2 = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);
    message.nodes.forEach((node) => node.visit(serializerVisitor2));
    return processMessagePieces(pieces);
  }
  function getSourceSpan(message) {
    const startNode = message.nodes[0];
    const endNode = message.nodes[message.nodes.length - 1];
    return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);
  }
  function processMessagePieces(pieces) {
    const messageParts = [];
    const placeHolders = [];
    if (pieces[0] instanceof PlaceholderPiece) {
      messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));
    }
    for (let i = 0; i < pieces.length; i++) {
      const part = pieces[i];
      if (part instanceof LiteralPiece) {
        messageParts.push(part);
      } else {
        placeHolders.push(part);
        if (pieces[i - 1] instanceof PlaceholderPiece) {
          messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));
        }
      }
    }
    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
      messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));
    }
    return { messageParts, placeHolders };
  }
  function createEmptyMessagePart(location2) {
    return new LiteralPiece("", new ParseSourceSpan(location2, location2));
  }
  var NG_CONTENT_SELECT_ATTR = "select";
  var NG_PROJECT_AS_ATTR_NAME = "ngProjectAs";
  var EVENT_BINDING_SCOPE_GLOBALS = /* @__PURE__ */ new Set(["$event"]);
  var GLOBAL_TARGET_RESOLVERS = /* @__PURE__ */ new Map([["window", Identifiers.resolveWindow], ["document", Identifiers.resolveDocument], ["body", Identifiers.resolveBody]]);
  var LEADING_TRIVIA_CHARS = [" ", "\n", "\r", "	"];
  function renderFlagCheckIfStmt(flags, statements) {
    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
  }
  function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
    const { type, name, target, phase, handler } = eventAst;
    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
      throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
    }
    const eventArgumentName = "$event";
    const implicitReceiverAccesses = /* @__PURE__ */ new Set();
    const implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);
    const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, "b", eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
    const statements = [];
    if (scope) {
      statements.push(...scope.variableDeclarations());
      statements.unshift(...scope.restoreViewStatement());
    }
    statements.push(...bindingStatements);
    const eventName = type === 1 ? prepareSyntheticListenerName(name, phase) : name;
    const fnName = handlerName && sanitizeIdentifier(handlerName);
    const fnArgs = [];
    if (implicitReceiverAccesses.has(eventArgumentName)) {
      fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
    }
    const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
    const params = [literal(eventName), handlerFn];
    if (target) {
      params.push(literal(false), importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
    }
    return params;
  }
  function createComponentDefConsts() {
    return {
      prepareStatements: [],
      constExpressions: [],
      i18nVarRefsCache: /* @__PURE__ */ new Map()
    };
  }
  var TemplateDefinitionBuilder = class {
    constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {
      this.constantPool = constantPool;
      this.level = level;
      this.contextName = contextName;
      this.i18nContext = i18nContext;
      this.templateIndex = templateIndex;
      this.templateName = templateName;
      this._namespace = _namespace;
      this.i18nUseExternalIds = i18nUseExternalIds;
      this._constants = _constants;
      this._dataIndex = 0;
      this._bindingContext = 0;
      this._prefixCode = [];
      this._creationCodeFns = [];
      this._updateCodeFns = [];
      this._currentIndex = 0;
      this._tempVariables = [];
      this._nestedTemplateFns = [];
      this.i18n = null;
      this._pureFunctionSlots = 0;
      this._bindingSlots = 0;
      this._ngContentReservedSlots = [];
      this._ngContentSelectorsOffset = 0;
      this._implicitReceiverExpr = null;
      this.visitReference = invalid;
      this.visitVariable = invalid;
      this.visitTextAttribute = invalid;
      this.visitBoundAttribute = invalid;
      this.visitBoundEvent = invalid;
      this._bindingScope = parentBindingScope.nestedScope(level);
      this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, "_") + "_";
      this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
        this._bindingScope.set(this.level, localName, value);
        this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);
      });
    }
    buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
      this._ngContentSelectorsOffset = ngContentSelectorsOffset;
      if (this._namespace !== Identifiers.namespaceHTML) {
        this.creationInstruction(null, this._namespace);
      }
      variables.forEach((v) => this.registerContextVariables(v));
      const initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);
      const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
      if (initI18nContext) {
        this.i18nStart(null, i18n, selfClosingI18nInstruction);
      }
      visitAll$1(this, nodes);
      this._pureFunctionSlots += this._bindingSlots;
      this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
      this._nestedTemplateFns.forEach((buildTemplateFn) => buildTemplateFn());
      if (this.level === 0 && this._ngContentReservedSlots.length) {
        const parameters = [];
        if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== "*") {
          const r3ReservedSlots = this._ngContentReservedSlots.map((s) => s !== "*" ? parseSelectorToR3Selector(s) : s);
          parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
        }
        this.creationInstruction(null, Identifiers.projectionDef, parameters, true);
      }
      if (initI18nContext) {
        this.i18nEnd(null, selfClosingI18nInstruction);
      }
      const creationStatements = getInstructionStatements(this._creationCodeFns);
      const updateStatements = getInstructionStatements(this._updateCodeFns);
      const creationVariables = this._bindingScope.viewSnapshotStatements();
      const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
      const creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1, creationVariables.concat(creationStatements))] : [];
      const updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2, updateVariables.concat(updateStatements))] : [];
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
        ...this._prefixCode,
        ...creationBlock,
        ...updateBlock
      ], INFERRED_TYPE, null, this.templateName);
    }
    getLocal(name) {
      return this._bindingScope.get(name);
    }
    notifyImplicitReceiverUse() {
      this._bindingScope.notifyImplicitReceiverUse();
    }
    maybeRestoreView() {
      this._bindingScope.maybeRestoreView();
    }
    i18nTranslate(message, params = {}, ref, transformFn) {
      const _ref = ref || this.i18nGenerateMainBlockVar();
      const closureVar = this.i18nGenerateClosureVar(message.id);
      const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);
      this._constants.prepareStatements.push(...statements);
      return _ref;
    }
    registerContextVariables(variable$1) {
      const scopedName = this._bindingScope.freshReferenceName();
      const retrievalLevel = this.level;
      const lhs = variable(variable$1.name + scopedName);
      this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1, (scope, relativeLevel) => {
        let rhs;
        if (scope.bindingLevel === retrievalLevel) {
          if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {
            rhs = variable(RESTORED_VIEW_CONTEXT_NAME);
            scope.notifyRestoredViewContextUse();
          } else {
            rhs = variable(CONTEXT_NAME);
          }
        } else {
          const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
          rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
        }
        return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
      });
    }
    i18nAppendBindings(expressions) {
      if (expressions.length > 0) {
        expressions.forEach((expression) => this.i18n.appendBinding(expression));
      }
    }
    i18nBindProps(props) {
      const bound = {};
      Object.keys(props).forEach((key) => {
        const prop = props[key];
        if (prop instanceof Text$3) {
          bound[key] = literal(prop.value);
        } else {
          const value = prop.value.visit(this._valueConverter);
          this.allocateBindingSlots(value);
          if (value instanceof Interpolation) {
            const { strings, expressions } = value;
            const { id, bindings } = this.i18n;
            const label = assembleI18nBoundString(strings, bindings.size, id);
            this.i18nAppendBindings(expressions);
            bound[key] = literal(label);
          }
        }
      });
      return bound;
    }
    i18nGenerateMainBlockVar() {
      return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));
    }
    i18nGenerateClosureVar(messageId) {
      let name;
      const suffix = this.fileBasedI18nSuffix.toUpperCase();
      if (this.i18nUseExternalIds) {
        const prefix = getTranslationConstPrefix(`EXTERNAL_`);
        const uniqueSuffix = this.constantPool.uniqueName(suffix);
        name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;
      } else {
        const prefix = getTranslationConstPrefix(suffix);
        name = this.constantPool.uniqueName(prefix);
      }
      return variable(name);
    }
    i18nUpdateRef(context) {
      const { icus, meta, isRoot, isResolved, isEmitted } = context;
      if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
        context.isEmitted = true;
        const placeholders = context.getSerializedPlaceholders();
        let icuMapping = {};
        let params = placeholders.size ? placeholdersToParams(placeholders) : {};
        if (icus.size) {
          icus.forEach((refs, key) => {
            if (refs.length === 1) {
              params[key] = refs[0];
            } else {
              const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
              params[key] = literal(placeholder);
              icuMapping[key] = literalArr(refs);
            }
          });
        }
        const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) || Object.keys(icuMapping).length;
        let transformFn;
        if (needsPostprocessing) {
          transformFn = (raw) => {
            const args = [raw];
            if (Object.keys(icuMapping).length) {
              args.push(mapLiteral(icuMapping, true));
            }
            return invokeInstruction(null, Identifiers.i18nPostprocess, args);
          };
        }
        this.i18nTranslate(meta, params, context.ref, transformFn);
      }
    }
    i18nStart(span = null, meta, selfClosing) {
      const index = this.allocateDataSlot();
      this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(index, this.templateIndex, meta) : new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);
      const { id, ref } = this.i18n;
      const params = [literal(index), this.addToConsts(ref)];
      if (id > 0) {
        params.push(literal(id));
      }
      this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);
    }
    i18nEnd(span = null, selfClosing) {
      if (!this.i18n) {
        throw new Error("i18nEnd is executed with no i18n context present");
      }
      if (this.i18nContext) {
        this.i18nContext.reconcileChildContext(this.i18n);
        this.i18nUpdateRef(this.i18nContext);
      } else {
        this.i18nUpdateRef(this.i18n);
      }
      const { index, bindings } = this.i18n;
      if (bindings.size) {
        for (const binding of bindings) {
          this.updateInstructionWithAdvance(this.getConstCount() - 1, span, Identifiers.i18nExp, () => this.convertPropertyBinding(binding));
        }
        this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);
      }
      if (!selfClosing) {
        this.creationInstruction(span, Identifiers.i18nEnd);
      }
      this.i18n = null;
    }
    i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
      let hasBindings = false;
      const i18nAttrArgs = [];
      attrs.forEach((attr) => {
        const message = attr.i18n;
        const converted = attr.value.visit(this._valueConverter);
        this.allocateBindingSlots(converted);
        if (converted instanceof Interpolation) {
          const placeholders = assembleBoundTextPlaceholders(message);
          const params = placeholdersToParams(placeholders);
          i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
          converted.expressions.forEach((expression) => {
            hasBindings = true;
            this.updateInstructionWithAdvance(nodeIndex, sourceSpan, Identifiers.i18nExp, () => this.convertPropertyBinding(expression));
          });
        }
      });
      if (i18nAttrArgs.length > 0) {
        const index = literal(this.allocateDataSlot());
        const constIndex = this.addToConsts(literalArr(i18nAttrArgs));
        this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);
        if (hasBindings) {
          this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);
        }
      }
    }
    getNamespaceInstruction(namespaceKey) {
      switch (namespaceKey) {
        case "math":
          return Identifiers.namespaceMathML;
        case "svg":
          return Identifiers.namespaceSVG;
        default:
          return Identifiers.namespaceHTML;
      }
    }
    addNamespaceInstruction(nsInstruction, element2) {
      this._namespace = nsInstruction;
      this.creationInstruction(element2.startSourceSpan, nsInstruction);
    }
    interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
      this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);
    }
    visitContent(ngContent) {
      const slot = this.allocateDataSlot();
      const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
      const parameters = [literal(slot)];
      this._ngContentReservedSlots.push(ngContent.selector);
      const nonContentSelectAttributes = ngContent.attributes.filter((attr) => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);
      const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);
      if (attributes.length > 0) {
        parameters.push(literal(projectionSlotIdx), literalArr(attributes));
      } else if (projectionSlotIdx !== 0) {
        parameters.push(literal(projectionSlotIdx));
      }
      this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);
      if (this.i18n) {
        this.i18n.appendProjection(ngContent.i18n, slot);
      }
    }
    visitElement(element2) {
      const elementIndex = this.allocateDataSlot();
      const stylingBuilder = new StylingBuilder(null);
      let isNonBindableMode = false;
      const isI18nRootElement = isI18nRootNode(element2.i18n) && !isSingleI18nIcu(element2.i18n);
      const outputAttrs = [];
      const [namespaceKey, elementName] = splitNsName(element2.name);
      const isNgContainer$1 = isNgContainer(element2.name);
      for (const attr of element2.attributes) {
        const { name, value } = attr;
        if (name === NON_BINDABLE_ATTR) {
          isNonBindableMode = true;
        } else if (name === "style") {
          stylingBuilder.registerStyleAttr(value);
        } else if (name === "class") {
          stylingBuilder.registerClassAttr(value);
        } else {
          outputAttrs.push(attr);
        }
      }
      const parameters = [literal(elementIndex)];
      if (!isNgContainer$1) {
        parameters.push(literal(elementName));
      }
      const allOtherInputs = [];
      const boundI18nAttrs = [];
      element2.inputs.forEach((input) => {
        const stylingInputWasSet = stylingBuilder.registerBoundInput(input);
        if (!stylingInputWasSet) {
          if (input.type === 0 && input.i18n) {
            boundI18nAttrs.push(input);
          } else {
            allOtherInputs.push(input);
          }
        }
      });
      const attributes = this.getAttributeExpressions(element2.name, outputAttrs, allOtherInputs, element2.outputs, stylingBuilder, [], boundI18nAttrs);
      parameters.push(this.addAttrsToConsts(attributes));
      const refs = this.prepareRefsArray(element2.references);
      parameters.push(this.addToConsts(refs));
      const wasInNamespace = this._namespace;
      const currentNamespace = this.getNamespaceInstruction(namespaceKey);
      if (currentNamespace !== wasInNamespace) {
        this.addNamespaceInstruction(currentNamespace, element2);
      }
      if (this.i18n) {
        this.i18n.appendElement(element2.i18n, elementIndex);
      }
      const hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element2.children) : element2.children.length > 0;
      const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element2.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;
      const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element2.children);
      if (createSelfClosingInstruction) {
        this.creationInstruction(element2.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));
      } else {
        this.creationInstruction(element2.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));
        if (isNonBindableMode) {
          this.creationInstruction(element2.startSourceSpan, Identifiers.disableBindings);
        }
        if (boundI18nAttrs.length > 0) {
          this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, element2.startSourceSpan ?? element2.sourceSpan);
        }
        if (element2.outputs.length > 0) {
          for (const outputAst of element2.outputs) {
            this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter(element2.name, outputAst, elementIndex));
          }
        }
        if (isI18nRootElement) {
          this.i18nStart(element2.startSourceSpan, element2.i18n, createSelfClosingI18nInstruction);
        }
      }
      const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
      const limit = stylingInstructions.length - 1;
      for (let i = 0; i <= limit; i++) {
        const instruction = stylingInstructions[i];
        this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);
      }
      const emptyValueBindInstruction = literal(void 0);
      const propertyBindings = [];
      const attributeBindings = [];
      allOtherInputs.forEach((input) => {
        const inputType = input.type;
        if (inputType === 4) {
          const value = input.value.visit(this._valueConverter);
          const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;
          this.allocateBindingSlots(value);
          propertyBindings.push({
            span: input.sourceSpan,
            paramsOrFn: getBindingFunctionParams(() => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction, prepareSyntheticPropertyName(input.name))
          });
        } else {
          if (input.i18n)
            return;
          const value = input.value.visit(this._valueConverter);
          if (value !== void 0) {
            const params = [];
            const [attrNamespace, attrName] = splitNsName(input.name);
            const isAttributeBinding = inputType === 1;
            const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
            if (sanitizationRef)
              params.push(sanitizationRef);
            if (attrNamespace) {
              const namespaceLiteral = literal(attrNamespace);
              if (sanitizationRef) {
                params.push(namespaceLiteral);
              } else {
                params.push(literal(null), namespaceLiteral);
              }
            }
            this.allocateBindingSlots(value);
            if (inputType === 0) {
              if (value instanceof Interpolation) {
                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);
              } else {
                propertyBindings.push({
                  span: input.sourceSpan,
                  paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), attrName, params)
                });
              }
            } else if (inputType === 1) {
              if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {
                this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);
              } else {
                const boundValue = value instanceof Interpolation ? value.expressions[0] : value;
                attributeBindings.push({
                  span: input.sourceSpan,
                  paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(boundValue), attrName, params)
                });
              }
            } else {
              this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {
                return [
                  literal(elementIndex),
                  literal(attrName),
                  this.convertPropertyBinding(value),
                  ...params
                ];
              });
            }
          }
        }
      });
      for (const propertyBinding of propertyBindings) {
        this.updateInstructionWithAdvance(elementIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);
      }
      for (const attributeBinding of attributeBindings) {
        this.updateInstructionWithAdvance(elementIndex, attributeBinding.span, Identifiers.attribute, attributeBinding.paramsOrFn);
      }
      visitAll$1(this, element2.children);
      if (!isI18nRootElement && this.i18n) {
        this.i18n.appendElement(element2.i18n, elementIndex, true);
      }
      if (!createSelfClosingInstruction) {
        const span = element2.endSourceSpan ?? element2.sourceSpan;
        if (isI18nRootElement) {
          this.i18nEnd(span, createSelfClosingI18nInstruction);
        }
        if (isNonBindableMode) {
          this.creationInstruction(span, Identifiers.enableBindings);
        }
        this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);
      }
    }
    visitTemplate(template) {
      const NG_TEMPLATE_TAG_NAME = "ng-template";
      const templateIndex = this.allocateDataSlot();
      if (this.i18n) {
        this.i18n.appendTemplate(template.i18n, templateIndex);
      }
      const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;
      const contextName = `${this.contextName}${template.tagName ? "_" + sanitizeIdentifier(template.tagName) : ""}_${templateIndex}`;
      const templateName = `${contextName}_Template`;
      const parameters = [
        literal(templateIndex),
        variable(templateName),
        literal(tagNameWithoutNamespace)
      ];
      const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, void 0, template.templateAttrs);
      parameters.push(this.addAttrsToConsts(attrsExprs));
      if (template.references && template.references.length) {
        const refs = this.prepareRefsArray(template.references);
        parameters.push(this.addToConsts(refs));
        parameters.push(importExpr(Identifiers.templateRefExtractor));
      }
      const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
      this._nestedTemplateFns.push(() => {
        const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);
        this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));
        if (templateVisitor._ngContentReservedSlots.length) {
          this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);
        }
      });
      this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {
        parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
        return trimTrailingNulls(parameters);
      });
      this.templatePropertyBindings(templateIndex, template.templateAttrs);
      if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {
        const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);
        if (i18nInputs.length > 0) {
          this.i18nAttributesInstruction(templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);
        }
        if (inputs.length > 0) {
          this.templatePropertyBindings(templateIndex, inputs);
        }
        for (const outputAst of template.outputs) {
          this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter("ng_template", outputAst, templateIndex));
        }
      }
    }
    visitBoundText(text) {
      if (this.i18n) {
        const value2 = text.value.visit(this._valueConverter);
        this.allocateBindingSlots(value2);
        if (value2 instanceof Interpolation) {
          this.i18n.appendBoundText(text.i18n);
          this.i18nAppendBindings(value2.expressions);
        }
        return;
      }
      const nodeIndex = this.allocateDataSlot();
      this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);
      const value = text.value.visit(this._valueConverter);
      this.allocateBindingSlots(value);
      if (value instanceof Interpolation) {
        this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));
      } else {
        error2("Text nodes should be interpolated and never bound directly.");
      }
    }
    visitText(text) {
      if (!this.i18n) {
        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);
      }
    }
    visitIcu(icu) {
      let initWasInvoked = false;
      if (!this.i18n) {
        initWasInvoked = true;
        this.i18nStart(null, icu.i18n, true);
      }
      const i18n = this.i18n;
      const vars = this.i18nBindProps(icu.vars);
      const placeholders = this.i18nBindProps(icu.placeholders);
      const message = icu.i18n;
      const transformFn = (raw) => {
        const params = { ...vars, ...placeholders };
        const formatted = i18nFormatPlaceholderNames(params, false);
        return invokeInstruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
      };
      if (isSingleI18nIcu(i18n.meta)) {
        this.i18nTranslate(message, {}, i18n.ref, transformFn);
      } else {
        const ref = this.i18nTranslate(message, {}, void 0, transformFn);
        i18n.appendIcu(icuFromI18nMessage(message).name, ref);
      }
      if (initWasInvoked) {
        this.i18nEnd(null, true);
      }
      return null;
    }
    allocateDataSlot() {
      return this._dataIndex++;
    }
    getConstCount() {
      return this._dataIndex;
    }
    getVarCount() {
      return this._pureFunctionSlots;
    }
    getConsts() {
      return this._constants;
    }
    getNgContentSelectors() {
      return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;
    }
    bindingContext() {
      return `${this._bindingContext++}`;
    }
    templatePropertyBindings(templateIndex, attrs) {
      const propertyBindings = [];
      for (const input of attrs) {
        if (!(input instanceof BoundAttribute)) {
          continue;
        }
        const value = input.value.visit(this._valueConverter);
        if (value === void 0) {
          continue;
        }
        this.allocateBindingSlots(value);
        if (value instanceof Interpolation) {
          const params = [];
          this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
        } else {
          propertyBindings.push({
            span: input.sourceSpan,
            paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), input.name)
          });
        }
      }
      for (const propertyBinding of propertyBindings) {
        this.updateInstructionWithAdvance(templateIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);
      }
    }
    instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
      fns[prepend ? "unshift" : "push"]({ span, reference, paramsOrFn });
    }
    processStylingUpdateInstruction(elementIndex, instruction) {
      let allocateBindingSlots = 0;
      if (instruction) {
        for (const call of instruction.calls) {
          allocateBindingSlots += call.allocateBindingSlots;
          this.updateInstructionWithAdvance(elementIndex, call.sourceSpan, instruction.reference, () => call.params((value) => call.supportsInterpolation && value instanceof Interpolation ? this.getUpdateInstructionArguments(value) : this.convertPropertyBinding(value)));
        }
      }
      return allocateBindingSlots;
    }
    creationInstruction(span, reference, paramsOrFn, prepend) {
      this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
    }
    updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
      this.addAdvanceInstructionIfNecessary(nodeIndex, span);
      this.updateInstruction(span, reference, paramsOrFn);
    }
    updateInstruction(span, reference, paramsOrFn) {
      this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
    }
    addAdvanceInstructionIfNecessary(nodeIndex, span) {
      if (nodeIndex !== this._currentIndex) {
        const delta = nodeIndex - this._currentIndex;
        if (delta < 1) {
          throw new Error("advance instruction can only go forwards");
        }
        this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);
        this._currentIndex = nodeIndex;
      }
    }
    allocatePureFunctionSlots(numSlots) {
      const originalSlots = this._pureFunctionSlots;
      this._pureFunctionSlots += numSlots;
      return originalSlots;
    }
    allocateBindingSlots(value) {
      this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
    }
    getImplicitReceiverExpr() {
      if (this._implicitReceiverExpr) {
        return this._implicitReceiverExpr;
      }
      return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);
    }
    convertPropertyBinding(value) {
      const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
      const valExpr = convertedPropertyBinding.currValExpr;
      this._tempVariables.push(...convertedPropertyBinding.stmts);
      return valExpr;
    }
    getUpdateInstructionArguments(value) {
      const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
      this._tempVariables.push(...stmts);
      return args;
    }
    getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {
      const alreadySeen = /* @__PURE__ */ new Set();
      const attrExprs = [];
      let ngProjectAsAttr;
      for (const attr of renderAttributes) {
        if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
          ngProjectAsAttr = attr;
        }
        if (attr.i18n) {
          const { i18nVarRefsCache } = this._constants;
          let i18nVarRef;
          if (i18nVarRefsCache.has(attr.i18n)) {
            i18nVarRef = i18nVarRefsCache.get(attr.i18n);
          } else {
            i18nVarRef = this.i18nTranslate(attr.i18n);
            i18nVarRefsCache.set(attr.i18n, i18nVarRef);
          }
          attrExprs.push(literal(attr.name), i18nVarRef);
        } else {
          attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));
        }
      }
      if (ngProjectAsAttr) {
        attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));
      }
      function addAttrExpr(key, value) {
        if (typeof key === "string") {
          if (!alreadySeen.has(key)) {
            attrExprs.push(...getAttributeNameLiterals(key));
            value !== void 0 && attrExprs.push(value);
            alreadySeen.add(key);
          }
        } else {
          attrExprs.push(literal(key));
        }
      }
      if (styles) {
        styles.populateInitialStylingAttrs(attrExprs);
      }
      if (inputs.length || outputs.length) {
        const attrsLengthBeforeInputs = attrExprs.length;
        for (let i = 0; i < inputs.length; i++) {
          const input = inputs[i];
          if (input.type !== 4 && input.type !== 1) {
            addAttrExpr(input.name);
          }
        }
        for (let i = 0; i < outputs.length; i++) {
          const output = outputs[i];
          if (output.type !== 1) {
            addAttrExpr(output.name);
          }
        }
        if (attrExprs.length !== attrsLengthBeforeInputs) {
          attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3));
        }
      }
      if (templateAttrs.length) {
        attrExprs.push(literal(4));
        templateAttrs.forEach((attr) => addAttrExpr(attr.name));
      }
      if (boundI18nAttrs.length) {
        attrExprs.push(literal(6));
        boundI18nAttrs.forEach((attr) => addAttrExpr(attr.name));
      }
      return attrExprs;
    }
    addToConsts(expression) {
      if (isNull(expression)) {
        return TYPED_NULL_EXPR;
      }
      const consts = this._constants.constExpressions;
      for (let i = 0; i < consts.length; i++) {
        if (consts[i].isEquivalent(expression)) {
          return literal(i);
        }
      }
      return literal(consts.push(expression) - 1);
    }
    addAttrsToConsts(attrs) {
      return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
    }
    prepareRefsArray(references) {
      if (!references || references.length === 0) {
        return TYPED_NULL_EXPR;
      }
      const refsParam = flatten2(references.map((reference) => {
        const slot = this.allocateDataSlot();
        const variableName = this._bindingScope.freshReferenceName();
        const retrievalLevel = this.level;
        const lhs = variable(variableName);
        this._bindingScope.set(retrievalLevel, reference.name, lhs, 0, (scope, relativeLevel) => {
          const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
          const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));
          return nextContextStmt.concat(refExpr.toConstDecl());
        }, true);
        return [reference.name, reference.value];
      }));
      return asLiteral(refsParam);
    }
    prepareListenerParameter(tagName, outputAst, index) {
      return () => {
        const eventName = outputAst.name;
        const bindingFnName = outputAst.type === 1 ? prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);
        const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;
        const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);
        return prepareEventListenerParameters(outputAst, handlerName, scope);
      };
    }
  };
  var ValueConverter = class extends AstMemoryEfficientTransformer {
    constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
      super();
      this.constantPool = constantPool;
      this.allocateSlot = allocateSlot;
      this.allocatePureFunctionSlots = allocatePureFunctionSlots;
      this.definePipe = definePipe;
      this._pipeBindExprs = [];
    }
    visitPipe(pipe, context) {
      const slot = this.allocateSlot();
      const slotPseudoLocal = `PIPE:${slot}`;
      const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
      const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);
      const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);
      this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
      const args = [pipe.exp, ...pipe.args];
      const convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);
      const pipeBindExpr = new Call(pipe.span, pipe.sourceSpan, target, [
        new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),
        new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),
        ...convertedArgs
      ], null);
      this._pipeBindExprs.push(pipeBindExpr);
      return pipeBindExpr;
    }
    updatePipeSlotOffsets(bindingSlots) {
      this._pipeBindExprs.forEach((pipe) => {
        const slotOffset = pipe.args[1];
        slotOffset.value += bindingSlots;
      });
    }
    visitLiteralArray(array, context) {
      return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), (values) => {
        const literal2 = literalArr(values);
        return getLiteralFactory(this.constantPool, literal2, this.allocatePureFunctionSlots);
      });
    }
    visitLiteralMap(map2, context) {
      return new BuiltinFunctionCall(map2.span, map2.sourceSpan, this.visitAll(map2.values), (values) => {
        const literal2 = literalMap(values.map((value, index) => ({ key: map2.keys[index].key, value, quoted: map2.keys[index].quoted })));
        return getLiteralFactory(this.constantPool, literal2, this.allocatePureFunctionSlots);
      });
    }
  };
  var pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];
  function pipeBindingCallInfo(args) {
    const identifier = pipeBindingIdentifiers[args.length];
    return {
      identifier: identifier || Identifiers.pipeBindV,
      isVarLength: !identifier
    };
  }
  var pureFunctionIdentifiers = [
    Identifiers.pureFunction0,
    Identifiers.pureFunction1,
    Identifiers.pureFunction2,
    Identifiers.pureFunction3,
    Identifiers.pureFunction4,
    Identifiers.pureFunction5,
    Identifiers.pureFunction6,
    Identifiers.pureFunction7,
    Identifiers.pureFunction8
  ];
  function pureFunctionCallInfo(args) {
    const identifier = pureFunctionIdentifiers[args.length];
    return {
      identifier: identifier || Identifiers.pureFunctionV,
      isVarLength: !identifier
    };
  }
  function generateNextContextExpr(relativeLevelDiff) {
    return importExpr(Identifiers.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
  }
  function getLiteralFactory(constantPool, literal$1, allocateSlots) {
    const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);
    const startSlot = allocateSlots(1 + literalFactoryArguments.length);
    const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);
    const args = [literal(startSlot), literalFactory];
    if (isVarLength) {
      args.push(literalArr(literalFactoryArguments));
    } else {
      args.push(...literalFactoryArguments);
    }
    return importExpr(identifier).callFn(args);
  }
  function getAttributeNameLiterals(name) {
    const [attributeNamespace, attributeName] = splitNsName(name);
    const nameLiteral = literal(attributeName);
    if (attributeNamespace) {
      return [
        literal(0),
        literal(attributeNamespace),
        nameLiteral
      ];
    }
    return [nameLiteral];
  }
  var SHARED_CONTEXT_KEY = "$$shared_ctx$$";
  var BindingScope = class {
    constructor(bindingLevel = 0, parent = null, globals) {
      this.bindingLevel = bindingLevel;
      this.parent = parent;
      this.globals = globals;
      this.map = /* @__PURE__ */ new Map();
      this.referenceNameIndex = 0;
      this.restoreViewVariable = null;
      this.usesRestoredViewContext = false;
      if (globals !== void 0) {
        for (const name of globals) {
          this.set(0, name, variable(name));
        }
      }
    }
    static createRootScope() {
      return new BindingScope();
    }
    get(name) {
      let current = this;
      while (current) {
        let value = current.map.get(name);
        if (value != null) {
          if (current !== this) {
            value = {
              retrievalLevel: value.retrievalLevel,
              lhs: value.lhs,
              declareLocalCallback: value.declareLocalCallback,
              declare: false,
              priority: value.priority
            };
            this.map.set(name, value);
            this.maybeGenerateSharedContextVar(value);
            this.maybeRestoreView();
          }
          if (value.declareLocalCallback && !value.declare) {
            value.declare = true;
          }
          return value.lhs;
        }
        current = current.parent;
      }
      return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
    }
    set(retrievalLevel, name, lhs, priority = 0, declareLocalCallback, localRef) {
      if (this.map.has(name)) {
        if (localRef) {
          return this;
        }
        error2(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
      }
      this.map.set(name, {
        retrievalLevel,
        lhs,
        declare: false,
        declareLocalCallback,
        priority
      });
      return this;
    }
    getLocal(name) {
      return this.get(name);
    }
    notifyImplicitReceiverUse() {
      if (this.bindingLevel !== 0) {
        this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
      }
    }
    nestedScope(level, globals) {
      const newScope = new BindingScope(level, this, globals);
      if (level > 0)
        newScope.generateSharedContextVar(0);
      return newScope;
    }
    getOrCreateSharedContextVar(retrievalLevel) {
      const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;
      if (!this.map.has(bindingKey)) {
        this.generateSharedContextVar(retrievalLevel);
      }
      return this.map.get(bindingKey).lhs;
    }
    getSharedContextName(retrievalLevel) {
      const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
      return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
    }
    maybeGenerateSharedContextVar(value) {
      if (value.priority === 1 && value.retrievalLevel < this.bindingLevel) {
        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
        if (sharedCtxObj) {
          sharedCtxObj.declare = true;
        } else {
          this.generateSharedContextVar(value.retrievalLevel);
        }
      }
    }
    generateSharedContextVar(retrievalLevel) {
      const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
      this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
        retrievalLevel,
        lhs,
        declareLocalCallback: (scope, relativeLevel) => {
          return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
        },
        declare: false,
        priority: 2
      });
    }
    getComponentProperty(name) {
      const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
      componentValue.declare = true;
      this.maybeRestoreView();
      return componentValue.lhs.prop(name);
    }
    maybeRestoreView() {
      if (this.isListenerScope()) {
        if (!this.parent.restoreViewVariable) {
          this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
        }
        this.restoreViewVariable = this.parent.restoreViewVariable;
      }
    }
    restoreViewStatement() {
      const statements = [];
      if (this.restoreViewVariable) {
        const restoreCall = invokeInstruction(null, Identifiers.restoreView, [this.restoreViewVariable]);
        statements.push(this.usesRestoredViewContext ? variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() : restoreCall.toStmt());
      }
      return statements;
    }
    viewSnapshotStatements() {
      return this.restoreViewVariable ? [
        this.restoreViewVariable.set(invokeInstruction(null, Identifiers.getCurrentView, [])).toConstDecl()
      ] : [];
    }
    isListenerScope() {
      return this.parent && this.parent.bindingLevel === this.bindingLevel;
    }
    variableDeclarations() {
      let currentContextLevel = 0;
      return Array.from(this.map.values()).filter((value) => value.declare).sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority).reduce((stmts, value) => {
        const levelDiff = this.bindingLevel - value.retrievalLevel;
        const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
        currentContextLevel = levelDiff;
        return stmts.concat(currStmts);
      }, []);
    }
    freshReferenceName() {
      let current = this;
      while (current.parent)
        current = current.parent;
      const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
      return ref;
    }
    hasRestoreViewVariable() {
      return !!this.restoreViewVariable;
    }
    notifyRestoredViewContextUse() {
      this.usesRestoredViewContext = true;
    }
  };
  function getNgProjectAsLiteral(attribute) {
    const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
    return [literal(5), asLiteral(parsedR3Selector)];
  }
  function getPropertyInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers.propertyInterpolate;
      case 3:
        return Identifiers.propertyInterpolate1;
      case 5:
        return Identifiers.propertyInterpolate2;
      case 7:
        return Identifiers.propertyInterpolate3;
      case 9:
        return Identifiers.propertyInterpolate4;
      case 11:
        return Identifiers.propertyInterpolate5;
      case 13:
        return Identifiers.propertyInterpolate6;
      case 15:
        return Identifiers.propertyInterpolate7;
      case 17:
        return Identifiers.propertyInterpolate8;
      default:
        return Identifiers.propertyInterpolateV;
    }
  }
  function getAttributeInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 3:
        return Identifiers.attributeInterpolate1;
      case 5:
        return Identifiers.attributeInterpolate2;
      case 7:
        return Identifiers.attributeInterpolate3;
      case 9:
        return Identifiers.attributeInterpolate4;
      case 11:
        return Identifiers.attributeInterpolate5;
      case 13:
        return Identifiers.attributeInterpolate6;
      case 15:
        return Identifiers.attributeInterpolate7;
      case 17:
        return Identifiers.attributeInterpolate8;
      default:
        return Identifiers.attributeInterpolateV;
    }
  }
  function getTextInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers.textInterpolate;
      case 3:
        return Identifiers.textInterpolate1;
      case 5:
        return Identifiers.textInterpolate2;
      case 7:
        return Identifiers.textInterpolate3;
      case 9:
        return Identifiers.textInterpolate4;
      case 11:
        return Identifiers.textInterpolate5;
      case 13:
        return Identifiers.textInterpolate6;
      case 15:
        return Identifiers.textInterpolate7;
      case 17:
        return Identifiers.textInterpolate8;
      default:
        return Identifiers.textInterpolateV;
    }
  }
  function parseTemplate(template, templateUrl, options = {}) {
    const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;
    const bindingParser = makeBindingParser(interpolationConfig);
    const htmlParser = new HtmlParser();
    const parseResult = htmlParser.parse(template, templateUrl, { leadingTriviaChars: LEADING_TRIVIA_CHARS, ...options, tokenizeExpansionForms: true });
    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {
      const parsedTemplate2 = {
        interpolationConfig,
        preserveWhitespaces,
        errors: parseResult.errors,
        nodes: [],
        styleUrls: [],
        styles: [],
        ngContentSelectors: []
      };
      if (options.collectCommentNodes) {
        parsedTemplate2.commentNodes = [];
      }
      return parsedTemplate2;
    }
    let rootNodes = parseResult.rootNodes;
    const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
    const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);
    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {
      const parsedTemplate2 = {
        interpolationConfig,
        preserveWhitespaces,
        errors: i18nMetaResult.errors,
        nodes: [],
        styleUrls: [],
        styles: [],
        ngContentSelectors: []
      };
      if (options.collectCommentNodes) {
        parsedTemplate2.commentNodes = [];
      }
      return parsedTemplate2;
    }
    rootNodes = i18nMetaResult.rootNodes;
    if (!preserveWhitespaces) {
      rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);
      if (i18nMetaVisitor.hasI18nMeta) {
        rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig, false), rootNodes);
      }
    }
    const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });
    errors.push(...parseResult.errors, ...i18nMetaResult.errors);
    const parsedTemplate = {
      interpolationConfig,
      preserveWhitespaces,
      errors: errors.length > 0 ? errors : null,
      nodes,
      styleUrls,
      styles,
      ngContentSelectors
    };
    if (options.collectCommentNodes) {
      parsedTemplate.commentNodes = commentNodes;
    }
    return parsedTemplate;
  }
  var elementRegistry = new DomElementSchemaRegistry();
  function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
    return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, elementRegistry, []);
  }
  function resolveSanitizationFn(context, isAttribute) {
    switch (context) {
      case SecurityContext2.HTML:
        return importExpr(Identifiers.sanitizeHtml);
      case SecurityContext2.SCRIPT:
        return importExpr(Identifiers.sanitizeScript);
      case SecurityContext2.STYLE:
        return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;
      case SecurityContext2.URL:
        return importExpr(Identifiers.sanitizeUrl);
      case SecurityContext2.RESOURCE_URL:
        return importExpr(Identifiers.sanitizeResourceUrl);
      default:
        return null;
    }
  }
  function trustedConstAttribute(tagName, attr) {
    const value = asLiteral(attr.value);
    if (isTrustedTypesSink(tagName, attr.name)) {
      switch (elementRegistry.securityContext(tagName, attr.name, true)) {
        case SecurityContext2.HTML:
          return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), void 0, attr.valueSpan);
        case SecurityContext2.RESOURCE_URL:
          return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), void 0, attr.valueSpan);
        default:
          return value;
      }
    } else {
      return value;
    }
  }
  function isSingleElementTemplate(children) {
    return children.length === 1 && children[0] instanceof Element$1;
  }
  function isTextNode(node) {
    return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;
  }
  function hasTextChildrenOnly(children) {
    return children.every(isTextNode);
  }
  function getBindingFunctionParams(deferredParams, name, eagerParams) {
    return () => {
      const value = deferredParams();
      const fnParams = Array.isArray(value) ? value : [value];
      if (eagerParams) {
        fnParams.push(...eagerParams);
      }
      if (name) {
        fnParams.unshift(literal(name));
      }
      return fnParams;
    };
  }
  var NG_I18N_CLOSURE_MODE = "ngI18nClosureMode";
  function getTranslationDeclStmts(message, variable2, closureVar, params = {}, transformFn) {
    const statements = [
      declareI18nVariable(variable2),
      ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable2, message, closureVar, i18nFormatPlaceholderNames(params, true)), createLocalizeStatements(variable2, message, i18nFormatPlaceholderNames(params, false)))
    ];
    if (transformFn) {
      statements.push(new ExpressionStatement(variable2.set(transformFn(variable2))));
    }
    return statements;
  }
  function createClosureModeGuard() {
    return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal("undefined", STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));
  }
  function flatten2(list) {
    return list.reduce((flat, item) => {
      const flatItem = Array.isArray(item) ? flatten2(item) : item;
      return flat.concat(flatItem);
    }, []);
  }
  var ATTR_REGEX = /attr\.([^\]]+)/;
  var COMPONENT_VARIABLE = "%COMP%";
  var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
  var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
  function baseDirectiveFields(meta, constantPool, bindingParser) {
    const definitionMap = new DefinitionMap();
    const selectors = parseSelectorToR3Selector(meta.selector);
    definitionMap.set("type", meta.internalType);
    if (selectors.length > 0) {
      definitionMap.set("selectors", asLiteral(selectors));
    }
    if (meta.queries.length > 0) {
      definitionMap.set("contentQueries", createContentQueriesFunction(meta.queries, constantPool, meta.name));
    }
    if (meta.viewQueries.length) {
      definitionMap.set("viewQuery", createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
    }
    definitionMap.set("hostBindings", createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || "", meta.name, definitionMap));
    definitionMap.set("inputs", conditionallyCreateMapObjectLiteral(meta.inputs, true));
    definitionMap.set("outputs", conditionallyCreateMapObjectLiteral(meta.outputs));
    if (meta.exportAs !== null) {
      definitionMap.set("exportAs", literalArr(meta.exportAs.map((e) => literal(e))));
    }
    return definitionMap;
  }
  function addFeatures(definitionMap, meta) {
    const features = [];
    const providers = meta.providers;
    const viewProviders = meta.viewProviders;
    if (providers || viewProviders) {
      const args = [providers || new LiteralArrayExpr([])];
      if (viewProviders) {
        args.push(viewProviders);
      }
      features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));
    }
    if (meta.usesInheritance) {
      features.push(importExpr(Identifiers.InheritDefinitionFeature));
    }
    if (meta.fullInheritance) {
      features.push(importExpr(Identifiers.CopyDefinitionFeature));
    }
    if (meta.lifecycle.usesOnChanges) {
      features.push(importExpr(Identifiers.NgOnChangesFeature));
    }
    if (features.length) {
      definitionMap.set("features", literalArr(features));
    }
  }
  function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
    addFeatures(definitionMap, meta);
    const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createDirectiveType(meta);
    return { expression, type, statements: [] };
  }
  function compileComponentFromMetadata(meta, constantPool, bindingParser) {
    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
    addFeatures(definitionMap, meta);
    const selector = meta.selector && CssSelector.parse(meta.selector);
    const firstSelector = selector && selector[0];
    if (firstSelector) {
      const selectorAttributes = firstSelector.getAttrs();
      if (selectorAttributes.length) {
        definitionMap.set("attrs", constantPool.getConstLiteral(literalArr(selectorAttributes.map((value) => value != null ? literal(value) : literal(void 0))), true));
      }
    }
    const templateTypeName = meta.name;
    const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
    const changeDetection = meta.changeDetection;
    const template = meta.template;
    const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
    const ngContentSelectors = templateBuilder.getNgContentSelectors();
    if (ngContentSelectors) {
      definitionMap.set("ngContentSelectors", ngContentSelectors);
    }
    definitionMap.set("decls", literal(templateBuilder.getConstCount()));
    definitionMap.set("vars", literal(templateBuilder.getVarCount()));
    const { constExpressions, prepareStatements } = templateBuilder.getConsts();
    if (constExpressions.length > 0) {
      let constsExpr = literalArr(constExpressions);
      if (prepareStatements.length > 0) {
        constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);
      }
      definitionMap.set("consts", constsExpr);
    }
    definitionMap.set("template", templateFunctionExpression);
    if (meta.directives.length > 0) {
      const directivesList = literalArr(meta.directives.map((dir) => dir.type));
      const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);
      definitionMap.set("directives", directivesExpr);
    }
    if (meta.pipes.size > 0) {
      const pipesList = literalArr(Array.from(meta.pipes.values()));
      const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);
      definitionMap.set("pipes", pipesExpr);
    }
    if (meta.encapsulation === null) {
      meta.encapsulation = ViewEncapsulation2.Emulated;
    }
    if (meta.styles && meta.styles.length) {
      const styleValues = meta.encapsulation == ViewEncapsulation2.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;
      const strings = styleValues.map((str) => constantPool.getConstLiteral(literal(str)));
      definitionMap.set("styles", literalArr(strings));
    } else if (meta.encapsulation === ViewEncapsulation2.Emulated) {
      meta.encapsulation = ViewEncapsulation2.None;
    }
    if (meta.encapsulation !== ViewEncapsulation2.Emulated) {
      definitionMap.set("encapsulation", literal(meta.encapsulation));
    }
    if (meta.animations !== null) {
      definitionMap.set("data", literalMap([{ key: "animation", value: meta.animations, quoted: false }]));
    }
    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy2.Default) {
      definitionMap.set("changeDetection", literal(changeDetection));
    }
    const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createComponentType(meta);
    return { expression, type, statements: [] };
  }
  function createComponentType(meta) {
    const typeParams = createDirectiveTypeParams(meta);
    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
    return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));
  }
  function compileDeclarationList(list, mode) {
    switch (mode) {
      case 0:
        return list;
      case 1:
        return fn([], [new ReturnStatement(list)]);
      case 2:
        const resolvedList = list.prop("map").callFn([importExpr(Identifiers.resolveForwardRef)]);
        return fn([], [new ReturnStatement(resolvedList)]);
    }
  }
  function prepareQueryParams(query, constantPool) {
    const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];
    if (query.read) {
      parameters.push(query.read);
    }
    return parameters;
  }
  function toQueryFlags(query) {
    return (query.descendants ? 1 : 0) | (query.static ? 2 : 0) | (query.emitDistinctChangesOnly ? 4 : 0);
  }
  function convertAttributesToExpressions(attributes) {
    const values = [];
    for (let key of Object.getOwnPropertyNames(attributes)) {
      const value = attributes[key];
      values.push(literal(key), value);
    }
    return values;
  }
  function createContentQueriesFunction(queries, constantPool, name) {
    const createStatements = [];
    const updateStatements = [];
    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
    for (const query of queries) {
      createStatements.push(importExpr(Identifiers.contentQuery).callFn([variable("dirIndex"), ...prepareQueryParams(query, constantPool)]).toStmt());
      const temporary = tempAllocator();
      const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
      const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
      const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop("first") : temporary);
      updateStatements.push(refresh.and(updateDirective).toStmt());
    }
    const contentQueriesFnName = name ? `${name}_ContentQueries` : null;
    return fn([
      new FnParam(RENDER_FLAGS, NUMBER_TYPE),
      new FnParam(CONTEXT_NAME, null),
      new FnParam("dirIndex", null)
    ], [
      renderFlagCheckIfStmt(1, createStatements),
      renderFlagCheckIfStmt(2, updateStatements)
    ], INFERRED_TYPE, null, contentQueriesFnName);
  }
  function stringAsType(str) {
    return expressionType(literal(str));
  }
  function stringMapAsType(map2) {
    const mapValues = Object.keys(map2).map((key) => {
      const value = Array.isArray(map2[key]) ? map2[key][0] : map2[key];
      return {
        key,
        value: literal(value),
        quoted: true
      };
    });
    return expressionType(literalMap(mapValues));
  }
  function stringArrayAsType(arr) {
    return arr.length > 0 ? expressionType(literalArr(arr.map((value) => literal(value)))) : NONE_TYPE;
  }
  function createDirectiveTypeParams(meta) {
    const selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, "") : null;
    return [
      typeWithParameters(meta.type.type, meta.typeArgumentCount),
      selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,
      meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,
      stringMapAsType(meta.inputs),
      stringMapAsType(meta.outputs),
      stringArrayAsType(meta.queries.map((q) => q.propertyName))
    ];
  }
  function createDirectiveType(meta) {
    const typeParams = createDirectiveTypeParams(meta);
    return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));
  }
  function createViewQueriesFunction(viewQueries, constantPool, name) {
    const createStatements = [];
    const updateStatements = [];
    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
    viewQueries.forEach((query) => {
      const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));
      createStatements.push(queryDefinition.toStmt());
      const temporary = tempAllocator();
      const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
      const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
      const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop("first") : temporary);
      updateStatements.push(refresh.and(updateDirective).toStmt());
    });
    const viewQueryFnName = name ? `${name}_Query` : null;
    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
      renderFlagCheckIfStmt(1, createStatements),
      renderFlagCheckIfStmt(2, updateStatements)
    ], INFERRED_TYPE, null, viewQueryFnName);
  }
  function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
    const bindingContext = variable(CONTEXT_NAME);
    const styleBuilder = new StylingBuilder(bindingContext);
    const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;
    if (styleAttr !== void 0) {
      styleBuilder.registerStyleAttr(styleAttr);
    }
    if (classAttr !== void 0) {
      styleBuilder.registerClassAttr(classAttr);
    }
    const createInstructions = [];
    const updateInstructions = [];
    const updateVariables = [];
    const hostBindingSourceSpan = typeSourceSpan;
    const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, hostBindingSourceSpan);
    if (eventBindings && eventBindings.length) {
      createInstructions.push(...createHostListeners(eventBindings, name));
    }
    const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, hostBindingSourceSpan);
    const allOtherBindings = [];
    let totalHostVarsCount = 0;
    bindings && bindings.forEach((binding) => {
      const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);
      if (stylingInputWasSet) {
        totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
      } else {
        allOtherBindings.push(binding);
        totalHostVarsCount++;
      }
    });
    let valueConverter;
    const getValueConverter = () => {
      if (!valueConverter) {
        const hostVarsCountFn = (numSlots) => {
          const originalVarsCount = totalHostVarsCount;
          totalHostVarsCount += numSlots;
          return originalVarsCount;
        };
        valueConverter = new ValueConverter(constantPool, () => error2("Unexpected node"), hostVarsCountFn, () => error2("Unexpected pipe"));
      }
      return valueConverter;
    };
    const propertyBindings = [];
    const attributeBindings = [];
    const syntheticHostBindings = [];
    for (const binding of allOtherBindings) {
      const value = binding.expression.visit(getValueConverter());
      const bindingExpr = bindingFn(bindingContext, value);
      const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);
      const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter((context) => context !== SecurityContext2.NONE);
      let sanitizerFn = null;
      if (securityContexts.length) {
        if (securityContexts.length === 2 && securityContexts.indexOf(SecurityContext2.URL) > -1 && securityContexts.indexOf(SecurityContext2.RESOURCE_URL) > -1) {
          sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);
        } else {
          sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
        }
      }
      const instructionParams = [literal(bindingName), bindingExpr.currValExpr];
      if (sanitizerFn) {
        instructionParams.push(sanitizerFn);
      }
      updateVariables.push(...bindingExpr.stmts);
      if (instruction === Identifiers.hostProperty) {
        propertyBindings.push(instructionParams);
      } else if (instruction === Identifiers.attribute) {
        attributeBindings.push(instructionParams);
      } else if (instruction === Identifiers.syntheticHostProperty) {
        syntheticHostBindings.push(instructionParams);
      } else {
        updateInstructions.push({ reference: instruction, paramsOrFn: instructionParams, span: null });
      }
    }
    for (const bindingParams of propertyBindings) {
      updateInstructions.push({ reference: Identifiers.hostProperty, paramsOrFn: bindingParams, span: null });
    }
    for (const bindingParams of attributeBindings) {
      updateInstructions.push({ reference: Identifiers.attribute, paramsOrFn: bindingParams, span: null });
    }
    for (const bindingParams of syntheticHostBindings) {
      updateInstructions.push({ reference: Identifiers.syntheticHostProperty, paramsOrFn: bindingParams, span: null });
    }
    const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);
    if (styleBuilder.hasBindings) {
      styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach((instruction) => {
        for (const call of instruction.calls) {
          totalHostVarsCount += Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
          updateInstructions.push({
            reference: instruction.reference,
            paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),
            span: null
          });
        }
      });
    }
    if (totalHostVarsCount) {
      definitionMap.set("hostVars", literal(totalHostVarsCount));
    }
    if (createInstructions.length > 0 || updateInstructions.length > 0) {
      const hostBindingsFnName = name ? `${name}_HostBindings` : null;
      const statements = [];
      if (createInstructions.length > 0) {
        statements.push(renderFlagCheckIfStmt(1, getInstructionStatements(createInstructions)));
      }
      if (updateInstructions.length > 0) {
        statements.push(renderFlagCheckIfStmt(2, updateVariables.concat(getInstructionStatements(updateInstructions))));
      }
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
    }
    return null;
  }
  function bindingFn(implicit, value) {
    return convertPropertyBinding(null, implicit, value, "b");
  }
  function convertStylingCall(call, bindingContext, bindingFn2) {
    return call.params((value) => bindingFn2(bindingContext, value).currValExpr);
  }
  function getBindingNameAndInstruction(binding) {
    let bindingName = binding.name;
    let instruction;
    const attrMatches = bindingName.match(ATTR_REGEX);
    if (attrMatches) {
      bindingName = attrMatches[1];
      instruction = Identifiers.attribute;
    } else {
      if (binding.isAnimation) {
        bindingName = prepareSyntheticPropertyName(bindingName);
        instruction = Identifiers.syntheticHostProperty;
      } else {
        instruction = Identifiers.hostProperty;
      }
    }
    return { bindingName, instruction, isAttribute: !!attrMatches };
  }
  function createHostListeners(eventBindings, name) {
    const listenerParams = [];
    const syntheticListenerParams = [];
    const instructions = [];
    for (const binding of eventBindings) {
      let bindingName = binding.name && sanitizeIdentifier(binding.name);
      const bindingFnName = binding.type === 1 ? prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;
      const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;
      const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);
      if (binding.type == 1) {
        syntheticListenerParams.push(params);
      } else {
        listenerParams.push(params);
      }
    }
    for (const params of syntheticListenerParams) {
      instructions.push({ reference: Identifiers.syntheticHostListener, paramsOrFn: params, span: null });
    }
    for (const params of listenerParams) {
      instructions.push({ reference: Identifiers.listener, paramsOrFn: params, span: null });
    }
    return instructions;
  }
  var HOST_REG_EXP = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
  function parseHostBindings(host) {
    const attributes = {};
    const listeners = {};
    const properties = {};
    const specialAttributes = {};
    for (const key of Object.keys(host)) {
      const value = host[key];
      const matches = key.match(HOST_REG_EXP);
      if (matches === null) {
        switch (key) {
          case "class":
            if (typeof value !== "string") {
              throw new Error(`Class binding must be string`);
            }
            specialAttributes.classAttr = value;
            break;
          case "style":
            if (typeof value !== "string") {
              throw new Error(`Style binding must be string`);
            }
            specialAttributes.styleAttr = value;
            break;
          default:
            if (typeof value === "string") {
              attributes[key] = literal(value);
            } else {
              attributes[key] = value;
            }
        }
      } else if (matches[1] != null) {
        if (typeof value !== "string") {
          throw new Error(`Property binding must be string`);
        }
        properties[matches[1]] = value;
      } else if (matches[2] != null) {
        if (typeof value !== "string") {
          throw new Error(`Event binding must be string`);
        }
        listeners[matches[2]] = value;
      }
    }
    return { attributes, listeners, properties, specialAttributes };
  }
  function verifyHostBindings(bindings, sourceSpan) {
    const bindingParser = makeBindingParser();
    bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);
    bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);
    return bindingParser.errors;
  }
  function compileStyles(styles, selector, hostSelector) {
    const shadowCss = new ShadowCss();
    return styles.map((style) => {
      return shadowCss.shimCssText(style, selector, hostSelector);
    });
  }
  var ResourceLoader = class {
  };
  var CompilerFacadeImpl = class {
    constructor(jitEvaluator = new JitEvaluator()) {
      this.jitEvaluator = jitEvaluator;
      this.FactoryTarget = FactoryTarget$1;
      this.ResourceLoader = ResourceLoader;
      this.elementSchemaRegistry = new DomElementSchemaRegistry();
    }
    compilePipe(angularCoreEnv2, sourceMapUrl, facade) {
      const metadata = {
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: 0,
        deps: null,
        pipeName: facade.pipeName,
        pure: facade.pure
      };
      const res = compilePipeFromMetadata(metadata);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compilePipeDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const meta = convertDeclarePipeFacadeToMetadata(declaration);
      const res = compilePipeFromMetadata(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileInjectable(angularCoreEnv2, sourceMapUrl, facade) {
      const { expression, statements } = compileInjectable2({
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: facade.typeArgumentCount,
        providedIn: computeProvidedIn(facade.providedIn),
        useClass: convertToProviderExpression(facade, USE_CLASS),
        useFactory: wrapExpression(facade, USE_FACTORY),
        useValue: convertToProviderExpression(facade, USE_VALUE2),
        useExisting: convertToProviderExpression(facade, USE_EXISTING),
        deps: facade.deps?.map(convertR3DependencyMetadata)
      }, true);
      return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, statements);
    }
    compileInjectableDeclaration(angularCoreEnv2, sourceMapUrl, facade) {
      const { expression, statements } = compileInjectable2({
        name: facade.type.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: 0,
        providedIn: computeProvidedIn(facade.providedIn),
        useClass: convertToProviderExpression(facade, USE_CLASS),
        useFactory: wrapExpression(facade, USE_FACTORY),
        useValue: convertToProviderExpression(facade, USE_VALUE2),
        useExisting: convertToProviderExpression(facade, USE_EXISTING),
        deps: facade.deps?.map(convertR3DeclareDependencyMetadata)
      }, true);
      return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, statements);
    }
    compileInjector(angularCoreEnv2, sourceMapUrl, facade) {
      const meta = {
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        providers: new WrappedNodeExpr(facade.providers),
        imports: facade.imports.map((i) => new WrappedNodeExpr(i))
      };
      const res = compileInjector(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileInjectorDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const meta = convertDeclareInjectorFacadeToMetadata(declaration);
      const res = compileInjector(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileNgModule(angularCoreEnv2, sourceMapUrl, facade) {
      const meta = {
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        adjacentType: new WrappedNodeExpr(facade.type),
        bootstrap: facade.bootstrap.map(wrapReference),
        declarations: facade.declarations.map(wrapReference),
        imports: facade.imports.map(wrapReference),
        exports: facade.exports.map(wrapReference),
        emitInline: true,
        containsForwardDecls: false,
        schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
        id: facade.id ? new WrappedNodeExpr(facade.id) : null
      };
      const res = compileNgModule2(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileNgModuleDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const expression = compileNgModuleDeclarationExpression(declaration);
      return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileDirective(angularCoreEnv2, sourceMapUrl, facade) {
      const meta = convertDirectiveFacadeToMetadata(facade);
      return this.compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta);
    }
    compileDirectiveDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const typeSourceSpan = this.createParseSourceSpan("Directive", declaration.type.name, sourceMapUrl);
      const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
      return this.compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta);
    }
    compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta) {
      const constantPool = new ConstantPool();
      const bindingParser = makeBindingParser();
      const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, constantPool.statements);
    }
    compileComponent(angularCoreEnv2, sourceMapUrl, facade) {
      const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);
      const meta = {
        ...facade,
        ...convertDirectiveFacadeToMetadata(facade),
        selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),
        template,
        declarationListEmitMode: 0,
        styles: [...facade.styles, ...template.styles],
        encapsulation: facade.encapsulation,
        interpolation,
        changeDetection: facade.changeDetection,
        animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,
        viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,
        relativeContextFilePath: "",
        i18nUseExternalIds: true
      };
      const jitExpressionSourceMap = `ng:///${facade.name}.js`;
      return this.compileComponentFromMeta(angularCoreEnv2, jitExpressionSourceMap, meta);
    }
    compileComponentDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const typeSourceSpan = this.createParseSourceSpan("Component", declaration.type.name, sourceMapUrl);
      const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
      return this.compileComponentFromMeta(angularCoreEnv2, sourceMapUrl, meta);
    }
    compileComponentFromMeta(angularCoreEnv2, sourceMapUrl, meta) {
      const constantPool = new ConstantPool();
      const bindingParser = makeBindingParser(meta.interpolation);
      const res = compileComponentFromMetadata(meta, constantPool, bindingParser);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, constantPool.statements);
    }
    compileFactory(angularCoreEnv2, sourceMapUrl, meta) {
      const factoryRes = compileFactoryFunction({
        name: meta.name,
        type: wrapReference(meta.type),
        internalType: new WrappedNodeExpr(meta.type),
        typeArgumentCount: meta.typeArgumentCount,
        deps: convertR3DependencyMetadataArray(meta.deps),
        target: meta.target
      });
      return this.jitExpression(factoryRes.expression, angularCoreEnv2, sourceMapUrl, factoryRes.statements);
    }
    compileFactoryDeclaration(angularCoreEnv2, sourceMapUrl, meta) {
      const factoryRes = compileFactoryFunction({
        name: meta.type.name,
        type: wrapReference(meta.type),
        internalType: new WrappedNodeExpr(meta.type),
        typeArgumentCount: 0,
        deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,
        target: meta.target
      });
      return this.jitExpression(factoryRes.expression, angularCoreEnv2, sourceMapUrl, factoryRes.statements);
    }
    createParseSourceSpan(kind, typeName, sourceUrl) {
      return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
    }
    jitExpression(def, context, sourceUrl, preStatements) {
      const statements = [
        ...preStatements,
        new DeclareVarStmt("$def", def, void 0, StmtModifier.Exported)
      ];
      const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), true);
      return res["$def"];
    }
  };
  var USE_CLASS = Object.keys({ useClass: null })[0];
  var USE_FACTORY = Object.keys({ useFactory: null })[0];
  var USE_VALUE2 = Object.keys({ useValue: null })[0];
  var USE_EXISTING = Object.keys({ useExisting: null })[0];
  function convertToR3QueryMetadata2(facade) {
    return {
      ...facade,
      predicate: convertQueryPredicate(facade.predicate),
      read: facade.read ? new WrappedNodeExpr(facade.read) : null,
      static: facade.static,
      emitDistinctChangesOnly: facade.emitDistinctChangesOnly
    };
  }
  function convertQueryDeclarationToMetadata(declaration) {
    return {
      propertyName: declaration.propertyName,
      first: declaration.first ?? false,
      predicate: convertQueryPredicate(declaration.predicate),
      descendants: declaration.descendants ?? false,
      read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,
      static: declaration.static ?? false,
      emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true
    };
  }
  function convertQueryPredicate(predicate) {
    return Array.isArray(predicate) ? predicate : createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1);
  }
  function convertDirectiveFacadeToMetadata(facade) {
    const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
    const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
    const propMetadata = facade.propMetadata;
    const inputsFromType = {};
    const outputsFromType = {};
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        propMetadata[field].forEach((ann) => {
          if (isInput(ann)) {
            inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
          } else if (isOutput(ann)) {
            outputsFromType[field] = ann.bindingPropertyName || field;
          }
        });
      }
    }
    return {
      ...facade,
      typeArgumentCount: 0,
      typeSourceSpan: facade.typeSourceSpan,
      type: wrapReference(facade.type),
      internalType: new WrappedNodeExpr(facade.type),
      deps: null,
      host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),
      inputs: { ...inputsFromMetadata, ...inputsFromType },
      outputs: { ...outputsFromMetadata, ...outputsFromType },
      queries: facade.queries.map(convertToR3QueryMetadata2),
      providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,
      viewQueries: facade.viewQueries.map(convertToR3QueryMetadata2),
      fullInheritance: false
    };
  }
  function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
    return {
      name: declaration.type.name,
      type: wrapReference(declaration.type),
      typeSourceSpan,
      internalType: new WrappedNodeExpr(declaration.type),
      selector: declaration.selector ?? null,
      inputs: declaration.inputs ?? {},
      outputs: declaration.outputs ?? {},
      host: convertHostDeclarationToMetadata(declaration.host),
      queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),
      viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),
      providers: declaration.providers !== void 0 ? new WrappedNodeExpr(declaration.providers) : null,
      exportAs: declaration.exportAs ?? null,
      usesInheritance: declaration.usesInheritance ?? false,
      lifecycle: { usesOnChanges: declaration.usesOnChanges ?? false },
      deps: null,
      typeArgumentCount: 0,
      fullInheritance: false
    };
  }
  function convertHostDeclarationToMetadata(host = {}) {
    return {
      attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),
      listeners: host.listeners ?? {},
      properties: host.properties ?? {},
      specialAttributes: {
        classAttr: host.classAttribute,
        styleAttr: host.styleAttribute
      }
    };
  }
  function convertOpaqueValuesToExpressions(obj) {
    const result = {};
    for (const key of Object.keys(obj)) {
      result[key] = new WrappedNodeExpr(obj[key]);
    }
    return result;
  }
  function convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {
    const { template, interpolation } = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, declaration.preserveWhitespaces ?? false, declaration.interpolation);
    return {
      ...convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan),
      template,
      styles: declaration.styles ?? [],
      directives: (declaration.components ?? []).concat(declaration.directives ?? []).map(convertUsedDirectiveDeclarationToMetadata),
      pipes: convertUsedPipesToMetadata(declaration.pipes),
      viewProviders: declaration.viewProviders !== void 0 ? new WrappedNodeExpr(declaration.viewProviders) : null,
      animations: declaration.animations !== void 0 ? new WrappedNodeExpr(declaration.animations) : null,
      changeDetection: declaration.changeDetection ?? ChangeDetectionStrategy2.Default,
      encapsulation: declaration.encapsulation ?? ViewEncapsulation2.Emulated,
      interpolation,
      declarationListEmitMode: 2,
      relativeContextFilePath: "",
      i18nUseExternalIds: true
    };
  }
  function convertUsedDirectiveDeclarationToMetadata(declaration) {
    return {
      selector: declaration.selector,
      type: new WrappedNodeExpr(declaration.type),
      inputs: declaration.inputs ?? [],
      outputs: declaration.outputs ?? [],
      exportAs: declaration.exportAs ?? null
    };
  }
  function convertUsedPipesToMetadata(declaredPipes) {
    const pipes = /* @__PURE__ */ new Map();
    if (declaredPipes === void 0) {
      return pipes;
    }
    for (const pipeName of Object.keys(declaredPipes)) {
      const pipeType = declaredPipes[pipeName];
      pipes.set(pipeName, new WrappedNodeExpr(pipeType));
    }
    return pipes;
  }
  function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
    const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;
    const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces, interpolationConfig });
    if (parsed.errors !== null) {
      const errors = parsed.errors.map((err) => err.toString()).join(", ");
      throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);
    }
    return { template: parsed, interpolation: interpolationConfig };
  }
  function convertToProviderExpression(obj, property) {
    if (obj.hasOwnProperty(property)) {
      return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0);
    } else {
      return void 0;
    }
  }
  function wrapExpression(obj, property) {
    if (obj.hasOwnProperty(property)) {
      return new WrappedNodeExpr(obj[property]);
    } else {
      return void 0;
    }
  }
  function computeProvidedIn(providedIn) {
    const expression = typeof providedIn === "function" ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn ?? null);
    return createMayBeForwardRefExpression(expression, 0);
  }
  function convertR3DependencyMetadataArray(facades) {
    return facades == null ? null : facades.map(convertR3DependencyMetadata);
  }
  function convertR3DependencyMetadata(facade) {
    const isAttributeDep = facade.attribute != null;
    const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);
    const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;
    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
  }
  function convertR3DeclareDependencyMetadata(facade) {
    const isAttributeDep = facade.attribute ?? false;
    const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);
    return createR3DependencyMetadata(token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false, facade.skipSelf ?? false);
  }
  function createR3DependencyMetadata(token, isAttributeDep, host, optional, self2, skipSelf) {
    const attributeNameType = isAttributeDep ? literal("unknown") : null;
    return { token, attributeNameType, host, optional, self: self2, skipSelf };
  }
  function extractHostBindings(propMetadata, sourceSpan, host) {
    const bindings = parseHostBindings(host || {});
    const errors = verifyHostBindings(bindings, sourceSpan);
    if (errors.length) {
      throw new Error(errors.map((error3) => error3.msg).join("\n"));
    }
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        propMetadata[field].forEach((ann) => {
          if (isHostBinding(ann)) {
            bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString("this", field);
          } else if (isHostListener(ann)) {
            bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(",")})`;
          }
        });
      }
    }
    return bindings;
  }
  function isHostBinding(value) {
    return value.ngMetadataName === "HostBinding";
  }
  function isHostListener(value) {
    return value.ngMetadataName === "HostListener";
  }
  function isInput(value) {
    return value.ngMetadataName === "Input";
  }
  function isOutput(value) {
    return value.ngMetadataName === "Output";
  }
  function parseInputOutputs(values) {
    return values.reduce((map2, value) => {
      const [field, property] = value.split(",").map((piece) => piece.trim());
      map2[field] = property || field;
      return map2;
    }, {});
  }
  function convertDeclarePipeFacadeToMetadata(declaration) {
    return {
      name: declaration.type.name,
      type: wrapReference(declaration.type),
      internalType: new WrappedNodeExpr(declaration.type),
      typeArgumentCount: 0,
      pipeName: declaration.name,
      deps: null,
      pure: declaration.pure ?? true
    };
  }
  function convertDeclareInjectorFacadeToMetadata(declaration) {
    return {
      name: declaration.type.name,
      type: wrapReference(declaration.type),
      internalType: new WrappedNodeExpr(declaration.type),
      providers: declaration.providers !== void 0 ? new WrappedNodeExpr(declaration.providers) : null,
      imports: declaration.imports !== void 0 ? declaration.imports.map((i) => new WrappedNodeExpr(i)) : []
    };
  }
  function publishFacade(global2) {
    const ng = global2.ng || (global2.ng = {});
    ng.\u0275compilerFacade = new CompilerFacadeImpl();
  }
  var VERSION2 = new Version2("13.3.3");
  var _VisitorMode;
  (function(_VisitorMode2) {
    _VisitorMode2[_VisitorMode2["Extract"] = 0] = "Extract";
    _VisitorMode2[_VisitorMode2["Merge"] = 1] = "Merge";
  })(_VisitorMode || (_VisitorMode = {}));
  var XmlTagDefinition = class {
    constructor() {
      this.closedByParent = false;
      this.isVoid = false;
      this.ignoreFirstLf = false;
      this.canSelfClose = true;
      this.preventNamespaceInheritance = false;
    }
    requireExtraParent(currentParent) {
      return false;
    }
    isClosedByChild(name) {
      return false;
    }
    getContentType() {
      return TagContentType.PARSABLE_DATA;
    }
  };
  var _TAG_DEFINITION = new XmlTagDefinition();
  var FactoryTarget2;
  (function(FactoryTarget3) {
    FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
    FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
    FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
    FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
    FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
  })(FactoryTarget2 || (FactoryTarget2 = {}));
  publishFacade(_global3);

  // node_modules/@angular/core/fesm2020/testing.mjs
  var ComponentFixture = class {
    constructor(componentRef, ngZone, _autoDetect) {
      this.componentRef = componentRef;
      this.ngZone = ngZone;
      this._autoDetect = _autoDetect;
      this._isStable = true;
      this._isDestroyed = false;
      this._resolve = null;
      this._promise = null;
      this._onUnstableSubscription = null;
      this._onStableSubscription = null;
      this._onMicrotaskEmptySubscription = null;
      this._onErrorSubscription = null;
      this.changeDetectorRef = componentRef.changeDetectorRef;
      this.elementRef = componentRef.location;
      this.debugElement = getDebugNode(this.elementRef.nativeElement);
      this.componentInstance = componentRef.instance;
      this.nativeElement = this.elementRef.nativeElement;
      this.componentRef = componentRef;
      this.ngZone = ngZone;
      if (ngZone) {
        ngZone.runOutsideAngular(() => {
          this._onUnstableSubscription = ngZone.onUnstable.subscribe({
            next: () => {
              this._isStable = false;
            }
          });
          this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({
            next: () => {
              if (this._autoDetect) {
                this.detectChanges(true);
              }
            }
          });
          this._onStableSubscription = ngZone.onStable.subscribe({
            next: () => {
              this._isStable = true;
              if (this._promise !== null) {
                scheduleMicroTask2(() => {
                  if (!ngZone.hasPendingMacrotasks) {
                    if (this._promise !== null) {
                      this._resolve(true);
                      this._resolve = null;
                      this._promise = null;
                    }
                  }
                });
              }
            }
          });
          this._onErrorSubscription = ngZone.onError.subscribe({
            next: (error3) => {
              throw error3;
            }
          });
        });
      }
    }
    _tick(checkNoChanges) {
      this.changeDetectorRef.detectChanges();
      if (checkNoChanges) {
        this.checkNoChanges();
      }
    }
    detectChanges(checkNoChanges = true) {
      if (this.ngZone != null) {
        this.ngZone.run(() => {
          this._tick(checkNoChanges);
        });
      } else {
        this._tick(checkNoChanges);
      }
    }
    checkNoChanges() {
      this.changeDetectorRef.checkNoChanges();
    }
    autoDetectChanges(autoDetect = true) {
      if (this.ngZone == null) {
        throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set");
      }
      this._autoDetect = autoDetect;
      this.detectChanges();
    }
    isStable() {
      return this._isStable && !this.ngZone.hasPendingMacrotasks;
    }
    whenStable() {
      if (this.isStable()) {
        return Promise.resolve(false);
      } else if (this._promise !== null) {
        return this._promise;
      } else {
        this._promise = new Promise((res) => {
          this._resolve = res;
        });
        return this._promise;
      }
    }
    _getRenderer() {
      if (this._renderer === void 0) {
        this._renderer = this.componentRef.injector.get(RendererFactory2, null);
      }
      return this._renderer;
    }
    whenRenderingDone() {
      const renderer = this._getRenderer();
      if (renderer && renderer.whenRenderingDone) {
        return renderer.whenRenderingDone();
      }
      return this.whenStable();
    }
    destroy() {
      if (!this._isDestroyed) {
        this.componentRef.destroy();
        if (this._onUnstableSubscription != null) {
          this._onUnstableSubscription.unsubscribe();
          this._onUnstableSubscription = null;
        }
        if (this._onStableSubscription != null) {
          this._onStableSubscription.unsubscribe();
          this._onStableSubscription = null;
        }
        if (this._onMicrotaskEmptySubscription != null) {
          this._onMicrotaskEmptySubscription.unsubscribe();
          this._onMicrotaskEmptySubscription = null;
        }
        if (this._onErrorSubscription != null) {
          this._onErrorSubscription.unsubscribe();
          this._onErrorSubscription = null;
        }
        this._isDestroyed = true;
      }
    }
  };
  function scheduleMicroTask2(fn2) {
    Zone.current.scheduleMicroTask("scheduleMicrotask", fn2);
  }
  var _Zone = typeof Zone !== "undefined" ? Zone : null;
  var fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__("fakeAsyncTest")];
  var fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.
        Please make sure that your environment includes zone.js/testing`;
  function resetFakeAsyncZone() {
    if (fakeAsyncTestModule) {
      return fakeAsyncTestModule.resetFakeAsyncZone();
    }
    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);
  }
  function flush(maxTurns) {
    if (fakeAsyncTestModule) {
      return fakeAsyncTestModule.flush(maxTurns);
    }
    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);
  }
  function resolveComponentResources2(resourceResolver) {
    const componentResolved = [];
    const urlMap = /* @__PURE__ */ new Map();
    function cachedResourceResolve(url) {
      let promise2 = urlMap.get(url);
      if (!promise2) {
        const resp = resourceResolver(url);
        urlMap.set(url, promise2 = resp.then(unwrapResponse2));
      }
      return promise2;
    }
    componentResourceResolutionQueue2.forEach((component, type) => {
      const promises = [];
      if (component.templateUrl) {
        promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
          component.template = template;
        }));
      }
      const styleUrls = component.styleUrls;
      const styles = component.styles || (component.styles = []);
      const styleOffset = component.styles.length;
      styleUrls && styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
      const fullyResolved = Promise.all(promises).then(() => componentDefResolved2(type));
      componentResolved.push(fullyResolved);
    });
    clearResolutionOfComponentResourcesQueue2();
    return Promise.all(componentResolved).then(() => void 0);
  }
  var componentResourceResolutionQueue2 = /* @__PURE__ */ new Map();
  var componentDefPendingResolution2 = /* @__PURE__ */ new Set();
  function isComponentDefPendingResolution(type) {
    return componentDefPendingResolution2.has(type);
  }
  function clearResolutionOfComponentResourcesQueue2() {
    const old = componentResourceResolutionQueue2;
    componentResourceResolutionQueue2 = /* @__PURE__ */ new Map();
    return old;
  }
  function restoreComponentResolutionQueue(queue2) {
    componentDefPendingResolution2.clear();
    queue2.forEach((_, type) => componentDefPendingResolution2.add(type));
    componentResourceResolutionQueue2 = queue2;
  }
  function unwrapResponse2(response) {
    return typeof response == "string" ? response : response.text();
  }
  function componentDefResolved2(type) {
    componentDefPendingResolution2.delete(type);
  }
  var _nextReferenceId = 0;
  var MetadataOverrider = class {
    constructor() {
      this._references = /* @__PURE__ */ new Map();
    }
    overrideMetadata(metadataClass, oldMetadata, override) {
      const props = {};
      if (oldMetadata) {
        _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);
      }
      if (override.set) {
        if (override.remove || override.add) {
          throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);
        }
        setMetadata(props, override.set);
      }
      if (override.remove) {
        removeMetadata(props, override.remove, this._references);
      }
      if (override.add) {
        addMetadata(props, override.add);
      }
      return new metadataClass(props);
    }
  };
  function removeMetadata(metadata, remove2, references) {
    const removeObjects = /* @__PURE__ */ new Set();
    for (const prop in remove2) {
      const removeValue = remove2[prop];
      if (Array.isArray(removeValue)) {
        removeValue.forEach((value) => {
          removeObjects.add(_propHashKey(prop, value, references));
        });
      } else {
        removeObjects.add(_propHashKey(prop, removeValue, references));
      }
    }
    for (const prop in metadata) {
      const propValue = metadata[prop];
      if (Array.isArray(propValue)) {
        metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));
      } else {
        if (removeObjects.has(_propHashKey(prop, propValue, references))) {
          metadata[prop] = void 0;
        }
      }
    }
  }
  function addMetadata(metadata, add) {
    for (const prop in add) {
      const addValue = add[prop];
      const propValue = metadata[prop];
      if (propValue != null && Array.isArray(propValue)) {
        metadata[prop] = propValue.concat(addValue);
      } else {
        metadata[prop] = addValue;
      }
    }
  }
  function setMetadata(metadata, set) {
    for (const prop in set) {
      metadata[prop] = set[prop];
    }
  }
  function _propHashKey(propName, propValue, references) {
    let nextObjectId = 0;
    const objectIds = /* @__PURE__ */ new Map();
    const replacer = (key, value) => {
      if (value !== null && typeof value === "object") {
        if (objectIds.has(value)) {
          return objectIds.get(value);
        }
        objectIds.set(value, `\u0275obj#${nextObjectId++}`);
        return value;
      } else if (typeof value === "function") {
        value = _serializeReference(value, references);
      }
      return value;
    };
    return `${propName}:${JSON.stringify(propValue, replacer)}`;
  }
  function _serializeReference(ref, references) {
    let id = references.get(ref);
    if (!id) {
      id = `${stringify(ref)}${_nextReferenceId++}`;
      references.set(ref, id);
    }
    return id;
  }
  function _valueProps(obj) {
    const props = [];
    Object.keys(obj).forEach((prop) => {
      if (!prop.startsWith("_")) {
        props.push(prop);
      }
    });
    let proto = obj;
    while (proto = Object.getPrototypeOf(proto)) {
      Object.keys(proto).forEach((protoProp) => {
        const desc = Object.getOwnPropertyDescriptor(proto, protoProp);
        if (!protoProp.startsWith("_") && desc && "get" in desc) {
          props.push(protoProp);
        }
      });
    }
    return props;
  }
  var reflection = new ReflectionCapabilities();
  var OverrideResolver = class {
    constructor() {
      this.overrides = /* @__PURE__ */ new Map();
      this.resolved = /* @__PURE__ */ new Map();
    }
    addOverride(type, override) {
      const overrides = this.overrides.get(type) || [];
      overrides.push(override);
      this.overrides.set(type, overrides);
      this.resolved.delete(type);
    }
    setOverrides(overrides) {
      this.overrides.clear();
      overrides.forEach(([type, override]) => {
        this.addOverride(type, override);
      });
    }
    getAnnotation(type) {
      const annotations = reflection.annotations(type);
      for (let i = annotations.length - 1; i >= 0; i--) {
        const annotation = annotations[i];
        const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;
        if (isKnownType) {
          return annotation instanceof this.type ? annotation : null;
        }
      }
      return null;
    }
    resolve(type) {
      let resolved = this.resolved.get(type) || null;
      if (!resolved) {
        resolved = this.getAnnotation(type);
        if (resolved) {
          const overrides = this.overrides.get(type);
          if (overrides) {
            const overrider = new MetadataOverrider();
            overrides.forEach((override) => {
              resolved = overrider.overrideMetadata(this.type, resolved, override);
            });
          }
        }
        this.resolved.set(type, resolved);
      }
      return resolved;
    }
  };
  var DirectiveResolver = class extends OverrideResolver {
    get type() {
      return Directive;
    }
  };
  var ComponentResolver = class extends OverrideResolver {
    get type() {
      return Component;
    }
  };
  var PipeResolver = class extends OverrideResolver {
    get type() {
      return Pipe;
    }
  };
  var NgModuleResolver = class extends OverrideResolver {
    get type() {
      return NgModule;
    }
  };
  var TestingModuleOverride;
  (function(TestingModuleOverride2) {
    TestingModuleOverride2[TestingModuleOverride2["DECLARATION"] = 0] = "DECLARATION";
    TestingModuleOverride2[TestingModuleOverride2["OVERRIDE_TEMPLATE"] = 1] = "OVERRIDE_TEMPLATE";
  })(TestingModuleOverride || (TestingModuleOverride = {}));
  function isTestingModuleOverride(value) {
    return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;
  }
  var R3TestBedCompiler = class {
    constructor(platform, additionalModuleTypes) {
      this.platform = platform;
      this.additionalModuleTypes = additionalModuleTypes;
      this.originalComponentResolutionQueue = null;
      this.declarations = [];
      this.imports = [];
      this.providers = [];
      this.schemas = [];
      this.pendingComponents = /* @__PURE__ */ new Set();
      this.pendingDirectives = /* @__PURE__ */ new Set();
      this.pendingPipes = /* @__PURE__ */ new Set();
      this.seenComponents = /* @__PURE__ */ new Set();
      this.seenDirectives = /* @__PURE__ */ new Set();
      this.overriddenModules = /* @__PURE__ */ new Set();
      this.existingComponentStyles = /* @__PURE__ */ new Map();
      this.resolvers = initResolvers();
      this.componentToModuleScope = /* @__PURE__ */ new Map();
      this.initialNgDefs = /* @__PURE__ */ new Map();
      this.defCleanupOps = [];
      this._injector = null;
      this.compilerProviders = null;
      this.providerOverrides = [];
      this.rootProviderOverrides = [];
      this.providerOverridesByModule = /* @__PURE__ */ new Map();
      this.providerOverridesByToken = /* @__PURE__ */ new Map();
      this.moduleProvidersOverridden = /* @__PURE__ */ new Set();
      this.testModuleRef = null;
      class DynamicTestModule {
      }
      this.testModuleType = DynamicTestModule;
    }
    setCompilerProviders(providers) {
      this.compilerProviders = providers;
      this._injector = null;
    }
    configureTestingModule(moduleDef) {
      if (moduleDef.declarations !== void 0) {
        this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);
        this.declarations.push(...moduleDef.declarations);
      }
      if (moduleDef.imports !== void 0) {
        this.queueTypesFromModulesArray(moduleDef.imports);
        this.imports.push(...moduleDef.imports);
      }
      if (moduleDef.providers !== void 0) {
        this.providers.push(...moduleDef.providers);
      }
      if (moduleDef.schemas !== void 0) {
        this.schemas.push(...moduleDef.schemas);
      }
    }
    overrideModule(ngModule, override) {
      this.overriddenModules.add(ngModule);
      this.resolvers.module.addOverride(ngModule, override);
      const metadata = this.resolvers.module.resolve(ngModule);
      if (metadata === null) {
        throw invalidTypeError(ngModule.name, "NgModule");
      }
      this.recompileNgModule(ngModule, metadata);
      this.queueTypesFromModulesArray([ngModule]);
    }
    overrideComponent(component, override) {
      this.resolvers.component.addOverride(component, override);
      this.pendingComponents.add(component);
    }
    overrideDirective(directive, override) {
      this.resolvers.directive.addOverride(directive, override);
      this.pendingDirectives.add(directive);
    }
    overridePipe(pipe, override) {
      this.resolvers.pipe.addOverride(pipe, override);
      this.pendingPipes.add(pipe);
    }
    overrideProvider(token, provider) {
      let providerDef;
      if (provider.useFactory !== void 0) {
        providerDef = {
          provide: token,
          useFactory: provider.useFactory,
          deps: provider.deps || [],
          multi: provider.multi
        };
      } else if (provider.useValue !== void 0) {
        providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };
      } else {
        providerDef = { provide: token };
      }
      const injectableDef = typeof token !== "string" ? getInjectableDef(token) : null;
      const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);
      const overridesBucket = providedIn === "root" ? this.rootProviderOverrides : this.providerOverrides;
      overridesBucket.push(providerDef);
      this.providerOverridesByToken.set(token, providerDef);
      if (injectableDef !== null && providedIn !== null && typeof providedIn !== "string") {
        const existingOverrides = this.providerOverridesByModule.get(providedIn);
        if (existingOverrides !== void 0) {
          existingOverrides.push(providerDef);
        } else {
          this.providerOverridesByModule.set(providedIn, [providerDef]);
        }
      }
    }
    overrideTemplateUsingTestingModule(type, template) {
      const def = type[NG_COMP_DEF];
      const hasStyleUrls = () => {
        const metadata = this.resolvers.component.resolve(type);
        return !!metadata.styleUrls && metadata.styleUrls.length > 0;
      };
      const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();
      const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };
      this.overrideComponent(type, { set: override });
      if (overrideStyleUrls && def.styles && def.styles.length > 0) {
        this.existingComponentStyles.set(type, def.styles);
      }
      this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);
    }
    async compileComponents() {
      this.clearComponentResolutionQueue();
      let needsAsyncResources = this.compileTypesSync();
      if (needsAsyncResources) {
        let resourceLoader;
        let resolver = (url) => {
          if (!resourceLoader) {
            resourceLoader = this.injector.get(ResourceLoader);
          }
          return Promise.resolve(resourceLoader.get(url));
        };
        await resolveComponentResources2(resolver);
      }
    }
    finalize() {
      this.compileTypesSync();
      this.compileTestModule();
      this.applyTransitiveScopes();
      this.applyProviderOverrides();
      this.patchComponentsWithExistingStyles();
      this.componentToModuleScope.clear();
      const parentInjector = this.platform.injector;
      this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector);
      this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();
      const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
      setLocaleId(localeId);
      return this.testModuleRef;
    }
    _compileNgModuleSync(moduleType) {
      this.queueTypesFromModulesArray([moduleType]);
      this.compileTypesSync();
      this.applyProviderOverrides();
      this.applyProviderOverridesToModule(moduleType);
      this.applyTransitiveScopes();
    }
    async _compileNgModuleAsync(moduleType) {
      this.queueTypesFromModulesArray([moduleType]);
      await this.compileComponents();
      this.applyProviderOverrides();
      this.applyProviderOverridesToModule(moduleType);
      this.applyTransitiveScopes();
    }
    _getModuleResolver() {
      return this.resolvers.module;
    }
    _getComponentFactories(moduleType) {
      return maybeUnwrapFn2(moduleType.\u0275mod.declarations).reduce((factories, declaration) => {
        const componentDef = declaration.\u0275cmp;
        componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef));
        return factories;
      }, []);
    }
    compileTypesSync() {
      let needsAsyncResources = false;
      this.pendingComponents.forEach((declaration) => {
        needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);
        const metadata = this.resolvers.component.resolve(declaration);
        if (metadata === null) {
          throw invalidTypeError(declaration.name, "Component");
        }
        this.maybeStoreNgDef(NG_COMP_DEF, declaration);
        compileComponent(declaration, metadata);
      });
      this.pendingComponents.clear();
      this.pendingDirectives.forEach((declaration) => {
        const metadata = this.resolvers.directive.resolve(declaration);
        if (metadata === null) {
          throw invalidTypeError(declaration.name, "Directive");
        }
        this.maybeStoreNgDef(NG_DIR_DEF, declaration);
        compileDirective(declaration, metadata);
      });
      this.pendingDirectives.clear();
      this.pendingPipes.forEach((declaration) => {
        const metadata = this.resolvers.pipe.resolve(declaration);
        if (metadata === null) {
          throw invalidTypeError(declaration.name, "Pipe");
        }
        this.maybeStoreNgDef(NG_PIPE_DEF, declaration);
        compilePipe(declaration, metadata);
      });
      this.pendingPipes.clear();
      return needsAsyncResources;
    }
    applyTransitiveScopes() {
      if (this.overriddenModules.size > 0) {
        const testingModuleDef = this.testModuleType[NG_MOD_DEF];
        const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);
        if (affectedModules.size > 0) {
          affectedModules.forEach((moduleType) => {
            this.storeFieldOfDefOnType(moduleType, NG_MOD_DEF, "transitiveCompileScopes");
            moduleType[NG_MOD_DEF].transitiveCompileScopes = null;
          });
        }
      }
      const moduleToScope = /* @__PURE__ */ new Map();
      const getScopeOfModule = (moduleType) => {
        if (!moduleToScope.has(moduleType)) {
          const isTestingModule = isTestingModuleOverride(moduleType);
          const realType = isTestingModule ? this.testModuleType : moduleType;
          moduleToScope.set(moduleType, transitiveScopesFor(realType));
        }
        return moduleToScope.get(moduleType);
      };
      this.componentToModuleScope.forEach((moduleType, componentType) => {
        const moduleScope = getScopeOfModule(moduleType);
        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, "directiveDefs");
        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, "pipeDefs");
        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, "tView");
        patchComponentDefWithScope(componentType.\u0275cmp, moduleScope);
      });
      this.componentToModuleScope.clear();
    }
    applyProviderOverrides() {
      const maybeApplyOverrides = (field) => (type) => {
        const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;
        const metadata = resolver.resolve(type);
        if (this.hasProviderOverrides(metadata.providers)) {
          this.patchDefWithProviderOverrides(type, field);
        }
      };
      this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));
      this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));
      this.seenComponents.clear();
      this.seenDirectives.clear();
    }
    applyProviderOverridesToModule(moduleType) {
      if (this.moduleProvidersOverridden.has(moduleType)) {
        return;
      }
      this.moduleProvidersOverridden.add(moduleType);
      const injectorDef = moduleType[NG_INJ_DEF];
      if (this.providerOverridesByToken.size > 0) {
        const providers = [
          ...injectorDef.providers,
          ...this.providerOverridesByModule.get(moduleType) || []
        ];
        if (this.hasProviderOverrides(providers)) {
          this.maybeStoreNgDef(NG_INJ_DEF, moduleType);
          this.storeFieldOfDefOnType(moduleType, NG_INJ_DEF, "providers");
          injectorDef.providers = this.getOverriddenProviders(providers);
        }
        const moduleDef = moduleType[NG_MOD_DEF];
        const imports = maybeUnwrapFn2(moduleDef.imports);
        for (const importedModule of imports) {
          this.applyProviderOverridesToModule(importedModule);
        }
        for (const importedModule of flatten3(injectorDef.imports)) {
          if (isModuleWithProviders2(importedModule)) {
            this.defCleanupOps.push({
              object: importedModule,
              fieldName: "providers",
              originalValue: importedModule.providers
            });
            importedModule.providers = this.getOverriddenProviders(importedModule.providers);
          }
        }
      }
    }
    patchComponentsWithExistingStyles() {
      this.existingComponentStyles.forEach((styles, type) => type[NG_COMP_DEF].styles = styles);
      this.existingComponentStyles.clear();
    }
    queueTypeArray(arr, moduleType) {
      for (const value of arr) {
        if (Array.isArray(value)) {
          this.queueTypeArray(value, moduleType);
        } else {
          this.queueType(value, moduleType);
        }
      }
    }
    recompileNgModule(ngModule, metadata) {
      this.maybeStoreNgDef(NG_MOD_DEF, ngModule);
      this.maybeStoreNgDef(NG_INJ_DEF, ngModule);
      compileNgModuleDefs(ngModule, metadata);
    }
    queueType(type, moduleType) {
      const component = this.resolvers.component.resolve(type);
      if (component) {
        if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {
          this.pendingComponents.add(type);
        }
        this.seenComponents.add(type);
        if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {
          this.componentToModuleScope.set(type, moduleType);
        }
        return;
      }
      const directive = this.resolvers.directive.resolve(type);
      if (directive) {
        if (!type.hasOwnProperty(NG_DIR_DEF)) {
          this.pendingDirectives.add(type);
        }
        this.seenDirectives.add(type);
        return;
      }
      const pipe = this.resolvers.pipe.resolve(type);
      if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {
        this.pendingPipes.add(type);
        return;
      }
    }
    queueTypesFromModulesArray(arr) {
      const processedNgModuleDefs = /* @__PURE__ */ new Set();
      const queueTypesFromModulesArrayRecur = (arr2) => {
        for (const value of arr2) {
          if (Array.isArray(value)) {
            queueTypesFromModulesArrayRecur(value);
          } else if (hasNgModuleDef(value)) {
            const def = value.\u0275mod;
            if (processedNgModuleDefs.has(def)) {
              continue;
            }
            processedNgModuleDefs.add(def);
            this.queueTypeArray(maybeUnwrapFn2(def.declarations), value);
            queueTypesFromModulesArrayRecur(maybeUnwrapFn2(def.imports));
            queueTypesFromModulesArrayRecur(maybeUnwrapFn2(def.exports));
          } else if (isModuleWithProviders2(value)) {
            queueTypesFromModulesArrayRecur([value.ngModule]);
          }
        }
      };
      queueTypesFromModulesArrayRecur(arr);
    }
    collectModulesAffectedByOverrides(arr) {
      const seenModules = /* @__PURE__ */ new Set();
      const affectedModules = /* @__PURE__ */ new Set();
      const calcAffectedModulesRecur = (arr2, path) => {
        for (const value of arr2) {
          if (Array.isArray(value)) {
            calcAffectedModulesRecur(value, path);
          } else if (hasNgModuleDef(value)) {
            if (seenModules.has(value)) {
              if (affectedModules.has(value)) {
                path.forEach((item) => affectedModules.add(item));
              }
              continue;
            }
            seenModules.add(value);
            if (this.overriddenModules.has(value)) {
              path.forEach((item) => affectedModules.add(item));
            }
            const moduleDef = value[NG_MOD_DEF];
            calcAffectedModulesRecur(maybeUnwrapFn2(moduleDef.imports), path.concat(value));
          }
        }
      };
      calcAffectedModulesRecur(arr, []);
      return affectedModules;
    }
    maybeStoreNgDef(prop, type) {
      if (!this.initialNgDefs.has(type)) {
        const currentDef = Object.getOwnPropertyDescriptor(type, prop);
        this.initialNgDefs.set(type, [prop, currentDef]);
      }
    }
    storeFieldOfDefOnType(type, defField, fieldName) {
      const def = type[defField];
      const originalValue = def[fieldName];
      this.defCleanupOps.push({ object: def, fieldName, originalValue });
    }
    clearComponentResolutionQueue() {
      if (this.originalComponentResolutionQueue === null) {
        this.originalComponentResolutionQueue = /* @__PURE__ */ new Map();
      }
      clearResolutionOfComponentResourcesQueue2().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));
    }
    restoreComponentResolutionQueue() {
      if (this.originalComponentResolutionQueue !== null) {
        restoreComponentResolutionQueue(this.originalComponentResolutionQueue);
        this.originalComponentResolutionQueue = null;
      }
    }
    restoreOriginalState() {
      forEachRight(this.defCleanupOps, (op) => {
        op.object[op.fieldName] = op.originalValue;
      });
      this.initialNgDefs.forEach((value, type) => {
        const [prop, descriptor] = value;
        if (!descriptor) {
          delete type[prop];
        } else {
          Object.defineProperty(type, prop, descriptor);
        }
      });
      this.initialNgDefs.clear();
      this.moduleProvidersOverridden.clear();
      this.restoreComponentResolutionQueue();
      setLocaleId(DEFAULT_LOCALE_ID);
    }
    compileTestModule() {
      class RootScopeModule {
      }
      compileNgModuleDefs(RootScopeModule, {
        providers: [...this.rootProviderOverrides]
      });
      const ngZone = new NgZone({ enableLongStackTrace: true });
      const providers = [
        { provide: NgZone, useValue: ngZone },
        { provide: Compiler, useFactory: () => new R3TestCompiler(this) },
        ...this.providers,
        ...this.providerOverrides
      ];
      const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];
      compileNgModuleDefs(this.testModuleType, {
        declarations: this.declarations,
        imports,
        schemas: this.schemas,
        providers
      }, true);
      this.applyProviderOverridesToModule(this.testModuleType);
    }
    get injector() {
      if (this._injector !== null) {
        return this._injector;
      }
      const providers = [];
      const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);
      compilerOptions.forEach((opts) => {
        if (opts.providers) {
          providers.push(opts.providers);
        }
      });
      if (this.compilerProviders !== null) {
        providers.push(...this.compilerProviders);
      }
      class CompilerModule {
      }
      compileNgModuleDefs(CompilerModule, { providers });
      const CompilerModuleFactory = new NgModuleFactory(CompilerModule);
      this._injector = CompilerModuleFactory.create(this.platform.injector).injector;
      return this._injector;
    }
    getSingleProviderOverrides(provider) {
      const token = getProviderToken(provider);
      return this.providerOverridesByToken.get(token) || null;
    }
    getProviderOverrides(providers) {
      if (!providers || !providers.length || this.providerOverridesByToken.size === 0)
        return [];
      return flatten3(flatten3(providers, (provider) => this.getSingleProviderOverrides(provider) || []));
    }
    getOverriddenProviders(providers) {
      if (!providers || !providers.length || this.providerOverridesByToken.size === 0)
        return [];
      const flattenedProviders = flatten3(providers);
      const overrides = this.getProviderOverrides(flattenedProviders);
      const overriddenProviders = [...flattenedProviders, ...overrides];
      const final = [];
      const seenOverriddenProviders = /* @__PURE__ */ new Set();
      forEachRight(overriddenProviders, (provider) => {
        const token = getProviderToken(provider);
        if (this.providerOverridesByToken.has(token)) {
          if (!seenOverriddenProviders.has(token)) {
            seenOverriddenProviders.add(token);
            final.unshift({ ...provider, multi: false });
          }
        } else {
          final.unshift(provider);
        }
      });
      return final;
    }
    hasProviderOverrides(providers) {
      return this.getProviderOverrides(providers).length > 0;
    }
    patchDefWithProviderOverrides(declaration, field) {
      const def = declaration[field];
      if (def && def.providersResolver) {
        this.maybeStoreNgDef(field, declaration);
        const resolver = def.providersResolver;
        const processProvidersFn = (providers) => this.getOverriddenProviders(providers);
        this.storeFieldOfDefOnType(declaration, field, "providersResolver");
        def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);
      }
    }
  };
  function initResolvers() {
    return {
      module: new NgModuleResolver(),
      component: new ComponentResolver(),
      directive: new DirectiveResolver(),
      pipe: new PipeResolver()
    };
  }
  function hasNgModuleDef(value) {
    return value.hasOwnProperty("\u0275mod");
  }
  function maybeUnwrapFn2(maybeFn) {
    return maybeFn instanceof Function ? maybeFn() : maybeFn;
  }
  function flatten3(values, mapFn) {
    const out = [];
    values.forEach((value) => {
      if (Array.isArray(value)) {
        out.push(...flatten3(value, mapFn));
      } else {
        out.push(mapFn ? mapFn(value) : value);
      }
    });
    return out;
  }
  function getProviderField(provider, field) {
    return provider && typeof provider === "object" && provider[field];
  }
  function getProviderToken(provider) {
    return getProviderField(provider, "provide") || provider;
  }
  function isModuleWithProviders2(value) {
    return value.hasOwnProperty("ngModule");
  }
  function forEachRight(values, fn2) {
    for (let idx = values.length - 1; idx >= 0; idx--) {
      fn2(values[idx], idx);
    }
  }
  function invalidTypeError(name, expectedType) {
    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);
  }
  var R3TestCompiler = class {
    constructor(testBed2) {
      this.testBed = testBed2;
    }
    compileModuleSync(moduleType) {
      this.testBed._compileNgModuleSync(moduleType);
      return new NgModuleFactory(moduleType);
    }
    async compileModuleAsync(moduleType) {
      await this.testBed._compileNgModuleAsync(moduleType);
      return new NgModuleFactory(moduleType);
    }
    compileModuleAndAllComponentsSync(moduleType) {
      const ngModuleFactory = this.compileModuleSync(moduleType);
      const componentFactories = this.testBed._getComponentFactories(moduleType);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    async compileModuleAndAllComponentsAsync(moduleType) {
      const ngModuleFactory = await this.compileModuleAsync(moduleType);
      const componentFactories = this.testBed._getComponentFactories(moduleType);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    clearCache() {
    }
    clearCacheFor(type) {
    }
    getModuleId(moduleType) {
      const meta = this.testBed._getModuleResolver().resolve(moduleType);
      return meta && meta.id || void 0;
    }
  };
  var TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;
  var TestComponentRenderer = class {
    insertRootElement(rootElementId) {
    }
    removeAllRootElements() {
    }
  };
  var ComponentFixtureAutoDetect = new InjectionToken("ComponentFixtureAutoDetect");
  var ComponentFixtureNoNgZone = new InjectionToken("ComponentFixtureNoNgZone");
  var _nextRootElementId = 0;
  var TestBedRender3 = class {
    constructor() {
      this.platform = null;
      this.ngModule = null;
      this._compiler = null;
      this._testModuleRef = null;
      this._activeFixtures = [];
      this._globalCompilationChecked = false;
    }
    static initTestEnvironment(ngModule, platform, summariesOrOptions) {
      const testBed2 = _getTestBedRender3();
      testBed2.initTestEnvironment(ngModule, platform, summariesOrOptions);
      return testBed2;
    }
    static resetTestEnvironment() {
      _getTestBedRender3().resetTestEnvironment();
    }
    static configureCompiler(config2) {
      _getTestBedRender3().configureCompiler(config2);
      return TestBedRender3;
    }
    static configureTestingModule(moduleDef) {
      _getTestBedRender3().configureTestingModule(moduleDef);
      return TestBedRender3;
    }
    static compileComponents() {
      return _getTestBedRender3().compileComponents();
    }
    static overrideModule(ngModule, override) {
      _getTestBedRender3().overrideModule(ngModule, override);
      return TestBedRender3;
    }
    static overrideComponent(component, override) {
      _getTestBedRender3().overrideComponent(component, override);
      return TestBedRender3;
    }
    static overrideDirective(directive, override) {
      _getTestBedRender3().overrideDirective(directive, override);
      return TestBedRender3;
    }
    static overridePipe(pipe, override) {
      _getTestBedRender3().overridePipe(pipe, override);
      return TestBedRender3;
    }
    static overrideTemplate(component, template) {
      _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: null } });
      return TestBedRender3;
    }
    static overrideTemplateUsingTestingModule(component, template) {
      _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);
      return TestBedRender3;
    }
    static overrideProvider(token, provider) {
      _getTestBedRender3().overrideProvider(token, provider);
      return TestBedRender3;
    }
    static inject(token, notFoundValue, flags) {
      return _getTestBedRender3().inject(token, notFoundValue, flags);
    }
    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      return _getTestBedRender3().inject(token, notFoundValue, flags);
    }
    static createComponent(component) {
      return _getTestBedRender3().createComponent(component);
    }
    static resetTestingModule() {
      _getTestBedRender3().resetTestingModule();
      return TestBedRender3;
    }
    static shouldTearDownTestingModule() {
      return _getTestBedRender3().shouldTearDownTestingModule();
    }
    static tearDownTestingModule() {
      _getTestBedRender3().tearDownTestingModule();
    }
    initTestEnvironment(ngModule, platform, summariesOrOptions) {
      if (this.platform || this.ngModule) {
        throw new Error("Cannot set base providers because it has already been called");
      }
      TestBedRender3._environmentTeardownOptions = typeof summariesOrOptions === "function" ? void 0 : summariesOrOptions?.teardown;
      this.platform = platform;
      this.ngModule = ngModule;
      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);
    }
    resetTestEnvironment() {
      this.resetTestingModule();
      this._compiler = null;
      this.platform = null;
      this.ngModule = null;
      TestBedRender3._environmentTeardownOptions = void 0;
    }
    resetTestingModule() {
      this.checkGlobalCompilationFinished();
      resetCompiledComponents();
      if (this._compiler !== null) {
        this.compiler.restoreOriginalState();
      }
      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);
      try {
        this.destroyActiveFixtures();
      } finally {
        try {
          if (this.shouldTearDownTestingModule()) {
            this.tearDownTestingModule();
          }
        } finally {
          this._testModuleRef = null;
          this._instanceTeardownOptions = void 0;
        }
      }
    }
    configureCompiler(config2) {
      if (config2.useJit != null) {
        throw new Error("the Render3 compiler JiT mode is not configurable !");
      }
      if (config2.providers !== void 0) {
        this.compiler.setCompilerProviders(config2.providers);
      }
    }
    configureTestingModule(moduleDef) {
      this.assertNotInstantiated("R3TestBed.configureTestingModule", "configure the test module");
      this.checkGlobalCompilationFinished();
      this._instanceTeardownOptions = moduleDef.teardown;
      this.compiler.configureTestingModule(moduleDef);
    }
    compileComponents() {
      return this.compiler.compileComponents();
    }
    inject(token, notFoundValue, flags) {
      if (token === TestBedRender3) {
        return this;
      }
      const UNDEFINED2 = {};
      const result = this.testModuleRef.injector.get(token, UNDEFINED2, flags);
      return result === UNDEFINED2 ? this.compiler.injector.get(token, notFoundValue, flags) : result;
    }
    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      return this.inject(token, notFoundValue, flags);
    }
    execute(tokens, fn2, context) {
      const params = tokens.map((t) => this.inject(t));
      return fn2.apply(context, params);
    }
    overrideModule(ngModule, override) {
      this.assertNotInstantiated("overrideModule", "override module metadata");
      this.compiler.overrideModule(ngModule, override);
    }
    overrideComponent(component, override) {
      this.assertNotInstantiated("overrideComponent", "override component metadata");
      this.compiler.overrideComponent(component, override);
    }
    overrideTemplateUsingTestingModule(component, template) {
      this.assertNotInstantiated("R3TestBed.overrideTemplateUsingTestingModule", "Cannot override template when the test module has already been instantiated");
      this.compiler.overrideTemplateUsingTestingModule(component, template);
    }
    overrideDirective(directive, override) {
      this.assertNotInstantiated("overrideDirective", "override directive metadata");
      this.compiler.overrideDirective(directive, override);
    }
    overridePipe(pipe, override) {
      this.assertNotInstantiated("overridePipe", "override pipe metadata");
      this.compiler.overridePipe(pipe, override);
    }
    overrideProvider(token, provider) {
      this.assertNotInstantiated("overrideProvider", "override provider");
      this.compiler.overrideProvider(token, provider);
    }
    createComponent(type) {
      const testComponentRenderer = this.inject(TestComponentRenderer);
      const rootElId = `root${_nextRootElementId++}`;
      testComponentRenderer.insertRootElement(rootElId);
      const componentDef = type.\u0275cmp;
      if (!componentDef) {
        throw new Error(`It looks like '${stringify(type)}' has not been IVY compiled - it has no '\u0275cmp' field`);
      }
      const noNgZone = this.inject(ComponentFixtureNoNgZone, false);
      const autoDetect = this.inject(ComponentFixtureAutoDetect, false);
      const ngZone = noNgZone ? null : this.inject(NgZone, null);
      const componentFactory = new ComponentFactory(componentDef);
      const initComponent = () => {
        const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);
        return new ComponentFixture(componentRef, ngZone, autoDetect);
      };
      const fixture2 = ngZone ? ngZone.run(initComponent) : initComponent();
      this._activeFixtures.push(fixture2);
      return fixture2;
    }
    get compiler() {
      if (this._compiler === null) {
        throw new Error(`Need to call TestBed.initTestEnvironment() first`);
      }
      return this._compiler;
    }
    get testModuleRef() {
      if (this._testModuleRef === null) {
        this._testModuleRef = this.compiler.finalize();
      }
      return this._testModuleRef;
    }
    assertNotInstantiated(methodName, methodDescription) {
      if (this._testModuleRef !== null) {
        throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`);
      }
    }
    checkGlobalCompilationFinished() {
      if (!this._globalCompilationChecked && this._testModuleRef === null) {
        flushModuleScopingQueueAsMuchAsPossible();
      }
      this._globalCompilationChecked = true;
    }
    destroyActiveFixtures() {
      let errorCount = 0;
      this._activeFixtures.forEach((fixture2) => {
        try {
          fixture2.destroy();
        } catch (e) {
          errorCount++;
          console.error("Error during cleanup of component", {
            component: fixture2.componentInstance,
            stacktrace: e
          });
        }
      });
      this._activeFixtures = [];
      if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {
        throw Error(`${errorCount} ${errorCount === 1 ? "component" : "components"} threw errors during cleanup`);
      }
    }
    shouldRethrowTeardownErrors() {
      const instanceOptions = this._instanceTeardownOptions;
      const environmentOptions = TestBedRender3._environmentTeardownOptions;
      if (!instanceOptions && !environmentOptions) {
        return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;
      }
      return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();
    }
    shouldTearDownTestingModule() {
      return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedRender3._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;
    }
    tearDownTestingModule() {
      if (this._testModuleRef === null) {
        return;
      }
      const testRenderer = this.inject(TestComponentRenderer);
      try {
        this._testModuleRef.destroy();
      } catch (e) {
        if (this.shouldRethrowTeardownErrors()) {
          throw e;
        } else {
          console.error("Error during cleanup of a testing module", {
            component: this._testModuleRef.instance,
            stacktrace: e
          });
        }
      } finally {
        testRenderer.removeAllRootElements?.();
      }
    }
  };
  var testBed;
  function _getTestBedRender3() {
    return testBed = testBed || new TestBedRender3();
  }
  var TestBed = TestBedRender3;
  var _global4 = typeof window === "undefined" ? global : window;
  if (_global4.beforeEach) {
    _global4.beforeEach(getCleanupHook(false));
  }
  if (_global4.afterEach) {
    _global4.afterEach(getCleanupHook(true));
  }
  function getCleanupHook(expectedTeardownValue) {
    return () => {
      if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {
        TestBed.resetTestingModule();
        resetFakeAsyncZone();
      }
    };
  }

  // dist/helpers.js
  var angular2 = __toESM(require_angular2(), 1);
  var __decorate2 = function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var syncTestZoneSpecCtor = Zone["SyncTestZoneSpec"];
  var fakeAsyncTestZoneSpecCtor = Zone["FakeAsyncTestZoneSpec"];
  var inCatalyst = false;
  function isInCatalyst() {
    return inCatalyst;
  }
  var changeDetectionDepth = 0;
  var mockDate;
  var oldNow;
  var MACRO_TASK_OPTIONS = [
    { source: "LoadModuleFactory", isPeriodic: false }
  ];
  var globalInternal = typeof window === "undefined" ? global : window;
  globalInternal["__zone_symbol__disableDatePatching"] = true;
  var expect = globalInternal.expect;
  function patchClock(mockedDate) {
    mockDate = new jasmine.MockDate(globalInternal);
    mockDate.install(mockedDate);
    oldNow = asyncScheduler.now;
    asyncScheduler.now = Date.now;
  }
  function unpatchClock() {
    if (mockDate) {
      mockDate.uninstall();
    }
    if (oldNow) {
      asyncScheduler.now = oldNow;
      oldNow = void 0;
    }
  }
  function reset() {
    inCatalyst = false;
    if (fixture) {
      fixture.destroy();
    }
    resetFakeAsyncZone2();
    fixture = null;
    isTestModuleSetup = false;
    isCompilationDone = false;
    destroyPlatform();
    unpatchClock();
  }
  function wrapDescribe(describeFunc, description, specDefinitions, mockedDate) {
    return describeFunc(description, function() {
      const topLevel = this.parentSuite != null && this.parentSuite.parentSuite == null;
      if (topLevel) {
        getOriginalFunction("beforeEach")(() => {
          reset();
          changeDetectionDepth = 0;
          patchClock(mockedDate);
        });
        getOriginalFunction("afterEach")((done) => {
          reset();
          done();
        });
      }
      Zone.current.fork(new syncTestZoneSpecCtor("catalyst")).run(() => {
        specDefinitions();
      });
    });
  }
  function describeInternal(description, specDefinitions, mockedDate) {
    return wrapDescribe(globalInternal.describe, description, specDefinitions, mockedDate);
  }
  function describeWithDateInternal(description, mockedDate, specDefinitions) {
    return describeInternal(description, specDefinitions, mockedDate);
  }
  function xdescribeWithDateInternal(description, mockedDate, specDefinitions) {
    return xdescribeInternal(description, specDefinitions, mockedDate);
  }
  function fdescribeWithDateInternal(description, mockedDate, specDefinitions) {
    return fdescribeInternal(description, specDefinitions, mockedDate);
  }
  function xdescribeInternal(description, specDefinitions, mockedDate) {
    return wrapDescribe(getOriginalFunction("xdescribe"), description, specDefinitions, mockedDate);
  }
  function fdescribeInternal(description, specDefinitions, mockedDate) {
    return wrapDescribe(getOriginalFunction("fdescribe"), description, specDefinitions, mockedDate);
  }
  function getOriginalFunction(name) {
    const env = jasmine.getEnv();
    const symbol = Zone.__symbol__(name);
    return env[symbol] || globalInternal[name];
  }
  function itInternalBroken(description, specDefinitions, timeout) {
    const originalIt = getOriginalFunction("it");
    return originalIt(description, wrapTestInFakeAsyncZone(specDefinitions), timeout);
  }
  function itInternalStrict(description, specDefinitions, timeout) {
    return strictFromOriginal("it", description, specDefinitions, timeout);
  }
  function xitInternalStrict(description, specDefinitions, timeout) {
    return strictFromOriginal("xit", description, specDefinitions, timeout);
  }
  function fitInternalStrict(description, specDefinitions, timeout) {
    return strictFromOriginal("fit", description, specDefinitions, timeout);
  }
  function strictFromOriginal(originalFunctionName, description, specDefinitions, timeout) {
    const originalIt = getOriginalFunction(originalFunctionName);
    return originalIt(description, wrapTestInFakeAsyncZone(specDefinitions, true, true), timeout);
  }
  function itLegacyInternal(description, specDefinitions, timeout) {
    const originalIt = getOriginalFunction("it");
    return originalIt(description, wrapTestInFakeAsyncZone(specDefinitions, false), timeout);
  }
  function itAsync(description, specDefinitions, timeout) {
    const originalIt = getOriginalFunction("it");
    return originalIt(description, () => __awaiter2(this, void 0, void 0, function* () {
      inCatalyst = true;
      yield specDefinitions();
      inCatalyst = false;
    }), timeout);
  }
  function xitAsync(description, specDefinitions, timeout) {
    const originalXit = getOriginalFunction("xit");
    return originalXit(description, () => __awaiter2(this, void 0, void 0, function* () {
      inCatalyst = true;
      yield specDefinitions();
      inCatalyst = false;
    }), timeout);
  }
  function fitAsync(description, specDefinitions, timeout) {
    const originalFit = getOriginalFunction("fit");
    return originalFit(description, () => __awaiter2(this, void 0, void 0, function* () {
      inCatalyst = true;
      yield specDefinitions();
      inCatalyst = false;
    }), timeout);
  }
  function xitInternal(description, specDefinitions, timeout) {
    const originalXit = getOriginalFunction("xit");
    return originalXit(description, wrapTestInFakeAsyncZone(specDefinitions), timeout);
  }
  function fitInternal(description, specDefinitions, timeout) {
    const originalFit = getOriginalFunction("fit");
    return originalFit(description, wrapTestInFakeAsyncZone(specDefinitions), timeout);
  }
  function fitLegacyInternal(description, specDefinitions, timeout) {
    const originalFit = getOriginalFunction("fit");
    return originalFit(description, wrapTestInFakeAsyncZone(specDefinitions, false), timeout);
  }
  describeInternal.skip = xdescribeInternal;
  describeInternal.only = fdescribeInternal;
  var describe = describeInternal;
  describeWithDateInternal.skip = xdescribeWithDateInternal;
  describeWithDateInternal.only = fdescribeWithDateInternal;
  itInternalBroken.skip = xitInternal;
  itInternalBroken.only = fitInternal;
  itAsync.skip = xitAsync;
  itAsync.only = fitAsync;
  itInternalStrict.skip = xitInternalStrict;
  itInternalStrict.only = fitInternalStrict;
  itInternalStrict.async = itAsync;
  itInternalStrict.broken = itInternalBroken;
  var it = itInternalStrict;
  itLegacyInternal.skip = xitInternal;
  itLegacyInternal.only = fitLegacyInternal;
  beforeEachInternal.async = beforeEachAsync;
  beforeEachInternal.broken = beforeEachBroken;
  var beforeEach = beforeEachInternal;
  function beforeEachInternal(specDefinitions, timeout) {
    const originalBeforeEach = getOriginalFunction("beforeEach");
    return originalBeforeEach(wrapTestInFakeAsyncZone(specDefinitions, true, true), timeout);
  }
  function beforeEachBroken(specDefinitions, timeout) {
    const originalBeforeEach = getOriginalFunction("beforeEach");
    return originalBeforeEach(wrapTestInFakeAsyncZone(specDefinitions), timeout);
  }
  function beforeEachAsync(specDefinitions, timeout) {
    const originalBeforeEach = getOriginalFunction("beforeEach");
    return originalBeforeEach(() => __awaiter2(this, void 0, void 0, function* () {
      inCatalyst = true;
      yield specDefinitions();
      inCatalyst = false;
    }), timeout);
  }
  function isPromise3(obj) {
    return obj && typeof obj === "object" && typeof obj.then === "function";
  }
  function wrapTestInFakeAsyncZone(specDefinitions, flush3 = true, strict = false) {
    return function(...args) {
      getFakeAsyncZone().run(() => {
        inCatalyst = true;
        let result;
        let unsafeAsync = false;
        try {
          result = specDefinitions.apply(this, args);
        } finally {
          if (isPromise3(result)) {
            const resetFlag = () => {
              inCatalyst = false;
            };
            const resetFlagError = (error3) => {
              resetFlag();
              throw error3;
            };
            result.then(resetFlag, resetFlagError);
            if (flush3) {
              flushInternal();
              if (inCatalyst) {
                unsafeAsync = true;
              }
            } else {
              flushMicroTasks();
            }
          } else {
            inCatalyst = false;
          }
        }
        if (unsafeAsync) {
          if (strict) {
            fail(`Test returned a promise that didn't resolve within the fake async zone. It either never completes or waits for real async data (use it.async in this case).`);
          } else {
            console.warn(`Test returned a promise that didn't resolve within the fake async zone. It either never completes or waits for real async data (use it.async in this case). This warning will become an error soon. See go/catalyst-it-async-problem for more details.`);
          }
        }
      });
    };
  }
  var zoneInitialized = false;
  var fakeAsyncTestZoneSpec;
  var fakeAsyncTestZone;
  function getFakeAsyncZone() {
    if (zoneInitialized) {
      return fakeAsyncTestZone;
    }
    fakeAsyncTestZoneSpec = new fakeAsyncTestZoneSpecCtor("catalyst", false, MACRO_TASK_OPTIONS);
    fakeAsyncTestZoneSpec.properties = {
      "FakeAsyncTestZoneSpec": fakeAsyncTestZoneSpec,
      "Catalyst": true
    };
    fakeAsyncTestZoneSpec.onInvokeTask = (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) => {
      try {
        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);
      } finally {
        if (changeDetectionDepth === 0 && task.type === "eventTask" && currentZone !== targetZone) {
          let ngZone = null;
          try {
            ngZone = TestBed.inject(NgZone);
          } catch (e) {
          }
          if (!ngZone || !ngZone.isStable) {
            flushMicroTasks();
          }
        }
      }
    };
    fakeAsyncTestZone = Zone.current.fork(fakeAsyncTestZoneSpec);
    zoneInitialized = true;
    return fakeAsyncTestZone;
  }
  function getFakeAsyncTestZoneSpec() {
    if (!zoneInitialized) {
      throw new Error("Internal error: FakeAsyncZone not created yet.");
    }
    return fakeAsyncTestZoneSpec;
  }
  function resetFakeAsyncZone2() {
    zoneInitialized = false;
  }
  var isTestModuleSetup = false;
  var fixture = null;
  function getFixture() {
    if (fixture == null) {
      throw new Error("Please call bootstrap() first");
    }
    return fixture;
  }
  var isCompilationDone = false;
  var componentInstance;
  var DynamicTemplateComponent = class DynamicTemplateComponent2 {
    constructor() {
      for (const key in componentInstance) {
        if (componentInstance.hasOwnProperty(key)) {
          Object.defineProperty(this, key, {
            get: () => componentInstance[key],
            set: (value) => {
              componentInstance[key] = value;
            },
            enumerable: true
          });
        }
      }
    }
  };
  DynamicTemplateComponent = __decorate2([
    Component({
      preserveWhitespaces: true,
      selector: "dynamic-template-component",
      template: ""
    })
  ], DynamicTemplateComponent);
  function flushInternal() {
    if (fixture != null) {
      getFixture().detectChanges();
    }
    getFakeAsyncTestZoneSpec().flush(20, true, mockDate.tick);
    if (fixture != null) {
      getFixture().detectChanges();
    }
  }
  function nowInternal(fn2) {
    let retVal = null;
    if (fixture != null) {
      TestBed.inject(NgZone).run(() => __awaiter2(this, void 0, void 0, function* () {
        retVal = yield fn2();
      }));
    } else {
      getFakeAsyncZone().run(() => __awaiter2(this, void 0, void 0, function* () {
        retVal = yield fn2();
      }));
    }
    flushMicroTasks();
    return retVal;
  }
  function getElInternal(selector, root) {
    root = root ? root : getFixture().nativeElement;
    const retVal = selector ? root.querySelector(selector) : root;
    if (!retVal) {
      throw new Error('Element not found for "' + selector + '"');
    }
    return retVal;
  }
  function isInFakeAsyncZone() {
    return Zone.current.get("FakeAsyncTestZoneSpec") != null;
  }
  function callInFakeAsyncZone(fn2) {
    if (isInFakeAsyncZone()) {
      return fn2();
    } else {
      return getFakeAsyncZone().run(fn2);
    }
  }
  function flushMicroTasks() {
    if (!zoneInitialized) {
      return;
    }
    return callInFakeAsyncZone(() => {
      getFakeAsyncTestZoneSpec().flushMicrotasks();
    });
  }
  function assertIsInCatalyst(msg = "") {
    if (!inCatalyst) {
      throw new Error(msg + ` Remember to import 'it', 'beforeEach', 'afterEach' etc. from the catalyst module.`);
    }
  }
  function flush2() {
    assertIsInCatalyst("Put flush() inside beforeEach, beforeAll, it, afterAll or afterEach.");
    callInFakeAsyncZone(flushInternal);
  }
  function now(fn2) {
    assertIsInCatalyst("Put now() inside beforeEach, beforeAll, it, afterAll or afterEach.");
    return callInFakeAsyncZone(() => nowInternal(fn2));
  }
  function getEl(selector, root) {
    assertIsInCatalyst("Put getEl() inside beforeEach, beforeAll, it, afterAll or afterEach.");
    return callInFakeAsyncZone(() => getElInternal(selector, root));
  }

  // dist/matchers/helpers.js
  function awaitValues(observable2) {
    const vals = [];
    const subscriptions = [];
    executeAsyncInCurrentZone(() => {
      subscriptions.push(observable2.subscribe((val) => {
        vals.push(val);
      }));
    });
    for (const subscription of subscriptions) {
      subscription.unsubscribe();
    }
    return vals;
  }
  function immediatelyGetValues(observable2) {
    const vals = [];
    let maybeError;
    observable2.subscribe((next) => {
      vals.push(next);
    }, (error3) => {
      maybeError = error3;
    }).unsubscribe();
    if (maybeError) {
      throw new Error(`Expected not to throw error but did! Cause: ${maybeError}`);
    }
    return vals;
  }
  function flushAllInCurrentZone() {
    if (isInCatalyst()) {
      flush2();
    } else {
      flush();
    }
  }
  function executeAsyncInCurrentZone(fn2) {
    if (isInCatalyst()) {
      now(fn2);
    } else {
      fn2();
    }
    flushAllInCurrentZone();
  }
  function extraInfo(info, expected, actual) {
    const areBothArrays = Array.isArray(expected) && Array.isArray(actual);
    const areBothObjects = Object.prototype.toString.call(expected) === "[object Object]" && Object.prototype.toString.call(actual) === "[object Object]";
    if (areBothArrays || areBothObjects) {
      return info;
    }
    return "";
  }

  // dist/matchers/async_matchers.js
  var asyncMatchersRaw = {
    toEmit(util, customEqualityTesters) {
      return {
        compare(actual, expectedValue) {
          return expectOne({
            actualValues: awaitValues(actual),
            expectedValue,
            valueNoun: "value",
            util,
            customEqualityTesters
          });
        }
      };
    },
    toEmitImmediately(util, customEqualityTesters) {
      return {
        compare(actual, expectedValue) {
          return expectOne({
            actualValues: immediatelyGetValues(actual),
            expectedValue,
            valueNoun: "value",
            util,
            customEqualityTesters
          });
        }
      };
    },
    toHaveNeverEmitted(util) {
      return {
        compare(actual, expectedValue) {
          return expectNone({ actualValues: awaitValues(actual), valueNoun: "value", util });
        }
      };
    },
    toHaveEmitted(util) {
      return {
        compare(actual, expectedValue) {
          return expectAny({ actualValues: awaitValues(actual), valueNoun: "value", util });
        }
      };
    },
    toEmitError(util, customEqualityTesters) {
      return {
        compare: (actual, expectedError) => {
          return expectOne({
            actualValues: awaitValues(mapErrorsToValues(actual)),
            expectedValue: expectedError,
            valueNoun: "error",
            util,
            customEqualityTesters
          });
        }
      };
    },
    toEmitErrorImmediately(util, customEqualityTesters) {
      return {
        compare(actual, expectedError) {
          return expectOne({
            actualValues: immediatelyGetValues(mapErrorsToValues(actual)),
            expectedValue: expectedError,
            valueNoun: "error",
            util,
            customEqualityTesters
          });
        }
      };
    },
    toEmitSequence(util, customEqualityTesters) {
      return {
        compare(actual, expectedValues) {
          return expectAll({
            actualValues: awaitValues(actual),
            expectedValues,
            valuesNoun: "values",
            util,
            customEqualityTesters
          });
        }
      };
    },
    toEmitSequenceImmediately(util, customEqualityTesters) {
      return {
        compare(actual, expectedValues) {
          return expectAll({
            actualValues: immediatelyGetValues(actual),
            expectedValues,
            valuesNoun: "values",
            util,
            customEqualityTesters
          });
        }
      };
    },
    toResolveWith(util, customEqualityTesters) {
      return {
        compare(actual, expected) {
          const promiseResult = analyzePromiseResult(actual);
          if (promiseResult.resolution !== PromiseResolution.RESOLVED) {
            return nonResolvedResultToMatcherResult(util, promiseResult);
          }
          const builder = jasmine.DiffBuilder();
          const pass = util.equals(promiseResult.resolvedValue, expected, customEqualityTesters, builder);
          const not2 = pass ? "not " : "";
          return {
            pass,
            message: `Expected ${not2}to resolve with: ${prettyPrint(util, expected)} but resolved with: ${prettyPrint(util, promiseResult.resolvedValue)}${extraInfo(builder.getMessage(), promiseResult.resolvedValue, expected)}`
          };
        }
      };
    },
    toRejectWith(util, customEqualityTesters) {
      return {
        compare(actual, expected) {
          const promiseResult = analyzePromiseResult(actual);
          if (promiseResult.resolution !== PromiseResolution.REJECTED) {
            return nonRejectedResultToMatcherResult(util, promiseResult);
          }
          const builder = jasmine.DiffBuilder();
          const pass = util.equals(promiseResult.rejectedValue, expected, customEqualityTesters, builder);
          const not2 = pass ? "not " : "";
          return {
            pass,
            message: `Expected ${not2}to reject with: ${prettyPrint(util, expected)} but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}${extraInfo(builder.getMessage(), promiseResult.rejectedValue, expected)}`
          };
        }
      };
    },
    toRejectWithError(util, customEqualityTesters) {
      return {
        compare(actual, expectedMessage) {
          const promiseResult = analyzePromiseResult(actual);
          if (promiseResult.resolution !== PromiseResolution.REJECTED) {
            return nonRejectedResultToMatcherResult(util, promiseResult);
          }
          if (!(promiseResult.rejectedValue instanceof Error)) {
            return {
              pass: false,
              message: `Expected promise to reject with an Error but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`
            };
          }
          if (expectedMessage === void 0 || expectedMessage === null) {
            return {
              pass: true
            };
          }
          if (typeof expectedMessage === "string") {
            const pass2 = util.equals(promiseResult.rejectedValue.message, expectedMessage, customEqualityTesters);
            const not3 = pass2 ? "not " : "";
            return {
              pass: pass2,
              message: `Expected ${not3}to reject with an Error that has the message: ${prettyPrint(util, expectedMessage)} but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`
            };
          }
          const pass = expectedMessage.test(promiseResult.rejectedValue.message);
          const not2 = pass ? "not " : "";
          return {
            pass,
            message: `Expected ${not2}to reject with an Error that has the message that matches the RegExp: ${prettyPrint(util, expectedMessage)} but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`
          };
        }
      };
    },
    toBePending(util, customEqualityTesters) {
      return {
        compare(actual, expected) {
          const promiseResult = analyzePromiseResult(actual);
          if (promiseResult.resolution !== PromiseResolution.STILL_PENDING) {
            return nonPendingResultToMatcherResult(util, promiseResult);
          }
          return {
            pass: true,
            message: `Expected to be pending`
          };
        }
      };
    }
  };
  var TEST_ONLY = { asyncMatchersRaw };
  var asyncMatchers = asyncMatchersRaw;
  var PromiseResolution;
  (function(PromiseResolution2) {
    PromiseResolution2[PromiseResolution2["STILL_PENDING"] = 0] = "STILL_PENDING";
    PromiseResolution2[PromiseResolution2["RESOLVED"] = 1] = "RESOLVED";
    PromiseResolution2[PromiseResolution2["REJECTED"] = 2] = "REJECTED";
  })(PromiseResolution || (PromiseResolution = {}));
  function analyzePromiseResult(promise2) {
    let result = {
      resolution: PromiseResolution.STILL_PENDING
    };
    executeAsyncInCurrentZone(() => {
      promise2.then((val) => {
        result = {
          resolution: PromiseResolution.RESOLVED,
          resolvedValue: val
        };
      }).catch((val) => {
        result = {
          resolution: PromiseResolution.REJECTED,
          rejectedValue: val
        };
      });
    });
    return result;
  }
  function nonResolvedResultToMatcherResult(util, promiseResult) {
    switch (promiseResult.resolution) {
      case PromiseResolution.STILL_PENDING:
        return {
          pass: false,
          message: "Expected promise to resolve, but it is still pending."
        };
      case PromiseResolution.REJECTED:
        return {
          pass: false,
          message: `Expected promise to resolve, but it rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`
        };
      default:
        throw new Error(`Unexpected PromiseResolution in PromiseResult: ${prettyPrint(util, promiseResult)}`);
    }
  }
  function nonRejectedResultToMatcherResult(util, promiseResult) {
    switch (promiseResult.resolution) {
      case PromiseResolution.STILL_PENDING:
        return {
          pass: false,
          message: "Expected promise to reject, but it is still pending."
        };
      case PromiseResolution.RESOLVED:
        return {
          pass: false,
          message: `Expected promise to reject, but it resolved with: ${prettyPrint(util, promiseResult.resolvedValue)}`
        };
      default:
        throw new Error(`Unexpected PromiseResolution in PromiseResult: ${prettyPrint(util, promiseResult)}`);
    }
  }
  function nonPendingResultToMatcherResult(util, promiseResult) {
    switch (promiseResult.resolution) {
      case PromiseResolution.RESOLVED:
        return {
          pass: false,
          message: `Expected promise to be pending, but it resolved with: ${prettyPrint(util, promiseResult.resolvedValue)}`
        };
      case PromiseResolution.REJECTED:
        return {
          pass: false,
          message: `Expected promise to be pending, but it rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`
        };
      default:
        throw new Error(`Unexpected PromiseResolution in PromiseResult: ${prettyPrint(util, promiseResult)}`);
    }
  }
  function mapErrorsToValues(obs) {
    return obs.pipe(filter(() => false), map(() => ({})), catchError((val) => of(val)));
  }
  function expectNone(args) {
    const len = args.actualValues.length;
    if (len !== 0) {
      return {
        pass: false,
        message: `Expected observable not to emit ${args.valueNoun}, but got ${len} ${len === 1 ? "value" : "values"} instead: "${prettyPrint(args.util, args.actualValues)}"`
      };
    } else {
      return {
        pass: true,
        message: `Expected observable to emit at least one value`
      };
    }
  }
  function expectAny(args) {
    if (args.actualValues.length) {
      return {
        pass: true,
        message: `Expected observable to emit at least one value`
      };
    } else {
      return {
        pass: false,
        message: `Expected observable to emit at least one value, but got none.`
      };
    }
  }
  function expectOne(args) {
    const len = args.actualValues.length;
    if (len !== 1) {
      return {
        pass: false,
        message: `Expected observable to emit one ${args.valueNoun}, but got ${len} values instead: "${prettyPrint(args.util, args.actualValues)}"`
      };
    }
    const builder = jasmine.DiffBuilder();
    const actualValue = args.actualValues[0];
    const pass = args.util.equals(actualValue, args.expectedValue, args.customEqualityTesters, builder);
    return {
      pass,
      get message() {
        return `Expected ${pass ? "not " : ""}to emit ${args.valueNoun}: ${prettyPrint(args.util, args.expectedValue)} but emitted: ${prettyPrint(args.util, actualValue)}${extraInfo(builder.getMessage(), actualValue, args.expectedValue)}
`;
      }
    };
  }
  function expectAll(args) {
    const builder = jasmine.DiffBuilder();
    const pass = args.util.equals(args.actualValues, args.expectedValues, args.customEqualityTesters, builder);
    return {
      pass,
      get message() {
        return `Expected ${pass ? "not " : ""}to emit ${args.valuesNoun}: ${prettyPrint(args.util, args.expectedValues)} but emitted: ${prettyPrint(args.util, args.actualValues)}${extraInfo(builder.getMessage(), args.actualValues, args.expectedValues)}`;
      }
    };
  }
  function prettyPrint(util, val) {
    return "\n\n" + util.pp(val) + "\n\n";
  }

  // node_modules/@angular/cdk/fesm2020/testing.mjs
  var autoChangeDetectionSubject = new BehaviorSubject({
    isDisabled: false
  });
  var autoChangeDetectionSubscription;
  function defaultAutoChangeDetectionHandler(status) {
    status.onDetectChangesNow?.();
  }
  function handleAutoChangeDetectionStatus(handler) {
    stopHandlingAutoChangeDetectionStatus();
    autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);
  }
  function stopHandlingAutoChangeDetectionStatus() {
    autoChangeDetectionSubscription?.unsubscribe();
    autoChangeDetectionSubscription = null;
  }
  async function batchChangeDetection(fn2, triggerBeforeAndAfter) {
    if (autoChangeDetectionSubject.getValue().isDisabled) {
      return await fn2();
    }
    if (!autoChangeDetectionSubscription) {
      handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);
    }
    if (triggerBeforeAndAfter) {
      await new Promise((resolve) => autoChangeDetectionSubject.next({
        isDisabled: true,
        onDetectChangesNow: resolve
      }));
      try {
        return await fn2();
      } finally {
        await new Promise((resolve) => autoChangeDetectionSubject.next({
          isDisabled: false,
          onDetectChangesNow: resolve
        }));
      }
    } else {
      autoChangeDetectionSubject.next({ isDisabled: true });
      try {
        return await fn2();
      } finally {
        autoChangeDetectionSubject.next({ isDisabled: false });
      }
    }
  }
  async function parallel(values) {
    return batchChangeDetection(() => Promise.all(values()), true);
  }
  var ComponentHarness = class {
    constructor(locatorFactory) {
      this.locatorFactory = locatorFactory;
    }
    async host() {
      return this.locatorFactory.rootElement;
    }
    documentRootLocatorFactory() {
      return this.locatorFactory.documentRootLocatorFactory();
    }
    locatorFor(...queries) {
      return this.locatorFactory.locatorFor(...queries);
    }
    locatorForOptional(...queries) {
      return this.locatorFactory.locatorForOptional(...queries);
    }
    locatorForAll(...queries) {
      return this.locatorFactory.locatorForAll(...queries);
    }
    async forceStabilize() {
      return this.locatorFactory.forceStabilize();
    }
    async waitForTasksOutsideAngular() {
      return this.locatorFactory.waitForTasksOutsideAngular();
    }
  };
  var HarnessPredicate = class {
    constructor(harnessType, options) {
      this.harnessType = harnessType;
      this._predicates = [];
      this._descriptions = [];
      this._addBaseOptions(options);
    }
    static async stringMatches(value, pattern) {
      value = await value;
      if (pattern === null) {
        return value === null;
      } else if (value === null) {
        return false;
      }
      return typeof pattern === "string" ? value === pattern : pattern.test(value);
    }
    add(description, predicate) {
      this._descriptions.push(description);
      this._predicates.push(predicate);
      return this;
    }
    addOption(name, option, predicate) {
      if (option !== void 0) {
        this.add(`${name} = ${_valueAsString(option)}`, (item) => predicate(item, option));
      }
      return this;
    }
    async filter(harnesses) {
      if (harnesses.length === 0) {
        return [];
      }
      const results = await parallel(() => harnesses.map((h) => this.evaluate(h)));
      return harnesses.filter((_, i) => results[i]);
    }
    async evaluate(harness) {
      const results = await parallel(() => this._predicates.map((p) => p(harness)));
      return results.reduce((combined, current) => combined && current, true);
    }
    getDescription() {
      return this._descriptions.join(", ");
    }
    getSelector() {
      if (!this._ancestor) {
        return (this.harnessType.hostSelector || "").trim();
      }
      const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);
      const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || "");
      const result = [];
      ancestors.forEach((escapedAncestor) => {
        const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);
        return selectors.forEach((escapedSelector) => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));
      });
      return result.join(", ");
    }
    _addBaseOptions(options) {
      this._ancestor = options.ancestor || "";
      if (this._ancestor) {
        this._descriptions.push(`has ancestor matching selector "${this._ancestor}"`);
      }
      const selector = options.selector;
      if (selector !== void 0) {
        this.add(`host matches selector "${selector}"`, async (item) => {
          return (await item.host()).matchesSelector(selector);
        });
      }
    }
  };
  function _valueAsString(value) {
    if (value === void 0) {
      return "undefined";
    }
    try {
      const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp ? `\u25ECMAT_RE_ESCAPE\u25EC${v.toString().replace(/"/g, "\u25ECMAT_RE_ESCAPE\u25EC")}\u25ECMAT_RE_ESCAPE\u25EC` : v);
      return stringifiedValue.replace(/"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬"/g, "").replace(/◬MAT_RE_ESCAPE◬/g, '"');
    } catch {
      return "{...}";
    }
  }
  function _splitAndEscapeSelector(selector) {
    const placeholders = [];
    const result = selector.replace(/(["'][^["']*["'])/g, (_, keep) => {
      const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;
      placeholders.push(keep);
      return replaceBy;
    });
    return [result.split(",").map((part) => part.trim()), placeholders];
  }
  function _restoreSelector(selector, placeholders) {
    return selector.replace(/__cdkPlaceholder-(\d+)__/g, (_, index) => placeholders[+index]);
  }
  var HarnessEnvironment = class {
    constructor(rawRootElement) {
      this.rawRootElement = rawRootElement;
    }
    get rootElement() {
      this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);
      return this._rootElement;
    }
    set rootElement(element2) {
      this._rootElement = element2;
    }
    documentRootLocatorFactory() {
      return this.createEnvironment(this.getDocumentRoot());
    }
    locatorFor(...queries) {
      return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));
    }
    locatorForOptional(...queries) {
      return async () => (await this._getAllHarnessesAndTestElements(queries))[0] || null;
    }
    locatorForAll(...queries) {
      return () => this._getAllHarnessesAndTestElements(queries);
    }
    async rootHarnessLoader() {
      return this;
    }
    async harnessLoaderFor(selector) {
      return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [
        _getDescriptionForHarnessLoaderQuery(selector)
      ]));
    }
    async harnessLoaderForOptional(selector) {
      const elements = await this.getAllRawElements(selector);
      return elements[0] ? this.createEnvironment(elements[0]) : null;
    }
    async harnessLoaderForAll(selector) {
      const elements = await this.getAllRawElements(selector);
      return elements.map((element2) => this.createEnvironment(element2));
    }
    getHarness(query) {
      return this.locatorFor(query)();
    }
    getHarnessOrNull(query) {
      return this.locatorForOptional(query)();
    }
    getAllHarnesses(query) {
      return this.locatorForAll(query)();
    }
    async hasHarness(query) {
      return await this.locatorForOptional(query)() !== null;
    }
    async getChildLoader(selector) {
      return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [
        _getDescriptionForHarnessLoaderQuery(selector)
      ]));
    }
    async getAllChildLoaders(selector) {
      return (await this.getAllRawElements(selector)).map((e) => this.createEnvironment(e));
    }
    createComponentHarness(harnessType, element2) {
      return new harnessType(this.createEnvironment(element2));
    }
    async _getAllHarnessesAndTestElements(queries) {
      if (!queries.length) {
        throw Error("CDK Component harness query must contain at least one element.");
      }
      const { allQueries, harnessQueries, elementQueries, harnessTypes } = _parseQueries(queries);
      const rawElements = await this.getAllRawElements([...elementQueries, ...harnessQueries.map((predicate) => predicate.getSelector())].join(","));
      const skipSelectorCheck = elementQueries.length === 0 && harnessTypes.size === 1 || harnessQueries.length === 0;
      const perElementMatches = await parallel(() => rawElements.map(async (rawElement) => {
        const testElement = this.createTestElement(rawElement);
        const allResultsForElement = await parallel(() => allQueries.map((query) => this._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));
        return _removeDuplicateQueryResults(allResultsForElement);
      }));
      return [].concat(...perElementMatches);
    }
    async _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {
      if (typeof query === "string") {
        return skipSelectorCheck || await testElement.matchesSelector(query) ? testElement : null;
      }
      if (skipSelectorCheck || await testElement.matchesSelector(query.getSelector())) {
        const harness = this.createComponentHarness(query.harnessType, rawElement);
        return await query.evaluate(harness) ? harness : null;
      }
      return null;
    }
  };
  function _parseQueries(queries) {
    const allQueries = [];
    const harnessQueries = [];
    const elementQueries = [];
    const harnessTypes = /* @__PURE__ */ new Set();
    for (const query of queries) {
      if (typeof query === "string") {
        allQueries.push(query);
        elementQueries.push(query);
      } else {
        const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});
        allQueries.push(predicate);
        harnessQueries.push(predicate);
        harnessTypes.add(predicate.harnessType);
      }
    }
    return { allQueries, harnessQueries, elementQueries, harnessTypes };
  }
  async function _removeDuplicateQueryResults(results) {
    let testElementMatched = false;
    let matchedHarnessTypes = /* @__PURE__ */ new Set();
    const dedupedMatches = [];
    for (const result of results) {
      if (!result) {
        continue;
      }
      if (result instanceof ComponentHarness) {
        if (!matchedHarnessTypes.has(result.constructor)) {
          matchedHarnessTypes.add(result.constructor);
          dedupedMatches.push(result);
        }
      } else if (!testElementMatched) {
        testElementMatched = true;
        dedupedMatches.push(result);
      }
    }
    return dedupedMatches;
  }
  async function _assertResultFound(results, queryDescriptions) {
    const result = (await results)[0];
    if (result == void 0) {
      throw Error(`Failed to find element matching one of the following queries:
` + queryDescriptions.map((desc) => `(${desc})`).join(",\n"));
    }
    return result;
  }
  function _getDescriptionForLocatorForQueries(queries) {
    return queries.map((query) => typeof query === "string" ? _getDescriptionForTestElementQuery(query) : _getDescriptionForComponentHarnessQuery(query));
  }
  function _getDescriptionForComponentHarnessQuery(query) {
    const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});
    const { name, hostSelector } = harnessPredicate.harnessType;
    const description = `${name} with host element matching selector: "${hostSelector}"`;
    const constraints = harnessPredicate.getDescription();
    return description + (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : "");
  }
  function _getDescriptionForTestElementQuery(selector) {
    return `TestElement for element matching selector: "${selector}"`;
  }
  function _getDescriptionForHarnessLoaderQuery(selector) {
    return `HarnessLoader for element matching selector: "${selector}"`;
  }
  var TestKey;
  (function(TestKey2) {
    TestKey2[TestKey2["BACKSPACE"] = 0] = "BACKSPACE";
    TestKey2[TestKey2["TAB"] = 1] = "TAB";
    TestKey2[TestKey2["ENTER"] = 2] = "ENTER";
    TestKey2[TestKey2["SHIFT"] = 3] = "SHIFT";
    TestKey2[TestKey2["CONTROL"] = 4] = "CONTROL";
    TestKey2[TestKey2["ALT"] = 5] = "ALT";
    TestKey2[TestKey2["ESCAPE"] = 6] = "ESCAPE";
    TestKey2[TestKey2["PAGE_UP"] = 7] = "PAGE_UP";
    TestKey2[TestKey2["PAGE_DOWN"] = 8] = "PAGE_DOWN";
    TestKey2[TestKey2["END"] = 9] = "END";
    TestKey2[TestKey2["HOME"] = 10] = "HOME";
    TestKey2[TestKey2["LEFT_ARROW"] = 11] = "LEFT_ARROW";
    TestKey2[TestKey2["UP_ARROW"] = 12] = "UP_ARROW";
    TestKey2[TestKey2["RIGHT_ARROW"] = 13] = "RIGHT_ARROW";
    TestKey2[TestKey2["DOWN_ARROW"] = 14] = "DOWN_ARROW";
    TestKey2[TestKey2["INSERT"] = 15] = "INSERT";
    TestKey2[TestKey2["DELETE"] = 16] = "DELETE";
    TestKey2[TestKey2["F1"] = 17] = "F1";
    TestKey2[TestKey2["F2"] = 18] = "F2";
    TestKey2[TestKey2["F3"] = 19] = "F3";
    TestKey2[TestKey2["F4"] = 20] = "F4";
    TestKey2[TestKey2["F5"] = 21] = "F5";
    TestKey2[TestKey2["F6"] = 22] = "F6";
    TestKey2[TestKey2["F7"] = 23] = "F7";
    TestKey2[TestKey2["F8"] = 24] = "F8";
    TestKey2[TestKey2["F9"] = 25] = "F9";
    TestKey2[TestKey2["F10"] = 26] = "F10";
    TestKey2[TestKey2["F11"] = 27] = "F11";
    TestKey2[TestKey2["F12"] = 28] = "F12";
    TestKey2[TestKey2["META"] = 29] = "META";
  })(TestKey || (TestKey = {}));
  function getNoKeysSpecifiedError() {
    return Error("No keys have been specified.");
  }
  function _getTextWithExcludedElements(element2, excludeSelector) {
    const clone = element2.cloneNode(true);
    const exclusions = clone.querySelectorAll(excludeSelector);
    for (let i = 0; i < exclusions.length; i++) {
      exclusions[i].remove();
    }
    return (clone.textContent || "").trim();
  }

  // node_modules/@angular/cdk/fesm2020/keycodes.mjs
  var BACKSPACE = 8;
  var TAB = 9;
  var ENTER = 13;
  var SHIFT = 16;
  var CONTROL = 17;
  var ALT = 18;
  var ESCAPE = 27;
  var PAGE_UP = 33;
  var PAGE_DOWN = 34;
  var END = 35;
  var HOME = 36;
  var LEFT_ARROW = 37;
  var UP_ARROW = 38;
  var RIGHT_ARROW = 39;
  var DOWN_ARROW = 40;
  var INSERT = 45;
  var DELETE = 46;
  var META = 91;
  var F1 = 112;
  var F2 = 113;
  var F3 = 114;
  var F4 = 115;
  var F5 = 116;
  var F6 = 117;
  var F7 = 118;
  var F8 = 119;
  var F9 = 120;
  var F10 = 121;
  var F11 = 122;
  var F12 = 123;
  var PERIOD = 190;

  // node_modules/@angular/cdk/fesm2020/testing/testbed.mjs
  var stateObservableSymbol = Symbol("ProxyZone_PATCHED#stateObservable");
  function createMouseEvent(type, clientX = 0, clientY = 0, offsetX = 1, offsetY = 1, button = 0, modifiers = {}) {
    const screenX = clientX;
    const screenY = clientY;
    const event = new MouseEvent(type, {
      bubbles: true,
      cancelable: true,
      composed: true,
      view: window,
      detail: 0,
      relatedTarget: null,
      screenX,
      screenY,
      clientX,
      clientY,
      ctrlKey: modifiers.control,
      altKey: modifiers.alt,
      shiftKey: modifiers.shift,
      metaKey: modifiers.meta,
      button,
      buttons: 1
    });
    if (offsetX != null) {
      defineReadonlyEventProperty(event, "offsetX", offsetX);
    }
    if (offsetY != null) {
      defineReadonlyEventProperty(event, "offsetY", offsetY);
    }
    return event;
  }
  function createPointerEvent(type, clientX = 0, clientY = 0, offsetX, offsetY, options = { isPrimary: true }) {
    const event = new PointerEvent(type, {
      bubbles: true,
      cancelable: true,
      composed: true,
      view: window,
      clientX,
      clientY,
      ...options
    });
    if (offsetX != null) {
      defineReadonlyEventProperty(event, "offsetX", offsetX);
    }
    if (offsetY != null) {
      defineReadonlyEventProperty(event, "offsetY", offsetY);
    }
    return event;
  }
  function createKeyboardEvent(type, keyCode = 0, key = "", modifiers = {}) {
    return new KeyboardEvent(type, {
      bubbles: true,
      cancelable: true,
      composed: true,
      view: window,
      keyCode,
      key,
      shiftKey: modifiers.shift,
      metaKey: modifiers.meta,
      altKey: modifiers.alt,
      ctrlKey: modifiers.control
    });
  }
  function createFakeEvent(type, bubbles = false, cancelable = true, composed = true) {
    return new Event(type, { bubbles, cancelable, composed });
  }
  function defineReadonlyEventProperty(event, propertyName, value) {
    Object.defineProperty(event, propertyName, { get: () => value, configurable: true });
  }
  function dispatchEvent(node, event) {
    node.dispatchEvent(event);
    return event;
  }
  function dispatchFakeEvent(node, type, bubbles) {
    return dispatchEvent(node, createFakeEvent(type, bubbles));
  }
  function dispatchKeyboardEvent(node, type, keyCode, key, modifiers) {
    return dispatchEvent(node, createKeyboardEvent(type, keyCode, key, modifiers));
  }
  function dispatchMouseEvent(node, type, clientX = 0, clientY = 0, offsetX, offsetY, button, modifiers) {
    return dispatchEvent(node, createMouseEvent(type, clientX, clientY, offsetX, offsetY, button, modifiers));
  }
  function dispatchPointerEvent(node, type, clientX = 0, clientY = 0, offsetX, offsetY, options) {
    return dispatchEvent(node, createPointerEvent(type, clientX, clientY, offsetX, offsetY, options));
  }
  function triggerFocusChange(element2, event) {
    let eventFired = false;
    const handler = () => eventFired = true;
    element2.addEventListener(event, handler);
    element2[event]();
    element2.removeEventListener(event, handler);
    if (!eventFired) {
      dispatchFakeEvent(element2, event);
    }
  }
  function triggerFocus(element2) {
    triggerFocusChange(element2, "focus");
  }
  function triggerBlur(element2) {
    triggerFocusChange(element2, "blur");
  }
  var incrementalInputTypes = /* @__PURE__ */ new Set([
    "text",
    "email",
    "hidden",
    "password",
    "search",
    "tel",
    "url"
  ]);
  function isTextInput(element2) {
    const nodeName = element2.nodeName.toLowerCase();
    return nodeName === "input" || nodeName === "textarea";
  }
  function typeInElement(element2, ...modifiersAndKeys) {
    const first = modifiersAndKeys[0];
    let modifiers;
    let rest;
    if (first !== void 0 && typeof first !== "string" && first.keyCode === void 0 && first.key === void 0) {
      modifiers = first;
      rest = modifiersAndKeys.slice(1);
    } else {
      modifiers = {};
      rest = modifiersAndKeys;
    }
    const isInput2 = isTextInput(element2);
    const inputType = element2.getAttribute("type") || "text";
    const keys = rest.map((k) => typeof k === "string" ? k.split("").map((c) => ({ keyCode: c.toUpperCase().charCodeAt(0), key: c })) : [k]).reduce((arr, k) => arr.concat(k), []);
    if (keys.length === 0) {
      throw getNoKeysSpecifiedError();
    }
    const enterValueIncrementally = inputType === "number" ? keys.every((key) => key.key !== "." && key.key !== "-" && key.keyCode !== PERIOD) : incrementalInputTypes.has(inputType);
    triggerFocus(element2);
    if (!enterValueIncrementally) {
      element2.value = keys.reduce((value, key) => value + (key.key || ""), "");
    }
    for (const key of keys) {
      dispatchKeyboardEvent(element2, "keydown", key.keyCode, key.key, modifiers);
      dispatchKeyboardEvent(element2, "keypress", key.keyCode, key.key, modifiers);
      if (isInput2 && key.key && key.key.length === 1) {
        if (enterValueIncrementally) {
          element2.value += key.key;
          dispatchFakeEvent(element2, "input");
        }
      }
      dispatchKeyboardEvent(element2, "keyup", key.keyCode, key.key, modifiers);
    }
    if (!enterValueIncrementally) {
      dispatchFakeEvent(element2, "input");
    }
  }
  function clearElement(element2) {
    triggerFocus(element2);
    element2.value = "";
    dispatchFakeEvent(element2, "input");
  }
  var keyMap = {
    [TestKey.BACKSPACE]: { keyCode: BACKSPACE, key: "Backspace" },
    [TestKey.TAB]: { keyCode: TAB, key: "Tab" },
    [TestKey.ENTER]: { keyCode: ENTER, key: "Enter" },
    [TestKey.SHIFT]: { keyCode: SHIFT, key: "Shift" },
    [TestKey.CONTROL]: { keyCode: CONTROL, key: "Control" },
    [TestKey.ALT]: { keyCode: ALT, key: "Alt" },
    [TestKey.ESCAPE]: { keyCode: ESCAPE, key: "Escape" },
    [TestKey.PAGE_UP]: { keyCode: PAGE_UP, key: "PageUp" },
    [TestKey.PAGE_DOWN]: { keyCode: PAGE_DOWN, key: "PageDown" },
    [TestKey.END]: { keyCode: END, key: "End" },
    [TestKey.HOME]: { keyCode: HOME, key: "Home" },
    [TestKey.LEFT_ARROW]: { keyCode: LEFT_ARROW, key: "ArrowLeft" },
    [TestKey.UP_ARROW]: { keyCode: UP_ARROW, key: "ArrowUp" },
    [TestKey.RIGHT_ARROW]: { keyCode: RIGHT_ARROW, key: "ArrowRight" },
    [TestKey.DOWN_ARROW]: { keyCode: DOWN_ARROW, key: "ArrowDown" },
    [TestKey.INSERT]: { keyCode: INSERT, key: "Insert" },
    [TestKey.DELETE]: { keyCode: DELETE, key: "Delete" },
    [TestKey.F1]: { keyCode: F1, key: "F1" },
    [TestKey.F2]: { keyCode: F2, key: "F2" },
    [TestKey.F3]: { keyCode: F3, key: "F3" },
    [TestKey.F4]: { keyCode: F4, key: "F4" },
    [TestKey.F5]: { keyCode: F5, key: "F5" },
    [TestKey.F6]: { keyCode: F6, key: "F6" },
    [TestKey.F7]: { keyCode: F7, key: "F7" },
    [TestKey.F8]: { keyCode: F8, key: "F8" },
    [TestKey.F9]: { keyCode: F9, key: "F9" },
    [TestKey.F10]: { keyCode: F10, key: "F10" },
    [TestKey.F11]: { keyCode: F11, key: "F11" },
    [TestKey.F12]: { keyCode: F12, key: "F12" },
    [TestKey.META]: { keyCode: META, key: "Meta" }
  };
  var UnitTestElement = class {
    constructor(element2, _stabilize) {
      this.element = element2;
      this._stabilize = _stabilize;
    }
    async blur() {
      triggerBlur(this.element);
      await this._stabilize();
    }
    async clear() {
      if (!isTextInput(this.element)) {
        throw Error("Attempting to clear an invalid element");
      }
      clearElement(this.element);
      await this._stabilize();
    }
    async click(...args) {
      const isDisabled = this.element.disabled === true;
      await this._dispatchMouseEventSequence(isDisabled ? null : "click", args, 0);
      await this._stabilize();
    }
    async rightClick(...args) {
      await this._dispatchMouseEventSequence("contextmenu", args, 2);
      await this._stabilize();
    }
    async focus() {
      triggerFocus(this.element);
      await this._stabilize();
    }
    async getCssValue(property) {
      await this._stabilize();
      return getComputedStyle(this.element).getPropertyValue(property);
    }
    async hover() {
      this._dispatchPointerEventIfSupported("pointerenter");
      dispatchMouseEvent(this.element, "mouseover");
      dispatchMouseEvent(this.element, "mouseenter");
      await this._stabilize();
    }
    async mouseAway() {
      this._dispatchPointerEventIfSupported("pointerleave");
      dispatchMouseEvent(this.element, "mouseout");
      dispatchMouseEvent(this.element, "mouseleave");
      await this._stabilize();
    }
    async sendKeys(...modifiersAndKeys) {
      const args = modifiersAndKeys.map((k) => typeof k === "number" ? keyMap[k] : k);
      typeInElement(this.element, ...args);
      await this._stabilize();
    }
    async text(options) {
      await this._stabilize();
      if (options?.exclude) {
        return _getTextWithExcludedElements(this.element, options.exclude);
      }
      return (this.element.textContent || "").trim();
    }
    async getAttribute(name) {
      await this._stabilize();
      return this.element.getAttribute(name);
    }
    async hasClass(name) {
      await this._stabilize();
      return this.element.classList.contains(name);
    }
    async getDimensions() {
      await this._stabilize();
      return this.element.getBoundingClientRect();
    }
    async getProperty(name) {
      await this._stabilize();
      return this.element[name];
    }
    async setInputValue(value) {
      this.element.value = value;
      await this._stabilize();
    }
    async selectOptions(...optionIndexes) {
      let hasChanged = false;
      const options = this.element.querySelectorAll("option");
      const indexes = new Set(optionIndexes);
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        const wasSelected = option.selected;
        option.selected = indexes.has(i);
        if (option.selected !== wasSelected) {
          hasChanged = true;
          dispatchFakeEvent(this.element, "change");
        }
      }
      if (hasChanged) {
        await this._stabilize();
      }
    }
    async matchesSelector(selector) {
      await this._stabilize();
      const elementPrototype = Element.prototype;
      return (elementPrototype["matches"] || elementPrototype["msMatchesSelector"]).call(this.element, selector);
    }
    async isFocused() {
      await this._stabilize();
      return document.activeElement === this.element;
    }
    async dispatchEvent(name, data) {
      const event = createFakeEvent(name);
      if (data) {
        Object.assign(event, data);
      }
      dispatchEvent(this.element, event);
      await this._stabilize();
    }
    _dispatchPointerEventIfSupported(name, clientX, clientY, offsetX, offsetY, button) {
      if (typeof PointerEvent !== "undefined" && PointerEvent) {
        dispatchPointerEvent(this.element, name, clientX, clientY, offsetX, offsetY, {
          isPrimary: true,
          button
        });
      }
    }
    async _dispatchMouseEventSequence(primaryEventName, args, button) {
      let clientX = void 0;
      let clientY = void 0;
      let offsetX = void 0;
      let offsetY = void 0;
      let modifiers = {};
      if (args.length && typeof args[args.length - 1] === "object") {
        modifiers = args.pop();
      }
      if (args.length) {
        const { left, top, width, height } = await this.getDimensions();
        offsetX = args[0] === "center" ? width / 2 : args[0];
        offsetY = args[0] === "center" ? height / 2 : args[1];
        clientX = Math.round(left + offsetX);
        clientY = Math.round(top + offsetY);
      }
      this._dispatchPointerEventIfSupported("pointerdown", clientX, clientY, offsetX, offsetY, button);
      dispatchMouseEvent(this.element, "mousedown", clientX, clientY, offsetX, offsetY, button, modifiers);
      this._dispatchPointerEventIfSupported("pointerup", clientX, clientY, offsetX, offsetY, button);
      dispatchMouseEvent(this.element, "mouseup", clientX, clientY, offsetX, offsetY, button, modifiers);
      if (primaryEventName !== null) {
        dispatchMouseEvent(this.element, primaryEventName, clientX, clientY, offsetX, offsetY, button, modifiers);
      }
      await this._stabilize();
    }
  };

  // dist/catalyst-harness-environment.js
  var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var defaultEnvironmentOptions = {
    queryFn: (selector, root) => root.querySelectorAll(selector)
  };
  var disableAutoChangeDetection = false;
  var autoChangeDetectionHandlerInstalled = false;
  function installAutoChangeDetectionStatusHandler() {
    if (!autoChangeDetectionHandlerInstalled) {
      autoChangeDetectionHandlerInstalled = true;
      handleAutoChangeDetectionStatus(({ isDisabled, onDetectChangesNow }) => {
        disableAutoChangeDetection = isDisabled;
        if (onDetectChangesNow) {
          detectChanges2();
          onDetectChangesNow();
        }
      });
    }
  }
  function detectChanges2() {
    flush2();
  }
  var CatalystHarnessEnvironment = class extends HarnessEnvironment {
    constructor(rawRootElement, options) {
      super(rawRootElement);
      this.options = Object.assign(Object.assign({}, defaultEnvironmentOptions), options);
      installAutoChangeDetectionStatusHandler();
    }
    static loader(options) {
      return new CatalystHarnessEnvironment(getEl(), options);
    }
    static getNativeElement(el) {
      if (el instanceof UnitTestElement) {
        return el.element;
      }
      throw new Error("This TestElement was not created by the CatalystHarnessEnvironment");
    }
    static documentRootLoader(options) {
      return new CatalystHarnessEnvironment(document.body, options);
    }
    static harnessForBootstrappedComponent(harnessType, options) {
      return __awaiter3(this, void 0, void 0, function* () {
        const environment = new CatalystHarnessEnvironment(getEl(), options);
        yield environment.forceStabilize();
        return environment.createComponentHarness(harnessType, getEl());
      });
    }
    forceStabilize() {
      return __awaiter3(this, void 0, void 0, function* () {
        if (!disableAutoChangeDetection) {
          detectChanges2();
        }
      });
    }
    waitForTasksOutsideAngular() {
      return __awaiter3(this, void 0, void 0, function* () {
        flush2();
      });
    }
    getDocumentRoot() {
      return document.body;
    }
    createTestElement(element2) {
      return new UnitTestElement(element2, () => this.forceStabilize());
    }
    createEnvironment(element2) {
      return new CatalystHarnessEnvironment(element2, this.options);
    }
    getAllRawElements(selector) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.forceStabilize();
        return Array.from(this.options.queryFn(selector, this.rawRootElement));
      });
    }
  };
  var getNativeElement = CatalystHarnessEnvironment.getNativeElement;

  // dist/matchers/async_matchers_test.js
  describe("AsyncMatchers", () => {
    beforeEach(() => {
      jasmine.addMatchers(asyncMatchers);
    });
    it("should emit value", () => {
      expect(of(1)).toEmit(1);
      expect(of(1).pipe(delay(0))).toEmit(1);
      expect(of(1).pipe(delay(1e3))).toEmit(1);
      expect(of("12")).toEmit("12");
      expect(of(void 0)).toEmit(void 0);
      expect(of(null)).toEmit(null);
      expect(of({ name: "name1" })).toEmit({ name: "name1" });
      expect(of(null)).not.toEmit(void 0);
      expect(of(void 0)).not.toEmit(null);
      expect(of(1)).not.toEmit(2);
      expect(of(1)).not.toEmit("1");
      expect(of("1")).not.toEmit(1);
      expect(of({ name: "name1" })).not.toEmit({ name: "name2" });
      expect(of(1, 2)).not.toEmit(1);
      expect(of(1, 2)).not.toEmit(2);
      const behaviorSubject = new BehaviorSubject(1);
      behaviorSubject.next(2);
      expect(behaviorSubject).not.toEmit(1);
      expect(behaviorSubject).toEmit(2);
      expect(new Observable((observer) => {
        observer.next(1);
      })).toEmit(1);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.next(2);
      })).not.toEmit(1);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.next(2);
      })).not.toEmit(2);
      expect(() => {
        expect(new Observable((observer) => {
          observer.next(1);
          observer.error(2);
        })).toEmit(2);
      }).toThrow();
    });
    it("should emit value immediately", () => {
      expect(of(1)).toEmitImmediately(1);
      expect(of(1).pipe(delay(0))).not.toEmitImmediately(1);
      expect(of(1).pipe(delay(1e3))).not.toEmitImmediately(1);
      expect(of("12")).toEmitImmediately("12");
      expect(of(void 0)).toEmitImmediately(void 0);
      expect(of(null)).toEmitImmediately(null);
      expect(of({ name: "name1" })).toEmitImmediately({ name: "name1" });
      expect(of(null)).not.toEmitImmediately(void 0);
      expect(of(void 0)).not.toEmitImmediately(null);
      expect(of(1)).not.toEmitImmediately(2);
      expect(of(1)).not.toEmitImmediately("1");
      expect(of("1")).not.toEmitImmediately(1);
      expect(of({ name: "name1" })).not.toEmitImmediately({ name: "name2" });
      expect(of(1, 2)).not.toEmitImmediately(1);
      expect(of(1, 2)).not.toEmitImmediately(2);
      const behaviorSubject = new BehaviorSubject(1);
      behaviorSubject.next(2);
      expect(behaviorSubject).not.toEmitImmediately(1);
      expect(behaviorSubject).toEmitImmediately(2);
      expect(new Observable((observer) => {
        observer.next(1);
      })).toEmitImmediately(1);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.next(2);
      })).not.toEmitImmediately(1);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.next(2);
      })).not.toEmitImmediately(2);
      expect(() => {
        expect(new Observable((observer) => {
          observer.error(2);
        })).not.toEmitImmediately(2);
      }).toThrow();
    });
    it("should not emit any values", () => {
      expect(NEVER).toHaveNeverEmitted();
      expect(of(null)).not.toHaveNeverEmitted();
      expect(of(void 0)).not.toHaveNeverEmitted();
      expect(of(1)).not.toHaveNeverEmitted();
      expect(of({ name: "name1" })).not.toHaveNeverEmitted();
      expect(of(1, 2)).not.toHaveNeverEmitted();
      const replaySubject = new ReplaySubject();
      expect(replaySubject).toHaveNeverEmitted();
      replaySubject.next(1);
      expect(replaySubject).not.toHaveNeverEmitted();
      expect(new Observable((observer) => {
      })).toHaveNeverEmitted();
      expect(new Observable((observer) => {
        observer.next(1);
      })).not.toHaveNeverEmitted();
      expect(() => {
        expect(new Observable((observer) => {
          observer.error(1);
        })).toHaveNeverEmitted();
      }).toThrow();
    });
    it("should emit any values", () => {
      expect(NEVER).not.toHaveEmitted();
      expect(of(null)).toHaveEmitted();
      expect(of(void 0)).toHaveEmitted();
      expect(of(1)).toHaveEmitted();
      expect(of({ name: "name1" })).toHaveEmitted();
      expect(of(1, 2)).toHaveEmitted();
      const replaySubject = new ReplaySubject();
      expect(replaySubject).not.toHaveEmitted();
      replaySubject.next(1);
      expect(replaySubject).toHaveEmitted();
      expect(new Observable((observer) => {
      })).not.toHaveEmitted();
      expect(new Observable((observer) => {
        observer.next(1);
      })).toHaveEmitted();
      expect(() => {
        expect(new Observable((observer) => {
          observer.error(1);
        })).not.toHaveEmitted();
      }).toThrow();
    });
    it("should emit error", () => {
      expect(throwError(1)).toEmitError(1);
      expect(of({}).pipe(delay(1e3), switchMap(() => throwError(1)))).toEmitError(1);
      expect(throwError("12")).toEmitError("12");
      expect(throwError(void 0)).toEmitError(void 0);
      expect(throwError(null)).toEmitError(null);
      expect(throwError({ name: "name1" })).toEmitError({ name: "name1" });
      expect(throwError(null)).not.toEmitError(void 0);
      expect(throwError(void 0)).not.toEmitError(null);
      expect(throwError(1)).not.toEmitError(2);
      expect(throwError(1)).not.toEmitError("1");
      expect(throwError("1")).not.toEmitError(1);
      expect(throwError({ name: "name1" })).not.toEmitError({ name: "name2" });
      expect(new Observable((observer) => {
        observer.error(1);
      })).toEmitError(1);
      expect(new Observable((observer) => {
        observer.error(1);
        observer.error(2);
      })).toEmitError(1);
      expect(new Observable((observer) => {
        observer.error(1);
        observer.error(2);
      })).not.toEmitError(2);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.error(2);
      })).toEmitError(2);
    });
    it("should emit error immediately", () => {
      expect(throwError(1)).toEmitErrorImmediately(1);
      expect(of({}).pipe(delay(0), switchMap(() => throwError(1)))).not.toEmitErrorImmediately(1);
      expect(of({}).pipe(delay(1e3), switchMap(() => throwError(1)))).not.toEmitErrorImmediately(1);
      expect(throwError("12")).toEmitErrorImmediately("12");
      expect(throwError(void 0)).toEmitErrorImmediately(void 0);
      expect(throwError(null)).toEmitErrorImmediately(null);
      expect(throwError({ name: "name1" })).toEmitErrorImmediately({ name: "name1" });
      expect(throwError(null)).not.toEmitErrorImmediately(void 0);
      expect(throwError(void 0)).not.toEmitErrorImmediately(null);
      expect(throwError(1)).not.toEmitErrorImmediately(2);
      expect(throwError(1)).not.toEmitErrorImmediately("1");
      expect(throwError("1")).not.toEmitErrorImmediately(1);
      expect(throwError({ name: "name1" })).not.toEmitErrorImmediately({
        name: "name2"
      });
      expect(new Observable((observer) => {
        observer.error(1);
      })).toEmitErrorImmediately(1);
      expect(new Observable((observer) => {
        observer.error(1);
        observer.error(2);
      })).toEmitErrorImmediately(1);
      expect(new Observable((observer) => {
        observer.error(1);
        observer.error(2);
      })).not.toEmitErrorImmediately(2);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.error(2);
      })).toEmitErrorImmediately(2);
    });
    it("should emit sequence", () => {
      expect(of(1, 2, 3)).toEmitSequence([1, 2, 3]);
      expect(of(1, 2, 3).pipe(delay(2e3))).toEmitSequence([1, 2, 3]);
      expect(of()).toEmitSequence([]);
      expect(of(1, 2, 3)).not.toEmitSequence([1, 2, "3"]);
      expect(of(1, 2)).not.toEmitSequence([1, 2, 3]);
      expect(of(1, 2, 3, 4)).not.toEmitSequence([1, 2, 3]);
      expect(new Observable(() => {
      })).toEmitSequence([]);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.next(2);
      })).toEmitSequence([1, 2]);
      expect(() => {
        expect(new Observable((observer) => {
          observer.next(1);
          observer.next(2);
          observer.error(3);
        })).toEmitSequence([1, 2]);
      }).toThrow();
    });
    it("should emit sequence immediately", () => {
      expect(of(1, 2, 3)).toEmitSequenceImmediately([1, 2, 3]);
      expect(of(1, 2, 3).pipe(delay(0))).toEmitSequenceImmediately([]);
      expect(of(1, 2, 3).pipe(delay(0))).not.toEmitSequenceImmediately([1, 2, 3]);
      expect(of(1, 2, 3).pipe(delay(2e3))).toEmitSequenceImmediately([]);
      expect(of(1, 2, 3).pipe(delay(2e3))).not.toEmitSequenceImmediately([
        1,
        2,
        3
      ]);
      expect(of()).toEmitSequenceImmediately([]);
      expect(of(1, 2, 3)).not.toEmitSequenceImmediately([1, 2, "3"]);
      expect(of(1, 2)).not.toEmitSequenceImmediately([1, 2, 3]);
      expect(of(1, 2, 3, 4)).not.toEmitSequenceImmediately([1, 2, 3]);
      expect(new Observable(() => {
      })).toEmitSequenceImmediately([]);
      expect(new Observable((observer) => {
        observer.next(1);
        observer.next(2);
      })).toEmitSequenceImmediately([1, 2]);
      expect(() => {
        expect(new Observable((observer) => {
          observer.error(3);
        })).not.toEmitSequenceImmediately([1, 2]);
      }).toThrow();
    });
    it("should resolve with", () => {
      expect(Promise.resolve({
        name: "obj1"
      })).toResolveWith({
        name: "obj1"
      });
      expect(Promise.resolve({
        name: "obj1"
      })).not.toResolveWith({
        name: "obj2"
      });
      expect(Promise.reject(1)).not.toResolveWith(1);
    });
    it("should reject with", () => {
      expect(Promise.reject({
        name: "obj1"
      })).toRejectWith({
        name: "obj1"
      });
      expect(Promise.reject({
        name: "obj1"
      })).not.toRejectWith({
        name: "obj2"
      });
      expect(Promise.resolve(1)).not.toRejectWith(1);
    });
    it("should reject with error", () => {
      const p = Promise.reject(new Error("some error"));
      expect(p).toRejectWithError("some error");
      expect(p).toRejectWithError(/some error/);
      expect(p).toRejectWithError(/.*error/);
      expect(p).not.toRejectWithError(/all good/);
    });
    it("should not reject with error", () => {
      expect(Promise.resolve({ name: "obj1" })).not.toRejectWithError(/error/);
      expect(Promise.reject({ name: "obj1" })).not.toRejectWithError(/error/);
    });
    it("should be pending", () => {
      expect(new Promise(() => {
      })).toBePending();
    });
    it("should not be pending", () => {
      expect(Promise.resolve({ name: "obj1" })).not.toBePending();
      expect(Promise.reject({ name: "obj1" })).not.toBePending();
    });
    it("should support empty emitters", () => {
      const subject = new ReplaySubject();
      subject.next();
      expect(subject).toEmit(void 0);
      expect(subject).toEmitSequence([void 0]);
      subject.complete();
    });
    it("should support custom equality testers", () => {
      const obj1 = {
        id: 1,
        name: "name1"
      };
      const obj2 = {
        id: 2,
        name: "name1"
      };
      const obj1Clone = {
        id: 1,
        name: "name2"
      };
      const objCustomEquality = (first, second) => {
        return !!first.id && !!second.id && first.id === second.id;
      };
      jasmine.addCustomEqualityTester(objCustomEquality);
      const subject = new ReplaySubject();
      subject.next(obj1);
      expect(subject).not.toEmit(obj2);
      expect(subject).toEmit(obj1Clone);
      expect(Promise.resolve(obj1)).not.toResolveWith(obj2);
      expect(Promise.resolve(obj1)).toResolveWith(obj1Clone);
      expect(Promise.reject(obj1)).not.toRejectWith(obj2);
      expect(Promise.reject(obj1)).toRejectWith(obj1Clone);
    });
  });
  describe("AsyncMatcher Factories", () => {
    const NATIVE_EQ_TESTER = (first, second) => {
      console.log(`Comparing ${first} with ${second}`);
      return first === second;
    };
    describe("biffBuilder", () => {
      function getComparator(name) {
        return TEST_ONLY.asyncMatchersRaw[name](jasmine.matchersUtil, []).compare;
      }
      it("is used by onEmit", () => {
        const comparator = getComparator("toEmit");
        const result = comparator(of([1, 2, 3]), [1, 2]);
        expect(result.message).toContain("Expected $.length = 3 to equal 2");
        expect(result.message).toContain("Unexpected $[2] = 3 in array.");
      });
      it("only works for arrays and objects", () => {
        const comparator = getComparator("toEmit");
        expect(comparator(of(1), 2).message).not.toContain("Expected 1 to equal 2.");
        expect(comparator(of("a"), "b").message).not.toContain("Expected a to equal b.");
        expect(comparator(of([1]), { a: 1 }).message).not.toContain("Expected [ 1 ] to equal Object({ a: 1 })");
      });
      it("is used by toResolveWith", () => {
        const comparator = getComparator("toResolveWith");
        const result = comparator(Promise.resolve([1, 2, 3]), [1, 2]);
        expect(result.message).toContain("Expected $.length = 3 to equal 2");
        expect(result.message).toContain("Unexpected $[2] = 3 in array.");
      });
      it("is used by toRejectWith", () => {
        const comparator = getComparator("toRejectWith");
        const result = comparator(Promise.reject([1, 2, 3]), [1, 2]);
        expect(result.message).toContain("Expected $.length = 3 to equal 2");
        expect(result.message).toContain("Unexpected $[2] = 3 in array.");
      });
      it("is used by toEmitSequence", () => {
        const comparator = getComparator("toEmitSequence");
        const result = comparator(of([1], [2], [3]), [[1, 2], [5, 6, 7]]);
        expect(result.message).toContain("Expected $.length = 3 to equal 2");
        expect(result.message).toContain("Expected $[0].length = 1 to equal 2");
        expect(result.message).toContain("Expected $[0][1] = undefined to equal 2");
        expect(result.message).toContain("Expected $[1].length = 1 to equal 3");
        expect(result.message).toContain("Expected $[1][0] = 2 to equal 5");
        expect(result.message).toContain("Expected $[1][1] = undefined to equal 6");
        expect(result.message).toContain("Expected $[1][2] = undefined to equal 7");
      });
    });
    describe("toEmit", () => {
      let toEmitCompare;
      beforeEach(() => {
        toEmitCompare = TEST_ONLY.asyncMatchersRaw["toEmit"](jasmine.matchersUtil, [NATIVE_EQ_TESTER]).compare;
      });
      it("fails when comparing with unexpected object", () => {
        const o = of(1);
        const expected = 2;
        const result = toEmitCompare(o, expected);
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/Expected to emit value:\s*2\s*but emitted:\s*1/);
      });
    });
    describe("toResolveWith", () => {
      let toResolveWithCompare;
      beforeEach(() => {
        toResolveWithCompare = TEST_ONLY.asyncMatchersRaw["toResolveWith"](jasmine.matchersUtil, [NATIVE_EQ_TESTER]).compare;
      });
      it("passes when resolution is with expected object", () => {
        const p = Promise.resolve("some resolution");
        const result = toResolveWithCompare(p, "some resolution");
        expect(result).toBeDefined();
        expect(result.pass).toBe(true);
        expect(result.message).toMatch(/^Expected not to resolve with:.*/);
      });
      it("fails when resolution is with unexpected object", () => {
        const p = Promise.resolve("some unexpected resolution");
        const result = toResolveWithCompare(p, "some resolution");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected to resolve with:(.|\n)*but resolved with:/);
      });
      it("fails when promise rejects", () => {
        const p = Promise.reject("it rejected to this string");
        const result = toResolveWithCompare(p, "some resolution");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected promise to resolve, but it rejected with:.*/);
      });
      it("fails when promise is still pending", () => {
        const p = new Promise(() => {
        });
        const result = toResolveWithCompare(p, "some resolution");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toEqual("Expected promise to resolve, but it is still pending.");
      });
    });
    describe("toRejectWith", () => {
      let toRejectWithCompare;
      beforeEach(() => {
        toRejectWithCompare = TEST_ONLY.asyncMatchersRaw["toRejectWith"](jasmine.matchersUtil, [NATIVE_EQ_TESTER]).compare;
      });
      it("passes when rejection is with expected object", () => {
        const p = Promise.reject("some rejection");
        const result = toRejectWithCompare(p, "some rejection");
        expect(result).toBeDefined();
        expect(result.pass).toBe(true);
        expect(result.message).toMatch(/^Expected not to reject with:.*/);
      });
      it("fails when rejection is with unexpected object", () => {
        const p = Promise.reject("some unexpected rejection");
        const result = toRejectWithCompare(p, "some rejection");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected to reject with:(.|\n)*but rejected with:/);
      });
      it("fails when promise resolves", () => {
        const p = Promise.resolve("it resolved to this string");
        const result = toRejectWithCompare(p, "some rejection");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected promise to reject, but it resolved with:.*/);
      });
      it("fails when promise is still pending", () => {
        const p = new Promise(() => {
        });
        const result = toRejectWithCompare(p, "some rejection");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toEqual("Expected promise to reject, but it is still pending.");
      });
    });
    describe("toRejectWithError", () => {
      let toRejectWithErrorCompare;
      beforeEach(() => {
        toRejectWithErrorCompare = TEST_ONLY.asyncMatchersRaw["toRejectWithError"](jasmine.matchersUtil, [NATIVE_EQ_TESTER]).compare;
      });
      it("passes when rejection is Error with expected error message RegExp", () => {
        const p = Promise.reject(new Error("some error"));
        const result = toRejectWithErrorCompare(p, /.*error/);
        expect(result).toBeDefined();
        expect(result.pass).toBe(true);
        expect(result.message).toMatch(new RegExp("^Expected not to reject with an Error that has the message that matches the RegExp:.*"));
      });
      it("failes when rejection is Error with unexpected error message RegExp", () => {
        const p = Promise.reject(new Error("some error"));
        const result = toRejectWithErrorCompare(p, /something else/);
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(new RegExp("^Expected to reject with an Error that has the message that matches the RegExp:.*"));
      });
      it("passes when rejection is Error with expected error message string", () => {
        const p = Promise.reject(new Error("some error"));
        const result = toRejectWithErrorCompare(p, "some error");
        expect(result).toBeDefined();
        expect(result.pass).toBe(true);
        expect(result.message).toMatch(new RegExp("^Expected not to reject with an Error that has the message:*"));
      });
      it("fails when rejection is Error with unexpected error message string", () => {
        const p = Promise.reject(new Error("some error"));
        const result = toRejectWithErrorCompare(p, "something else");
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected to reject with an Error that has the message:*/);
      });
      it("passes when rejection is Error with no expected error message", () => {
        const p = Promise.reject(new Error("some error"));
        const result = toRejectWithErrorCompare(p);
        expect(result).toBeDefined();
        expect(result.pass).toBe(true);
        expect(result.message).toBeUndefined();
      });
      it("fails when rejection is not an Error", () => {
        const p = Promise.reject("this is not an Error object");
        const result = toRejectWithErrorCompare(p);
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected promise to reject with an Error but rejected with:.*/);
      });
      it("fails when promise resolves", () => {
        const p = Promise.resolve("it resolved to this string");
        const result = toRejectWithErrorCompare(p);
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toMatch(/^Expected promise to reject, but it resolved with:.*/);
      });
      it("fails when promise is still pending", () => {
        const p = new Promise(() => {
        });
        const result = toRejectWithErrorCompare(p);
        expect(result).toBeDefined();
        expect(result.pass).toBe(false);
        expect(result.message).toEqual("Expected promise to reject, but it is still pending.");
      });
    });
  });
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license Angular v13.3.3
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license AngularJS v1.8.3
 * (c) 2010-2020 Google LLC. http://angularjs.org
 * License: MIT
 */
