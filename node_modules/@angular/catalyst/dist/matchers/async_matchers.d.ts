/// <reference types="jasmine" />
declare global {
    namespace jasmine {
        interface Matchers<T> {
            toEmit(value: {} | null | undefined): void;
            toEmitImmediately(value: {} | null | undefined): void;
            toHaveNeverEmitted(): void;
            toHaveEmitted(): void;
            toEmitError(value: {} | null | undefined): void;
            toEmitErrorImmediately(value: {} | null | undefined): void;
            toEmitSequence(value: {}): void;
            toEmitSequenceImmediately(value: {}): void;
            toResolveWith(value: {} | null | undefined): void;
            toRejectWith(value: {} | null | undefined): void;
            /**
             * Similar to toRejectWith but expects the rejection to be with an object
             * of type Error.
             *
             * If expectedMessage is provided then the Error must have a message
             * property that:
             *
             * * is equal to the expectedMessage if it is a string.
             * * fully matches expectedMessage if it is a RegExp.
             */
            toRejectWithError(expectedMessage?: string | RegExp | null): void;
            toBePending(): void;
        }
    }
}
export declare const TEST_ONLY: {
    asyncMatchersRaw: jasmine.CustomMatcherFactories;
};
/** A bunch of CustomMatcherFactories useful for testing async results. */
export declare const asyncMatchers: jasmine.CustomMatcherFactories;
//# sourceMappingURL=async_matchers.d.ts.map