import { of } from 'rxjs';
import { catchError, filter, map } from 'rxjs/operators';
import { awaitValues, executeAsyncInCurrentZone, extraInfo, immediatelyGetValues } from './helpers.js';
const asyncMatchersRaw = {
    /**
     * Checks to see if observable emits provided value. Fails if multiple values
     * emitted.
     *
     * Throws an exception if used outside of FakeAsyncZone or SyncZone.
     *
     * @see toEmitImmediately
     */
    toEmit(util, customEqualityTesters) {
        return {
            compare(actual, expectedValue) {
                return expectOne({
                    actualValues: awaitValues(actual),
                    expectedValue,
                    valueNoun: 'value',
                    util,
                    customEqualityTesters,
                });
            }
        };
    },
    /**
     * Checks to see if observable emits provided value immediately. Fails if
     * multiple values are emitted or if something would have been emitted
     * asynchronously.
     *
     * @see toEmit
     */
    toEmitImmediately(util, customEqualityTesters) {
        return {
            compare(actual, expectedValue) {
                return expectOne({
                    actualValues: immediatelyGetValues(actual),
                    expectedValue,
                    valueNoun: 'value',
                    util,
                    customEqualityTesters,
                });
            }
        };
    },
    /**
     * Checks to see that an observable has not emitted. Fails if the observable
     * has emitted anything.
     *
     * @see toEmit
     */
    toHaveNeverEmitted(util) {
        return {
            compare(actual, expectedValue) {
                return expectNone({ actualValues: awaitValues(actual), valueNoun: 'value', util });
            }
        };
    },
    /**
     * Checks to see that an observable has emitted. Fails if the observable
     * has never emitted anything.
     *
     * @see toEmit
     */
    toHaveEmitted(util) {
        return {
            compare(actual, expectedValue) {
                return expectAny({ actualValues: awaitValues(actual), valueNoun: 'value', util });
            }
        };
    },
    /**
     * Checks to see if observable emits an error with provided value. Fails if
     * multiple values emitted.
     *
     * Throws an exception if used outside of FakeAsyncZone or SyncZone.
     *
     * @see toEmitErrorImmediately
     */
    toEmitError(util, customEqualityTesters) {
        return {
            compare: (actual, expectedError) => {
                return expectOne({
                    actualValues: awaitValues(mapErrorsToValues(actual)),
                    expectedValue: expectedError,
                    valueNoun: 'error',
                    util,
                    customEqualityTesters,
                });
            }
        };
    },
    /**
     * Checks to see if observable immediately emits an error with provided value.
     * Fails if multiple are emitted.
     *
     * @see toEmitError
     */
    toEmitErrorImmediately(util, customEqualityTesters) {
        return {
            compare(actual, expectedError) {
                return expectOne({
                    actualValues: immediatelyGetValues(mapErrorsToValues(actual)),
                    expectedValue: expectedError,
                    valueNoun: 'error',
                    util,
                    customEqualityTesters,
                });
            }
        };
    },
    /**
     * Checks to see if observable emits provided values in specified order.
     *
     * Throws an exception if used outside of FakeAsyncZone or SyncZone.
     *
     * @see toEmitSequenceImmediately
     */
    toEmitSequence(util, customEqualityTesters) {
        return {
            compare(actual, expectedValues) {
                return expectAll({
                    actualValues: awaitValues(actual),
                    expectedValues,
                    valuesNoun: 'values',
                    util,
                    customEqualityTesters,
                });
            }
        };
    },
    /**
     * Checks to see if observable immediately emits provided values in specified
     * order.
     *
     * @see toEmitSequence
     */
    toEmitSequenceImmediately(util, customEqualityTesters) {
        return {
            compare(actual, expectedValues) {
                return expectAll({
                    actualValues: immediatelyGetValues(actual),
                    expectedValues,
                    valuesNoun: 'values',
                    util,
                    customEqualityTesters,
                });
            }
        };
    },
    toResolveWith(util, customEqualityTesters) {
        return {
            compare(actual, expected) {
                const promiseResult = analyzePromiseResult(actual);
                if (promiseResult.resolution !== PromiseResolution.RESOLVED) {
                    return nonResolvedResultToMatcherResult(util, promiseResult);
                }
                const builder = jasmine.DiffBuilder();
                const pass = util.equals(promiseResult.resolvedValue, expected, customEqualityTesters, builder);
                const not = pass ? 'not ' : '';
                return {
                    pass,
                    message: `Expected ${not}to resolve with: ${prettyPrint(util, expected)} but resolved with: ${prettyPrint(util, promiseResult.resolvedValue)}${extraInfo(builder.getMessage(), promiseResult.resolvedValue, expected)}`,
                };
            }
        };
    },
    toRejectWith(util, customEqualityTesters) {
        return {
            compare(actual, expected) {
                const promiseResult = analyzePromiseResult(actual);
                if (promiseResult.resolution !== PromiseResolution.REJECTED) {
                    return nonRejectedResultToMatcherResult(util, promiseResult);
                }
                const builder = jasmine.DiffBuilder();
                const pass = util.equals(promiseResult.rejectedValue, expected, customEqualityTesters, builder);
                const not = pass ? 'not ' : '';
                return {
                    pass,
                    message: `Expected ${not}to reject with: ${prettyPrint(util, expected)} but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}${extraInfo(builder.getMessage(), promiseResult.rejectedValue, expected)}`,
                };
            }
        };
    },
    toRejectWithError(util, customEqualityTesters) {
        return {
            compare(actual, expectedMessage) {
                const promiseResult = analyzePromiseResult(actual);
                if (promiseResult.resolution !== PromiseResolution.REJECTED) {
                    return nonRejectedResultToMatcherResult(util, promiseResult);
                }
                if (!(promiseResult.rejectedValue instanceof Error)) {
                    return {
                        pass: false,
                        message: `Expected promise to reject with an Error but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`,
                    };
                }
                if (expectedMessage === undefined || expectedMessage === null) {
                    // No further checks
                    return {
                        pass: true,
                    };
                }
                if (typeof expectedMessage === 'string') {
                    const pass = util.equals(promiseResult.rejectedValue.message, expectedMessage, customEqualityTesters);
                    const not = pass ? 'not ' : '';
                    return {
                        pass,
                        message: `Expected ${not}to reject with an Error that has the message: ${prettyPrint(util, expectedMessage)} but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`,
                    };
                }
                // If we are here, expectedMessage is a RegExp
                const pass = expectedMessage.test(promiseResult.rejectedValue.message);
                const not = pass ? 'not ' : '';
                return {
                    pass,
                    message: `Expected ${not}to reject with an Error that has the ` +
                        `message that matches the RegExp: ${prettyPrint(util, expectedMessage)} but rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`,
                };
            }
        };
    },
    toBePending(util, customEqualityTesters) {
        return {
            compare(actual, expected) {
                const promiseResult = analyzePromiseResult(actual);
                if (promiseResult.resolution !== PromiseResolution.STILL_PENDING) {
                    return nonPendingResultToMatcherResult(util, promiseResult);
                }
                return {
                    pass: true,
                    message: `Expected to be pending`,
                };
            }
        };
    },
};
// Having it like this allows us to have the exact types being used by the
// asyncMatchers available in the test.
export const TEST_ONLY = { asyncMatchersRaw };
/** A bunch of CustomMatcherFactories useful for testing async results. */
export const asyncMatchers = asyncMatchersRaw;
/** Enum used to discriminate between the different types of PromiseResult. */
var PromiseResolution;
(function (PromiseResolution) {
    PromiseResolution[PromiseResolution["STILL_PENDING"] = 0] = "STILL_PENDING";
    PromiseResolution[PromiseResolution["RESOLVED"] = 1] = "RESOLVED";
    PromiseResolution[PromiseResolution["REJECTED"] = 2] = "REJECTED";
})(PromiseResolution || (PromiseResolution = {}));
/**
 * Analyzes a Promise and returns whether it was resolved, rejected or it is
 * still pending. When it was resolved or rejected, then the corresponding value
 * is included in the returned object.
 */
function analyzePromiseResult(promise) {
    let result = {
        resolution: PromiseResolution.STILL_PENDING,
    };
    executeAsyncInCurrentZone(() => {
        promise
            .then((val) => {
            result = {
                resolution: PromiseResolution.RESOLVED,
                resolvedValue: val,
            };
        })
            .catch((val) => {
            result = {
                resolution: PromiseResolution.REJECTED,
                rejectedValue: val,
            };
        });
    });
    return result;
}
/**
 * Converts a NonResolvedResult into a CustomMatcherResult with the appropriate
 * error message. It is intended to be used on a Promise that should have been
 * resolved, but it wasn't.
 */
function nonResolvedResultToMatcherResult(util, promiseResult) {
    switch (promiseResult.resolution) {
        case PromiseResolution.STILL_PENDING:
            return {
                pass: false,
                message: 'Expected promise to resolve, but it is still pending.',
            };
        case PromiseResolution.REJECTED:
            return {
                pass: false,
                message: `Expected promise to resolve, but it rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`,
            };
        default:
            throw new Error(`Unexpected PromiseResolution in PromiseResult: ${prettyPrint(util, promiseResult)}`);
    }
}
/**
 * Converts a NonRejectedResult into a CustomMatcherResult with the appropriate
 * error message. It is intended to be used on a Promise that should have been
 * rejected, but it wasn't.
 */
function nonRejectedResultToMatcherResult(util, promiseResult) {
    switch (promiseResult.resolution) {
        case PromiseResolution.STILL_PENDING:
            return {
                pass: false,
                message: 'Expected promise to reject, but it is still pending.',
            };
        case PromiseResolution.RESOLVED:
            return {
                pass: false,
                message: `Expected promise to reject, but it resolved with: ${prettyPrint(util, promiseResult.resolvedValue)}`,
            };
        default:
            throw new Error(`Unexpected PromiseResolution in PromiseResult: ${prettyPrint(util, promiseResult)}`);
    }
}
/**
 * Converts a NonPendingResult into a CustomMatcherResult with the appropriate
 * error message. It is intended to be used on a Promise that should bave been
 * pending, but it wasn't.
 */
function nonPendingResultToMatcherResult(util, promiseResult) {
    switch (promiseResult.resolution) {
        case PromiseResolution.RESOLVED:
            return {
                pass: false,
                message: `Expected promise to be pending, but it resolved with: ${prettyPrint(util, promiseResult.resolvedValue)}`,
            };
        case PromiseResolution.REJECTED:
            return {
                pass: false,
                message: `Expected promise to be pending, but it rejected with: ${prettyPrint(util, promiseResult.rejectedValue)}`,
            };
        default:
            throw new Error(`Unexpected PromiseResolution in PromiseResult: ${prettyPrint(util, promiseResult)}`);
    }
}
function mapErrorsToValues(obs) {
    // Ignore all values and map type to same as returned by catchError.
    return obs.pipe(filter(() => false), map(() => ({})), catchError((val) => of(val)));
}
function expectNone(args) {
    const len = args.actualValues.length;
    if (len !== 0) {
        return {
            pass: false,
            message: `Expected observable not to emit ${args.valueNoun}, but got ${len} ${len === 1 ? 'value' : 'values'} instead: "${prettyPrint(args.util, args.actualValues)}"`
        };
    }
    else {
        return {
            pass: true,
            message: `Expected observable to emit at least one value`
        };
    }
}
function expectAny(args) {
    if (args.actualValues.length) {
        return {
            pass: true,
            message: `Expected observable to emit at least one value`
        };
    }
    else {
        return {
            pass: false,
            message: `Expected observable to emit at least one value, but got none.`
        };
    }
}
function expectOne(args) {
    const len = args.actualValues.length;
    if (len !== 1) {
        return {
            pass: false,
            message: `Expected observable to emit one ${args.valueNoun}, but got ${len} values instead: "${prettyPrint(args.util, args.actualValues)}"`
        };
    }
    const builder = jasmine.DiffBuilder();
    const actualValue = args.actualValues[0];
    const pass = args.util.equals(actualValue, args.expectedValue, args.customEqualityTesters, builder);
    return {
        pass,
        get message() {
            return `Expected ${pass ? 'not ' : ''}to emit ${args.valueNoun}: ${prettyPrint(args.util, args.expectedValue)} but emitted: ${prettyPrint(args.util, actualValue)}${extraInfo(builder.getMessage(), actualValue, args.expectedValue)}
`;
        }
    };
}
function expectAll(args) {
    const builder = jasmine.DiffBuilder();
    const pass = args.util.equals(args.actualValues, args.expectedValues, args.customEqualityTesters, builder);
    return {
        pass,
        get message() {
            return `Expected ${pass ? 'not ' : ''}to emit ${args.valuesNoun}: ${prettyPrint(args.util, args.expectedValues)} but emitted: ${prettyPrint(args.util, args.actualValues)}${extraInfo(builder.getMessage(), args.actualValues, args.expectedValues)}`;
        }
    };
}
function prettyPrint(util, val) {
    return '\n\n' + util.pp(val) + '\n\n';
}
